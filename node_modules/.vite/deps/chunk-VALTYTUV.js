var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@babylonjs/core/abstractScene.js
var AbstractScene;
var init_abstractScene = __esm({
  "node_modules/@babylonjs/core/abstractScene.js"() {
    AbstractScene = function() {
      function AbstractScene2() {
        this.rootNodes = new Array();
        this.cameras = new Array();
        this.lights = new Array();
        this.meshes = new Array();
        this.skeletons = new Array();
        this.particleSystems = new Array();
        this.animations = [];
        this.animationGroups = new Array();
        this.multiMaterials = new Array();
        this.materials = new Array();
        this.morphTargetManagers = new Array();
        this.geometries = new Array();
        this.transformNodes = new Array();
        this.actionManagers = new Array();
        this.textures = new Array();
        this._environmentTexture = null;
        this.postProcesses = new Array();
      }
      AbstractScene2.AddParser = function(name, parser) {
        this._BabylonFileParsers[name] = parser;
      };
      AbstractScene2.GetParser = function(name) {
        if (this._BabylonFileParsers[name]) {
          return this._BabylonFileParsers[name];
        }
        return null;
      };
      AbstractScene2.AddIndividualParser = function(name, parser) {
        this._IndividualBabylonFileParsers[name] = parser;
      };
      AbstractScene2.GetIndividualParser = function(name) {
        if (this._IndividualBabylonFileParsers[name]) {
          return this._IndividualBabylonFileParsers[name];
        }
        return null;
      };
      AbstractScene2.Parse = function(jsonData, scene, container, rootUrl) {
        for (var parserName in this._BabylonFileParsers) {
          if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {
            this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
          }
        }
      };
      Object.defineProperty(AbstractScene2.prototype, "environmentTexture", {
        get: function() {
          return this._environmentTexture;
        },
        set: function(value) {
          this._environmentTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      AbstractScene2.prototype.getNodes = function() {
        var nodes = new Array();
        nodes = nodes.concat(this.meshes);
        nodes = nodes.concat(this.lights);
        nodes = nodes.concat(this.cameras);
        nodes = nodes.concat(this.transformNodes);
        this.skeletons.forEach(function(skeleton) {
          return nodes = nodes.concat(skeleton.bones);
        });
        return nodes;
      };
      AbstractScene2._BabylonFileParsers = {};
      AbstractScene2._IndividualBabylonFileParsers = {};
      return AbstractScene2;
    }();
  }
});

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager;
var init_abstractActionManager = __esm({
  "node_modules/@babylonjs/core/Actions/abstractActionManager.js"() {
    AbstractActionManager = function() {
      function AbstractActionManager2() {
        this.hoverCursor = "";
        this.actions = new Array();
        this.isRecursive = false;
      }
      Object.defineProperty(AbstractActionManager2, "HasTriggers", {
        get: function() {
          for (var t in AbstractActionManager2.Triggers) {
            if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
              return true;
            }
          }
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractActionManager2, "HasPickTriggers", {
        get: function() {
          for (var t in AbstractActionManager2.Triggers) {
            if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
              var tAsInt = parseInt(t);
              if (tAsInt >= 1 && tAsInt <= 7) {
                return true;
              }
            }
          }
          return false;
        },
        enumerable: false,
        configurable: true
      });
      AbstractActionManager2.HasSpecificTrigger = function(trigger) {
        for (var t in AbstractActionManager2.Triggers) {
          if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
            var tAsInt = parseInt(t);
            if (tAsInt === trigger) {
              return true;
            }
          }
        }
        return false;
      };
      AbstractActionManager2.Triggers = {};
      return AbstractActionManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/observable.js
var EventState, Observer, MultiObserver, Observable;
var init_observable = __esm({
  "node_modules/@babylonjs/core/Misc/observable.js"() {
    EventState = function() {
      function EventState2(mask, skipNextObservers, target, currentTarget) {
        if (skipNextObservers === void 0) {
          skipNextObservers = false;
        }
        this.initialize(mask, skipNextObservers, target, currentTarget);
      }
      EventState2.prototype.initialize = function(mask, skipNextObservers, target, currentTarget) {
        if (skipNextObservers === void 0) {
          skipNextObservers = false;
        }
        this.mask = mask;
        this.skipNextObservers = skipNextObservers;
        this.target = target;
        this.currentTarget = currentTarget;
        return this;
      };
      return EventState2;
    }();
    Observer = function() {
      function Observer2(callback, mask, scope) {
        if (scope === void 0) {
          scope = null;
        }
        this.callback = callback;
        this.mask = mask;
        this.scope = scope;
        this._willBeUnregistered = false;
        this.unregisterOnNextCall = false;
      }
      return Observer2;
    }();
    MultiObserver = function() {
      function MultiObserver2() {
      }
      MultiObserver2.prototype.dispose = function() {
        if (this._observers && this._observables) {
          for (var index = 0; index < this._observers.length; index++) {
            this._observables[index].remove(this._observers[index]);
          }
        }
        this._observers = null;
        this._observables = null;
      };
      MultiObserver2.Watch = function(observables, callback, mask, scope) {
        if (mask === void 0) {
          mask = -1;
        }
        if (scope === void 0) {
          scope = null;
        }
        var result = new MultiObserver2();
        result._observers = new Array();
        result._observables = observables;
        for (var _i = 0, observables_1 = observables; _i < observables_1.length; _i++) {
          var observable = observables_1[_i];
          var observer = observable.add(callback, mask, false, scope);
          if (observer) {
            result._observers.push(observer);
          }
        }
        return result;
      };
      return MultiObserver2;
    }();
    Observable = function() {
      function Observable2(onObserverAdded) {
        this._observers = new Array();
        this._eventState = new EventState(0);
        if (onObserverAdded) {
          this._onObserverAdded = onObserverAdded;
        }
      }
      Observable2.FromPromise = function(promise, onErrorObservable) {
        var observable = new Observable2();
        promise.then(function(ret) {
          observable.notifyObservers(ret);
        }).catch(function(err) {
          if (onErrorObservable) {
            onErrorObservable.notifyObservers(err);
          } else {
            throw err;
          }
        });
        return observable;
      };
      Object.defineProperty(Observable2.prototype, "observers", {
        get: function() {
          return this._observers;
        },
        enumerable: false,
        configurable: true
      });
      Observable2.prototype.add = function(callback, mask, insertFirst, scope, unregisterOnFirstCall) {
        if (mask === void 0) {
          mask = -1;
        }
        if (insertFirst === void 0) {
          insertFirst = false;
        }
        if (scope === void 0) {
          scope = null;
        }
        if (unregisterOnFirstCall === void 0) {
          unregisterOnFirstCall = false;
        }
        if (!callback) {
          return null;
        }
        var observer = new Observer(callback, mask, scope);
        observer.unregisterOnNextCall = unregisterOnFirstCall;
        if (insertFirst) {
          this._observers.unshift(observer);
        } else {
          this._observers.push(observer);
        }
        if (this._onObserverAdded) {
          this._onObserverAdded(observer);
        }
        return observer;
      };
      Observable2.prototype.addOnce = function(callback) {
        return this.add(callback, void 0, void 0, void 0, true);
      };
      Observable2.prototype.remove = function(observer) {
        if (!observer) {
          return false;
        }
        var index = this._observers.indexOf(observer);
        if (index !== -1) {
          this._deferUnregister(observer);
          return true;
        }
        return false;
      };
      Observable2.prototype.removeCallback = function(callback, scope) {
        for (var index = 0; index < this._observers.length; index++) {
          var observer = this._observers[index];
          if (observer._willBeUnregistered) {
            continue;
          }
          if (observer.callback === callback && (!scope || scope === observer.scope)) {
            this._deferUnregister(observer);
            return true;
          }
        }
        return false;
      };
      Observable2.prototype._deferUnregister = function(observer) {
        var _this = this;
        observer.unregisterOnNextCall = false;
        observer._willBeUnregistered = true;
        setTimeout(function() {
          _this._remove(observer);
        }, 0);
      };
      Observable2.prototype._remove = function(observer) {
        if (!observer) {
          return false;
        }
        var index = this._observers.indexOf(observer);
        if (index !== -1) {
          this._observers.splice(index, 1);
          return true;
        }
        return false;
      };
      Observable2.prototype.makeObserverTopPriority = function(observer) {
        this._remove(observer);
        this._observers.unshift(observer);
      };
      Observable2.prototype.makeObserverBottomPriority = function(observer) {
        this._remove(observer);
        this._observers.push(observer);
      };
      Observable2.prototype.notifyObservers = function(eventData, mask, target, currentTarget, userInfo) {
        if (mask === void 0) {
          mask = -1;
        }
        if (!this._observers.length) {
          return true;
        }
        var state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        state.lastReturnValue = eventData;
        state.userInfo = userInfo;
        for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
          var obs = _a[_i];
          if (obs._willBeUnregistered) {
            continue;
          }
          if (obs.mask & mask) {
            if (obs.scope) {
              state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
            } else {
              state.lastReturnValue = obs.callback(eventData, state);
            }
            if (obs.unregisterOnNextCall) {
              this._deferUnregister(obs);
            }
          }
          if (state.skipNextObservers) {
            return false;
          }
        }
        return true;
      };
      Observable2.prototype.notifyObserversWithPromise = function(eventData, mask, target, currentTarget, userInfo) {
        var _this = this;
        if (mask === void 0) {
          mask = -1;
        }
        var p = Promise.resolve(eventData);
        if (!this._observers.length) {
          return p;
        }
        var state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        state.userInfo = userInfo;
        this._observers.forEach(function(obs) {
          if (state.skipNextObservers) {
            return;
          }
          if (obs._willBeUnregistered) {
            return;
          }
          if (obs.mask & mask) {
            if (obs.scope) {
              p = p.then(function(lastReturnedValue) {
                state.lastReturnValue = lastReturnedValue;
                return obs.callback.apply(obs.scope, [eventData, state]);
              });
            } else {
              p = p.then(function(lastReturnedValue) {
                state.lastReturnValue = lastReturnedValue;
                return obs.callback(eventData, state);
              });
            }
            if (obs.unregisterOnNextCall) {
              _this._deferUnregister(obs);
            }
          }
        });
        return p.then(function() {
          return eventData;
        });
      };
      Observable2.prototype.notifyObserver = function(observer, eventData, mask) {
        if (mask === void 0) {
          mask = -1;
        }
        if (observer._willBeUnregistered) {
          return;
        }
        var state = this._eventState;
        state.mask = mask;
        state.skipNextObservers = false;
        observer.callback(eventData, state);
        if (observer.unregisterOnNextCall) {
          this._deferUnregister(observer);
        }
      };
      Observable2.prototype.hasObservers = function() {
        return this._observers.length > 0;
      };
      Observable2.prototype.clear = function() {
        this._observers = new Array();
        this._onObserverAdded = null;
      };
      Observable2.prototype.clone = function() {
        var result = new Observable2();
        result._observers = this._observers.slice(0);
        return result;
      };
      Observable2.prototype.hasSpecificMask = function(mask) {
        if (mask === void 0) {
          mask = -1;
        }
        for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
          var obs = _a[_i];
          if (obs.mask & mask || obs.mask === mask) {
            return true;
          }
        }
        return false;
      };
      return Observable2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.scalar.js
var Scalar;
var init_math_scalar = __esm({
  "node_modules/@babylonjs/core/Maths/math.scalar.js"() {
    Scalar = function() {
      function Scalar2() {
      }
      Scalar2.WithinEpsilon = function(a, b, epsilon) {
        if (epsilon === void 0) {
          epsilon = 1401298e-51;
        }
        return Math.abs(a - b) <= epsilon;
      };
      Scalar2.ToHex = function(i) {
        var str = i.toString(16);
        if (i <= 15) {
          return ("0" + str).toUpperCase();
        }
        return str.toUpperCase();
      };
      Scalar2.Sign = function(value) {
        value = +value;
        if (value === 0 || isNaN(value)) {
          return value;
        }
        return value > 0 ? 1 : -1;
      };
      Scalar2.Clamp = function(value, min, max) {
        if (min === void 0) {
          min = 0;
        }
        if (max === void 0) {
          max = 1;
        }
        return Math.min(max, Math.max(min, value));
      };
      Scalar2.Log2 = function(value) {
        return Math.log(value) * Math.LOG2E;
      };
      Scalar2.ILog2 = function(value) {
        if (Math.log2) {
          return Math.floor(Math.log2(value));
        }
        if (value < 0) {
          return NaN;
        } else if (value === 0) {
          return -Infinity;
        }
        var n = 0;
        if (value < 1) {
          while (value < 1) {
            n++;
            value = value * 2;
          }
          n = -n;
        } else if (value > 1) {
          while (value > 1) {
            n++;
            value = Math.floor(value / 2);
          }
        }
        return n;
      };
      Scalar2.Repeat = function(value, length) {
        return value - Math.floor(value / length) * length;
      };
      Scalar2.Normalize = function(value, min, max) {
        return (value - min) / (max - min);
      };
      Scalar2.Denormalize = function(normalized, min, max) {
        return normalized * (max - min) + min;
      };
      Scalar2.DeltaAngle = function(current, target) {
        var num = Scalar2.Repeat(target - current, 360);
        if (num > 180) {
          num -= 360;
        }
        return num;
      };
      Scalar2.PingPong = function(tx, length) {
        var t = Scalar2.Repeat(tx, length * 2);
        return length - Math.abs(t - length);
      };
      Scalar2.SmoothStep = function(from, to, tx) {
        var t = Scalar2.Clamp(tx);
        t = -2 * t * t * t + 3 * t * t;
        return to * t + from * (1 - t);
      };
      Scalar2.MoveTowards = function(current, target, maxDelta) {
        var result = 0;
        if (Math.abs(target - current) <= maxDelta) {
          result = target;
        } else {
          result = current + Scalar2.Sign(target - current) * maxDelta;
        }
        return result;
      };
      Scalar2.MoveTowardsAngle = function(current, target, maxDelta) {
        var num = Scalar2.DeltaAngle(current, target);
        var result = 0;
        if (-maxDelta < num && num < maxDelta) {
          result = target;
        } else {
          target = current + num;
          result = Scalar2.MoveTowards(current, target, maxDelta);
        }
        return result;
      };
      Scalar2.Lerp = function(start, end, amount) {
        return start + (end - start) * amount;
      };
      Scalar2.LerpAngle = function(start, end, amount) {
        var num = Scalar2.Repeat(end - start, 360);
        if (num > 180) {
          num -= 360;
        }
        return start + num * Scalar2.Clamp(amount);
      };
      Scalar2.InverseLerp = function(a, b, value) {
        var result = 0;
        if (a != b) {
          result = Scalar2.Clamp((value - a) / (b - a));
        } else {
          result = 0;
        }
        return result;
      };
      Scalar2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
      };
      Scalar2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var t2 = time * time;
        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
      };
      Scalar2.RandomRange = function(min, max) {
        if (min === max) {
          return min;
        }
        return Math.random() * (max - min) + min;
      };
      Scalar2.RangeToPercent = function(number, min, max) {
        return (number - min) / (max - min);
      };
      Scalar2.PercentToRange = function(percent, min, max) {
        return (max - min) * percent + min;
      };
      Scalar2.NormalizeRadians = function(angle) {
        angle -= Scalar2.TwoPi * Math.floor((angle + Math.PI) / Scalar2.TwoPi);
        return angle;
      };
      Scalar2.HCF = function(a, b) {
        var r = a % b;
        if (r === 0) {
          return b;
        }
        return Scalar2.HCF(b, r);
      };
      Scalar2.TwoPi = Math.PI * 2;
      return Scalar2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.constants.js
var ToGammaSpace, ToLinearSpace, PHI, Epsilon;
var init_math_constants = __esm({
  "node_modules/@babylonjs/core/Maths/math.constants.js"() {
    ToGammaSpace = 1 / 2.2;
    ToLinearSpace = 2.2;
    PHI = (1 + Math.sqrt(5)) / 2;
    Epsilon = 1e-3;
  }
});

// node_modules/@babylonjs/core/Misc/typeStore.js
function RegisterClass(className2, type) {
  _RegisteredTypes[className2] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}
var _RegisteredTypes;
var init_typeStore = __esm({
  "node_modules/@babylonjs/core/Misc/typeStore.js"() {
    _RegisteredTypes = {};
  }
});

// node_modules/@babylonjs/core/Engines/performanceConfigurator.js
var PerformanceConfigurator;
var init_performanceConfigurator = __esm({
  "node_modules/@babylonjs/core/Engines/performanceConfigurator.js"() {
    PerformanceConfigurator = function() {
      function PerformanceConfigurator2() {
      }
      PerformanceConfigurator2.SetMatrixPrecision = function(use64bits) {
        PerformanceConfigurator2.MatrixTrackPrecisionChange = false;
        if (use64bits && !PerformanceConfigurator2.MatrixUse64Bits) {
          if (PerformanceConfigurator2.MatrixTrackedMatrices) {
            for (var m = 0; m < PerformanceConfigurator2.MatrixTrackedMatrices.length; ++m) {
              var matrix = PerformanceConfigurator2.MatrixTrackedMatrices[m];
              var values = matrix._m;
              matrix._m = new Array(16);
              for (var i = 0; i < 16; ++i) {
                matrix._m[i] = values[i];
              }
            }
          }
        }
        PerformanceConfigurator2.MatrixUse64Bits = use64bits;
        PerformanceConfigurator2.MatrixCurrentType = PerformanceConfigurator2.MatrixUse64Bits ? Array : Float32Array;
        PerformanceConfigurator2.MatrixTrackedMatrices = null;
      };
      PerformanceConfigurator2.MatrixUse64Bits = false;
      PerformanceConfigurator2.MatrixTrackPrecisionChange = true;
      PerformanceConfigurator2.MatrixCurrentType = Float32Array;
      PerformanceConfigurator2.MatrixTrackedMatrices = [];
      return PerformanceConfigurator2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/engineStore.js
var EngineStore;
var init_engineStore = __esm({
  "node_modules/@babylonjs/core/Engines/engineStore.js"() {
    EngineStore = function() {
      function EngineStore2() {
      }
      Object.defineProperty(EngineStore2, "LastCreatedEngine", {
        get: function() {
          if (this.Instances.length === 0) {
            return null;
          }
          return this.Instances[this.Instances.length - 1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(EngineStore2, "LastCreatedScene", {
        get: function() {
          return this._LastCreatedScene;
        },
        enumerable: false,
        configurable: true
      });
      EngineStore2.Instances = new Array();
      EngineStore2._LastCreatedScene = null;
      EngineStore2.UseFallbackTexture = true;
      EngineStore2.FallbackTexture = "";
      return EngineStore2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/arrayTools.js
var ArrayTools;
var init_arrayTools = __esm({
  "node_modules/@babylonjs/core/Misc/arrayTools.js"() {
    ArrayTools = function() {
      function ArrayTools2() {
      }
      ArrayTools2.BuildArray = function(size, itemBuilder) {
        var a = [];
        for (var i = 0; i < size; ++i) {
          a.push(itemBuilder());
        }
        return a;
      };
      ArrayTools2.BuildTuple = function(size, itemBuilder) {
        return ArrayTools2.BuildArray(size, itemBuilder);
      };
      return ArrayTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.vector.js
var _ExtractAsInt, Vector2, Vector3, Vector4, Quaternion, Matrix, MathTmp, TmpVectors, mtxConvertNDCToHalfZRange;
var init_math_vector = __esm({
  "node_modules/@babylonjs/core/Maths/math.vector.js"() {
    init_math_scalar();
    init_math_constants();
    init_arrayTools();
    init_typeStore();
    init_performanceConfigurator();
    init_engineStore();
    _ExtractAsInt = function(value) {
      return parseInt(value.toString().replace(/\W/g, ""));
    };
    Vector2 = function() {
      function Vector22(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this.x = x;
        this.y = y;
      }
      Vector22.prototype.toString = function() {
        return "{X: ".concat(this.x, " Y: ").concat(this.y, "}");
      };
      Vector22.prototype.getClassName = function() {
        return "Vector2";
      };
      Vector22.prototype.getHashCode = function() {
        var x = _ExtractAsInt(this.x);
        var y = _ExtractAsInt(this.y);
        var hash = x;
        hash = hash * 397 ^ y;
        return hash;
      };
      Vector22.prototype.toArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this.x;
        array[index + 1] = this.y;
        return this;
      };
      Vector22.prototype.fromArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        Vector22.FromArrayToRef(array, index, this);
        return this;
      };
      Vector22.prototype.asArray = function() {
        var result = new Array();
        this.toArray(result, 0);
        return result;
      };
      Vector22.prototype.copyFrom = function(source) {
        this.x = source.x;
        this.y = source.y;
        return this;
      };
      Vector22.prototype.copyFromFloats = function(x, y) {
        this.x = x;
        this.y = y;
        return this;
      };
      Vector22.prototype.set = function(x, y) {
        return this.copyFromFloats(x, y);
      };
      Vector22.prototype.add = function(otherVector) {
        return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
      };
      Vector22.prototype.addToRef = function(otherVector, result) {
        result.x = this.x + otherVector.x;
        result.y = this.y + otherVector.y;
        return this;
      };
      Vector22.prototype.addInPlace = function(otherVector) {
        this.x += otherVector.x;
        this.y += otherVector.y;
        return this;
      };
      Vector22.prototype.addVector3 = function(otherVector) {
        return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
      };
      Vector22.prototype.subtract = function(otherVector) {
        return new Vector22(this.x - otherVector.x, this.y - otherVector.y);
      };
      Vector22.prototype.subtractToRef = function(otherVector, result) {
        result.x = this.x - otherVector.x;
        result.y = this.y - otherVector.y;
        return this;
      };
      Vector22.prototype.subtractInPlace = function(otherVector) {
        this.x -= otherVector.x;
        this.y -= otherVector.y;
        return this;
      };
      Vector22.prototype.multiplyInPlace = function(otherVector) {
        this.x *= otherVector.x;
        this.y *= otherVector.y;
        return this;
      };
      Vector22.prototype.multiply = function(otherVector) {
        return new Vector22(this.x * otherVector.x, this.y * otherVector.y);
      };
      Vector22.prototype.multiplyToRef = function(otherVector, result) {
        result.x = this.x * otherVector.x;
        result.y = this.y * otherVector.y;
        return this;
      };
      Vector22.prototype.multiplyByFloats = function(x, y) {
        return new Vector22(this.x * x, this.y * y);
      };
      Vector22.prototype.divide = function(otherVector) {
        return new Vector22(this.x / otherVector.x, this.y / otherVector.y);
      };
      Vector22.prototype.divideToRef = function(otherVector, result) {
        result.x = this.x / otherVector.x;
        result.y = this.y / otherVector.y;
        return this;
      };
      Vector22.prototype.divideInPlace = function(otherVector) {
        return this.divideToRef(otherVector, this);
      };
      Vector22.prototype.negate = function() {
        return new Vector22(-this.x, -this.y);
      };
      Vector22.prototype.negateInPlace = function() {
        this.x *= -1;
        this.y *= -1;
        return this;
      };
      Vector22.prototype.negateToRef = function(result) {
        return result.copyFromFloats(this.x * -1, this.y * -1);
      };
      Vector22.prototype.scaleInPlace = function(scale) {
        this.x *= scale;
        this.y *= scale;
        return this;
      };
      Vector22.prototype.scale = function(scale) {
        var result = new Vector22(0, 0);
        this.scaleToRef(scale, result);
        return result;
      };
      Vector22.prototype.scaleToRef = function(scale, result) {
        result.x = this.x * scale;
        result.y = this.y * scale;
        return this;
      };
      Vector22.prototype.scaleAndAddToRef = function(scale, result) {
        result.x += this.x * scale;
        result.y += this.y * scale;
        return this;
      };
      Vector22.prototype.equals = function(otherVector) {
        return otherVector && this.x === otherVector.x && this.y === otherVector.y;
      };
      Vector22.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
        if (epsilon === void 0) {
          epsilon = Epsilon;
        }
        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
      };
      Vector22.prototype.floor = function() {
        return new Vector22(Math.floor(this.x), Math.floor(this.y));
      };
      Vector22.prototype.fract = function() {
        return new Vector22(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
      };
      Vector22.prototype.rotateToRef = function(angle, result) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        result.x = cos * this.x - sin * this.y;
        result.y = sin * this.x + cos * this.y;
        return this;
      };
      Vector22.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };
      Vector22.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y;
      };
      Vector22.prototype.normalize = function() {
        Vector22.NormalizeToRef(this, this);
        return this;
      };
      Vector22.prototype.clone = function() {
        return new Vector22(this.x, this.y);
      };
      Vector22.Zero = function() {
        return new Vector22(0, 0);
      };
      Vector22.One = function() {
        return new Vector22(1, 1);
      };
      Vector22.FromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return new Vector22(array[offset], array[offset + 1]);
      };
      Vector22.FromArrayToRef = function(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
      };
      Vector22.CatmullRom = function(value1, value2, value3, value4, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
        var y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
        return new Vector22(x, y);
      };
      Vector22.Clamp = function(value, min, max) {
        var x = value.x;
        x = x > max.x ? max.x : x;
        x = x < min.x ? min.x : x;
        var y = value.y;
        y = y > max.y ? max.y : y;
        y = y < min.y ? min.y : y;
        return new Vector22(x, y);
      };
      Vector22.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
        var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
        return new Vector22(x, y);
      };
      Vector22.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var result = Vector22.Zero();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      };
      Vector22.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
        var t2 = time * time;
        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
      };
      Vector22.Lerp = function(start, end, amount) {
        var x = start.x + (end.x - start.x) * amount;
        var y = start.y + (end.y - start.y) * amount;
        return new Vector22(x, y);
      };
      Vector22.Dot = function(left, right) {
        return left.x * right.x + left.y * right.y;
      };
      Vector22.Normalize = function(vector) {
        var newVector = Vector22.Zero();
        this.NormalizeToRef(vector, newVector);
        return newVector;
      };
      Vector22.NormalizeToRef = function(vector, result) {
        var len = vector.length();
        if (len === 0) {
          return;
        }
        result.x = vector.x / len;
        result.y = vector.y / len;
      };
      Vector22.Minimize = function(left, right) {
        var x = left.x < right.x ? left.x : right.x;
        var y = left.y < right.y ? left.y : right.y;
        return new Vector22(x, y);
      };
      Vector22.Maximize = function(left, right) {
        var x = left.x > right.x ? left.x : right.x;
        var y = left.y > right.y ? left.y : right.y;
        return new Vector22(x, y);
      };
      Vector22.Transform = function(vector, transformation) {
        var r = Vector22.Zero();
        Vector22.TransformToRef(vector, transformation, r);
        return r;
      };
      Vector22.TransformToRef = function(vector, transformation, result) {
        var m = transformation.m;
        var x = vector.x * m[0] + vector.y * m[4] + m[12];
        var y = vector.x * m[1] + vector.y * m[5] + m[13];
        result.x = x;
        result.y = y;
      };
      Vector22.PointInTriangle = function(p, p0, p1, p2) {
        var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
        var sign = a < 0 ? -1 : 1;
        var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
        var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
        return s > 0 && t > 0 && s + t < 2 * a * sign;
      };
      Vector22.Distance = function(value1, value2) {
        return Math.sqrt(Vector22.DistanceSquared(value1, value2));
      };
      Vector22.DistanceSquared = function(value1, value2) {
        var x = value1.x - value2.x;
        var y = value1.y - value2.y;
        return x * x + y * y;
      };
      Vector22.Center = function(value1, value2) {
        return Vector22.CenterToRef(value1, value2, Vector22.Zero());
      };
      Vector22.CenterToRef = function(value1, value2, ref) {
        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
      };
      Vector22.DistanceOfPointFromSegment = function(p, segA, segB) {
        var l2 = Vector22.DistanceSquared(segA, segB);
        if (l2 === 0) {
          return Vector22.Distance(p, segA);
        }
        var v = segB.subtract(segA);
        var t = Math.max(0, Math.min(1, Vector22.Dot(p.subtract(segA), v) / l2));
        var proj = segA.add(v.multiplyByFloats(t, t));
        return Vector22.Distance(p, proj);
      };
      return Vector22;
    }();
    Vector3 = function() {
      function Vector32(x, y, z) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this._isDirty = true;
        this._x = x;
        this._y = y;
        this._z = z;
      }
      Object.defineProperty(Vector32.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(value) {
          this._x = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(value) {
          this._y = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32.prototype, "z", {
        get: function() {
          return this._z;
        },
        set: function(value) {
          this._z = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Vector32.prototype.toString = function() {
        return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, "}");
      };
      Vector32.prototype.getClassName = function() {
        return "Vector3";
      };
      Vector32.prototype.getHashCode = function() {
        var x = _ExtractAsInt(this._x);
        var y = _ExtractAsInt(this._y);
        var z = _ExtractAsInt(this._z);
        var hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        return hash;
      };
      Vector32.prototype.asArray = function() {
        var result = [];
        this.toArray(result, 0);
        return result;
      };
      Vector32.prototype.toArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this._x;
        array[index + 1] = this._y;
        array[index + 2] = this._z;
        return this;
      };
      Vector32.prototype.fromArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        Vector32.FromArrayToRef(array, index, this);
        return this;
      };
      Vector32.prototype.toQuaternion = function() {
        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
      };
      Vector32.prototype.addInPlace = function(otherVector) {
        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
      };
      Vector32.prototype.addInPlaceFromFloats = function(x, y, z) {
        this.x += x;
        this.y += y;
        this.z += z;
        return this;
      };
      Vector32.prototype.add = function(otherVector) {
        return new Vector32(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
      };
      Vector32.prototype.addToRef = function(otherVector, result) {
        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
      };
      Vector32.prototype.subtractInPlace = function(otherVector) {
        this.x -= otherVector._x;
        this.y -= otherVector._y;
        this.z -= otherVector._z;
        return this;
      };
      Vector32.prototype.subtract = function(otherVector) {
        return new Vector32(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
      };
      Vector32.prototype.subtractToRef = function(otherVector, result) {
        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
      };
      Vector32.prototype.subtractFromFloats = function(x, y, z) {
        return new Vector32(this._x - x, this._y - y, this._z - z);
      };
      Vector32.prototype.subtractFromFloatsToRef = function(x, y, z, result) {
        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
      };
      Vector32.prototype.negate = function() {
        return new Vector32(-this._x, -this._y, -this._z);
      };
      Vector32.prototype.negateInPlace = function() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        return this;
      };
      Vector32.prototype.negateToRef = function(result) {
        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
      };
      Vector32.prototype.scaleInPlace = function(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        return this;
      };
      Vector32.prototype.scale = function(scale) {
        return new Vector32(this._x * scale, this._y * scale, this._z * scale);
      };
      Vector32.prototype.scaleToRef = function(scale, result) {
        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
      };
      Vector32.prototype.scaleAndAddToRef = function(scale, result) {
        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
      };
      Vector32.prototype.projectOnPlane = function(plane, origin) {
        var result = Vector32.Zero();
        this.projectOnPlaneToRef(plane, origin, result);
        return result;
      };
      Vector32.prototype.projectOnPlaneToRef = function(plane, origin, result) {
        var n = plane.normal;
        var d = plane.d;
        var V = MathTmp.Vector3[0];
        this.subtractToRef(origin, V);
        V.normalize();
        var denom = Vector32.Dot(V, n);
        var t = -(Vector32.Dot(origin, n) + d) / denom;
        var scaledV = V.scaleInPlace(t);
        origin.addToRef(scaledV, result);
      };
      Vector32.prototype.equals = function(otherVector) {
        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
      };
      Vector32.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
        if (epsilon === void 0) {
          epsilon = Epsilon;
        }
        return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
      };
      Vector32.prototype.equalsToFloats = function(x, y, z) {
        return this._x === x && this._y === y && this._z === z;
      };
      Vector32.prototype.multiplyInPlace = function(otherVector) {
        this.x *= otherVector._x;
        this.y *= otherVector._y;
        this.z *= otherVector._z;
        return this;
      };
      Vector32.prototype.multiply = function(otherVector) {
        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
      };
      Vector32.prototype.multiplyToRef = function(otherVector, result) {
        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
      };
      Vector32.prototype.multiplyByFloats = function(x, y, z) {
        return new Vector32(this._x * x, this._y * y, this._z * z);
      };
      Vector32.prototype.divide = function(otherVector) {
        return new Vector32(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
      };
      Vector32.prototype.divideToRef = function(otherVector, result) {
        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
      };
      Vector32.prototype.divideInPlace = function(otherVector) {
        return this.divideToRef(otherVector, this);
      };
      Vector32.prototype.minimizeInPlace = function(other) {
        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
      };
      Vector32.prototype.maximizeInPlace = function(other) {
        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
      };
      Vector32.prototype.minimizeInPlaceFromFloats = function(x, y, z) {
        if (x < this._x) {
          this.x = x;
        }
        if (y < this._y) {
          this.y = y;
        }
        if (z < this._z) {
          this.z = z;
        }
        return this;
      };
      Vector32.prototype.maximizeInPlaceFromFloats = function(x, y, z) {
        if (x > this._x) {
          this.x = x;
        }
        if (y > this._y) {
          this.y = y;
        }
        if (z > this._z) {
          this.z = z;
        }
        return this;
      };
      Vector32.prototype.isNonUniformWithinEpsilon = function(epsilon) {
        var absX = Math.abs(this._x);
        var absY = Math.abs(this._y);
        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
          return true;
        }
        var absZ = Math.abs(this._z);
        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
          return true;
        }
        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
          return true;
        }
        return false;
      };
      Object.defineProperty(Vector32.prototype, "isNonUniform", {
        get: function() {
          var absX = Math.abs(this._x);
          var absY = Math.abs(this._y);
          if (absX !== absY) {
            return true;
          }
          var absZ = Math.abs(this._z);
          if (absX !== absZ) {
            return true;
          }
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Vector32.prototype.floor = function() {
        return new Vector32(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
      };
      Vector32.prototype.fract = function() {
        return new Vector32(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
      };
      Vector32.prototype.length = function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
      };
      Vector32.prototype.lengthSquared = function() {
        return this._x * this._x + this._y * this._y + this._z * this._z;
      };
      Object.defineProperty(Vector32.prototype, "hasAZeroComponent", {
        get: function() {
          return this._x * this._y * this._z === 0;
        },
        enumerable: false,
        configurable: true
      });
      Vector32.prototype.normalize = function() {
        return this.normalizeFromLength(this.length());
      };
      Vector32.prototype.reorderInPlace = function(order) {
        var _this = this;
        order = order.toLowerCase();
        if (order === "xyz") {
          return this;
        }
        MathTmp.Vector3[0].copyFrom(this);
        ["x", "y", "z"].forEach(function(val, i) {
          _this[val] = MathTmp.Vector3[0][order[i]];
        });
        return this;
      };
      Vector32.prototype.rotateByQuaternionToRef = function(quaternion, result) {
        quaternion.toRotationMatrix(MathTmp.Matrix[0]);
        Vector32.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
        return result;
      };
      Vector32.prototype.rotateByQuaternionAroundPointToRef = function(quaternion, point, result) {
        this.subtractToRef(point, MathTmp.Vector3[0]);
        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
        point.addToRef(MathTmp.Vector3[0], result);
        return result;
      };
      Vector32.prototype.cross = function(other) {
        return Vector32.Cross(this, other);
      };
      Vector32.prototype.normalizeFromLength = function(len) {
        if (len === 0 || len === 1) {
          return this;
        }
        return this.scaleInPlace(1 / len);
      };
      Vector32.prototype.normalizeToNew = function() {
        var normalized = new Vector32(0, 0, 0);
        this.normalizeToRef(normalized);
        return normalized;
      };
      Vector32.prototype.normalizeToRef = function(reference) {
        var len = this.length();
        if (len === 0 || len === 1) {
          return reference.copyFromFloats(this._x, this._y, this._z);
        }
        return this.scaleToRef(1 / len, reference);
      };
      Vector32.prototype.clone = function() {
        return new Vector32(this._x, this._y, this._z);
      };
      Vector32.prototype.copyFrom = function(source) {
        return this.copyFromFloats(source._x, source._y, source._z);
      };
      Vector32.prototype.copyFromFloats = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      };
      Vector32.prototype.set = function(x, y, z) {
        return this.copyFromFloats(x, y, z);
      };
      Vector32.prototype.setAll = function(v) {
        this.x = this.y = this.z = v;
        return this;
      };
      Vector32.GetClipFactor = function(vector0, vector1, axis, size) {
        var d0 = Vector32.Dot(vector0, axis) - size;
        var d1 = Vector32.Dot(vector1, axis) - size;
        var s = d0 / (d0 - d1);
        return s;
      };
      Vector32.GetAngleBetweenVectors = function(vector0, vector1, normal) {
        var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
        var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
        var dot = Vector32.Dot(v0, v1);
        dot = Scalar.Clamp(dot, -1, 1);
        var angle = Math.acos(dot);
        var n = MathTmp.Vector3[3];
        Vector32.CrossToRef(v0, v1, n);
        if (Vector32.Dot(n, normal) > 0) {
          return isNaN(angle) ? 0 : angle;
        }
        return isNaN(angle) ? -Math.PI : -Math.acos(dot);
      };
      Vector32.GetAngleBetweenVectorsOnPlane = function(vector0, vector1, normal) {
        MathTmp.Vector3[0].copyFrom(vector0);
        var v0 = MathTmp.Vector3[0];
        MathTmp.Vector3[1].copyFrom(vector1);
        var v1 = MathTmp.Vector3[1];
        MathTmp.Vector3[2].copyFrom(normal);
        var vNormal = MathTmp.Vector3[2];
        var right = MathTmp.Vector3[3];
        var forward = MathTmp.Vector3[4];
        v0.normalize();
        v1.normalize();
        vNormal.normalize();
        Vector32.CrossToRef(vNormal, v0, right);
        Vector32.CrossToRef(right, vNormal, forward);
        var angle = Math.atan2(Vector32.Dot(v1, right), Vector32.Dot(v1, forward));
        return Scalar.NormalizeRadians(angle);
      };
      Vector32.SlerpToRef = function(vector0, vector1, slerp, result) {
        slerp = Scalar.Clamp(slerp, 0, 1);
        var vector0Dir = MathTmp.Vector3[0];
        var vector1Dir = MathTmp.Vector3[1];
        vector0Dir.copyFrom(vector0);
        var vector0Length = vector0Dir.length();
        vector0Dir.normalizeFromLength(vector0Length);
        vector1Dir.copyFrom(vector1);
        var vector1Length = vector1Dir.length();
        vector1Dir.normalizeFromLength(vector1Length);
        var dot = Vector32.Dot(vector0Dir, vector1Dir);
        var scale0;
        var scale1;
        if (dot < 1 - Epsilon) {
          var omega = Math.acos(dot);
          var invSin = 1 / Math.sin(omega);
          scale0 = Math.sin((1 - slerp) * omega) * invSin;
          scale1 = Math.sin(slerp * omega) * invSin;
        } else {
          scale0 = 1 - slerp;
          scale1 = slerp;
        }
        vector0Dir.scaleInPlace(scale0);
        vector1Dir.scaleInPlace(scale1);
        result.copyFrom(vector0Dir).addInPlace(vector1Dir);
        result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
      };
      Vector32.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
        Vector32.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
      };
      Vector32.FromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return new Vector32(array[offset], array[offset + 1], array[offset + 2]);
      };
      Vector32.FromFloatArray = function(array, offset) {
        return Vector32.FromArray(array, offset);
      };
      Vector32.FromArrayToRef = function(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
        result.z = array[offset + 2];
      };
      Vector32.FromFloatArrayToRef = function(array, offset, result) {
        return Vector32.FromArrayToRef(array, offset, result);
      };
      Vector32.FromFloatsToRef = function(x, y, z, result) {
        result.copyFromFloats(x, y, z);
      };
      Vector32.Zero = function() {
        return new Vector32(0, 0, 0);
      };
      Vector32.One = function() {
        return new Vector32(1, 1, 1);
      };
      Vector32.Up = function() {
        return new Vector32(0, 1, 0);
      };
      Object.defineProperty(Vector32, "UpReadOnly", {
        get: function() {
          return Vector32._UpReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32, "RightReadOnly", {
        get: function() {
          return Vector32._RightReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32, "LeftReadOnly", {
        get: function() {
          return Vector32._LeftReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32, "LeftHandedForwardReadOnly", {
        get: function() {
          return Vector32._LeftHandedForwardReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32, "RightHandedForwardReadOnly", {
        get: function() {
          return Vector32._RightHandedForwardReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Vector32, "ZeroReadOnly", {
        get: function() {
          return Vector32._ZeroReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Vector32.Down = function() {
        return new Vector32(0, -1, 0);
      };
      Vector32.Forward = function(rightHandedSystem) {
        if (rightHandedSystem === void 0) {
          rightHandedSystem = false;
        }
        return new Vector32(0, 0, rightHandedSystem ? -1 : 1);
      };
      Vector32.Backward = function(rightHandedSystem) {
        if (rightHandedSystem === void 0) {
          rightHandedSystem = false;
        }
        return new Vector32(0, 0, rightHandedSystem ? 1 : -1);
      };
      Vector32.Right = function() {
        return new Vector32(1, 0, 0);
      };
      Vector32.Left = function() {
        return new Vector32(-1, 0, 0);
      };
      Vector32.TransformCoordinates = function(vector, transformation) {
        var result = Vector32.Zero();
        Vector32.TransformCoordinatesToRef(vector, transformation, result);
        return result;
      };
      Vector32.TransformCoordinatesToRef = function(vector, transformation, result) {
        Vector32.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
      };
      Vector32.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
        var m = transformation.m;
        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
        var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
        result.x = rx * rw;
        result.y = ry * rw;
        result.z = rz * rw;
      };
      Vector32.TransformNormal = function(vector, transformation) {
        var result = Vector32.Zero();
        Vector32.TransformNormalToRef(vector, transformation, result);
        return result;
      };
      Vector32.TransformNormalToRef = function(vector, transformation, result) {
        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
      };
      Vector32.TransformNormalFromFloatsToRef = function(x, y, z, transformation, result) {
        var m = transformation.m;
        result.x = x * m[0] + y * m[4] + z * m[8];
        result.y = x * m[1] + y * m[5] + z * m[9];
        result.z = x * m[2] + y * m[6] + z * m[10];
      };
      Vector32.CatmullRom = function(value1, value2, value3, value4, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
        var y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
        var z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
        return new Vector32(x, y, z);
      };
      Vector32.Clamp = function(value, min, max) {
        var v = new Vector32();
        Vector32.ClampToRef(value, min, max, v);
        return v;
      };
      Vector32.ClampToRef = function(value, min, max, result) {
        var x = value._x;
        x = x > max._x ? max._x : x;
        x = x < min._x ? min._x : x;
        var y = value._y;
        y = y > max._y ? max._y : y;
        y = y < min._y ? min._y : y;
        var z = value._z;
        z = z > max._z ? max._z : z;
        z = z < min._z ? min._z : z;
        result.copyFromFloats(x, y, z);
      };
      Vector32.CheckExtends = function(v, min, max) {
        min.minimizeInPlace(v);
        max.maximizeInPlace(v);
      };
      Vector32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
        var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
        var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
        return new Vector32(x, y, z);
      };
      Vector32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var result = Vector32.Zero();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      };
      Vector32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
        var t2 = time * time;
        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
      };
      Vector32.Lerp = function(start, end, amount) {
        var result = new Vector32(0, 0, 0);
        Vector32.LerpToRef(start, end, amount, result);
        return result;
      };
      Vector32.LerpToRef = function(start, end, amount, result) {
        result.x = start._x + (end._x - start._x) * amount;
        result.y = start._y + (end._y - start._y) * amount;
        result.z = start._z + (end._z - start._z) * amount;
      };
      Vector32.Dot = function(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
      };
      Vector32.Cross = function(left, right) {
        var result = Vector32.Zero();
        Vector32.CrossToRef(left, right, result);
        return result;
      };
      Vector32.CrossToRef = function(left, right, result) {
        var x = left._y * right._z - left._z * right._y;
        var y = left._z * right._x - left._x * right._z;
        var z = left._x * right._y - left._y * right._x;
        result.copyFromFloats(x, y, z);
      };
      Vector32.Normalize = function(vector) {
        var result = Vector32.Zero();
        Vector32.NormalizeToRef(vector, result);
        return result;
      };
      Vector32.NormalizeToRef = function(vector, result) {
        vector.normalizeToRef(result);
      };
      Vector32.Project = function(vector, world, transform, viewport) {
        var result = new Vector32();
        Vector32.ProjectToRef(vector, world, transform, viewport, result);
        return result;
      };
      Vector32.ProjectToRef = function(vector, world, transform, viewport, result) {
        var cw = viewport.width;
        var ch = viewport.height;
        var cx = viewport.x;
        var cy = viewport.y;
        var viewportMatrix = MathTmp.Matrix[1];
        Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
        var matrix = MathTmp.Matrix[0];
        world.multiplyToRef(transform, matrix);
        matrix.multiplyToRef(viewportMatrix, matrix);
        Vector32.TransformCoordinatesToRef(vector, matrix, result);
        return result;
      };
      Vector32._UnprojectFromInvertedMatrixToRef = function(source, matrix, result) {
        Vector32.TransformCoordinatesToRef(source, matrix, result);
        var m = matrix.m;
        var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
        if (Scalar.WithinEpsilon(num, 1)) {
          result.scaleInPlace(1 / num);
        }
      };
      Vector32.UnprojectFromTransform = function(source, viewportWidth, viewportHeight, world, transform) {
        return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);
      };
      Vector32.Unproject = function(source, viewportWidth, viewportHeight, world, view, projection) {
        var result = Vector32.Zero();
        Vector32.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
        return result;
      };
      Vector32.UnprojectToRef = function(source, viewportWidth, viewportHeight, world, view, projection, result) {
        Vector32.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
      };
      Vector32.UnprojectFloatsToRef = function(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
        var _a;
        var matrix = MathTmp.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        matrix.invert();
        var screenSource = MathTmp.Vector3[0];
        screenSource.x = sourceX / viewportWidth * 2 - 1;
        screenSource.y = -(sourceY / viewportHeight * 2 - 1);
        if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {
          screenSource.z = sourceZ;
        } else {
          screenSource.z = 2 * sourceZ - 1;
        }
        Vector32._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
      };
      Vector32.Minimize = function(left, right) {
        var min = left.clone();
        min.minimizeInPlace(right);
        return min;
      };
      Vector32.Maximize = function(left, right) {
        var max = left.clone();
        max.maximizeInPlace(right);
        return max;
      };
      Vector32.Distance = function(value1, value2) {
        return Math.sqrt(Vector32.DistanceSquared(value1, value2));
      };
      Vector32.DistanceSquared = function(value1, value2) {
        var x = value1._x - value2._x;
        var y = value1._y - value2._y;
        var z = value1._z - value2._z;
        return x * x + y * y + z * z;
      };
      Vector32.ProjectOnTriangleToRef = function(vector, p0, p1, p2, ref) {
        var p1p0 = MathTmp.Vector3[0];
        var p2p0 = MathTmp.Vector3[1];
        var p2p1 = MathTmp.Vector3[2];
        var normal = MathTmp.Vector3[3];
        var vectorp0 = MathTmp.Vector3[4];
        p1.subtractToRef(p0, p1p0);
        p2.subtractToRef(p0, p2p0);
        p2.subtractToRef(p1, p2p1);
        var p1p0L = p1p0.length();
        var p2p0L = p2p0.length();
        var p2p1L = p2p1.length();
        if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
          ref.copyFrom(p0);
          return Vector32.Distance(vector, p0);
        }
        vector.subtractToRef(p0, vectorp0);
        Vector32.CrossToRef(p1p0, p2p0, normal);
        var nl = normal.length();
        if (nl < Epsilon) {
          ref.copyFrom(p0);
          return Vector32.Distance(vector, p0);
        }
        normal.normalizeFromLength(nl);
        var l = vectorp0.length();
        if (l < Epsilon) {
          ref.copyFrom(p0);
          return 0;
        }
        vectorp0.normalizeFromLength(l);
        var cosA = Vector32.Dot(normal, vectorp0);
        var projVector = MathTmp.Vector3[5];
        var proj = MathTmp.Vector3[6];
        projVector.copyFrom(normal).scaleInPlace(-l * cosA);
        proj.copyFrom(vector).addInPlace(projVector);
        var v0 = MathTmp.Vector3[4];
        var v1 = MathTmp.Vector3[5];
        var v2 = MathTmp.Vector3[7];
        var tmp = MathTmp.Vector3[8];
        v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
        tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
        v0.addInPlace(tmp).scaleInPlace(-1);
        v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
        tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
        v1.addInPlace(tmp).scaleInPlace(-1);
        v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
        tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
        v2.addInPlace(tmp).scaleInPlace(-1);
        var projP = MathTmp.Vector3[9];
        var dot;
        projP.copyFrom(proj).subtractInPlace(p0);
        Vector32.CrossToRef(v0, projP, tmp);
        dot = Vector32.Dot(tmp, normal);
        var s0 = dot;
        projP.copyFrom(proj).subtractInPlace(p1);
        Vector32.CrossToRef(v1, projP, tmp);
        dot = Vector32.Dot(tmp, normal);
        var s1 = dot;
        projP.copyFrom(proj).subtractInPlace(p2);
        Vector32.CrossToRef(v2, projP, tmp);
        dot = Vector32.Dot(tmp, normal);
        var s2 = dot;
        var edge = MathTmp.Vector3[10];
        var e0, e1;
        if (s0 > 0 && s1 < 0) {
          edge.copyFrom(p1p0);
          e0 = p0;
          e1 = p1;
        } else if (s1 > 0 && s2 < 0) {
          edge.copyFrom(p2p1);
          e0 = p1;
          e1 = p2;
        } else {
          edge.copyFrom(p2p0).scaleInPlace(-1);
          e0 = p2;
          e1 = p0;
        }
        var tmp2 = MathTmp.Vector3[9];
        var tmp3 = MathTmp.Vector3[4];
        e0.subtractToRef(proj, tmp);
        e1.subtractToRef(proj, tmp2);
        Vector32.CrossToRef(tmp, tmp2, tmp3);
        var isOutside = Vector32.Dot(tmp3, normal) < 0;
        if (!isOutside) {
          ref.copyFrom(proj);
          return Math.abs(l * cosA);
        }
        var r = MathTmp.Vector3[5];
        Vector32.CrossToRef(edge, tmp3, r);
        r.normalize();
        var e0proj = MathTmp.Vector3[9];
        e0proj.copyFrom(e0).subtractInPlace(proj);
        var e0projL = e0proj.length();
        if (e0projL < Epsilon) {
          ref.copyFrom(e0);
          return Vector32.Distance(vector, e0);
        }
        e0proj.normalizeFromLength(e0projL);
        var cosG = Vector32.Dot(r, e0proj);
        var triProj = MathTmp.Vector3[7];
        triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
        tmp.copyFrom(triProj).subtractInPlace(e0);
        l = edge.length();
        edge.normalizeFromLength(l);
        var t = Vector32.Dot(tmp, edge) / Math.max(l, Epsilon);
        t = Scalar.Clamp(t, 0, 1);
        triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
        ref.copyFrom(triProj);
        return Vector32.Distance(vector, triProj);
      };
      Vector32.Center = function(value1, value2) {
        return Vector32.CenterToRef(value1, value2, Vector32.Zero());
      };
      Vector32.CenterToRef = function(value1, value2, ref) {
        return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
      };
      Vector32.RotationFromAxis = function(axis1, axis2, axis3) {
        var rotation = Vector32.Zero();
        Vector32.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
        return rotation;
      };
      Vector32.RotationFromAxisToRef = function(axis1, axis2, axis3, ref) {
        var quat = MathTmp.Quaternion[0];
        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
        quat.toEulerAnglesToRef(ref);
      };
      Vector32._UpReadOnly = Vector32.Up();
      Vector32._LeftHandedForwardReadOnly = Vector32.Forward(false);
      Vector32._RightHandedForwardReadOnly = Vector32.Forward(true);
      Vector32._RightReadOnly = Vector32.Right();
      Vector32._LeftReadOnly = Vector32.Left();
      Vector32._ZeroReadOnly = Vector32.Zero();
      return Vector32;
    }();
    Vector4 = function() {
      function Vector42(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      Vector42.prototype.toString = function() {
        return "{X: ".concat(this.x, " Y: ").concat(this.y, " Z: ").concat(this.z, " W: ").concat(this.w, "}");
      };
      Vector42.prototype.getClassName = function() {
        return "Vector4";
      };
      Vector42.prototype.getHashCode = function() {
        var x = _ExtractAsInt(this.x);
        var y = _ExtractAsInt(this.y);
        var z = _ExtractAsInt(this.z);
        var w = _ExtractAsInt(this.w);
        var hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        hash = hash * 397 ^ w;
        return hash;
      };
      Vector42.prototype.asArray = function() {
        var result = new Array();
        this.toArray(result, 0);
        return result;
      };
      Vector42.prototype.toArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this.x;
        array[index + 1] = this.y;
        array[index + 2] = this.z;
        array[index + 3] = this.w;
        return this;
      };
      Vector42.prototype.fromArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        Vector42.FromArrayToRef(array, index, this);
        return this;
      };
      Vector42.prototype.addInPlace = function(otherVector) {
        this.x += otherVector.x;
        this.y += otherVector.y;
        this.z += otherVector.z;
        this.w += otherVector.w;
        return this;
      };
      Vector42.prototype.add = function(otherVector) {
        return new Vector42(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
      };
      Vector42.prototype.addToRef = function(otherVector, result) {
        result.x = this.x + otherVector.x;
        result.y = this.y + otherVector.y;
        result.z = this.z + otherVector.z;
        result.w = this.w + otherVector.w;
        return this;
      };
      Vector42.prototype.subtractInPlace = function(otherVector) {
        this.x -= otherVector.x;
        this.y -= otherVector.y;
        this.z -= otherVector.z;
        this.w -= otherVector.w;
        return this;
      };
      Vector42.prototype.subtract = function(otherVector) {
        return new Vector42(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
      };
      Vector42.prototype.subtractToRef = function(otherVector, result) {
        result.x = this.x - otherVector.x;
        result.y = this.y - otherVector.y;
        result.z = this.z - otherVector.z;
        result.w = this.w - otherVector.w;
        return this;
      };
      Vector42.prototype.subtractFromFloats = function(x, y, z, w) {
        return new Vector42(this.x - x, this.y - y, this.z - z, this.w - w);
      };
      Vector42.prototype.subtractFromFloatsToRef = function(x, y, z, w, result) {
        result.x = this.x - x;
        result.y = this.y - y;
        result.z = this.z - z;
        result.w = this.w - w;
        return this;
      };
      Vector42.prototype.negate = function() {
        return new Vector42(-this.x, -this.y, -this.z, -this.w);
      };
      Vector42.prototype.negateInPlace = function() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        this.w *= -1;
        return this;
      };
      Vector42.prototype.negateToRef = function(result) {
        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
      };
      Vector42.prototype.scaleInPlace = function(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;
        return this;
      };
      Vector42.prototype.scale = function(scale) {
        return new Vector42(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
      };
      Vector42.prototype.scaleToRef = function(scale, result) {
        result.x = this.x * scale;
        result.y = this.y * scale;
        result.z = this.z * scale;
        result.w = this.w * scale;
        return this;
      };
      Vector42.prototype.scaleAndAddToRef = function(scale, result) {
        result.x += this.x * scale;
        result.y += this.y * scale;
        result.z += this.z * scale;
        result.w += this.w * scale;
        return this;
      };
      Vector42.prototype.equals = function(otherVector) {
        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
      };
      Vector42.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
        if (epsilon === void 0) {
          epsilon = Epsilon;
        }
        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
      };
      Vector42.prototype.equalsToFloats = function(x, y, z, w) {
        return this.x === x && this.y === y && this.z === z && this.w === w;
      };
      Vector42.prototype.multiplyInPlace = function(otherVector) {
        this.x *= otherVector.x;
        this.y *= otherVector.y;
        this.z *= otherVector.z;
        this.w *= otherVector.w;
        return this;
      };
      Vector42.prototype.multiply = function(otherVector) {
        return new Vector42(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
      };
      Vector42.prototype.multiplyToRef = function(otherVector, result) {
        result.x = this.x * otherVector.x;
        result.y = this.y * otherVector.y;
        result.z = this.z * otherVector.z;
        result.w = this.w * otherVector.w;
        return this;
      };
      Vector42.prototype.multiplyByFloats = function(x, y, z, w) {
        return new Vector42(this.x * x, this.y * y, this.z * z, this.w * w);
      };
      Vector42.prototype.divide = function(otherVector) {
        return new Vector42(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
      };
      Vector42.prototype.divideToRef = function(otherVector, result) {
        result.x = this.x / otherVector.x;
        result.y = this.y / otherVector.y;
        result.z = this.z / otherVector.z;
        result.w = this.w / otherVector.w;
        return this;
      };
      Vector42.prototype.divideInPlace = function(otherVector) {
        return this.divideToRef(otherVector, this);
      };
      Vector42.prototype.minimizeInPlace = function(other) {
        if (other.x < this.x) {
          this.x = other.x;
        }
        if (other.y < this.y) {
          this.y = other.y;
        }
        if (other.z < this.z) {
          this.z = other.z;
        }
        if (other.w < this.w) {
          this.w = other.w;
        }
        return this;
      };
      Vector42.prototype.maximizeInPlace = function(other) {
        if (other.x > this.x) {
          this.x = other.x;
        }
        if (other.y > this.y) {
          this.y = other.y;
        }
        if (other.z > this.z) {
          this.z = other.z;
        }
        if (other.w > this.w) {
          this.w = other.w;
        }
        return this;
      };
      Vector42.prototype.floor = function() {
        return new Vector42(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
      };
      Vector42.prototype.fract = function() {
        return new Vector42(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
      };
      Vector42.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      };
      Vector42.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      };
      Vector42.prototype.normalize = function() {
        var len = this.length();
        if (len === 0) {
          return this;
        }
        return this.scaleInPlace(1 / len);
      };
      Vector42.prototype.toVector3 = function() {
        return new Vector3(this.x, this.y, this.z);
      };
      Vector42.prototype.clone = function() {
        return new Vector42(this.x, this.y, this.z, this.w);
      };
      Vector42.prototype.copyFrom = function(source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        this.w = source.w;
        return this;
      };
      Vector42.prototype.copyFromFloats = function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      };
      Vector42.prototype.set = function(x, y, z, w) {
        return this.copyFromFloats(x, y, z, w);
      };
      Vector42.prototype.setAll = function(v) {
        this.x = this.y = this.z = this.w = v;
        return this;
      };
      Vector42.FromArray = function(array, offset) {
        if (!offset) {
          offset = 0;
        }
        return new Vector42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      };
      Vector42.FromArrayToRef = function(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
        result.z = array[offset + 2];
        result.w = array[offset + 3];
      };
      Vector42.FromFloatArrayToRef = function(array, offset, result) {
        Vector42.FromArrayToRef(array, offset, result);
      };
      Vector42.FromFloatsToRef = function(x, y, z, w, result) {
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
      };
      Vector42.Zero = function() {
        return new Vector42(0, 0, 0, 0);
      };
      Vector42.One = function() {
        return new Vector42(1, 1, 1, 1);
      };
      Vector42.Normalize = function(vector) {
        var result = Vector42.Zero();
        Vector42.NormalizeToRef(vector, result);
        return result;
      };
      Vector42.NormalizeToRef = function(vector, result) {
        result.copyFrom(vector);
        result.normalize();
      };
      Vector42.Minimize = function(left, right) {
        var min = left.clone();
        min.minimizeInPlace(right);
        return min;
      };
      Vector42.Maximize = function(left, right) {
        var max = left.clone();
        max.maximizeInPlace(right);
        return max;
      };
      Vector42.Distance = function(value1, value2) {
        return Math.sqrt(Vector42.DistanceSquared(value1, value2));
      };
      Vector42.DistanceSquared = function(value1, value2) {
        var x = value1.x - value2.x;
        var y = value1.y - value2.y;
        var z = value1.z - value2.z;
        var w = value1.w - value2.w;
        return x * x + y * y + z * z + w * w;
      };
      Vector42.Center = function(value1, value2) {
        return Vector42.CenterToRef(value1, value2, Vector42.Zero());
      };
      Vector42.CenterToRef = function(value1, value2, ref) {
        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
      };
      Vector42.TransformCoordinates = function(vector, transformation) {
        var result = Vector42.Zero();
        Vector42.TransformCoordinatesToRef(vector, transformation, result);
        return result;
      };
      Vector42.TransformCoordinatesToRef = function(vector, transformation, result) {
        Vector42.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
      };
      Vector42.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
        var m = transformation.m;
        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
        var rw = x * m[3] + y * m[7] + z * m[11] + m[15];
        result.x = rx;
        result.y = ry;
        result.z = rz;
        result.w = rw;
      };
      Vector42.TransformNormal = function(vector, transformation) {
        var result = Vector42.Zero();
        Vector42.TransformNormalToRef(vector, transformation, result);
        return result;
      };
      Vector42.TransformNormalToRef = function(vector, transformation, result) {
        var m = transformation.m;
        var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
        var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
        var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = vector.w;
      };
      Vector42.TransformNormalFromFloatsToRef = function(x, y, z, w, transformation, result) {
        var m = transformation.m;
        result.x = x * m[0] + y * m[4] + z * m[8];
        result.y = x * m[1] + y * m[5] + z * m[9];
        result.z = x * m[2] + y * m[6] + z * m[10];
        result.w = w;
      };
      Vector42.FromVector3 = function(source, w) {
        if (w === void 0) {
          w = 0;
        }
        return new Vector42(source._x, source._y, source._z, w);
      };
      return Vector42;
    }();
    Quaternion = function() {
      function Quaternion2(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (w === void 0) {
          w = 1;
        }
        this._isDirty = true;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      Object.defineProperty(Quaternion2.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(value) {
          this._x = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Quaternion2.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(value) {
          this._y = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Quaternion2.prototype, "z", {
        get: function() {
          return this._z;
        },
        set: function(value) {
          this._z = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Quaternion2.prototype, "w", {
        get: function() {
          return this._w;
        },
        set: function(value) {
          this._w = value;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Quaternion2.prototype.toString = function() {
        return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, " W: ").concat(this._w, "}");
      };
      Quaternion2.prototype.getClassName = function() {
        return "Quaternion";
      };
      Quaternion2.prototype.getHashCode = function() {
        var x = _ExtractAsInt(this._x);
        var y = _ExtractAsInt(this._y);
        var z = _ExtractAsInt(this._z);
        var w = _ExtractAsInt(this._w);
        var hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        hash = hash * 397 ^ w;
        return hash;
      };
      Quaternion2.prototype.asArray = function() {
        return [this._x, this._y, this._z, this._w];
      };
      Quaternion2.prototype.equals = function(otherQuaternion) {
        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
      };
      Quaternion2.prototype.equalsWithEpsilon = function(otherQuaternion, epsilon) {
        if (epsilon === void 0) {
          epsilon = Epsilon;
        }
        return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
      };
      Quaternion2.prototype.clone = function() {
        return new Quaternion2(this._x, this._y, this._z, this._w);
      };
      Quaternion2.prototype.copyFrom = function(other) {
        this.x = other._x;
        this.y = other._y;
        this.z = other._z;
        this.w = other._w;
        return this;
      };
      Quaternion2.prototype.copyFromFloats = function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      };
      Quaternion2.prototype.set = function(x, y, z, w) {
        return this.copyFromFloats(x, y, z, w);
      };
      Quaternion2.prototype.add = function(other) {
        return new Quaternion2(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
      };
      Quaternion2.prototype.addInPlace = function(other) {
        this._x += other._x;
        this._y += other._y;
        this._z += other._z;
        this._w += other._w;
        return this;
      };
      Quaternion2.prototype.subtract = function(other) {
        return new Quaternion2(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
      };
      Quaternion2.prototype.scale = function(value) {
        return new Quaternion2(this._x * value, this._y * value, this._z * value, this._w * value);
      };
      Quaternion2.prototype.scaleToRef = function(scale, result) {
        result.x = this._x * scale;
        result.y = this._y * scale;
        result.z = this._z * scale;
        result.w = this._w * scale;
        return this;
      };
      Quaternion2.prototype.scaleInPlace = function(value) {
        this.x *= value;
        this.y *= value;
        this.z *= value;
        this.w *= value;
        return this;
      };
      Quaternion2.prototype.scaleAndAddToRef = function(scale, result) {
        result.x += this._x * scale;
        result.y += this._y * scale;
        result.z += this._z * scale;
        result.w += this._w * scale;
        return this;
      };
      Quaternion2.prototype.multiply = function(q1) {
        var result = new Quaternion2(0, 0, 0, 1);
        this.multiplyToRef(q1, result);
        return result;
      };
      Quaternion2.prototype.multiplyToRef = function(q1, result) {
        var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
        var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
        var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
        var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
        result.copyFromFloats(x, y, z, w);
        return this;
      };
      Quaternion2.prototype.multiplyInPlace = function(q1) {
        this.multiplyToRef(q1, this);
        return this;
      };
      Quaternion2.prototype.conjugateToRef = function(ref) {
        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
        return this;
      };
      Quaternion2.prototype.conjugateInPlace = function() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        return this;
      };
      Quaternion2.prototype.conjugate = function() {
        var result = new Quaternion2(-this._x, -this._y, -this._z, this._w);
        return result;
      };
      Quaternion2.prototype.length = function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      };
      Quaternion2.prototype.normalize = function() {
        var len = this.length();
        if (len === 0) {
          return this;
        }
        var inv = 1 / len;
        this.x *= inv;
        this.y *= inv;
        this.z *= inv;
        this.w *= inv;
        return this;
      };
      Quaternion2.prototype.toEulerAngles = function() {
        var result = Vector3.Zero();
        this.toEulerAnglesToRef(result);
        return result;
      };
      Quaternion2.prototype.toEulerAnglesToRef = function(result) {
        var qz = this._z;
        var qx = this._x;
        var qy = this._y;
        var qw = this._w;
        var sqw = qw * qw;
        var sqz = qz * qz;
        var sqx = qx * qx;
        var sqy = qy * qy;
        var zAxisY = qy * qz - qx * qw;
        var limit = 0.4999999;
        if (zAxisY < -limit) {
          result.y = 2 * Math.atan2(qy, qw);
          result.x = Math.PI / 2;
          result.z = 0;
        } else if (zAxisY > limit) {
          result.y = 2 * Math.atan2(qy, qw);
          result.x = -Math.PI / 2;
          result.z = 0;
        } else {
          result.z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
          result.x = Math.asin(-2 * (qz * qy - qx * qw));
          result.y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
        }
        return this;
      };
      Quaternion2.prototype.toRotationMatrix = function(result) {
        Matrix.FromQuaternionToRef(this, result);
        return this;
      };
      Quaternion2.prototype.fromRotationMatrix = function(matrix) {
        Quaternion2.FromRotationMatrixToRef(matrix, this);
        return this;
      };
      Quaternion2.FromRotationMatrix = function(matrix) {
        var result = new Quaternion2();
        Quaternion2.FromRotationMatrixToRef(matrix, result);
        return result;
      };
      Quaternion2.FromRotationMatrixToRef = function(matrix, result) {
        var data = matrix.m;
        var m11 = data[0], m12 = data[4], m13 = data[8];
        var m21 = data[1], m22 = data[5], m23 = data[9];
        var m31 = data[2], m32 = data[6], m33 = data[10];
        var trace = m11 + m22 + m33;
        var s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1);
          result.w = 0.25 / s;
          result.x = (m32 - m23) * s;
          result.y = (m13 - m31) * s;
          result.z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          result.w = (m32 - m23) / s;
          result.x = 0.25 * s;
          result.y = (m12 + m21) / s;
          result.z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          result.w = (m13 - m31) / s;
          result.x = (m12 + m21) / s;
          result.y = 0.25 * s;
          result.z = (m23 + m32) / s;
        } else {
          s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          result.w = (m21 - m12) / s;
          result.x = (m13 + m31) / s;
          result.y = (m23 + m32) / s;
          result.z = 0.25 * s;
        }
      };
      Quaternion2.Dot = function(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
      };
      Quaternion2.AreClose = function(quat0, quat1) {
        var dot = Quaternion2.Dot(quat0, quat1);
        return dot >= 0;
      };
      Quaternion2.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
        var slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
        slerp = Scalar.Clamp(slerp, 0, 1);
        Quaternion2.SlerpToRef(source, goal, slerp, result);
      };
      Quaternion2.Zero = function() {
        return new Quaternion2(0, 0, 0, 0);
      };
      Quaternion2.Inverse = function(q) {
        return new Quaternion2(-q._x, -q._y, -q._z, q._w);
      };
      Quaternion2.InverseToRef = function(q, result) {
        result.set(-q._x, -q._y, -q._z, q._w);
        return result;
      };
      Quaternion2.Identity = function() {
        return new Quaternion2(0, 0, 0, 1);
      };
      Quaternion2.IsIdentity = function(quaternion) {
        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
      };
      Quaternion2.RotationAxis = function(axis, angle) {
        return Quaternion2.RotationAxisToRef(axis, angle, new Quaternion2());
      };
      Quaternion2.RotationAxisToRef = function(axis, angle, result) {
        var sin = Math.sin(angle / 2);
        axis.normalize();
        result.w = Math.cos(angle / 2);
        result.x = axis._x * sin;
        result.y = axis._y * sin;
        result.z = axis._z * sin;
        return result;
      };
      Quaternion2.FromArray = function(array, offset) {
        if (!offset) {
          offset = 0;
        }
        return new Quaternion2(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      };
      Quaternion2.FromArrayToRef = function(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
        result.z = array[offset + 2];
        result.w = array[offset + 3];
      };
      Quaternion2.FromEulerAngles = function(x, y, z) {
        var q = new Quaternion2();
        Quaternion2.RotationYawPitchRollToRef(y, x, z, q);
        return q;
      };
      Quaternion2.FromEulerAnglesToRef = function(x, y, z, result) {
        Quaternion2.RotationYawPitchRollToRef(y, x, z, result);
        return result;
      };
      Quaternion2.FromEulerVector = function(vec) {
        var q = new Quaternion2();
        Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
        return q;
      };
      Quaternion2.FromEulerVectorToRef = function(vec, result) {
        Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
        return result;
      };
      Quaternion2.FromUnitVectorsToRef = function(vecFrom, vecTo, result) {
        var r = Vector3.Dot(vecFrom, vecTo) + 1;
        if (r < Epsilon) {
          if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
            result.set(-vecFrom.y, vecFrom.x, 0, 0);
          } else {
            result.set(0, -vecFrom.z, vecFrom.y, 0);
          }
        } else {
          Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
          result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
        }
        return result.normalize();
      };
      Quaternion2.RotationYawPitchRoll = function(yaw, pitch, roll) {
        var q = new Quaternion2();
        Quaternion2.RotationYawPitchRollToRef(yaw, pitch, roll, q);
        return q;
      };
      Quaternion2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
        result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
      };
      Quaternion2.RotationAlphaBetaGamma = function(alpha, beta, gamma) {
        var result = new Quaternion2();
        Quaternion2.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
        return result;
      };
      Quaternion2.RotationAlphaBetaGammaToRef = function(alpha, beta, gamma, result) {
        var halfGammaPlusAlpha = (gamma + alpha) * 0.5;
        var halfGammaMinusAlpha = (gamma - alpha) * 0.5;
        var halfBeta = beta * 0.5;
        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
      };
      Quaternion2.RotationQuaternionFromAxis = function(axis1, axis2, axis3) {
        var quat = new Quaternion2(0, 0, 0, 0);
        Quaternion2.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
        return quat;
      };
      Quaternion2.RotationQuaternionFromAxisToRef = function(axis1, axis2, axis3, ref) {
        var rotMat = MathTmp.Matrix[0];
        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
        Quaternion2.FromRotationMatrixToRef(rotMat, ref);
      };
      Quaternion2.FromLookDirectionLH = function(forward, up) {
        var quat = new Quaternion2();
        Quaternion2.FromLookDirectionLHToRef(forward, up, quat);
        return quat;
      };
      Quaternion2.FromLookDirectionLHToRef = function(forward, up, ref) {
        var rotMat = MathTmp.Matrix[0];
        Matrix.LookDirectionLHToRef(forward, up, rotMat);
        Quaternion2.FromRotationMatrixToRef(rotMat, ref);
      };
      Quaternion2.FromLookDirectionRH = function(forward, up) {
        var quat = new Quaternion2();
        Quaternion2.FromLookDirectionRHToRef(forward, up, quat);
        return quat;
      };
      Quaternion2.FromLookDirectionRHToRef = function(forward, up, ref) {
        var rotMat = MathTmp.Matrix[0];
        Matrix.LookDirectionRHToRef(forward, up, rotMat);
        return Quaternion2.FromRotationMatrixToRef(rotMat, ref);
      };
      Quaternion2.Slerp = function(left, right, amount) {
        var result = Quaternion2.Identity();
        Quaternion2.SlerpToRef(left, right, amount, result);
        return result;
      };
      Quaternion2.SlerpToRef = function(left, right, amount, result) {
        var num2;
        var num3;
        var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
        var flag = false;
        if (num4 < 0) {
          flag = true;
          num4 = -num4;
        }
        if (num4 > 0.999999) {
          num3 = 1 - amount;
          num2 = flag ? -amount : amount;
        } else {
          var num5 = Math.acos(num4);
          var num6 = 1 / Math.sin(num5);
          num3 = Math.sin((1 - amount) * num5) * num6;
          num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
        }
        result.x = num3 * left._x + num2 * right._x;
        result.y = num3 * left._y + num2 * right._y;
        result.z = num3 * left._z + num2 * right._z;
        result.w = num3 * left._w + num2 * right._w;
      };
      Quaternion2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
        var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
        var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
        var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
        return new Quaternion2(x, y, z, w);
      };
      Quaternion2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var result = Quaternion2.Zero();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      };
      Quaternion2.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
        var t2 = time * time;
        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
        result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;
      };
      return Quaternion2;
    }();
    Matrix = function() {
      function Matrix2() {
        this._isIdentity = false;
        this._isIdentityDirty = true;
        this._isIdentity3x2 = true;
        this._isIdentity3x2Dirty = true;
        this.updateFlag = -1;
        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
          PerformanceConfigurator.MatrixTrackedMatrices.push(this);
        }
        this._m = new PerformanceConfigurator.MatrixCurrentType(16);
        this.markAsUpdated();
      }
      Object.defineProperty(Matrix2, "Use64Bits", {
        get: function() {
          return PerformanceConfigurator.MatrixUse64Bits;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix2.prototype, "m", {
        get: function() {
          return this._m;
        },
        enumerable: false,
        configurable: true
      });
      Matrix2.prototype.markAsUpdated = function() {
        this.updateFlag = Matrix2._UpdateFlagSeed++;
        this._isIdentity = false;
        this._isIdentity3x2 = false;
        this._isIdentityDirty = true;
        this._isIdentity3x2Dirty = true;
      };
      Matrix2.prototype._updateIdentityStatus = function(isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {
        if (isIdentityDirty === void 0) {
          isIdentityDirty = false;
        }
        if (isIdentity3x2 === void 0) {
          isIdentity3x2 = false;
        }
        if (isIdentity3x2Dirty === void 0) {
          isIdentity3x2Dirty = true;
        }
        this._isIdentity = isIdentity;
        this._isIdentity3x2 = isIdentity || isIdentity3x2;
        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
      };
      Matrix2.prototype.isIdentity = function() {
        if (this._isIdentityDirty) {
          this._isIdentityDirty = false;
          var m = this._m;
          this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
        }
        return this._isIdentity;
      };
      Matrix2.prototype.isIdentityAs3x2 = function() {
        if (this._isIdentity3x2Dirty) {
          this._isIdentity3x2Dirty = false;
          if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
            this._isIdentity3x2 = false;
          } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
            this._isIdentity3x2 = false;
          } else {
            this._isIdentity3x2 = true;
          }
        }
        return this._isIdentity3x2;
      };
      Matrix2.prototype.determinant = function() {
        if (this._isIdentity === true) {
          return 1;
        }
        var m = this._m;
        var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        var det_22_33 = m22 * m33 - m32 * m23;
        var det_21_33 = m21 * m33 - m31 * m23;
        var det_21_32 = m21 * m32 - m31 * m22;
        var det_20_33 = m20 * m33 - m30 * m23;
        var det_20_32 = m20 * m32 - m22 * m30;
        var det_20_31 = m20 * m31 - m30 * m21;
        var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
      };
      Matrix2.prototype.toArray = function() {
        return this._m;
      };
      Matrix2.prototype.asArray = function() {
        return this._m;
      };
      Matrix2.prototype.invert = function() {
        this.invertToRef(this);
        return this;
      };
      Matrix2.prototype.reset = function() {
        Matrix2.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
        this._updateIdentityStatus(false);
        return this;
      };
      Matrix2.prototype.add = function(other) {
        var result = new Matrix2();
        this.addToRef(other, result);
        return result;
      };
      Matrix2.prototype.addToRef = function(other, result) {
        var m = this._m;
        var resultM = result._m;
        var otherM = other.m;
        for (var index = 0; index < 16; index++) {
          resultM[index] = m[index] + otherM[index];
        }
        result.markAsUpdated();
        return this;
      };
      Matrix2.prototype.addToSelf = function(other) {
        var m = this._m;
        var otherM = other.m;
        for (var index = 0; index < 16; index++) {
          m[index] += otherM[index];
        }
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.invertToRef = function(other) {
        if (this._isIdentity === true) {
          Matrix2.IdentityToRef(other);
          return this;
        }
        var m = this._m;
        var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        var det_22_33 = m22 * m33 - m32 * m23;
        var det_21_33 = m21 * m33 - m31 * m23;
        var det_21_32 = m21 * m32 - m31 * m22;
        var det_20_33 = m20 * m33 - m30 * m23;
        var det_20_32 = m20 * m32 - m22 * m30;
        var det_20_31 = m20 * m31 - m30 * m21;
        var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
        if (det === 0) {
          other.copyFrom(this);
          return this;
        }
        var detInv = 1 / det;
        var det_12_33 = m12 * m33 - m32 * m13;
        var det_11_33 = m11 * m33 - m31 * m13;
        var det_11_32 = m11 * m32 - m31 * m12;
        var det_10_33 = m10 * m33 - m30 * m13;
        var det_10_32 = m10 * m32 - m30 * m12;
        var det_10_31 = m10 * m31 - m30 * m11;
        var det_12_23 = m12 * m23 - m22 * m13;
        var det_11_23 = m11 * m23 - m21 * m13;
        var det_11_22 = m11 * m22 - m21 * m12;
        var det_10_23 = m10 * m23 - m20 * m13;
        var det_10_22 = m10 * m22 - m20 * m12;
        var det_10_21 = m10 * m21 - m20 * m11;
        var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
        var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
        var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
        var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
        var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
        var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
        var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
        var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
        var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
        var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
        var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
        var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
        Matrix2.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
        return this;
      };
      Matrix2.prototype.addAtIndex = function(index, value) {
        this._m[index] += value;
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.multiplyAtIndex = function(index, value) {
        this._m[index] *= value;
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.setTranslationFromFloats = function(x, y, z) {
        this._m[12] = x;
        this._m[13] = y;
        this._m[14] = z;
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.addTranslationFromFloats = function(x, y, z) {
        this._m[12] += x;
        this._m[13] += y;
        this._m[14] += z;
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.setTranslation = function(vector3) {
        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
      };
      Matrix2.prototype.getTranslation = function() {
        return new Vector3(this._m[12], this._m[13], this._m[14]);
      };
      Matrix2.prototype.getTranslationToRef = function(result) {
        result.x = this._m[12];
        result.y = this._m[13];
        result.z = this._m[14];
        return this;
      };
      Matrix2.prototype.removeRotationAndScaling = function() {
        var m = this.m;
        Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
        return this;
      };
      Matrix2.prototype.multiply = function(other) {
        var result = new Matrix2();
        this.multiplyToRef(other, result);
        return result;
      };
      Matrix2.prototype.copyFrom = function(other) {
        other.copyToArray(this._m);
        var o = other;
        this.updateFlag = o.updateFlag;
        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
        return this;
      };
      Matrix2.prototype.copyToArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var source = this._m;
        array[offset] = source[0];
        array[offset + 1] = source[1];
        array[offset + 2] = source[2];
        array[offset + 3] = source[3];
        array[offset + 4] = source[4];
        array[offset + 5] = source[5];
        array[offset + 6] = source[6];
        array[offset + 7] = source[7];
        array[offset + 8] = source[8];
        array[offset + 9] = source[9];
        array[offset + 10] = source[10];
        array[offset + 11] = source[11];
        array[offset + 12] = source[12];
        array[offset + 13] = source[13];
        array[offset + 14] = source[14];
        array[offset + 15] = source[15];
        return this;
      };
      Matrix2.prototype.multiplyToRef = function(other, result) {
        if (this._isIdentity) {
          result.copyFrom(other);
          return this;
        }
        if (other._isIdentity) {
          result.copyFrom(this);
          return this;
        }
        this.multiplyToArray(other, result._m, 0);
        result.markAsUpdated();
        return this;
      };
      Matrix2.prototype.multiplyToArray = function(other, result, offset) {
        var m = this._m;
        var otherM = other.m;
        var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
        var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
        var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
        var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
        var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
        var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
        var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
        var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
        return this;
      };
      Matrix2.prototype.equals = function(value) {
        var other = value;
        if (!other) {
          return false;
        }
        if (this._isIdentity || other._isIdentity) {
          if (!this._isIdentityDirty && !other._isIdentityDirty) {
            return this._isIdentity && other._isIdentity;
          }
        }
        var m = this.m;
        var om = other.m;
        return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
      };
      Matrix2.prototype.clone = function() {
        var matrix = new Matrix2();
        matrix.copyFrom(this);
        return matrix;
      };
      Matrix2.prototype.getClassName = function() {
        return "Matrix";
      };
      Matrix2.prototype.getHashCode = function() {
        var hash = _ExtractAsInt(this._m[0]);
        for (var i = 1; i < 16; i++) {
          hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
        }
        return hash;
      };
      Matrix2.prototype.decomposeToTransformNode = function(node) {
        node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
        return this.decompose(node.scaling, node.rotationQuaternion, node.position);
      };
      Matrix2.prototype.decompose = function(scale, rotation, translation, preserveScalingNode) {
        if (this._isIdentity) {
          if (translation) {
            translation.setAll(0);
          }
          if (scale) {
            scale.setAll(1);
          }
          if (rotation) {
            rotation.copyFromFloats(0, 0, 0, 1);
          }
          return true;
        }
        var m = this._m;
        if (translation) {
          translation.copyFromFloats(m[12], m[13], m[14]);
        }
        scale = scale || MathTmp.Vector3[0];
        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
        if (preserveScalingNode) {
          var signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;
          var signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;
          var signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;
          scale.x *= signX;
          scale.y *= signY;
          scale.z *= signZ;
        } else {
          if (this.determinant() <= 0) {
            scale.y *= -1;
          }
        }
        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
          if (rotation) {
            rotation.copyFromFloats(0, 0, 0, 1);
          }
          return false;
        }
        if (rotation) {
          var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
          Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
          Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
        }
        return true;
      };
      Matrix2.prototype.getRow = function(index) {
        if (index < 0 || index > 3) {
          return null;
        }
        var i = index * 4;
        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
      };
      Matrix2.prototype.setRow = function(index, row) {
        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
      };
      Matrix2.prototype.transpose = function() {
        return Matrix2.Transpose(this);
      };
      Matrix2.prototype.transposeToRef = function(result) {
        Matrix2.TransposeToRef(this, result);
        return this;
      };
      Matrix2.prototype.setRowFromFloats = function(index, x, y, z, w) {
        if (index < 0 || index > 3) {
          return this;
        }
        var i = index * 4;
        this._m[i + 0] = x;
        this._m[i + 1] = y;
        this._m[i + 2] = z;
        this._m[i + 3] = w;
        this.markAsUpdated();
        return this;
      };
      Matrix2.prototype.scale = function(scale) {
        var result = new Matrix2();
        this.scaleToRef(scale, result);
        return result;
      };
      Matrix2.prototype.scaleToRef = function(scale, result) {
        for (var index = 0; index < 16; index++) {
          result._m[index] = this._m[index] * scale;
        }
        result.markAsUpdated();
        return this;
      };
      Matrix2.prototype.scaleAndAddToRef = function(scale, result) {
        for (var index = 0; index < 16; index++) {
          result._m[index] += this._m[index] * scale;
        }
        result.markAsUpdated();
        return this;
      };
      Matrix2.prototype.toNormalMatrix = function(ref) {
        var tmp = MathTmp.Matrix[0];
        this.invertToRef(tmp);
        tmp.transposeToRef(ref);
        var m = ref._m;
        Matrix2.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
      };
      Matrix2.prototype.getRotationMatrix = function() {
        var result = new Matrix2();
        this.getRotationMatrixToRef(result);
        return result;
      };
      Matrix2.prototype.getRotationMatrixToRef = function(result) {
        var scale = MathTmp.Vector3[0];
        if (!this.decompose(scale)) {
          Matrix2.IdentityToRef(result);
          return this;
        }
        var m = this._m;
        var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
        Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
        return this;
      };
      Matrix2.prototype.toggleModelMatrixHandInPlace = function() {
        var m = this._m;
        m[2] *= -1;
        m[6] *= -1;
        m[8] *= -1;
        m[9] *= -1;
        m[14] *= -1;
        this.markAsUpdated();
      };
      Matrix2.prototype.toggleProjectionMatrixHandInPlace = function() {
        var m = this._m;
        m[8] *= -1;
        m[9] *= -1;
        m[10] *= -1;
        m[11] *= -1;
        this.markAsUpdated();
      };
      Matrix2.FromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var result = new Matrix2();
        Matrix2.FromArrayToRef(array, offset, result);
        return result;
      };
      Matrix2.FromArrayToRef = function(array, offset, result) {
        for (var index = 0; index < 16; index++) {
          result._m[index] = array[index + offset];
        }
        result.markAsUpdated();
      };
      Matrix2.FromFloat32ArrayToRefScaled = function(array, offset, scale, result) {
        for (var index = 0; index < 16; index++) {
          result._m[index] = array[index + offset] * scale;
        }
        result.markAsUpdated();
      };
      Object.defineProperty(Matrix2, "IdentityReadOnly", {
        get: function() {
          return Matrix2._IdentityReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Matrix2.FromValuesToRef = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
        var m = result._m;
        m[0] = initialM11;
        m[1] = initialM12;
        m[2] = initialM13;
        m[3] = initialM14;
        m[4] = initialM21;
        m[5] = initialM22;
        m[6] = initialM23;
        m[7] = initialM24;
        m[8] = initialM31;
        m[9] = initialM32;
        m[10] = initialM33;
        m[11] = initialM34;
        m[12] = initialM41;
        m[13] = initialM42;
        m[14] = initialM43;
        m[15] = initialM44;
        result.markAsUpdated();
      };
      Matrix2.FromValues = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
        var result = new Matrix2();
        var m = result._m;
        m[0] = initialM11;
        m[1] = initialM12;
        m[2] = initialM13;
        m[3] = initialM14;
        m[4] = initialM21;
        m[5] = initialM22;
        m[6] = initialM23;
        m[7] = initialM24;
        m[8] = initialM31;
        m[9] = initialM32;
        m[10] = initialM33;
        m[11] = initialM34;
        m[12] = initialM41;
        m[13] = initialM42;
        m[14] = initialM43;
        m[15] = initialM44;
        result.markAsUpdated();
        return result;
      };
      Matrix2.Compose = function(scale, rotation, translation) {
        var result = new Matrix2();
        Matrix2.ComposeToRef(scale, rotation, translation, result);
        return result;
      };
      Matrix2.ComposeToRef = function(scale, rotation, translation, result) {
        var m = result._m;
        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        var sx = scale._x, sy = scale._y, sz = scale._z;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = translation._x;
        m[13] = translation._y;
        m[14] = translation._z;
        m[15] = 1;
        result.markAsUpdated();
      };
      Matrix2.Identity = function() {
        var identity = Matrix2.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        identity._updateIdentityStatus(true);
        return identity;
      };
      Matrix2.IdentityToRef = function(result) {
        Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(true);
      };
      Matrix2.Zero = function() {
        var zero = Matrix2.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        zero._updateIdentityStatus(false);
        return zero;
      };
      Matrix2.RotationX = function(angle) {
        var result = new Matrix2();
        Matrix2.RotationXToRef(angle, result);
        return result;
      };
      Matrix2.Invert = function(source) {
        var result = new Matrix2();
        source.invertToRef(result);
        return result;
      };
      Matrix2.RotationXToRef = function(angle, result) {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        Matrix2.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
      };
      Matrix2.RotationY = function(angle) {
        var result = new Matrix2();
        Matrix2.RotationYToRef(angle, result);
        return result;
      };
      Matrix2.RotationYToRef = function(angle, result) {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        Matrix2.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
      };
      Matrix2.RotationZ = function(angle) {
        var result = new Matrix2();
        Matrix2.RotationZToRef(angle, result);
        return result;
      };
      Matrix2.RotationZToRef = function(angle, result) {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        Matrix2.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
      };
      Matrix2.RotationAxis = function(axis, angle) {
        var result = new Matrix2();
        Matrix2.RotationAxisToRef(axis, angle, result);
        return result;
      };
      Matrix2.RotationAxisToRef = function(axis, angle, result) {
        var s = Math.sin(-angle);
        var c = Math.cos(-angle);
        var c1 = 1 - c;
        axis.normalize();
        var m = result._m;
        m[0] = axis._x * axis._x * c1 + c;
        m[1] = axis._x * axis._y * c1 - axis._z * s;
        m[2] = axis._x * axis._z * c1 + axis._y * s;
        m[3] = 0;
        m[4] = axis._y * axis._x * c1 + axis._z * s;
        m[5] = axis._y * axis._y * c1 + c;
        m[6] = axis._y * axis._z * c1 - axis._x * s;
        m[7] = 0;
        m[8] = axis._z * axis._x * c1 - axis._y * s;
        m[9] = axis._z * axis._y * c1 + axis._x * s;
        m[10] = axis._z * axis._z * c1 + c;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        result.markAsUpdated();
      };
      Matrix2.RotationAlignToRef = function(from, to, result) {
        var c = Vector3.Dot(to, from);
        var m = result._m;
        if (c < -1 + Epsilon) {
          m[0] = -1;
          m[1] = 0;
          m[2] = 0;
          m[3] = 0;
          m[4] = 0;
          m[5] = -1;
          m[6] = 0;
          m[7] = 0;
          m[8] = 0;
          m[9] = 0;
          m[10] = 1;
          m[11] = 0;
        } else {
          var v = Vector3.Cross(to, from);
          var k = 1 / (1 + c);
          m[0] = v._x * v._x * k + c;
          m[1] = v._y * v._x * k - v._z;
          m[2] = v._z * v._x * k + v._y;
          m[3] = 0;
          m[4] = v._x * v._y * k + v._z;
          m[5] = v._y * v._y * k + c;
          m[6] = v._z * v._y * k - v._x;
          m[7] = 0;
          m[8] = v._x * v._z * k - v._y;
          m[9] = v._y * v._z * k + v._x;
          m[10] = v._z * v._z * k + c;
          m[11] = 0;
        }
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        result.markAsUpdated();
      };
      Matrix2.RotationYawPitchRoll = function(yaw, pitch, roll) {
        var result = new Matrix2();
        Matrix2.RotationYawPitchRollToRef(yaw, pitch, roll, result);
        return result;
      };
      Matrix2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
        MathTmp.Quaternion[0].toRotationMatrix(result);
      };
      Matrix2.Scaling = function(x, y, z) {
        var result = new Matrix2();
        Matrix2.ScalingToRef(x, y, z, result);
        return result;
      };
      Matrix2.ScalingToRef = function(x, y, z, result) {
        Matrix2.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
      };
      Matrix2.Translation = function(x, y, z) {
        var result = new Matrix2();
        Matrix2.TranslationToRef(x, y, z, result);
        return result;
      };
      Matrix2.TranslationToRef = function(x, y, z, result) {
        Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
      };
      Matrix2.Lerp = function(startValue, endValue, gradient) {
        var result = new Matrix2();
        Matrix2.LerpToRef(startValue, endValue, gradient, result);
        return result;
      };
      Matrix2.LerpToRef = function(startValue, endValue, gradient, result) {
        var resultM = result._m;
        var startM = startValue.m;
        var endM = endValue.m;
        for (var index = 0; index < 16; index++) {
          resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
        }
        result.markAsUpdated();
      };
      Matrix2.DecomposeLerp = function(startValue, endValue, gradient) {
        var result = new Matrix2();
        Matrix2.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      };
      Matrix2.DecomposeLerpToRef = function(startValue, endValue, gradient, result) {
        var startScale = MathTmp.Vector3[0];
        var startRotation = MathTmp.Quaternion[0];
        var startTranslation = MathTmp.Vector3[1];
        startValue.decompose(startScale, startRotation, startTranslation);
        var endScale = MathTmp.Vector3[2];
        var endRotation = MathTmp.Quaternion[1];
        var endTranslation = MathTmp.Vector3[3];
        endValue.decompose(endScale, endRotation, endTranslation);
        var resultScale = MathTmp.Vector3[4];
        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
        var resultRotation = MathTmp.Quaternion[2];
        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
        var resultTranslation = MathTmp.Vector3[5];
        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
        Matrix2.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
      };
      Matrix2.LookAtLH = function(eye, target, up) {
        var result = new Matrix2();
        Matrix2.LookAtLHToRef(eye, target, up, result);
        return result;
      };
      Matrix2.LookAtLHToRef = function(eye, target, up, result) {
        var xAxis = MathTmp.Vector3[0];
        var yAxis = MathTmp.Vector3[1];
        var zAxis = MathTmp.Vector3[2];
        target.subtractToRef(eye, zAxis);
        zAxis.normalize();
        Vector3.CrossToRef(up, zAxis, xAxis);
        var xSquareLength = xAxis.lengthSquared();
        if (xSquareLength === 0) {
          xAxis.x = 1;
        } else {
          xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
        }
        Vector3.CrossToRef(zAxis, xAxis, yAxis);
        yAxis.normalize();
        var ex = -Vector3.Dot(xAxis, eye);
        var ey = -Vector3.Dot(yAxis, eye);
        var ez = -Vector3.Dot(zAxis, eye);
        Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
      };
      Matrix2.LookAtRH = function(eye, target, up) {
        var result = new Matrix2();
        Matrix2.LookAtRHToRef(eye, target, up, result);
        return result;
      };
      Matrix2.LookAtRHToRef = function(eye, target, up, result) {
        var xAxis = MathTmp.Vector3[0];
        var yAxis = MathTmp.Vector3[1];
        var zAxis = MathTmp.Vector3[2];
        eye.subtractToRef(target, zAxis);
        zAxis.normalize();
        Vector3.CrossToRef(up, zAxis, xAxis);
        var xSquareLength = xAxis.lengthSquared();
        if (xSquareLength === 0) {
          xAxis.x = 1;
        } else {
          xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
        }
        Vector3.CrossToRef(zAxis, xAxis, yAxis);
        yAxis.normalize();
        var ex = -Vector3.Dot(xAxis, eye);
        var ey = -Vector3.Dot(yAxis, eye);
        var ez = -Vector3.Dot(zAxis, eye);
        Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
      };
      Matrix2.LookDirectionLH = function(forward, up) {
        var result = new Matrix2();
        Matrix2.LookDirectionLHToRef(forward, up, result);
        return result;
      };
      Matrix2.LookDirectionLHToRef = function(forward, up, result) {
        var back = MathTmp.Vector3[0];
        back.copyFrom(forward);
        back.scaleInPlace(-1);
        var left = MathTmp.Vector3[1];
        Vector3.CrossToRef(up, back, left);
        Matrix2.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
      };
      Matrix2.LookDirectionRH = function(forward, up) {
        var result = new Matrix2();
        Matrix2.LookDirectionRHToRef(forward, up, result);
        return result;
      };
      Matrix2.LookDirectionRHToRef = function(forward, up, result) {
        var right = MathTmp.Vector3[2];
        Vector3.CrossToRef(up, forward, right);
        Matrix2.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
      };
      Matrix2.OrthoLH = function(width, height, znear, zfar, halfZRange) {
        var matrix = new Matrix2();
        Matrix2.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
        return matrix;
      };
      Matrix2.OrthoLHToRef = function(width, height, znear, zfar, result, halfZRange) {
        var n = znear;
        var f = zfar;
        var a = 2 / width;
        var b = 2 / height;
        var c = 2 / (f - n);
        var d = -(f + n) / (f - n);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
      };
      Matrix2.OrthoOffCenterLH = function(left, right, bottom, top, znear, zfar, halfZRange) {
        var matrix = new Matrix2();
        Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
        return matrix;
      };
      Matrix2.OrthoOffCenterLHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
        var n = znear;
        var f = zfar;
        var a = 2 / (right - left);
        var b = 2 / (top - bottom);
        var c = 2 / (f - n);
        var d = -(f + n) / (f - n);
        var i0 = (left + right) / (left - right);
        var i1 = (top + bottom) / (bottom - top);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result.markAsUpdated();
      };
      Matrix2.OrthoOffCenterRH = function(left, right, bottom, top, znear, zfar, halfZRange) {
        var matrix = new Matrix2();
        Matrix2.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
        return matrix;
      };
      Matrix2.OrthoOffCenterRHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
        Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
        result._m[10] *= -1;
      };
      Matrix2.PerspectiveLH = function(width, height, znear, zfar, halfZRange, projectionPlaneTilt) {
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        var matrix = new Matrix2();
        var n = znear;
        var f = zfar;
        var a = 2 * n / width;
        var b = 2 * n / height;
        var c = (f + n) / (f - n);
        var d = -2 * f * n / (f - n);
        var rot = Math.tan(projectionPlaneTilt);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
        if (halfZRange) {
          matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
        }
        matrix._updateIdentityStatus(false);
        return matrix;
      };
      Matrix2.PerspectiveFovLH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        if (reverseDepthBufferMode === void 0) {
          reverseDepthBufferMode = false;
        }
        var matrix = new Matrix2();
        Matrix2.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
        return matrix;
      };
      Matrix2.PerspectiveFovLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
        if (isVerticalFovFixed === void 0) {
          isVerticalFovFixed = true;
        }
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        if (reverseDepthBufferMode === void 0) {
          reverseDepthBufferMode = false;
        }
        var n = znear;
        var f = zfar;
        var t = 1 / Math.tan(fov * 0.5);
        var a = isVerticalFovFixed ? t / aspect : t;
        var b = isVerticalFovFixed ? t : t * aspect;
        var c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
        var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
        var rot = Math.tan(projectionPlaneTilt);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
      };
      Matrix2.PerspectiveFovReverseLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
        if (isVerticalFovFixed === void 0) {
          isVerticalFovFixed = true;
        }
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        var t = 1 / Math.tan(fov * 0.5);
        var a = isVerticalFovFixed ? t / aspect : t;
        var b = isVerticalFovFixed ? t : t * aspect;
        var rot = Math.tan(projectionPlaneTilt);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
      };
      Matrix2.PerspectiveFovRH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        if (reverseDepthBufferMode === void 0) {
          reverseDepthBufferMode = false;
        }
        var matrix = new Matrix2();
        Matrix2.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
        return matrix;
      };
      Matrix2.PerspectiveFovRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
        if (isVerticalFovFixed === void 0) {
          isVerticalFovFixed = true;
        }
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        if (reverseDepthBufferMode === void 0) {
          reverseDepthBufferMode = false;
        }
        var n = znear;
        var f = zfar;
        var t = 1 / Math.tan(fov * 0.5);
        var a = isVerticalFovFixed ? t / aspect : t;
        var b = isVerticalFovFixed ? t : t * aspect;
        var c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
        var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
        var rot = Math.tan(projectionPlaneTilt);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
      };
      Matrix2.PerspectiveFovReverseRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
        if (isVerticalFovFixed === void 0) {
          isVerticalFovFixed = true;
        }
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        var t = 1 / Math.tan(fov * 0.5);
        var a = isVerticalFovFixed ? t / aspect : t;
        var b = isVerticalFovFixed ? t : t * aspect;
        var rot = Math.tan(projectionPlaneTilt);
        Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
      };
      Matrix2.PerspectiveFovWebVRToRef = function(fov, znear, zfar, result, rightHanded, halfZRange, projectionPlaneTilt) {
        if (rightHanded === void 0) {
          rightHanded = false;
        }
        if (projectionPlaneTilt === void 0) {
          projectionPlaneTilt = 0;
        }
        var rightHandedFactor = rightHanded ? -1 : 1;
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
        var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
        var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
        var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
        var xScale = 2 / (leftTan + rightTan);
        var yScale = 2 / (upTan + downTan);
        var rot = Math.tan(projectionPlaneTilt);
        var m = result._m;
        m[0] = xScale;
        m[1] = m[2] = m[3] = m[4] = 0;
        m[5] = yScale;
        m[6] = 0;
        m[7] = rot;
        m[8] = (leftTan - rightTan) * xScale * 0.5;
        m[9] = -((upTan - downTan) * yScale * 0.5);
        m[10] = -zfar / (znear - zfar);
        m[11] = 1 * rightHandedFactor;
        m[12] = m[13] = m[15] = 0;
        m[14] = -(2 * zfar * znear) / (zfar - znear);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result.markAsUpdated();
      };
      Matrix2.GetFinalMatrix = function(viewport, world, view, projection, zmin, zmax) {
        var cw = viewport.width;
        var ch = viewport.height;
        var cx = viewport.x;
        var cy = viewport.y;
        var viewportMatrix = Matrix2.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
        var matrix = MathTmp.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        return matrix.multiply(viewportMatrix);
      };
      Matrix2.GetAsMatrix2x2 = function(matrix) {
        var m = matrix.m;
        var arr = [m[0], m[1], m[4], m[5]];
        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
      };
      Matrix2.GetAsMatrix3x3 = function(matrix) {
        var m = matrix.m;
        var arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];
        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
      };
      Matrix2.Transpose = function(matrix) {
        var result = new Matrix2();
        Matrix2.TransposeToRef(matrix, result);
        return result;
      };
      Matrix2.TransposeToRef = function(matrix, result) {
        var rm = result._m;
        var mm = matrix.m;
        rm[0] = mm[0];
        rm[1] = mm[4];
        rm[2] = mm[8];
        rm[3] = mm[12];
        rm[4] = mm[1];
        rm[5] = mm[5];
        rm[6] = mm[9];
        rm[7] = mm[13];
        rm[8] = mm[2];
        rm[9] = mm[6];
        rm[10] = mm[10];
        rm[11] = mm[14];
        rm[12] = mm[3];
        rm[13] = mm[7];
        rm[14] = mm[11];
        rm[15] = mm[15];
        result.markAsUpdated();
        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
      };
      Matrix2.Reflection = function(plane) {
        var matrix = new Matrix2();
        Matrix2.ReflectionToRef(plane, matrix);
        return matrix;
      };
      Matrix2.ReflectionToRef = function(plane, result) {
        plane.normalize();
        var x = plane.normal.x;
        var y = plane.normal.y;
        var z = plane.normal.z;
        var temp = -2 * x;
        var temp2 = -2 * y;
        var temp3 = -2 * z;
        Matrix2.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
      };
      Matrix2.FromXYZAxesToRef = function(xaxis, yaxis, zaxis, result) {
        Matrix2.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
      };
      Matrix2.FromQuaternionToRef = function(quat, result) {
        var xx = quat._x * quat._x;
        var yy = quat._y * quat._y;
        var zz = quat._z * quat._z;
        var xy = quat._x * quat._y;
        var zw = quat._z * quat._w;
        var zx = quat._z * quat._x;
        var yw = quat._y * quat._w;
        var yz = quat._y * quat._z;
        var xw = quat._x * quat._w;
        result._m[0] = 1 - 2 * (yy + zz);
        result._m[1] = 2 * (xy + zw);
        result._m[2] = 2 * (zx - yw);
        result._m[3] = 0;
        result._m[4] = 2 * (xy - zw);
        result._m[5] = 1 - 2 * (zz + xx);
        result._m[6] = 2 * (yz + xw);
        result._m[7] = 0;
        result._m[8] = 2 * (zx + yw);
        result._m[9] = 2 * (yz - xw);
        result._m[10] = 1 - 2 * (yy + xx);
        result._m[11] = 0;
        result._m[12] = 0;
        result._m[13] = 0;
        result._m[14] = 0;
        result._m[15] = 1;
        result.markAsUpdated();
      };
      Matrix2._UpdateFlagSeed = 0;
      Matrix2._IdentityReadOnly = Matrix2.Identity();
      return Matrix2;
    }();
    MathTmp = function() {
      function MathTmp2() {
      }
      MathTmp2.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
      MathTmp2.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
      MathTmp2.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
      return MathTmp2;
    }();
    TmpVectors = function() {
      function TmpVectors2() {
      }
      TmpVectors2.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
      TmpVectors2.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
      TmpVectors2.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
      TmpVectors2.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
      TmpVectors2.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
      return TmpVectors2;
    }();
    RegisterClass("BABYLON.Vector2", Vector2);
    RegisterClass("BABYLON.Vector3", Vector3);
    RegisterClass("BABYLON.Vector4", Vector4);
    RegisterClass("BABYLON.Matrix", Matrix);
    mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
  }
});

// node_modules/@babylonjs/core/Maths/math.color.js
var Color3, Color4, TmpColors;
var init_math_color = __esm({
  "node_modules/@babylonjs/core/Maths/math.color.js"() {
    init_math_scalar();
    init_math_constants();
    init_arrayTools();
    init_typeStore();
    Color3 = function() {
      function Color32(r, g, b) {
        if (r === void 0) {
          r = 0;
        }
        if (g === void 0) {
          g = 0;
        }
        if (b === void 0) {
          b = 0;
        }
        this.r = r;
        this.g = g;
        this.b = b;
      }
      Color32.prototype.toString = function() {
        return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
      };
      Color32.prototype.getClassName = function() {
        return "Color3";
      };
      Color32.prototype.getHashCode = function() {
        var hash = this.r * 255 | 0;
        hash = hash * 397 ^ (this.g * 255 | 0);
        hash = hash * 397 ^ (this.b * 255 | 0);
        return hash;
      };
      Color32.prototype.toArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this.r;
        array[index + 1] = this.g;
        array[index + 2] = this.b;
        return this;
      };
      Color32.prototype.fromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        Color32.FromArrayToRef(array, offset, this);
        return this;
      };
      Color32.prototype.toColor4 = function(alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        return new Color4(this.r, this.g, this.b, alpha);
      };
      Color32.prototype.asArray = function() {
        return [this.r, this.g, this.b];
      };
      Color32.prototype.toLuminance = function() {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
      };
      Color32.prototype.multiply = function(otherColor) {
        return new Color32(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
      };
      Color32.prototype.multiplyToRef = function(otherColor, result) {
        result.r = this.r * otherColor.r;
        result.g = this.g * otherColor.g;
        result.b = this.b * otherColor.b;
        return this;
      };
      Color32.prototype.equals = function(otherColor) {
        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
      };
      Color32.prototype.equalsFloats = function(r, g, b) {
        return this.r === r && this.g === g && this.b === b;
      };
      Color32.prototype.scale = function(scale) {
        return new Color32(this.r * scale, this.g * scale, this.b * scale);
      };
      Color32.prototype.scaleToRef = function(scale, result) {
        result.r = this.r * scale;
        result.g = this.g * scale;
        result.b = this.b * scale;
        return this;
      };
      Color32.prototype.scaleAndAddToRef = function(scale, result) {
        result.r += this.r * scale;
        result.g += this.g * scale;
        result.b += this.b * scale;
        return this;
      };
      Color32.prototype.clampToRef = function(min, max, result) {
        if (min === void 0) {
          min = 0;
        }
        if (max === void 0) {
          max = 1;
        }
        result.r = Scalar.Clamp(this.r, min, max);
        result.g = Scalar.Clamp(this.g, min, max);
        result.b = Scalar.Clamp(this.b, min, max);
        return this;
      };
      Color32.prototype.add = function(otherColor) {
        return new Color32(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
      };
      Color32.prototype.addToRef = function(otherColor, result) {
        result.r = this.r + otherColor.r;
        result.g = this.g + otherColor.g;
        result.b = this.b + otherColor.b;
        return this;
      };
      Color32.prototype.subtract = function(otherColor) {
        return new Color32(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
      };
      Color32.prototype.subtractToRef = function(otherColor, result) {
        result.r = this.r - otherColor.r;
        result.g = this.g - otherColor.g;
        result.b = this.b - otherColor.b;
        return this;
      };
      Color32.prototype.clone = function() {
        return new Color32(this.r, this.g, this.b);
      };
      Color32.prototype.copyFrom = function(source) {
        this.r = source.r;
        this.g = source.g;
        this.b = source.b;
        return this;
      };
      Color32.prototype.copyFromFloats = function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      };
      Color32.prototype.set = function(r, g, b) {
        return this.copyFromFloats(r, g, b);
      };
      Color32.prototype.toHexString = function() {
        var intR = Math.round(this.r * 255);
        var intG = Math.round(this.g * 255);
        var intB = Math.round(this.b * 255);
        return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
      };
      Color32.prototype.toLinearSpace = function() {
        var convertedColor = new Color32();
        this.toLinearSpaceToRef(convertedColor);
        return convertedColor;
      };
      Color32.prototype.toHSV = function() {
        var result = new Color32();
        this.toHSVToRef(result);
        return result;
      };
      Color32.prototype.toHSVToRef = function(result) {
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var s = 0;
        var v = max;
        var dm = max - min;
        if (max !== 0) {
          s = dm / max;
        }
        if (max != min) {
          if (max == r) {
            h = (g - b) / dm;
            if (g < b) {
              h += 6;
            }
          } else if (max == g) {
            h = (b - r) / dm + 2;
          } else if (max == b) {
            h = (r - g) / dm + 4;
          }
          h *= 60;
        }
        result.r = h;
        result.g = s;
        result.b = v;
      };
      Color32.prototype.toLinearSpaceToRef = function(convertedColor) {
        convertedColor.r = Math.pow(this.r, ToLinearSpace);
        convertedColor.g = Math.pow(this.g, ToLinearSpace);
        convertedColor.b = Math.pow(this.b, ToLinearSpace);
        return this;
      };
      Color32.prototype.toGammaSpace = function() {
        var convertedColor = new Color32();
        this.toGammaSpaceToRef(convertedColor);
        return convertedColor;
      };
      Color32.prototype.toGammaSpaceToRef = function(convertedColor) {
        convertedColor.r = Math.pow(this.r, ToGammaSpace);
        convertedColor.g = Math.pow(this.g, ToGammaSpace);
        convertedColor.b = Math.pow(this.b, ToGammaSpace);
        return this;
      };
      Color32.HSVtoRGBToRef = function(hue, saturation, value, result) {
        var chroma = value * saturation;
        var h = hue / 60;
        var x = chroma * (1 - Math.abs(h % 2 - 1));
        var r = 0;
        var g = 0;
        var b = 0;
        if (h >= 0 && h <= 1) {
          r = chroma;
          g = x;
        } else if (h >= 1 && h <= 2) {
          r = x;
          g = chroma;
        } else if (h >= 2 && h <= 3) {
          g = chroma;
          b = x;
        } else if (h >= 3 && h <= 4) {
          g = x;
          b = chroma;
        } else if (h >= 4 && h <= 5) {
          r = x;
          b = chroma;
        } else if (h >= 5 && h <= 6) {
          r = chroma;
          b = x;
        }
        var m = value - chroma;
        result.set(r + m, g + m, b + m);
      };
      Color32.FromHexString = function(hex) {
        if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
          return new Color32(0, 0, 0);
        }
        var r = parseInt(hex.substring(1, 3), 16);
        var g = parseInt(hex.substring(3, 5), 16);
        var b = parseInt(hex.substring(5, 7), 16);
        return Color32.FromInts(r, g, b);
      };
      Color32.FromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return new Color32(array[offset], array[offset + 1], array[offset + 2]);
      };
      Color32.FromArrayToRef = function(array, offset, result) {
        if (offset === void 0) {
          offset = 0;
        }
        result.r = array[offset];
        result.g = array[offset + 1];
        result.b = array[offset + 2];
      };
      Color32.FromInts = function(r, g, b) {
        return new Color32(r / 255, g / 255, b / 255);
      };
      Color32.Lerp = function(start, end, amount) {
        var result = new Color32(0, 0, 0);
        Color32.LerpToRef(start, end, amount, result);
        return result;
      };
      Color32.LerpToRef = function(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
      };
      Color32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
        var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
        var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
        return new Color32(r, g, b);
      };
      Color32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var result = Color32.Black();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      };
      Color32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
        var t2 = time * time;
        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
      };
      Color32.Red = function() {
        return new Color32(1, 0, 0);
      };
      Color32.Green = function() {
        return new Color32(0, 1, 0);
      };
      Color32.Blue = function() {
        return new Color32(0, 0, 1);
      };
      Color32.Black = function() {
        return new Color32(0, 0, 0);
      };
      Object.defineProperty(Color32, "BlackReadOnly", {
        get: function() {
          return Color32._BlackReadOnly;
        },
        enumerable: false,
        configurable: true
      });
      Color32.White = function() {
        return new Color32(1, 1, 1);
      };
      Color32.Purple = function() {
        return new Color32(0.5, 0, 0.5);
      };
      Color32.Magenta = function() {
        return new Color32(1, 0, 1);
      };
      Color32.Yellow = function() {
        return new Color32(1, 1, 0);
      };
      Color32.Gray = function() {
        return new Color32(0.5, 0.5, 0.5);
      };
      Color32.Teal = function() {
        return new Color32(0, 1, 1);
      };
      Color32.Random = function() {
        return new Color32(Math.random(), Math.random(), Math.random());
      };
      Color32._BlackReadOnly = Color32.Black();
      return Color32;
    }();
    Color4 = function() {
      function Color42(r, g, b, a) {
        if (r === void 0) {
          r = 0;
        }
        if (g === void 0) {
          g = 0;
        }
        if (b === void 0) {
          b = 0;
        }
        if (a === void 0) {
          a = 1;
        }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
      }
      Color42.prototype.addInPlace = function(right) {
        this.r += right.r;
        this.g += right.g;
        this.b += right.b;
        this.a += right.a;
        return this;
      };
      Color42.prototype.asArray = function() {
        return [this.r, this.g, this.b, this.a];
      };
      Color42.prototype.toArray = function(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this.r;
        array[index + 1] = this.g;
        array[index + 2] = this.b;
        array[index + 3] = this.a;
        return this;
      };
      Color42.prototype.fromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        Color42.FromArrayToRef(array, offset, this);
        return this;
      };
      Color42.prototype.equals = function(otherColor) {
        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
      };
      Color42.prototype.add = function(right) {
        return new Color42(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
      };
      Color42.prototype.subtract = function(right) {
        return new Color42(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
      };
      Color42.prototype.subtractToRef = function(right, result) {
        result.r = this.r - right.r;
        result.g = this.g - right.g;
        result.b = this.b - right.b;
        result.a = this.a - right.a;
        return this;
      };
      Color42.prototype.scale = function(scale) {
        return new Color42(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
      };
      Color42.prototype.scaleToRef = function(scale, result) {
        result.r = this.r * scale;
        result.g = this.g * scale;
        result.b = this.b * scale;
        result.a = this.a * scale;
        return this;
      };
      Color42.prototype.scaleAndAddToRef = function(scale, result) {
        result.r += this.r * scale;
        result.g += this.g * scale;
        result.b += this.b * scale;
        result.a += this.a * scale;
        return this;
      };
      Color42.prototype.clampToRef = function(min, max, result) {
        if (min === void 0) {
          min = 0;
        }
        if (max === void 0) {
          max = 1;
        }
        result.r = Scalar.Clamp(this.r, min, max);
        result.g = Scalar.Clamp(this.g, min, max);
        result.b = Scalar.Clamp(this.b, min, max);
        result.a = Scalar.Clamp(this.a, min, max);
        return this;
      };
      Color42.prototype.multiply = function(color) {
        return new Color42(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
      };
      Color42.prototype.multiplyToRef = function(color, result) {
        result.r = this.r * color.r;
        result.g = this.g * color.g;
        result.b = this.b * color.b;
        result.a = this.a * color.a;
        return result;
      };
      Color42.prototype.toString = function() {
        return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
      };
      Color42.prototype.getClassName = function() {
        return "Color4";
      };
      Color42.prototype.getHashCode = function() {
        var hash = this.r * 255 | 0;
        hash = hash * 397 ^ (this.g * 255 | 0);
        hash = hash * 397 ^ (this.b * 255 | 0);
        hash = hash * 397 ^ (this.a * 255 | 0);
        return hash;
      };
      Color42.prototype.clone = function() {
        return new Color42(this.r, this.g, this.b, this.a);
      };
      Color42.prototype.copyFrom = function(source) {
        this.r = source.r;
        this.g = source.g;
        this.b = source.b;
        this.a = source.a;
        return this;
      };
      Color42.prototype.copyFromFloats = function(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
      };
      Color42.prototype.set = function(r, g, b, a) {
        return this.copyFromFloats(r, g, b, a);
      };
      Color42.prototype.toHexString = function(returnAsColor3) {
        if (returnAsColor3 === void 0) {
          returnAsColor3 = false;
        }
        var intR = Math.round(this.r * 255);
        var intG = Math.round(this.g * 255);
        var intB = Math.round(this.b * 255);
        if (returnAsColor3) {
          return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
        }
        var intA = Math.round(this.a * 255);
        return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
      };
      Color42.prototype.toLinearSpace = function() {
        var convertedColor = new Color42();
        this.toLinearSpaceToRef(convertedColor);
        return convertedColor;
      };
      Color42.prototype.toLinearSpaceToRef = function(convertedColor) {
        convertedColor.r = Math.pow(this.r, ToLinearSpace);
        convertedColor.g = Math.pow(this.g, ToLinearSpace);
        convertedColor.b = Math.pow(this.b, ToLinearSpace);
        convertedColor.a = this.a;
        return this;
      };
      Color42.prototype.toGammaSpace = function() {
        var convertedColor = new Color42();
        this.toGammaSpaceToRef(convertedColor);
        return convertedColor;
      };
      Color42.prototype.toGammaSpaceToRef = function(convertedColor) {
        convertedColor.r = Math.pow(this.r, ToGammaSpace);
        convertedColor.g = Math.pow(this.g, ToGammaSpace);
        convertedColor.b = Math.pow(this.b, ToGammaSpace);
        convertedColor.a = this.a;
        return this;
      };
      Color42.FromHexString = function(hex) {
        if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
          return new Color42(0, 0, 0, 0);
        }
        var r = parseInt(hex.substring(1, 3), 16);
        var g = parseInt(hex.substring(3, 5), 16);
        var b = parseInt(hex.substring(5, 7), 16);
        var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
        return Color42.FromInts(r, g, b, a);
      };
      Color42.Lerp = function(left, right, amount) {
        var result = new Color42(0, 0, 0, 0);
        Color42.LerpToRef(left, right, amount, result);
        return result;
      };
      Color42.LerpToRef = function(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
        result.a = left.a + (right.a - left.a) * amount;
      };
      Color42.Hermite = function(value1, tangent1, value2, tangent2, amount) {
        var squared = amount * amount;
        var cubed = amount * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + amount;
        var part4 = cubed - squared;
        var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
        var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
        var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
        var a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
        return new Color42(r, g, b, a);
      };
      Color42.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
        var result = new Color42();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      };
      Color42.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
        var t2 = time * time;
        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
      };
      Color42.FromColor3 = function(color3, alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        return new Color42(color3.r, color3.g, color3.b, alpha);
      };
      Color42.FromArray = function(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return new Color42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      };
      Color42.FromArrayToRef = function(array, offset, result) {
        if (offset === void 0) {
          offset = 0;
        }
        result.r = array[offset];
        result.g = array[offset + 1];
        result.b = array[offset + 2];
        result.a = array[offset + 3];
      };
      Color42.FromInts = function(r, g, b, a) {
        return new Color42(r / 255, g / 255, b / 255, a / 255);
      };
      Color42.CheckColors4 = function(colors, count) {
        if (colors.length === count * 3) {
          var colors4 = [];
          for (var index = 0; index < colors.length; index += 3) {
            var newIndex = index / 3 * 4;
            colors4[newIndex] = colors[index];
            colors4[newIndex + 1] = colors[index + 1];
            colors4[newIndex + 2] = colors[index + 2];
            colors4[newIndex + 3] = 1;
          }
          return colors4;
        }
        return colors;
      };
      return Color42;
    }();
    TmpColors = function() {
      function TmpColors2() {
      }
      TmpColors2.Color3 = ArrayTools.BuildArray(3, Color3.Black);
      TmpColors2.Color4 = ArrayTools.BuildArray(3, function() {
        return new Color4(0, 0, 0, 0);
      });
      return TmpColors2;
    }();
    RegisterClass("BABYLON.Color3", Color3);
    RegisterClass("BABYLON.Color4", Color4);
  }
});

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent;
var init_actionEvent = __esm({
  "node_modules/@babylonjs/core/Actions/actionEvent.js"() {
    ActionEvent = function() {
      function ActionEvent2(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
        this.source = source;
        this.pointerX = pointerX;
        this.pointerY = pointerY;
        this.meshUnderPointer = meshUnderPointer;
        this.sourceEvent = sourceEvent;
        this.additionalData = additionalData;
      }
      ActionEvent2.CreateNew = function(source, evt, additionalData) {
        var scene = source.getScene();
        return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
      };
      ActionEvent2.CreateNewFromSprite = function(source, scene, evt, additionalData) {
        return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
      };
      ActionEvent2.CreateNewFromScene = function(scene, evt) {
        return new ActionEvent2(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
      };
      ActionEvent2.CreateNewFromPrimitive = function(prim, pointerPos, evt, additionalData) {
        return new ActionEvent2(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
      };
      return ActionEvent2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/logger.js
var Logger;
var init_logger = __esm({
  "node_modules/@babylonjs/core/Misc/logger.js"() {
    Logger = function() {
      function Logger2() {
      }
      Logger2._CheckLimit = function(message, limit) {
        var entry = Logger2._LogLimitOutputs[message];
        if (!entry) {
          entry = { limit, current: 1 };
          Logger2._LogLimitOutputs[message] = entry;
        } else {
          entry.current++;
        }
        return entry.current <= entry.limit;
      };
      Logger2._GenerateLimitMessage = function(message, messageType) {
        var entry = Logger2._LogLimitOutputs[message];
        if (!entry || !Logger2.MessageLimitReached) {
          return;
        }
        if (entry.current === entry.limit) {
          switch (messageType) {
            case 0:
              Logger2.Log(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "log"));
              break;
            case 1:
              Logger2.Warn(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "warning"));
              break;
            case 2:
              Logger2.Error(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "error"));
              break;
          }
        }
      };
      Logger2._AddLogEntry = function(entry) {
        Logger2._LogCache = entry + Logger2._LogCache;
        if (Logger2.OnNewCacheEntry) {
          Logger2.OnNewCacheEntry(entry);
        }
      };
      Logger2._FormatMessage = function(message) {
        var padStr = function(i) {
          return i < 10 ? "0" + i : "" + i;
        };
        var date = new Date();
        return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
      };
      Logger2._LogDisabled = function(message, limit) {
      };
      Logger2._LogEnabled = function(message, limit) {
        if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
          return;
        }
        var formattedMessage = Logger2._FormatMessage(message);
        console.log("BJS - " + formattedMessage);
        var entry = "<div style='color:white'>" + formattedMessage + "</div><br>";
        Logger2._AddLogEntry(entry);
        Logger2._GenerateLimitMessage(message, 0);
      };
      Logger2._WarnDisabled = function(message, limit) {
      };
      Logger2._WarnEnabled = function(message, limit) {
        if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
          return;
        }
        var formattedMessage = Logger2._FormatMessage(message);
        console.warn("BJS - " + formattedMessage);
        var entry = "<div style='color:orange'>" + message + "</div><br>";
        Logger2._AddLogEntry(entry);
        Logger2._GenerateLimitMessage(message, 1);
      };
      Logger2._ErrorDisabled = function(message, limit) {
      };
      Logger2._ErrorEnabled = function(message, limit) {
        if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
          return;
        }
        var formattedMessage = Logger2._FormatMessage(message);
        Logger2.errorsCount++;
        console.error("BJS - " + formattedMessage);
        var entry = "<div style='color:red'>" + formattedMessage + "</div><br>";
        Logger2._AddLogEntry(entry);
        Logger2._GenerateLimitMessage(message, 2);
      };
      Object.defineProperty(Logger2, "LogCache", {
        get: function() {
          return Logger2._LogCache;
        },
        enumerable: false,
        configurable: true
      });
      Logger2.ClearLogCache = function() {
        Logger2._LogCache = "";
        Logger2._LogLimitOutputs = {};
        Logger2.errorsCount = 0;
      };
      Object.defineProperty(Logger2, "LogLevels", {
        set: function(level) {
          if ((level & Logger2.MessageLogLevel) === Logger2.MessageLogLevel) {
            Logger2.Log = Logger2._LogEnabled;
          } else {
            Logger2.Log = Logger2._LogDisabled;
          }
          if ((level & Logger2.WarningLogLevel) === Logger2.WarningLogLevel) {
            Logger2.Warn = Logger2._WarnEnabled;
          } else {
            Logger2.Warn = Logger2._WarnDisabled;
          }
          if ((level & Logger2.ErrorLogLevel) === Logger2.ErrorLogLevel) {
            Logger2.Error = Logger2._ErrorEnabled;
          } else {
            Logger2.Error = Logger2._ErrorDisabled;
          }
        },
        enumerable: false,
        configurable: true
      });
      Logger2.NoneLogLevel = 0;
      Logger2.MessageLogLevel = 1;
      Logger2.WarningLogLevel = 2;
      Logger2.ErrorLogLevel = 4;
      Logger2.AllLogLevel = 7;
      Logger2.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
      Logger2._LogCache = "";
      Logger2._LogLimitOutputs = {};
      Logger2.errorsCount = 0;
      Logger2.Log = Logger2._LogEnabled;
      Logger2.Warn = Logger2._WarnEnabled;
      Logger2.Error = Logger2._ErrorEnabled;
      return Logger2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/stringTools.js
var EndsWith, StartsWith, Decode, EncodeArrayBufferToBase64, DecodeBase64ToString, DecodeBase64ToBinary, PadNumber, StringTools;
var init_stringTools = __esm({
  "node_modules/@babylonjs/core/Misc/stringTools.js"() {
    EndsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    StartsWith = function(str, suffix) {
      if (!str) {
        return false;
      }
      return str.indexOf(suffix) === 0;
    };
    Decode = function(buffer) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(buffer);
      }
      var result = "";
      for (var i = 0; i < buffer.byteLength; i++) {
        result += String.fromCharCode(buffer[i]);
      }
      return result;
    };
    EncodeArrayBufferToBase64 = function(buffer) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var output = "";
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0;
      var bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
      while (i < bytes.length) {
        chr1 = bytes[i++];
        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
      }
      return output;
    };
    DecodeBase64ToString = function(base64Data) {
      return atob(base64Data);
    };
    DecodeBase64ToBinary = function(base64Data) {
      var decodedString = DecodeBase64ToString(base64Data);
      var bufferLength = decodedString.length;
      var bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
      for (var i = 0; i < bufferLength; i++) {
        bufferView[i] = decodedString.charCodeAt(i);
      }
      return bufferView.buffer;
    };
    PadNumber = function(num, length) {
      var str = String(num);
      while (str.length < length) {
        str = "0" + str;
      }
      return str;
    };
    StringTools = {
      EndsWith,
      StartsWith,
      Decode,
      EncodeArrayBufferToBase64,
      DecodeBase64ToString,
      DecodeBase64ToBinary,
      PadNumber
    };
  }
});

// node_modules/@babylonjs/core/Misc/deepCopier.js
function GetAllPropertyNames(obj) {
  var props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var CloneValue, DeepCopier;
var init_deepCopier = __esm({
  "node_modules/@babylonjs/core/Misc/deepCopier.js"() {
    init_stringTools();
    init_logger();
    CloneValue = function(source, destinationObject) {
      if (!source) {
        return null;
      }
      if (source.getClassName && source.getClassName() === "Mesh") {
        return null;
      }
      if (source.getClassName && source.getClassName() === "SubMesh") {
        return source.clone(destinationObject);
      } else if (source.clone) {
        return source.clone();
      }
      return null;
    };
    DeepCopier = function() {
      function DeepCopier2() {
      }
      DeepCopier2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
        var properties = GetAllPropertyNames(source);
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
          var prop = properties_1[_i];
          if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
            continue;
          }
          if (EndsWith(prop, "Observable")) {
            continue;
          }
          if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
            continue;
          }
          var sourceValue = source[prop];
          var typeOfSourceValue = typeof sourceValue;
          if (typeOfSourceValue === "function") {
            continue;
          }
          try {
            if (typeOfSourceValue === "object") {
              if (sourceValue instanceof Array) {
                destination[prop] = [];
                if (sourceValue.length > 0) {
                  if (typeof sourceValue[0] == "object") {
                    for (var index = 0; index < sourceValue.length; index++) {
                      var clonedValue = CloneValue(sourceValue[index], destination);
                      if (destination[prop].indexOf(clonedValue) === -1) {
                        destination[prop].push(clonedValue);
                      }
                    }
                  } else {
                    destination[prop] = sourceValue.slice(0);
                  }
                }
              } else {
                destination[prop] = CloneValue(sourceValue, destination);
              }
            } else {
              destination[prop] = sourceValue;
            }
          } catch (e) {
            Logger.Warn(e.message);
          }
        }
      };
      return DeepCopier2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js
var AndOrNotEvaluator;
var init_andOrNotEvaluator = __esm({
  "node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js"() {
    AndOrNotEvaluator = function() {
      function AndOrNotEvaluator2() {
      }
      AndOrNotEvaluator2.Eval = function(query, evaluateCallback) {
        if (!query.match(/\([^()]*\)/g)) {
          query = AndOrNotEvaluator2._HandleParenthesisContent(query, evaluateCallback);
        } else {
          query = query.replace(/\([^()]*\)/g, function(r) {
            r = r.slice(1, r.length - 1);
            return AndOrNotEvaluator2._HandleParenthesisContent(r, evaluateCallback);
          });
        }
        if (query === "true") {
          return true;
        }
        if (query === "false") {
          return false;
        }
        return AndOrNotEvaluator2.Eval(query, evaluateCallback);
      };
      AndOrNotEvaluator2._HandleParenthesisContent = function(parenthesisContent, evaluateCallback) {
        evaluateCallback = evaluateCallback || function(r) {
          return r === "true" ? true : false;
        };
        var result;
        var or = parenthesisContent.split("||");
        for (var i in or) {
          if (Object.prototype.hasOwnProperty.call(or, i)) {
            var ori = AndOrNotEvaluator2._SimplifyNegation(or[i].trim());
            var and = ori.split("&&");
            if (and.length > 1) {
              for (var j = 0; j < and.length; ++j) {
                var andj = AndOrNotEvaluator2._SimplifyNegation(and[j].trim());
                if (andj !== "true" && andj !== "false") {
                  if (andj[0] === "!") {
                    result = !evaluateCallback(andj.substring(1));
                  } else {
                    result = evaluateCallback(andj);
                  }
                } else {
                  result = andj === "true" ? true : false;
                }
                if (!result) {
                  ori = "false";
                  break;
                }
              }
            }
            if (result || ori === "true") {
              result = true;
              break;
            }
            if (ori !== "true" && ori !== "false") {
              if (ori[0] === "!") {
                result = !evaluateCallback(ori.substring(1));
              } else {
                result = evaluateCallback(ori);
              }
            } else {
              result = ori === "true" ? true : false;
            }
          }
        }
        return result ? "true" : "false";
      };
      AndOrNotEvaluator2._SimplifyNegation = function(booleanString) {
        booleanString = booleanString.replace(/^[\s!]+/, function(r) {
          r = r.replace(/[\s]/g, function() {
            return "";
          });
          return r.length % 2 ? "!" : "";
        });
        booleanString = booleanString.trim();
        if (booleanString === "!true") {
          booleanString = "false";
        } else if (booleanString === "!false") {
          booleanString = "true";
        }
        return booleanString;
      };
      return AndOrNotEvaluator2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/tags.js
var Tags;
var init_tags = __esm({
  "node_modules/@babylonjs/core/Misc/tags.js"() {
    init_andOrNotEvaluator();
    Tags = function() {
      function Tags2() {
      }
      Tags2.EnableFor = function(obj) {
        obj._tags = obj._tags || {};
        obj.hasTags = function() {
          return Tags2.HasTags(obj);
        };
        obj.addTags = function(tagsString) {
          return Tags2.AddTagsTo(obj, tagsString);
        };
        obj.removeTags = function(tagsString) {
          return Tags2.RemoveTagsFrom(obj, tagsString);
        };
        obj.matchesTagsQuery = function(tagsQuery) {
          return Tags2.MatchesQuery(obj, tagsQuery);
        };
      };
      Tags2.DisableFor = function(obj) {
        delete obj._tags;
        delete obj.hasTags;
        delete obj.addTags;
        delete obj.removeTags;
        delete obj.matchesTagsQuery;
      };
      Tags2.HasTags = function(obj) {
        if (!obj._tags) {
          return false;
        }
        var tags = obj._tags;
        for (var i in tags) {
          if (Object.prototype.hasOwnProperty.call(tags, i)) {
            return true;
          }
        }
        return false;
      };
      Tags2.GetTags = function(obj, asString) {
        if (asString === void 0) {
          asString = true;
        }
        if (!obj._tags) {
          return null;
        }
        if (asString) {
          var tagsArray = [];
          for (var tag in obj._tags) {
            if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
              tagsArray.push(tag);
            }
          }
          return tagsArray.join(" ");
        } else {
          return obj._tags;
        }
      };
      Tags2.AddTagsTo = function(obj, tagsString) {
        if (!tagsString) {
          return;
        }
        if (typeof tagsString !== "string") {
          return;
        }
        var tags = tagsString.split(" ");
        tags.forEach(function(tag) {
          Tags2._AddTagTo(obj, tag);
        });
      };
      Tags2._AddTagTo = function(obj, tag) {
        tag = tag.trim();
        if (tag === "" || tag === "true" || tag === "false") {
          return;
        }
        if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
          return;
        }
        Tags2.EnableFor(obj);
        obj._tags[tag] = true;
      };
      Tags2.RemoveTagsFrom = function(obj, tagsString) {
        if (!Tags2.HasTags(obj)) {
          return;
        }
        var tags = tagsString.split(" ");
        for (var t in tags) {
          Tags2._RemoveTagFrom(obj, tags[t]);
        }
      };
      Tags2._RemoveTagFrom = function(obj, tag) {
        delete obj._tags[tag];
      };
      Tags2.MatchesQuery = function(obj, tagsQuery) {
        if (tagsQuery === void 0) {
          return true;
        }
        if (tagsQuery === "") {
          return Tags2.HasTags(obj);
        }
        return AndOrNotEvaluator.Eval(tagsQuery, function(r) {
          return Tags2.HasTags(obj) && obj._tags[r];
        });
      };
      return Tags2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/devTools.js
function _WarnImport(name) {
  return "".concat(name, " needs to be imported before as it contains a side-effect required by your code.");
}
var init_devTools = __esm({
  "node_modules/@babylonjs/core/Misc/devTools.js"() {
  }
});

// node_modules/@babylonjs/core/Misc/decorators.js
function getDirectStore(target) {
  var classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  var classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  var store = __mergedStore[classKey];
  var currentTarget = target;
  var currentKey = classKey;
  while (currentKey) {
    var initialStore = __decoratorInitialStore[currentKey];
    for (var property in initialStore) {
      store[property] = initialStore[property];
    }
    var parent_1 = void 0;
    var done = false;
    do {
      parent_1 = Object.getPrototypeOf(currentTarget);
      if (!parent_1.getClassName) {
        done = true;
        break;
      }
      if (parent_1.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent_1;
    } while (parent_1);
    if (done) {
      break;
    }
    currentKey = parent_1.getClassName();
    currentTarget = parent_1;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return function(target, propertyKey) {
    var classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return function(target, propertyKey) {
    var key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
function nativeOverride(target, propertyKey, descriptor, predicate) {
  var jsFunc = descriptor.value;
  descriptor.value = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      var nativeFunc_1 = _native[propertyKey];
      if (predicate) {
        func = function() {
          var params2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            params2[_i2] = arguments[_i2];
          }
          return predicate.apply(void 0, params2) ? nativeFunc_1.apply(void 0, params2) : jsFunc.apply(void 0, params2);
        };
      } else {
        func = nativeFunc_1;
      }
    }
    target[propertyKey] = func;
    return func.apply(void 0, params);
  };
}
var __decoratorInitialStore, __mergedStore, _copySource, SerializationHelper;
var init_decorators = __esm({
  "node_modules/@babylonjs/core/Misc/decorators.js"() {
    init_tags();
    init_math_vector();
    init_devTools();
    init_math_color();
    __decoratorInitialStore = {};
    __mergedStore = {};
    _copySource = function(creationFunction, source, instanciate) {
      var destination = creationFunction();
      if (Tags) {
        Tags.AddTagsTo(destination, source.tags);
      }
      var classStore = getMergedStore(destination);
      for (var property in classStore) {
        var propertyDescriptor = classStore[property];
        var sourceProperty = source[property];
        var propertyType = propertyDescriptor.type;
        if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
          switch (propertyType) {
            case 0:
            case 6:
            case 11:
              destination[property] = sourceProperty;
              break;
            case 1:
              destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
              break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 7:
            case 10:
            case 12:
              destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
              break;
          }
        }
      }
      return destination;
    };
    SerializationHelper = function() {
      function SerializationHelper2() {
      }
      SerializationHelper2.AppendSerializedAnimations = function(source, destination) {
        if (source.animations) {
          destination.animations = [];
          for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
            var animation = source.animations[animationIndex];
            destination.animations.push(animation.serialize());
          }
        }
      };
      SerializationHelper2.Serialize = function(entity, serializationObject) {
        if (!serializationObject) {
          serializationObject = {};
        }
        if (Tags) {
          serializationObject.tags = Tags.GetTags(entity);
        }
        var serializedProperties = getMergedStore(entity);
        for (var property in serializedProperties) {
          var propertyDescriptor = serializedProperties[property];
          var targetPropertyName = propertyDescriptor.sourceName || property;
          var propertyType = propertyDescriptor.type;
          var sourceProperty = entity[property];
          if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
            switch (propertyType) {
              case 0:
                serializationObject[targetPropertyName] = sourceProperty;
                break;
              case 1:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 2:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 3:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 4:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 5:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 6:
                serializationObject[targetPropertyName] = sourceProperty.id;
                break;
              case 7:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 8:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 9:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 10:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 11:
                serializationObject[targetPropertyName] = sourceProperty.id;
                break;
              case 12:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
            }
          }
        }
        return serializationObject;
      };
      SerializationHelper2.Parse = function(creationFunction, source, scene, rootUrl) {
        if (rootUrl === void 0) {
          rootUrl = null;
        }
        var destination = creationFunction();
        if (!rootUrl) {
          rootUrl = "";
        }
        if (Tags) {
          Tags.AddTagsTo(destination, source.tags);
        }
        var classStore = getMergedStore(destination);
        for (var property in classStore) {
          var propertyDescriptor = classStore[property];
          var sourceProperty = source[propertyDescriptor.sourceName || property];
          var propertyType = propertyDescriptor.type;
          if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
            var dest = destination;
            switch (propertyType) {
              case 0:
                dest[property] = sourceProperty;
                break;
              case 1:
                if (scene) {
                  dest[property] = SerializationHelper2._TextureParser(sourceProperty, scene, rootUrl);
                }
                break;
              case 2:
                dest[property] = Color3.FromArray(sourceProperty);
                break;
              case 3:
                dest[property] = SerializationHelper2._FresnelParametersParser(sourceProperty);
                break;
              case 4:
                dest[property] = Vector2.FromArray(sourceProperty);
                break;
              case 5:
                dest[property] = Vector3.FromArray(sourceProperty);
                break;
              case 6:
                if (scene) {
                  dest[property] = scene.getLastMeshById(sourceProperty);
                }
                break;
              case 7:
                dest[property] = SerializationHelper2._ColorCurvesParser(sourceProperty);
                break;
              case 8:
                dest[property] = Color4.FromArray(sourceProperty);
                break;
              case 9:
                dest[property] = SerializationHelper2._ImageProcessingConfigurationParser(sourceProperty);
                break;
              case 10:
                dest[property] = Quaternion.FromArray(sourceProperty);
                break;
              case 11:
                if (scene) {
                  dest[property] = scene.getCameraById(sourceProperty);
                }
                break;
              case 12:
                dest[property] = Matrix.FromArray(sourceProperty);
                break;
            }
          }
        }
        return destination;
      };
      SerializationHelper2.Clone = function(creationFunction, source) {
        return _copySource(creationFunction, source, false);
      };
      SerializationHelper2.Instanciate = function(creationFunction, source) {
        return _copySource(creationFunction, source, true);
      };
      SerializationHelper2.AllowLoadingUniqueId = false;
      SerializationHelper2._ImageProcessingConfigurationParser = function(sourceProperty) {
        throw _WarnImport("ImageProcessingConfiguration");
      };
      SerializationHelper2._FresnelParametersParser = function(sourceProperty) {
        throw _WarnImport("FresnelParameters");
      };
      SerializationHelper2._ColorCurvesParser = function(sourceProperty) {
        throw _WarnImport("ColorCurves");
      };
      SerializationHelper2._TextureParser = function(sourceProperty, scene, rootUrl) {
        throw _WarnImport("Texture");
      };
      return SerializationHelper2;
    }();
    nativeOverride.filter = function(predicate) {
      return function(target, propertyKey, descriptor) {
        return nativeOverride(target, propertyKey, descriptor, predicate);
      };
    };
  }
});

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest;
var init_webRequest = __esm({
  "node_modules/@babylonjs/core/Misc/webRequest.js"() {
    WebRequest = function() {
      function WebRequest2() {
        this._xhr = createXMLHttpRequest();
      }
      WebRequest2.prototype._injectCustomRequestHeaders = function() {
        for (var key in WebRequest2.CustomRequestHeaders) {
          var val = WebRequest2.CustomRequestHeaders[key];
          if (val) {
            this._xhr.setRequestHeader(key, val);
          }
        }
      };
      Object.defineProperty(WebRequest2.prototype, "onprogress", {
        get: function() {
          return this._xhr.onprogress;
        },
        set: function(value) {
          this._xhr.onprogress = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "readyState", {
        get: function() {
          return this._xhr.readyState;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "status", {
        get: function() {
          return this._xhr.status;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "statusText", {
        get: function() {
          return this._xhr.statusText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "response", {
        get: function() {
          return this._xhr.response;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "responseURL", {
        get: function() {
          return this._xhr.responseURL;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "responseText", {
        get: function() {
          return this._xhr.responseText;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "responseType", {
        get: function() {
          return this._xhr.responseType;
        },
        set: function(value) {
          this._xhr.responseType = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebRequest2.prototype, "timeout", {
        get: function() {
          return this._xhr.timeout;
        },
        set: function(value) {
          this._xhr.timeout = value;
        },
        enumerable: false,
        configurable: true
      });
      WebRequest2.prototype.addEventListener = function(type, listener, options) {
        this._xhr.addEventListener(type, listener, options);
      };
      WebRequest2.prototype.removeEventListener = function(type, listener, options) {
        this._xhr.removeEventListener(type, listener, options);
      };
      WebRequest2.prototype.abort = function() {
        this._xhr.abort();
      };
      WebRequest2.prototype.send = function(body) {
        if (WebRequest2.CustomRequestHeaders) {
          this._injectCustomRequestHeaders();
        }
        this._xhr.send(body);
      };
      WebRequest2.prototype.open = function(method, url) {
        for (var _i = 0, _a = WebRequest2.CustomRequestModifiers; _i < _a.length; _i++) {
          var update = _a[_i];
          update(this._xhr, url);
        }
        url = url.replace("file:http:", "http:");
        url = url.replace("file:https:", "https:");
        return this._xhr.open(method, url, true);
      };
      WebRequest2.prototype.setRequestHeader = function(name, value) {
        this._xhr.setRequestHeader(name, value);
      };
      WebRequest2.prototype.getResponseHeader = function(name) {
        return this._xhr.getResponseHeader(name);
      };
      WebRequest2.CustomRequestHeaders = {};
      WebRequest2.CustomRequestModifiers = new Array();
      return WebRequest2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/domManagement.js
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  var result = "";
  var child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement;
var init_domManagement = __esm({
  "node_modules/@babylonjs/core/Misc/domManagement.js"() {
    DomManagement = {
      IsWindowObjectExist,
      IsNavigatorAvailable,
      IsDocumentAvailable,
      GetDOMTextContent
    };
  }
});

// node_modules/@babylonjs/core/Misc/precisionDate.js
var PrecisionDate;
var init_precisionDate = __esm({
  "node_modules/@babylonjs/core/Misc/precisionDate.js"() {
    init_domManagement();
    PrecisionDate = function() {
      function PrecisionDate2() {
      }
      Object.defineProperty(PrecisionDate2, "Now", {
        get: function() {
          if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {
            return window.performance.now();
          }
          return Date.now();
        },
        enumerable: false,
        configurable: true
      });
      return PrecisionDate2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore;
var init_filesInputStore = __esm({
  "node_modules/@babylonjs/core/Misc/filesInputStore.js"() {
    FilesInputStore = function() {
      function FilesInputStore2() {
      }
      FilesInputStore2.FilesToLoad = {};
      return FilesInputStore2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy;
var init_retryStrategy = __esm({
  "node_modules/@babylonjs/core/Misc/retryStrategy.js"() {
    RetryStrategy = function() {
      function RetryStrategy2() {
      }
      RetryStrategy2.ExponentialBackoff = function(maxRetries, baseInterval) {
        if (maxRetries === void 0) {
          maxRetries = 3;
        }
        if (baseInterval === void 0) {
          baseInterval = 500;
        }
        return function(url, request, retryIndex) {
          if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
            return -1;
          }
          return Math.pow(2, retryIndex) * baseInterval;
        };
      };
      return RetryStrategy2;
    }();
  }
});

// node_modules/tslib/tslib.es6.js
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@babylonjs/core/Misc/error.js
var BaseError, ErrorCodes, RuntimeError;
var init_error = __esm({
  "node_modules/@babylonjs/core/Misc/error.js"() {
    init_tslib_es6();
    BaseError = function(_super) {
      __extends(BaseError2, _super);
      function BaseError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      BaseError2._setPrototypeOf = Object.setPrototypeOf || function(o, proto) {
        o.__proto__ = proto;
        return o;
      };
      return BaseError2;
    }(Error);
    ErrorCodes = {
      MeshInvalidPositionsError: 0,
      UnsupportedTextureError: 1e3,
      GLTFLoaderUnexpectedMagicError: 2e3,
      SceneLoaderError: 3e3,
      LoadFileError: 4e3,
      RequestFileError: 4001,
      ReadFileError: 4002
    };
    RuntimeError = function(_super) {
      __extends(RuntimeError2, _super);
      function RuntimeError2(message, errorCode, innerError) {
        var _this = _super.call(this, message) || this;
        _this.errorCode = errorCode;
        _this.innerError = innerError;
        _this.name = "RuntimeError";
        BaseError._setPrototypeOf(_this, RuntimeError2.prototype);
        return _this;
      }
      return RuntimeError2;
    }(BaseError);
  }
});

// node_modules/@babylonjs/core/Materials/shaderLanguage.js
var ShaderLanguage;
var init_shaderLanguage = __esm({
  "node_modules/@babylonjs/core/Materials/shaderLanguage.js"() {
    (function(ShaderLanguage2) {
      ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
      ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
    })(ShaderLanguage || (ShaderLanguage = {}));
  }
});

// node_modules/@babylonjs/core/Engines/shaderStore.js
var ShaderStore;
var init_shaderStore = __esm({
  "node_modules/@babylonjs/core/Engines/shaderStore.js"() {
    init_shaderLanguage();
    ShaderStore = function() {
      function ShaderStore2() {
      }
      ShaderStore2.GetShadersRepository = function(shaderLanguage) {
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersRepository : ShaderStore2.ShadersRepositoryWGSL;
      };
      ShaderStore2.GetShadersStore = function(shaderLanguage) {
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersStore : ShaderStore2.ShadersStoreWGSL;
      };
      ShaderStore2.GetIncludesShadersStore = function(shaderLanguage) {
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.IncludesShadersStore : ShaderStore2.IncludesShadersStoreWGSL;
      };
      ShaderStore2.ShadersRepository = "src/Shaders/";
      ShaderStore2.ShadersStore = {};
      ShaderStore2.IncludesShadersStore = {};
      ShaderStore2.ShadersRepositoryWGSL = "src/ShadersWGSL/";
      ShaderStore2.ShadersStoreWGSL = {};
      ShaderStore2.IncludesShadersStoreWGSL = {};
      return ShaderStore2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js
var ShaderCodeNode;
var init_shaderCodeNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js"() {
    init_stringTools();
    ShaderCodeNode = function() {
      function ShaderCodeNode2() {
        this.children = [];
      }
      ShaderCodeNode2.prototype.isValid = function(preprocessors) {
        return true;
      };
      ShaderCodeNode2.prototype.process = function(preprocessors, options) {
        var result = "";
        if (this.line) {
          var value = this.line;
          var processor = options.processor;
          if (processor) {
            if (processor.lineProcessor) {
              value = processor.lineProcessor(value, options.isFragment, options.processingContext);
            }
            if (processor.attributeProcessor && StartsWith(this.line, "attribute")) {
              value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
            } else if (processor.varyingProcessor && StartsWith(this.line, "varying")) {
              value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
              if (!options.lookForClosingBracketForUniformBuffer) {
                value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
              }
            } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
              if (!options.lookForClosingBracketForUniformBuffer) {
                value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
                options.lookForClosingBracketForUniformBuffer = true;
              }
            } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
              value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StartsWith(this.line, "uniform") && !options.lookForClosingBracketForUniformBuffer) {
              var regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
              if (regex.test(this.line)) {
                if (processor.uniformProcessor) {
                  value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
                }
              } else {
                if (processor.uniformBufferProcessor) {
                  value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
                  options.lookForClosingBracketForUniformBuffer = true;
                }
              }
            }
            if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
              options.lookForClosingBracketForUniformBuffer = false;
              if (processor.endOfUniformBufferProcessor) {
                value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              }
            }
          }
          result += value + "\r\n";
        }
        this.children.forEach(function(child) {
          result += child.process(preprocessors, options);
        });
        if (this.additionalDefineKey) {
          preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
        }
        return result;
      };
      return ShaderCodeNode2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js
var ShaderCodeCursor;
var init_shaderCodeCursor = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js"() {
    ShaderCodeCursor = function() {
      function ShaderCodeCursor2() {
      }
      Object.defineProperty(ShaderCodeCursor2.prototype, "currentLine", {
        get: function() {
          return this._lines[this.lineIndex];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ShaderCodeCursor2.prototype, "canRead", {
        get: function() {
          return this.lineIndex < this._lines.length - 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ShaderCodeCursor2.prototype, "lines", {
        set: function(value) {
          this._lines = [];
          for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
            var line = value_1[_i];
            if (line[0] === "#") {
              this._lines.push(line);
              continue;
            }
            if (line.trim().startsWith("//")) {
              this._lines.push(line);
              continue;
            }
            var split = line.split(";");
            for (var index = 0; index < split.length; index++) {
              var subLine = split[index];
              subLine = subLine.trim();
              if (!subLine) {
                continue;
              }
              this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return ShaderCodeCursor2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js
var ShaderCodeConditionNode;
var init_shaderCodeConditionNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js"() {
    init_tslib_es6();
    init_shaderCodeNode();
    ShaderCodeConditionNode = function(_super) {
      __extends(ShaderCodeConditionNode2, _super);
      function ShaderCodeConditionNode2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ShaderCodeConditionNode2.prototype.process = function(preprocessors, options) {
        for (var index = 0; index < this.children.length; index++) {
          var node = this.children[index];
          if (node.isValid(preprocessors)) {
            return node.process(preprocessors, options);
          }
        }
        return "";
      };
      return ShaderCodeConditionNode2;
    }(ShaderCodeNode);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js
var ShaderCodeTestNode;
var init_shaderCodeTestNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js"() {
    init_tslib_es6();
    init_shaderCodeNode();
    ShaderCodeTestNode = function(_super) {
      __extends(ShaderCodeTestNode2, _super);
      function ShaderCodeTestNode2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ShaderCodeTestNode2.prototype.isValid = function(preprocessors) {
        return this.testExpression.isTrue(preprocessors);
      };
      return ShaderCodeTestNode2;
    }(ShaderCodeNode);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js
var ShaderDefineExpression;
var init_shaderDefineExpression = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js"() {
    ShaderDefineExpression = function() {
      function ShaderDefineExpression2() {
      }
      ShaderDefineExpression2.prototype.isTrue = function(preprocessors) {
        return true;
      };
      ShaderDefineExpression2.postfixToInfix = function(postfix) {
        var stack = [];
        for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
          var c = postfix_1[_i];
          if (ShaderDefineExpression2._OperatorPriority[c] === void 0) {
            stack.push(c);
          } else {
            var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
            stack.length -= 2;
            stack.push("(".concat(v2).concat(c).concat(v1, ")"));
          }
        }
        return stack[stack.length - 1];
      };
      ShaderDefineExpression2.infixToPostfix = function(infix) {
        var result = [];
        var stackIdx = -1;
        var pushOperand = function() {
          operand = operand.trim();
          if (operand !== "") {
            result.push(operand);
            operand = "";
          }
        };
        var push = function(s) {
          if (stackIdx < ShaderDefineExpression2._Stack.length - 1) {
            ShaderDefineExpression2._Stack[++stackIdx] = s;
          }
        };
        var peek = function() {
          return ShaderDefineExpression2._Stack[stackIdx];
        };
        var pop = function() {
          return stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression2._Stack[stackIdx--];
        };
        var idx = 0, operand = "";
        while (idx < infix.length) {
          var c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
          if (c === "(") {
            operand = "";
            push(c);
          } else if (c === ")") {
            pushOperand();
            while (stackIdx !== -1 && peek() !== "(") {
              result.push(pop());
            }
            pop();
          } else if (ShaderDefineExpression2._OperatorPriority[token] > 1) {
            pushOperand();
            while (stackIdx !== -1 && ShaderDefineExpression2._OperatorPriority[peek()] >= ShaderDefineExpression2._OperatorPriority[token]) {
              result.push(pop());
            }
            push(token);
            idx++;
          } else {
            operand += c;
          }
          idx++;
        }
        pushOperand();
        while (stackIdx !== -1) {
          if (peek() === "(") {
            pop();
          } else {
            result.push(pop());
          }
        }
        return result;
      };
      ShaderDefineExpression2._OperatorPriority = {
        ")": 0,
        "(": 1,
        "||": 2,
        "&&": 3
      };
      ShaderDefineExpression2._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
      return ShaderDefineExpression2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js
var ShaderDefineIsDefinedOperator;
var init_shaderDefineIsDefinedOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js"() {
    init_tslib_es6();
    init_shaderDefineExpression();
    ShaderDefineIsDefinedOperator = function(_super) {
      __extends(ShaderDefineIsDefinedOperator2, _super);
      function ShaderDefineIsDefinedOperator2(define, not) {
        if (not === void 0) {
          not = false;
        }
        var _this = _super.call(this) || this;
        _this.define = define;
        _this.not = not;
        return _this;
      }
      ShaderDefineIsDefinedOperator2.prototype.isTrue = function(preprocessors) {
        var condition = preprocessors[this.define] !== void 0;
        if (this.not) {
          condition = !condition;
        }
        return condition;
      };
      return ShaderDefineIsDefinedOperator2;
    }(ShaderDefineExpression);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js
var ShaderDefineOrOperator;
var init_shaderDefineOrOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js"() {
    init_tslib_es6();
    init_shaderDefineExpression();
    ShaderDefineOrOperator = function(_super) {
      __extends(ShaderDefineOrOperator2, _super);
      function ShaderDefineOrOperator2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ShaderDefineOrOperator2.prototype.isTrue = function(preprocessors) {
        return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
      };
      return ShaderDefineOrOperator2;
    }(ShaderDefineExpression);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js
var ShaderDefineAndOperator;
var init_shaderDefineAndOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js"() {
    init_tslib_es6();
    init_shaderDefineExpression();
    ShaderDefineAndOperator = function(_super) {
      __extends(ShaderDefineAndOperator2, _super);
      function ShaderDefineAndOperator2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ShaderDefineAndOperator2.prototype.isTrue = function(preprocessors) {
        return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
      };
      return ShaderDefineAndOperator2;
    }(ShaderDefineExpression);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js
var ShaderDefineArithmeticOperator;
var init_shaderDefineArithmeticOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js"() {
    init_tslib_es6();
    init_shaderDefineExpression();
    ShaderDefineArithmeticOperator = function(_super) {
      __extends(ShaderDefineArithmeticOperator2, _super);
      function ShaderDefineArithmeticOperator2(define, operand, testValue) {
        var _this = _super.call(this) || this;
        _this.define = define;
        _this.operand = operand;
        _this.testValue = testValue;
        return _this;
      }
      ShaderDefineArithmeticOperator2.prototype.isTrue = function(preprocessors) {
        var value = preprocessors[this.define];
        if (value === void 0) {
          value = this.define;
        }
        var condition = false;
        var left = parseInt(value);
        var right = parseInt(this.testValue);
        switch (this.operand) {
          case ">":
            condition = left > right;
            break;
          case "<":
            condition = left < right;
            break;
          case "<=":
            condition = left <= right;
            break;
          case ">=":
            condition = left >= right;
            break;
          case "==":
            condition = left === right;
            break;
        }
        return condition;
      };
      return ShaderDefineArithmeticOperator2;
    }(ShaderDefineExpression);
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js
var regexSE, regexSERevert, regexShaderInclude, ShaderProcessor;
var init_shaderProcessor = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js"() {
    init_shaderCodeNode();
    init_shaderCodeCursor();
    init_shaderCodeConditionNode();
    init_shaderCodeTestNode();
    init_shaderDefineIsDefinedOperator();
    init_shaderDefineOrOperator();
    init_shaderDefineAndOperator();
    init_shaderDefineExpression();
    init_shaderDefineArithmeticOperator();
    init_devTools();
    init_shaderLanguage();
    regexSE = /defined\s*?\((.+?)\)/g;
    regexSERevert = /defined\s*?\[(.+?)\]/g;
    regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
    ShaderProcessor = function() {
      function ShaderProcessor2() {
      }
      ShaderProcessor2.Initialize = function(options) {
        if (options.processor && options.processor.initializeShaders) {
          options.processor.initializeShaders(options.processingContext);
        }
      };
      ShaderProcessor2.Process = function(sourceCode, options, callback, engine) {
        var _this = this;
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
          sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
        }
        this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
          if (options.processCodeAfterIncludes) {
            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
          }
          var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);
          callback(migratedCode);
        });
      };
      ShaderProcessor2.PreProcess = function(sourceCode, options, callback, engine) {
        var _this = this;
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
          sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
        }
        this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
          if (options.processCodeAfterIncludes) {
            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
          }
          var migratedCode = _this._ApplyPreProcessing(codeWithIncludes, options, engine);
          callback(migratedCode);
        });
      };
      ShaderProcessor2.Finalize = function(vertexCode, fragmentCode, options) {
        if (!options.processor || !options.processor.finalizeShaders) {
          return { vertexCode, fragmentCode };
        }
        return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
      };
      ShaderProcessor2._ProcessPrecision = function(source, options) {
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {
          return source;
        }
        var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
        if (source.indexOf("precision highp float") === -1) {
          if (!shouldUseHighPrecisionShader) {
            source = "precision mediump float;\n" + source;
          } else {
            source = "precision highp float;\n" + source;
          }
        } else {
          if (!shouldUseHighPrecisionShader) {
            source = source.replace("precision highp float", "precision mediump float");
          }
        }
        return source;
      };
      ShaderProcessor2._ExtractOperation = function(expression) {
        var regex = /defined\((.+)\)/;
        var match = regex.exec(expression);
        if (match && match.length) {
          return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
        }
        var operators = ["==", ">=", "<=", "<", ">"];
        var operator = "";
        var indexOperator = 0;
        for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {
          operator = operators_1[_i];
          indexOperator = expression.indexOf(operator);
          if (indexOperator > -1) {
            break;
          }
        }
        if (indexOperator === -1) {
          return new ShaderDefineIsDefinedOperator(expression);
        }
        var define = expression.substring(0, indexOperator).trim();
        var value = expression.substring(indexOperator + operator.length).trim();
        return new ShaderDefineArithmeticOperator(define, operator, value);
      };
      ShaderProcessor2._BuildSubExpression = function(expression) {
        expression = expression.replace(regexSE, "defined[$1]");
        var postfix = ShaderDefineExpression.infixToPostfix(expression);
        var stack = [];
        for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
          var c = postfix_1[_i];
          if (c !== "||" && c !== "&&") {
            stack.push(c);
          } else if (stack.length >= 2) {
            var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
            stack.length -= 2;
            var operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
            if (typeof v1 === "string") {
              v1 = v1.replace(regexSERevert, "defined($1)");
            }
            if (typeof v2 === "string") {
              v2 = v2.replace(regexSERevert, "defined($1)");
            }
            operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
            operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
            stack.push(operator);
          }
        }
        var result = stack[stack.length - 1];
        if (typeof result === "string") {
          result = result.replace(regexSERevert, "defined($1)");
        }
        return typeof result === "string" ? this._ExtractOperation(result) : result;
      };
      ShaderProcessor2._BuildExpression = function(line, start) {
        var node = new ShaderCodeTestNode();
        var command = line.substring(0, start);
        var expression = line.substring(start);
        expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
        if (command === "#ifdef") {
          node.testExpression = new ShaderDefineIsDefinedOperator(expression);
        } else if (command === "#ifndef") {
          node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
        } else {
          node.testExpression = this._BuildSubExpression(expression);
        }
        return node;
      };
      ShaderProcessor2._MoveCursorWithinIf = function(cursor, rootNode, ifNode) {
        var line = cursor.currentLine;
        while (this._MoveCursor(cursor, ifNode)) {
          line = cursor.currentLine;
          var first5 = line.substring(0, 5).toLowerCase();
          if (first5 === "#else") {
            var elseNode = new ShaderCodeNode();
            rootNode.children.push(elseNode);
            this._MoveCursor(cursor, elseNode);
            return;
          } else if (first5 === "#elif") {
            var elifNode = this._BuildExpression(line, 5);
            rootNode.children.push(elifNode);
            ifNode = elifNode;
          }
        }
      };
      ShaderProcessor2._MoveCursor = function(cursor, rootNode) {
        while (cursor.canRead) {
          cursor.lineIndex++;
          var line = cursor.currentLine;
          var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
          var matches = keywords.exec(line);
          if (matches && matches.length) {
            var keyword = matches[0];
            switch (keyword) {
              case "#ifdef": {
                var newRootNode = new ShaderCodeConditionNode();
                rootNode.children.push(newRootNode);
                var ifNode = this._BuildExpression(line, 6);
                newRootNode.children.push(ifNode);
                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                break;
              }
              case "#else":
              case "#elif":
                return true;
              case "#endif":
                return false;
              case "#ifndef": {
                var newRootNode = new ShaderCodeConditionNode();
                rootNode.children.push(newRootNode);
                var ifNode = this._BuildExpression(line, 7);
                newRootNode.children.push(ifNode);
                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                break;
              }
              case "#if": {
                var newRootNode = new ShaderCodeConditionNode();
                var ifNode = this._BuildExpression(line, 3);
                rootNode.children.push(newRootNode);
                newRootNode.children.push(ifNode);
                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                break;
              }
            }
          } else {
            var newNode = new ShaderCodeNode();
            newNode.line = line;
            rootNode.children.push(newNode);
            if (line[0] === "#" && line[1] === "d") {
              var split = line.replace(";", "").split(" ");
              newNode.additionalDefineKey = split[1];
              if (split.length === 3) {
                newNode.additionalDefineValue = split[2];
              }
            }
          }
        }
        return false;
      };
      ShaderProcessor2._EvaluatePreProcessors = function(sourceCode, preprocessors, options) {
        var rootNode = new ShaderCodeNode();
        var cursor = new ShaderCodeCursor();
        cursor.lineIndex = -1;
        cursor.lines = sourceCode.split("\n");
        this._MoveCursor(cursor, rootNode);
        return rootNode.process(preprocessors, options);
      };
      ShaderProcessor2._PreparePreProcessors = function(options, engine) {
        var _a;
        var defines = options.defines;
        var preprocessors = {};
        for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
          var define = defines_1[_i];
          var keyValue = define.replace("#define", "").replace(";", "").trim();
          var split = keyValue.split(" ");
          preprocessors[split[0]] = split.length > 1 ? split[1] : "";
        }
        if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {
          preprocessors["GL_ES"] = "true";
        }
        preprocessors["__VERSION__"] = options.version;
        preprocessors[options.platformName] = "true";
        engine._getGlobalDefines(preprocessors);
        return preprocessors;
      };
      ShaderProcessor2._ProcessShaderConversion = function(sourceCode, options, engine) {
        var preparedSourceCode = this._ProcessPrecision(sourceCode, options);
        if (!options.processor) {
          return preparedSourceCode;
        }
        if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
          return preparedSourceCode.replace("#version 300 es", "");
        }
        var defines = options.defines;
        var preprocessors = this._PreparePreProcessors(options, engine);
        if (options.processor.preProcessor) {
          preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
        }
        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
        if (options.processor.postProcessor) {
          preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
        }
        if (engine._features.needShaderCodeInlining) {
          preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
        }
        return preparedSourceCode;
      };
      ShaderProcessor2._ApplyPreProcessing = function(sourceCode, options, engine) {
        var _a, _b;
        var preparedSourceCode = sourceCode;
        var defines = options.defines;
        var preprocessors = this._PreparePreProcessors(options, engine);
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {
          preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
        }
        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
        if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {
          preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
        }
        if (engine._features.needShaderCodeInlining) {
          preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
        }
        return preparedSourceCode;
      };
      ShaderProcessor2._ProcessIncludes = function(sourceCode, options, callback) {
        var _this = this;
        var match = regexShaderInclude.exec(sourceCode);
        var returnValue = new String(sourceCode);
        var keepProcessing = false;
        var _loop_1 = function() {
          var includeFile = match[1];
          if (includeFile.indexOf("__decl__") !== -1) {
            includeFile = includeFile.replace(/__decl__/, "");
            if (options.supportsUniformBuffers) {
              includeFile = includeFile.replace(/Vertex/, "Ubo");
              includeFile = includeFile.replace(/Fragment/, "Ubo");
            }
            includeFile = includeFile + "Declaration";
          }
          if (options.includesShadersStore[includeFile]) {
            var includeContent = options.includesShadersStore[includeFile];
            if (match[2]) {
              var splits = match[3].split(",");
              for (var index = 0; index < splits.length; index += 2) {
                var source = new RegExp(splits[index], "g");
                var dest = splits[index + 1];
                includeContent = includeContent.replace(source, dest);
              }
            }
            if (match[4]) {
              var indexString = match[5];
              if (indexString.indexOf("..") !== -1) {
                var indexSplits = indexString.split("..");
                var minIndex = parseInt(indexSplits[0]);
                var maxIndex = parseInt(indexSplits[1]);
                var sourceIncludeContent = includeContent.slice(0);
                includeContent = "";
                if (isNaN(maxIndex)) {
                  maxIndex = options.indexParameters[indexSplits[1]];
                }
                for (var i = minIndex; i < maxIndex; i++) {
                  if (!options.supportsUniformBuffers) {
                    sourceIncludeContent = sourceIncludeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                      return p1 + "{X}";
                    });
                  }
                  includeContent += sourceIncludeContent.replace(/\{X\}/g, i.toString()) + "\n";
                }
              } else {
                if (!options.supportsUniformBuffers) {
                  includeContent = includeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                    return p1 + "{X}";
                  });
                }
                includeContent = includeContent.replace(/\{X\}/g, indexString);
              }
            }
            returnValue = returnValue.replace(match[0], includeContent);
            keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
          } else {
            var includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
            ShaderProcessor2._FileToolsLoadFile(includeShaderUrl, function(fileContent) {
              options.includesShadersStore[includeFile] = fileContent;
              _this._ProcessIncludes(returnValue, options, callback);
            });
            return { value: void 0 };
          }
          match = regexShaderInclude.exec(sourceCode);
        };
        while (match != null) {
          var state_1 = _loop_1();
          if (typeof state_1 === "object")
            return state_1.value;
        }
        if (keepProcessing) {
          this._ProcessIncludes(returnValue.toString(), options, callback);
        } else {
          callback(returnValue);
        }
      };
      ShaderProcessor2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        throw _WarnImport("FileTools");
      };
      return ShaderProcessor2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/effect.js
var Effect;
var init_effect = __esm({
  "node_modules/@babylonjs/core/Materials/effect.js"() {
    init_observable();
    init_domManagement();
    init_logger();
    init_shaderProcessor();
    init_shaderStore();
    init_shaderLanguage();
    Effect = function() {
      function Effect2(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters, key, shaderLanguage) {
        if (samplers === void 0) {
          samplers = null;
        }
        if (defines === void 0) {
          defines = null;
        }
        if (fallbacks === void 0) {
          fallbacks = null;
        }
        if (onCompiled === void 0) {
          onCompiled = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (key === void 0) {
          key = "";
        }
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        var _this = this;
        var _a, _b, _c;
        this.name = null;
        this.defines = "";
        this.onCompiled = null;
        this.onError = null;
        this.onBind = null;
        this.uniqueId = 0;
        this.onCompileObservable = new Observable();
        this.onErrorObservable = new Observable();
        this._onBindObservable = null;
        this._wasPreviouslyReady = false;
        this._bonesComputationForcedToCPU = false;
        this._uniformBuffersNames = {};
        this._multiTarget = false;
        this._samplers = {};
        this._isReady = false;
        this._compilationError = "";
        this._allFallbacksProcessed = false;
        this._uniforms = {};
        this._key = "";
        this._fallbacks = null;
        this._vertexSourceCodeOverride = "";
        this._fragmentSourceCodeOverride = "";
        this._transformFeedbackVaryings = null;
        this._pipelineContext = null;
        this._vertexSourceCode = "";
        this._fragmentSourceCode = "";
        this._rawVertexSourceCode = "";
        this._rawFragmentSourceCode = "";
        this.name = baseName;
        this._key = key;
        var processCodeAfterIncludes = void 0;
        var processFinalCode = null;
        if (attributesNamesOrOptions.attributes) {
          var options = attributesNamesOrOptions;
          this._engine = uniformsNamesOrEngine;
          this._attributesNames = options.attributes;
          this._uniformsNames = options.uniformsNames.concat(options.samplers);
          this._samplerList = options.samplers.slice();
          this.defines = options.defines;
          this.onError = options.onError;
          this.onCompiled = options.onCompiled;
          this._fallbacks = options.fallbacks;
          this._indexParameters = options.indexParameters;
          this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
          this._multiTarget = !!options.multiTarget;
          this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;
          if (options.uniformBuffersNames) {
            this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
            for (var i = 0; i < options.uniformBuffersNames.length; i++) {
              this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
            }
          }
          processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;
          processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : void 0;
        } else {
          this._engine = engine;
          this.defines = defines == null ? "" : defines;
          this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
          this._samplerList = samplers ? samplers.slice() : [];
          this._attributesNames = attributesNamesOrOptions;
          this._uniformBuffersNamesList = [];
          this._shaderLanguage = shaderLanguage;
          this.onError = onError;
          this.onCompiled = onCompiled;
          this._indexParameters = indexParameters;
          this._fallbacks = fallbacks;
        }
        this._attributeLocationByName = {};
        this.uniqueId = Effect2._UniqueIdSeed++;
        var vertexSource;
        var fragmentSource;
        var hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
        if (baseName.vertexSource) {
          vertexSource = "source:" + baseName.vertexSource;
        } else if (baseName.vertexElement) {
          vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
          if (!vertexSource) {
            vertexSource = baseName.vertexElement;
          }
        } else {
          vertexSource = baseName.vertex || baseName;
        }
        if (baseName.fragmentSource) {
          fragmentSource = "source:" + baseName.fragmentSource;
        } else if (baseName.fragmentElement) {
          fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
          if (!fragmentSource) {
            fragmentSource = baseName.fragmentElement;
          }
        } else {
          fragmentSource = baseName.fragment || baseName;
        }
        this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
        var processorOptions = {
          defines: this.defines.split("\n"),
          indexParameters: this._indexParameters,
          isFragment: false,
          shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
          processor: this._engine._getShaderProcessor(this._shaderLanguage),
          supportsUniformBuffers: this._engine.supportsUniformBuffers,
          shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
          includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
          version: (this._engine.version * 100).toString(),
          platformName: this._engine.shaderPlatformName,
          processingContext: this._processingContext,
          isNDCHalfZRange: this._engine.isNDCHalfZRange,
          useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
          processCodeAfterIncludes
        };
        var shaderCodes = [void 0, void 0];
        var shadersLoaded = function() {
          if (shaderCodes[0] && shaderCodes[1]) {
            processorOptions.isFragment = true;
            var migratedVertexCode_1 = shaderCodes[0], fragmentCode = shaderCodes[1];
            ShaderProcessor.Process(fragmentCode, processorOptions, function(migratedFragmentCode) {
              if (processFinalCode) {
                migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
              }
              var finalShaders = ShaderProcessor.Finalize(migratedVertexCode_1, migratedFragmentCode, processorOptions);
              _this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);
            }, _this._engine);
          }
        };
        this._loadShader(vertexSource, "Vertex", "", function(vertexCode) {
          ShaderProcessor.Initialize(processorOptions);
          ShaderProcessor.Process(vertexCode, processorOptions, function(migratedVertexCode) {
            _this._rawVertexSourceCode = vertexCode;
            if (processFinalCode) {
              migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
            }
            shaderCodes[0] = migratedVertexCode;
            shadersLoaded();
          }, _this._engine);
        });
        this._loadShader(fragmentSource, "Fragment", "Pixel", function(fragmentCode) {
          _this._rawFragmentSourceCode = fragmentCode;
          shaderCodes[1] = fragmentCode;
          shadersLoaded();
        });
      }
      Object.defineProperty(Effect2, "ShadersRepository", {
        get: function() {
          return ShaderStore.ShadersRepository;
        },
        set: function(repo) {
          ShaderStore.ShadersRepository = repo;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Effect2.prototype, "onBindObservable", {
        get: function() {
          if (!this._onBindObservable) {
            this._onBindObservable = new Observable();
          }
          return this._onBindObservable;
        },
        enumerable: false,
        configurable: true
      });
      Effect2.prototype._useFinalCode = function(migratedVertexCode, migratedFragmentCode, baseName) {
        if (baseName) {
          var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
          var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
          this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
          this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
        } else {
          this._vertexSourceCode = migratedVertexCode;
          this._fragmentSourceCode = migratedFragmentCode;
        }
        this._prepareEffect();
      };
      Object.defineProperty(Effect2.prototype, "key", {
        get: function() {
          return this._key;
        },
        enumerable: false,
        configurable: true
      });
      Effect2.prototype.isReady = function() {
        try {
          return this._isReadyInternal();
        } catch (_a) {
          return false;
        }
      };
      Effect2.prototype._isReadyInternal = function() {
        if (this._isReady) {
          return true;
        }
        if (this._pipelineContext) {
          return this._pipelineContext.isReady;
        }
        return false;
      };
      Effect2.prototype.getEngine = function() {
        return this._engine;
      };
      Effect2.prototype.getPipelineContext = function() {
        return this._pipelineContext;
      };
      Effect2.prototype.getAttributesNames = function() {
        return this._attributesNames;
      };
      Effect2.prototype.getAttributeLocation = function(index) {
        return this._attributes[index];
      };
      Effect2.prototype.getAttributeLocationByName = function(name) {
        return this._attributeLocationByName[name];
      };
      Effect2.prototype.getAttributesCount = function() {
        return this._attributes.length;
      };
      Effect2.prototype.getUniformIndex = function(uniformName) {
        return this._uniformsNames.indexOf(uniformName);
      };
      Effect2.prototype.getUniform = function(uniformName) {
        return this._uniforms[uniformName];
      };
      Effect2.prototype.getSamplers = function() {
        return this._samplerList;
      };
      Effect2.prototype.getUniformNames = function() {
        return this._uniformsNames;
      };
      Effect2.prototype.getUniformBuffersNames = function() {
        return this._uniformBuffersNamesList;
      };
      Effect2.prototype.getIndexParameters = function() {
        return this._indexParameters;
      };
      Effect2.prototype.getCompilationError = function() {
        return this._compilationError;
      };
      Effect2.prototype.allFallbacksProcessed = function() {
        return this._allFallbacksProcessed;
      };
      Effect2.prototype.executeWhenCompiled = function(func) {
        var _this = this;
        if (this.isReady()) {
          func(this);
          return;
        }
        this.onCompileObservable.add(function(effect) {
          func(effect);
        });
        if (!this._pipelineContext || this._pipelineContext.isAsync) {
          setTimeout(function() {
            _this._checkIsReady(null);
          }, 16);
        }
      };
      Effect2.prototype._checkIsReady = function(previousPipelineContext) {
        var _this = this;
        try {
          if (this._isReadyInternal()) {
            return;
          }
        } catch (e) {
          this._processCompilationErrors(e, previousPipelineContext);
          return;
        }
        setTimeout(function() {
          _this._checkIsReady(previousPipelineContext);
        }, 16);
      };
      Effect2.prototype._loadShader = function(shader, key, optionalKey, callback) {
        if (typeof HTMLElement !== "undefined") {
          if (shader instanceof HTMLElement) {
            var shaderCode = GetDOMTextContent(shader);
            callback(shaderCode);
            return;
          }
        }
        if (shader.substr(0, 7) === "source:") {
          callback(shader.substr(7));
          return;
        }
        if (shader.substr(0, 7) === "base64:") {
          var shaderBinary = window.atob(shader.substr(7));
          callback(shaderBinary);
          return;
        }
        var shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
        if (shaderStore[shader + key + "Shader"]) {
          callback(shaderStore[shader + key + "Shader"]);
          return;
        }
        if (optionalKey && shaderStore[shader + optionalKey + "Shader"]) {
          callback(shaderStore[shader + optionalKey + "Shader"]);
          return;
        }
        var shaderUrl;
        if (shader[0] === "." || shader[0] === "/" || shader.indexOf("http") > -1) {
          shaderUrl = shader;
        } else {
          shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader;
        }
        this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
      };
      Object.defineProperty(Effect2.prototype, "vertexSourceCode", {
        get: function() {
          var _a, _b;
          return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Effect2.prototype, "fragmentSourceCode", {
        get: function() {
          var _a, _b;
          return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Effect2.prototype, "rawVertexSourceCode", {
        get: function() {
          return this._rawVertexSourceCode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Effect2.prototype, "rawFragmentSourceCode", {
        get: function() {
          return this._rawFragmentSourceCode;
        },
        enumerable: false,
        configurable: true
      });
      Effect2.prototype._rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
        var _this = this;
        this._isReady = false;
        this._vertexSourceCodeOverride = vertexSourceCode;
        this._fragmentSourceCodeOverride = fragmentSourceCode;
        this.onError = function(effect, error) {
          if (onError) {
            onError(error);
          }
        };
        this.onCompiled = function() {
          var scenes = _this.getEngine().scenes;
          if (scenes) {
            for (var i = 0; i < scenes.length; i++) {
              scenes[i].markAllMaterialsAsDirty(63);
            }
          }
          _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
        };
        this._fallbacks = null;
        this._prepareEffect();
      };
      Effect2.prototype._prepareEffect = function() {
        var _this = this;
        var attributesNames = this._attributesNames;
        var defines = this.defines;
        var previousPipelineContext = this._pipelineContext;
        this._isReady = false;
        try {
          var engine_1 = this._engine;
          this._pipelineContext = engine_1.createPipelineContext(this._processingContext);
          this._pipelineContext._name = this._key;
          var rebuildRebind = this._rebuildProgram.bind(this);
          if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
            engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
          } else {
            engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
          }
          engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function() {
            _this._attributes = [];
            _this._pipelineContext._fillEffectInformation(_this, _this._uniformBuffersNames, _this._uniformsNames, _this._uniforms, _this._samplerList, _this._samplers, attributesNames, _this._attributes);
            if (attributesNames) {
              for (var i = 0; i < attributesNames.length; i++) {
                var name_1 = attributesNames[i];
                _this._attributeLocationByName[name_1] = _this._attributes[i];
              }
            }
            engine_1.bindSamplers(_this);
            _this._compilationError = "";
            _this._isReady = true;
            if (_this.onCompiled) {
              _this.onCompiled(_this);
            }
            _this.onCompileObservable.notifyObservers(_this);
            _this.onCompileObservable.clear();
            if (_this._fallbacks) {
              _this._fallbacks.unBindMesh();
            }
            if (previousPipelineContext) {
              _this.getEngine()._deletePipelineContext(previousPipelineContext);
            }
          });
          if (this._pipelineContext.isAsync) {
            this._checkIsReady(previousPipelineContext);
          }
        } catch (e) {
          this._processCompilationErrors(e, previousPipelineContext);
        }
      };
      Effect2.prototype._getShaderCodeAndErrorLine = function(code, error, isFragment) {
        var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
        var errorLine = null;
        if (error && code) {
          var res = error.match(regexp);
          if (res && res.length === 2) {
            var lineNumber = parseInt(res[1]);
            var lines = code.split("\n", -1);
            if (lines.length >= lineNumber) {
              errorLine = "Offending line [".concat(lineNumber, "] in ").concat(isFragment ? "fragment" : "vertex", " code: ").concat(lines[lineNumber - 1]);
            }
          }
        }
        return [code, errorLine];
      };
      Effect2.prototype._processCompilationErrors = function(e, previousPipelineContext) {
        var _a, _b;
        var _c, _d, _e;
        if (previousPipelineContext === void 0) {
          previousPipelineContext = null;
        }
        this._compilationError = e.message;
        var attributesNames = this._attributesNames;
        var fallbacks = this._fallbacks;
        Logger.Error("Unable to compile effect:");
        Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
          return " " + uniform;
        }));
        Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
          return " " + attribute;
        }));
        Logger.Error("Defines:\r\n" + this.defines);
        if (Effect2.LogShaderCodeOnCompilationError) {
          var lineErrorVertex = null, lineErrorFragment = null, code = null;
          if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {
            _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];
            if (code) {
              Logger.Error("Vertex code:");
              Logger.Error(code);
            }
          }
          if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {
            _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];
            if (code) {
              Logger.Error("Fragment code:");
              Logger.Error(code);
            }
          }
          if (lineErrorVertex) {
            Logger.Error(lineErrorVertex);
          }
          if (lineErrorFragment) {
            Logger.Error(lineErrorFragment);
          }
        }
        Logger.Error("Error: " + this._compilationError);
        if (previousPipelineContext) {
          this._pipelineContext = previousPipelineContext;
          this._isReady = true;
          if (this.onError) {
            this.onError(this, this._compilationError);
          }
          this.onErrorObservable.notifyObservers(this);
        }
        if (fallbacks) {
          this._pipelineContext = null;
          if (fallbacks.hasMoreFallbacks) {
            this._allFallbacksProcessed = false;
            Logger.Error("Trying next fallback.");
            this.defines = fallbacks.reduce(this.defines, this);
            this._prepareEffect();
          } else {
            this._allFallbacksProcessed = true;
            if (this.onError) {
              this.onError(this, this._compilationError);
            }
            this.onErrorObservable.notifyObservers(this);
            this.onErrorObservable.clear();
            if (this._fallbacks) {
              this._fallbacks.unBindMesh();
            }
          }
        } else {
          this._allFallbacksProcessed = true;
        }
      };
      Object.defineProperty(Effect2.prototype, "isSupported", {
        get: function() {
          return this._compilationError === "";
        },
        enumerable: false,
        configurable: true
      });
      Effect2.prototype._bindTexture = function(channel, texture) {
        this._engine._bindTexture(this._samplers[channel], texture, channel);
      };
      Effect2.prototype.setTexture = function(channel, texture) {
        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
      };
      Effect2.prototype.setDepthStencilTexture = function(channel, texture) {
        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
      };
      Effect2.prototype.setTextureArray = function(channel, textures) {
        var exName = channel + "Ex";
        if (this._samplerList.indexOf(exName + "0") === -1) {
          var initialPos = this._samplerList.indexOf(channel);
          for (var index = 1; index < textures.length; index++) {
            var currentExName = exName + (index - 1).toString();
            this._samplerList.splice(initialPos + index, 0, currentExName);
          }
          var channelIndex = 0;
          for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {
            var key = _a[_i];
            this._samplers[key] = channelIndex;
            channelIndex += 1;
          }
        }
        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
      };
      Effect2.prototype.setTextureFromPostProcess = function(channel, postProcess) {
        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
      };
      Effect2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
      };
      Effect2.prototype.bindUniformBuffer = function(buffer, name) {
        var bufferName = this._uniformBuffersNames[name];
        if (bufferName === void 0 || Effect2._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
          return;
        }
        Effect2._BaseCache[bufferName] = buffer;
        this._engine.bindUniformBufferBase(buffer, bufferName, name);
      };
      Effect2.prototype.bindUniformBlock = function(blockName, index) {
        this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
      };
      Effect2.prototype.setInt = function(uniformName, value) {
        this._pipelineContext.setInt(uniformName, value);
        return this;
      };
      Effect2.prototype.setInt2 = function(uniformName, x, y) {
        this._pipelineContext.setInt2(uniformName, x, y);
        return this;
      };
      Effect2.prototype.setInt3 = function(uniformName, x, y, z) {
        this._pipelineContext.setInt3(uniformName, x, y, z);
        return this;
      };
      Effect2.prototype.setInt4 = function(uniformName, x, y, z, w) {
        this._pipelineContext.setInt4(uniformName, x, y, z, w);
        return this;
      };
      Effect2.prototype.setIntArray = function(uniformName, array) {
        this._pipelineContext.setIntArray(uniformName, array);
        return this;
      };
      Effect2.prototype.setIntArray2 = function(uniformName, array) {
        this._pipelineContext.setIntArray2(uniformName, array);
        return this;
      };
      Effect2.prototype.setIntArray3 = function(uniformName, array) {
        this._pipelineContext.setIntArray3(uniformName, array);
        return this;
      };
      Effect2.prototype.setIntArray4 = function(uniformName, array) {
        this._pipelineContext.setIntArray4(uniformName, array);
        return this;
      };
      Effect2.prototype.setFloatArray = function(uniformName, array) {
        this._pipelineContext.setArray(uniformName, array);
        return this;
      };
      Effect2.prototype.setFloatArray2 = function(uniformName, array) {
        this._pipelineContext.setArray2(uniformName, array);
        return this;
      };
      Effect2.prototype.setFloatArray3 = function(uniformName, array) {
        this._pipelineContext.setArray3(uniformName, array);
        return this;
      };
      Effect2.prototype.setFloatArray4 = function(uniformName, array) {
        this._pipelineContext.setArray4(uniformName, array);
        return this;
      };
      Effect2.prototype.setArray = function(uniformName, array) {
        this._pipelineContext.setArray(uniformName, array);
        return this;
      };
      Effect2.prototype.setArray2 = function(uniformName, array) {
        this._pipelineContext.setArray2(uniformName, array);
        return this;
      };
      Effect2.prototype.setArray3 = function(uniformName, array) {
        this._pipelineContext.setArray3(uniformName, array);
        return this;
      };
      Effect2.prototype.setArray4 = function(uniformName, array) {
        this._pipelineContext.setArray4(uniformName, array);
        return this;
      };
      Effect2.prototype.setMatrices = function(uniformName, matrices) {
        this._pipelineContext.setMatrices(uniformName, matrices);
        return this;
      };
      Effect2.prototype.setMatrix = function(uniformName, matrix) {
        this._pipelineContext.setMatrix(uniformName, matrix);
        return this;
      };
      Effect2.prototype.setMatrix3x3 = function(uniformName, matrix) {
        this._pipelineContext.setMatrix3x3(uniformName, matrix);
        return this;
      };
      Effect2.prototype.setMatrix2x2 = function(uniformName, matrix) {
        this._pipelineContext.setMatrix2x2(uniformName, matrix);
        return this;
      };
      Effect2.prototype.setFloat = function(uniformName, value) {
        this._pipelineContext.setFloat(uniformName, value);
        return this;
      };
      Effect2.prototype.setBool = function(uniformName, bool) {
        this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
        return this;
      };
      Effect2.prototype.setVector2 = function(uniformName, vector2) {
        this._pipelineContext.setVector2(uniformName, vector2);
        return this;
      };
      Effect2.prototype.setFloat2 = function(uniformName, x, y) {
        this._pipelineContext.setFloat2(uniformName, x, y);
        return this;
      };
      Effect2.prototype.setVector3 = function(uniformName, vector3) {
        this._pipelineContext.setVector3(uniformName, vector3);
        return this;
      };
      Effect2.prototype.setFloat3 = function(uniformName, x, y, z) {
        this._pipelineContext.setFloat3(uniformName, x, y, z);
        return this;
      };
      Effect2.prototype.setVector4 = function(uniformName, vector4) {
        this._pipelineContext.setVector4(uniformName, vector4);
        return this;
      };
      Effect2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
        this._pipelineContext.setFloat4(uniformName, x, y, z, w);
        return this;
      };
      Effect2.prototype.setColor3 = function(uniformName, color3) {
        this._pipelineContext.setColor3(uniformName, color3);
        return this;
      };
      Effect2.prototype.setColor4 = function(uniformName, color3, alpha) {
        this._pipelineContext.setColor4(uniformName, color3, alpha);
        return this;
      };
      Effect2.prototype.setDirectColor4 = function(uniformName, color4) {
        this._pipelineContext.setDirectColor4(uniformName, color4);
        return this;
      };
      Effect2.prototype.dispose = function() {
        if (this._pipelineContext) {
          this._pipelineContext.dispose();
        }
        this._engine._releaseEffect(this);
      };
      Effect2.RegisterShader = function(name, pixelShader, vertexShader, shaderLanguage) {
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        if (pixelShader) {
          ShaderStore.GetShadersStore(shaderLanguage)["".concat(name, "PixelShader")] = pixelShader;
        }
        if (vertexShader) {
          ShaderStore.GetShadersStore(shaderLanguage)["".concat(name, "VertexShader")] = vertexShader;
        }
      };
      Effect2.ResetCache = function() {
        Effect2._BaseCache = {};
      };
      Effect2.LogShaderCodeOnCompilationError = true;
      Effect2._UniqueIdSeed = 0;
      Effect2._BaseCache = {};
      Effect2.ShadersStore = ShaderStore.ShadersStore;
      Effect2.IncludesShadersStore = ShaderStore.IncludesShadersStore;
      return Effect2;
    }();
  }
});

// node_modules/@babylonjs/core/States/depthCullingState.js
var DepthCullingState;
var init_depthCullingState = __esm({
  "node_modules/@babylonjs/core/States/depthCullingState.js"() {
    DepthCullingState = function() {
      function DepthCullingState2(reset) {
        if (reset === void 0) {
          reset = true;
        }
        this._isDepthTestDirty = false;
        this._isDepthMaskDirty = false;
        this._isDepthFuncDirty = false;
        this._isCullFaceDirty = false;
        this._isCullDirty = false;
        this._isZOffsetDirty = false;
        this._isFrontFaceDirty = false;
        if (reset) {
          this.reset();
        }
      }
      Object.defineProperty(DepthCullingState2.prototype, "isDirty", {
        get: function() {
          return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "zOffset", {
        get: function() {
          return this._zOffset;
        },
        set: function(value) {
          if (this._zOffset === value) {
            return;
          }
          this._zOffset = value;
          this._isZOffsetDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "zOffsetUnits", {
        get: function() {
          return this._zOffsetUnits;
        },
        set: function(value) {
          if (this._zOffsetUnits === value) {
            return;
          }
          this._zOffsetUnits = value;
          this._isZOffsetDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "cullFace", {
        get: function() {
          return this._cullFace;
        },
        set: function(value) {
          if (this._cullFace === value) {
            return;
          }
          this._cullFace = value;
          this._isCullFaceDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "cull", {
        get: function() {
          return this._cull;
        },
        set: function(value) {
          if (this._cull === value) {
            return;
          }
          this._cull = value;
          this._isCullDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "depthFunc", {
        get: function() {
          return this._depthFunc;
        },
        set: function(value) {
          if (this._depthFunc === value) {
            return;
          }
          this._depthFunc = value;
          this._isDepthFuncDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "depthMask", {
        get: function() {
          return this._depthMask;
        },
        set: function(value) {
          if (this._depthMask === value) {
            return;
          }
          this._depthMask = value;
          this._isDepthMaskDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "depthTest", {
        get: function() {
          return this._depthTest;
        },
        set: function(value) {
          if (this._depthTest === value) {
            return;
          }
          this._depthTest = value;
          this._isDepthTestDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DepthCullingState2.prototype, "frontFace", {
        get: function() {
          return this._frontFace;
        },
        set: function(value) {
          if (this._frontFace === value) {
            return;
          }
          this._frontFace = value;
          this._isFrontFaceDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      DepthCullingState2.prototype.reset = function() {
        this._depthMask = true;
        this._depthTest = true;
        this._depthFunc = null;
        this._cullFace = null;
        this._cull = null;
        this._zOffset = 0;
        this._zOffsetUnits = 0;
        this._frontFace = null;
        this._isDepthTestDirty = true;
        this._isDepthMaskDirty = true;
        this._isDepthFuncDirty = false;
        this._isCullFaceDirty = false;
        this._isCullDirty = false;
        this._isZOffsetDirty = true;
        this._isFrontFaceDirty = false;
      };
      DepthCullingState2.prototype.apply = function(gl) {
        if (!this.isDirty) {
          return;
        }
        if (this._isCullDirty) {
          if (this.cull) {
            gl.enable(gl.CULL_FACE);
          } else {
            gl.disable(gl.CULL_FACE);
          }
          this._isCullDirty = false;
        }
        if (this._isCullFaceDirty) {
          gl.cullFace(this.cullFace);
          this._isCullFaceDirty = false;
        }
        if (this._isDepthMaskDirty) {
          gl.depthMask(this.depthMask);
          this._isDepthMaskDirty = false;
        }
        if (this._isDepthTestDirty) {
          if (this.depthTest) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }
          this._isDepthTestDirty = false;
        }
        if (this._isDepthFuncDirty) {
          gl.depthFunc(this.depthFunc);
          this._isDepthFuncDirty = false;
        }
        if (this._isZOffsetDirty) {
          if (this.zOffset || this.zOffsetUnits) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(this.zOffset, this.zOffsetUnits);
          } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
          }
          this._isZOffsetDirty = false;
        }
        if (this._isFrontFaceDirty) {
          gl.frontFace(this.frontFace);
          this._isFrontFaceDirty = false;
        }
      };
      return DepthCullingState2;
    }();
  }
});

// node_modules/@babylonjs/core/States/stencilState.js
var StencilState;
var init_stencilState = __esm({
  "node_modules/@babylonjs/core/States/stencilState.js"() {
    StencilState = function() {
      function StencilState2() {
        this.reset();
      }
      StencilState2.prototype.reset = function() {
        this.enabled = false;
        this.mask = 255;
        this.func = StencilState2.ALWAYS;
        this.funcRef = 1;
        this.funcMask = 255;
        this.opStencilFail = StencilState2.KEEP;
        this.opDepthFail = StencilState2.KEEP;
        this.opStencilDepthPass = StencilState2.REPLACE;
      };
      Object.defineProperty(StencilState2.prototype, "stencilFunc", {
        get: function() {
          return this.func;
        },
        set: function(value) {
          this.func = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilFuncRef", {
        get: function() {
          return this.funcRef;
        },
        set: function(value) {
          this.funcRef = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilFuncMask", {
        get: function() {
          return this.funcMask;
        },
        set: function(value) {
          this.funcMask = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilOpStencilFail", {
        get: function() {
          return this.opStencilFail;
        },
        set: function(value) {
          this.opStencilFail = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilOpDepthFail", {
        get: function() {
          return this.opDepthFail;
        },
        set: function(value) {
          this.opDepthFail = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilOpStencilDepthPass", {
        get: function() {
          return this.opStencilDepthPass;
        },
        set: function(value) {
          this.opStencilDepthPass = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilMask", {
        get: function() {
          return this.mask;
        },
        set: function(value) {
          this.mask = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilState2.prototype, "stencilTest", {
        get: function() {
          return this.enabled;
        },
        set: function(value) {
          this.enabled = value;
        },
        enumerable: false,
        configurable: true
      });
      StencilState2.ALWAYS = 519;
      StencilState2.KEEP = 7680;
      StencilState2.REPLACE = 7681;
      return StencilState2;
    }();
  }
});

// node_modules/@babylonjs/core/States/alphaCullingState.js
var AlphaState;
var init_alphaCullingState = __esm({
  "node_modules/@babylonjs/core/States/alphaCullingState.js"() {
    AlphaState = function() {
      function AlphaState2() {
        this._blendFunctionParameters = new Array(4);
        this._blendEquationParameters = new Array(2);
        this._blendConstants = new Array(4);
        this._isBlendConstantsDirty = false;
        this._alphaBlend = false;
        this._isAlphaBlendDirty = false;
        this._isBlendFunctionParametersDirty = false;
        this._isBlendEquationParametersDirty = false;
        this.reset();
      }
      Object.defineProperty(AlphaState2.prototype, "isDirty", {
        get: function() {
          return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AlphaState2.prototype, "alphaBlend", {
        get: function() {
          return this._alphaBlend;
        },
        set: function(value) {
          if (this._alphaBlend === value) {
            return;
          }
          this._alphaBlend = value;
          this._isAlphaBlendDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      AlphaState2.prototype.setAlphaBlendConstants = function(r, g, b, a) {
        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
          return;
        }
        this._blendConstants[0] = r;
        this._blendConstants[1] = g;
        this._blendConstants[2] = b;
        this._blendConstants[3] = a;
        this._isBlendConstantsDirty = true;
      };
      AlphaState2.prototype.setAlphaBlendFunctionParameters = function(value0, value1, value2, value3) {
        if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
          return;
        }
        this._blendFunctionParameters[0] = value0;
        this._blendFunctionParameters[1] = value1;
        this._blendFunctionParameters[2] = value2;
        this._blendFunctionParameters[3] = value3;
        this._isBlendFunctionParametersDirty = true;
      };
      AlphaState2.prototype.setAlphaEquationParameters = function(rgb, alpha) {
        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
          return;
        }
        this._blendEquationParameters[0] = rgb;
        this._blendEquationParameters[1] = alpha;
        this._isBlendEquationParametersDirty = true;
      };
      AlphaState2.prototype.reset = function() {
        this._alphaBlend = false;
        this._blendFunctionParameters[0] = null;
        this._blendFunctionParameters[1] = null;
        this._blendFunctionParameters[2] = null;
        this._blendFunctionParameters[3] = null;
        this._blendEquationParameters[0] = null;
        this._blendEquationParameters[1] = null;
        this._blendConstants[0] = null;
        this._blendConstants[1] = null;
        this._blendConstants[2] = null;
        this._blendConstants[3] = null;
        this._isAlphaBlendDirty = true;
        this._isBlendFunctionParametersDirty = false;
        this._isBlendEquationParametersDirty = false;
        this._isBlendConstantsDirty = false;
      };
      AlphaState2.prototype.apply = function(gl) {
        if (!this.isDirty) {
          return;
        }
        if (this._isAlphaBlendDirty) {
          if (this._alphaBlend) {
            gl.enable(gl.BLEND);
          } else {
            gl.disable(gl.BLEND);
          }
          this._isAlphaBlendDirty = false;
        }
        if (this._isBlendFunctionParametersDirty) {
          gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
          this._isBlendFunctionParametersDirty = false;
        }
        if (this._isBlendEquationParametersDirty) {
          gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
          this._isBlendEquationParametersDirty = false;
        }
        if (this._isBlendConstantsDirty) {
          gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
          this._isBlendConstantsDirty = false;
        }
      };
      return AlphaState2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/textureSampler.js
var TextureSampler;
var init_textureSampler = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/textureSampler.js"() {
    TextureSampler = function() {
      function TextureSampler2() {
        this.samplingMode = -1;
        this._useMipMaps = true;
        this._cachedWrapU = null;
        this._cachedWrapV = null;
        this._cachedWrapR = null;
        this._cachedAnisotropicFilteringLevel = null;
        this._comparisonFunction = 0;
      }
      Object.defineProperty(TextureSampler2.prototype, "wrapU", {
        get: function() {
          return this._cachedWrapU;
        },
        set: function(value) {
          this._cachedWrapU = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextureSampler2.prototype, "wrapV", {
        get: function() {
          return this._cachedWrapV;
        },
        set: function(value) {
          this._cachedWrapV = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextureSampler2.prototype, "wrapR", {
        get: function() {
          return this._cachedWrapR;
        },
        set: function(value) {
          this._cachedWrapR = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextureSampler2.prototype, "anisotropicFilteringLevel", {
        get: function() {
          return this._cachedAnisotropicFilteringLevel;
        },
        set: function(value) {
          this._cachedAnisotropicFilteringLevel = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextureSampler2.prototype, "comparisonFunction", {
        get: function() {
          return this._comparisonFunction;
        },
        set: function(value) {
          this._comparisonFunction = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextureSampler2.prototype, "useMipMaps", {
        get: function() {
          return this._useMipMaps;
        },
        set: function(value) {
          this._useMipMaps = value;
        },
        enumerable: false,
        configurable: true
      });
      TextureSampler2.prototype.setParameters = function(wrapU, wrapV, wrapR, anisotropicFilteringLevel, samplingMode, comparisonFunction) {
        if (wrapU === void 0) {
          wrapU = 1;
        }
        if (wrapV === void 0) {
          wrapV = 1;
        }
        if (wrapR === void 0) {
          wrapR = 1;
        }
        if (anisotropicFilteringLevel === void 0) {
          anisotropicFilteringLevel = 1;
        }
        if (samplingMode === void 0) {
          samplingMode = 2;
        }
        if (comparisonFunction === void 0) {
          comparisonFunction = 0;
        }
        this._cachedWrapU = wrapU;
        this._cachedWrapV = wrapV;
        this._cachedWrapR = wrapR;
        this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
        this.samplingMode = samplingMode;
        this._comparisonFunction = comparisonFunction;
        return this;
      };
      TextureSampler2.prototype.compareSampler = function(other) {
        return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
      };
      return TextureSampler2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/internalTexture.js
var InternalTextureSource, InternalTexture;
var init_internalTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/internalTexture.js"() {
    init_tslib_es6();
    init_observable();
    init_textureSampler();
    (function(InternalTextureSource2) {
      InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
      InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
      InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
      InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
      InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
      InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
      InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
      InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
      InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
      InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
      InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
      InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
      InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
      InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
      InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
    })(InternalTextureSource || (InternalTextureSource = {}));
    InternalTexture = function(_super) {
      __extends(InternalTexture2, _super);
      function InternalTexture2(engine, source, delayAllocation) {
        if (delayAllocation === void 0) {
          delayAllocation = false;
        }
        var _this = _super.call(this) || this;
        _this.isReady = false;
        _this.isCube = false;
        _this.is3D = false;
        _this.is2DArray = false;
        _this.isMultiview = false;
        _this.url = "";
        _this.generateMipMaps = false;
        _this.samples = 0;
        _this.type = -1;
        _this.format = -1;
        _this.onLoadedObservable = new Observable();
        _this.onErrorObservable = new Observable();
        _this.onRebuildCallback = null;
        _this.width = 0;
        _this.height = 0;
        _this.depth = 0;
        _this.baseWidth = 0;
        _this.baseHeight = 0;
        _this.baseDepth = 0;
        _this.invertY = false;
        _this._invertVScale = false;
        _this._associatedChannel = -1;
        _this._source = InternalTextureSource.Unknown;
        _this._buffer = null;
        _this._bufferView = null;
        _this._bufferViewArray = null;
        _this._bufferViewArrayArray = null;
        _this._size = 0;
        _this._extension = "";
        _this._files = null;
        _this._workingCanvas = null;
        _this._workingContext = null;
        _this._cachedCoordinatesMode = null;
        _this._isDisabled = false;
        _this._compression = null;
        _this._sphericalPolynomial = null;
        _this._sphericalPolynomialPromise = null;
        _this._sphericalPolynomialComputed = false;
        _this._lodGenerationScale = 0;
        _this._lodGenerationOffset = 0;
        _this._useSRGBBuffer = false;
        _this._lodTextureHigh = null;
        _this._lodTextureMid = null;
        _this._lodTextureLow = null;
        _this._isRGBD = false;
        _this._linearSpecularLOD = false;
        _this._irradianceTexture = null;
        _this._hardwareTexture = null;
        _this._maxLodLevel = null;
        _this._references = 1;
        _this._gammaSpace = null;
        _this._engine = engine;
        _this._source = source;
        _this._uniqueId = InternalTexture2._Counter++;
        if (!delayAllocation) {
          _this._hardwareTexture = engine._createHardwareTexture();
        }
        return _this;
      }
      Object.defineProperty(InternalTexture2.prototype, "useMipMaps", {
        get: function() {
          return this.generateMipMaps;
        },
        set: function(value) {
          this.generateMipMaps = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InternalTexture2.prototype, "uniqueId", {
        get: function() {
          return this._uniqueId;
        },
        enumerable: false,
        configurable: true
      });
      InternalTexture2.prototype.getEngine = function() {
        return this._engine;
      };
      Object.defineProperty(InternalTexture2.prototype, "source", {
        get: function() {
          return this._source;
        },
        enumerable: false,
        configurable: true
      });
      InternalTexture2.prototype.incrementReferences = function() {
        this._references++;
      };
      InternalTexture2.prototype.updateSize = function(width, height, depth) {
        if (depth === void 0) {
          depth = 1;
        }
        this._engine.updateTextureDimensions(this, width, height, depth);
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.baseWidth = width;
        this.baseHeight = height;
        this.baseDepth = depth;
        this._size = width * height * depth;
      };
      InternalTexture2.prototype._rebuild = function() {
        var _this = this;
        var _a;
        this.isReady = false;
        this._cachedCoordinatesMode = null;
        this._cachedWrapU = null;
        this._cachedWrapV = null;
        this._cachedWrapR = null;
        this._cachedAnisotropicFilteringLevel = null;
        if (this.onRebuildCallback) {
          var data_1 = this.onRebuildCallback(this);
          var swapAndSetIsReady = function(proxyInternalTexture) {
            proxyInternalTexture._swapAndDie(_this, false);
            _this.isReady = data_1.isReady;
          };
          if (data_1.isAsync) {
            data_1.proxy.then(swapAndSetIsReady);
          } else {
            swapAndSetIsReady(data_1.proxy);
          }
          return;
        }
        var proxy;
        switch (this.source) {
          case InternalTextureSource.Temp:
            break;
          case InternalTextureSource.Url:
            proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
              proxy._swapAndDie(_this, false);
              _this.isReady = true;
            }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer);
            return;
          case InternalTextureSource.Raw:
            proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Raw3D:
            proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Raw2DArray:
            proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Dynamic:
            proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
            proxy._swapAndDie(this, false);
            this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
            break;
          case InternalTextureSource.Cube:
            proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
              proxy._swapAndDie(_this, false);
              _this.isReady = true;
            }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
            return;
          case InternalTextureSource.CubeRaw:
            proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.CubeRawRGBD:
            return;
          case InternalTextureSource.CubePrefiltered:
            proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(proxy2) {
              if (proxy2) {
                proxy2._swapAndDie(_this, false);
              }
              _this.isReady = true;
            }, null, this.format, this._extension);
            proxy._sphericalPolynomial = this._sphericalPolynomial;
            return;
        }
      };
      InternalTexture2.prototype._swapAndDie = function(target, swapAll) {
        var _a;
        if (swapAll === void 0) {
          swapAll = true;
        }
        (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);
        target._hardwareTexture = this._hardwareTexture;
        if (swapAll) {
          target._isRGBD = this._isRGBD;
        }
        if (this._lodTextureHigh) {
          if (target._lodTextureHigh) {
            target._lodTextureHigh.dispose();
          }
          target._lodTextureHigh = this._lodTextureHigh;
        }
        if (this._lodTextureMid) {
          if (target._lodTextureMid) {
            target._lodTextureMid.dispose();
          }
          target._lodTextureMid = this._lodTextureMid;
        }
        if (this._lodTextureLow) {
          if (target._lodTextureLow) {
            target._lodTextureLow.dispose();
          }
          target._lodTextureLow = this._lodTextureLow;
        }
        if (this._irradianceTexture) {
          if (target._irradianceTexture) {
            target._irradianceTexture.dispose();
          }
          target._irradianceTexture = this._irradianceTexture;
        }
        var cache = this._engine.getLoadedTexturesCache();
        var index = cache.indexOf(this);
        if (index !== -1) {
          cache.splice(index, 1);
        }
        index = cache.indexOf(target);
        if (index === -1) {
          cache.push(target);
        }
      };
      InternalTexture2.prototype.dispose = function() {
        this._references--;
        this.onLoadedObservable.clear();
        this.onErrorObservable.clear();
        if (this._references === 0) {
          this._engine._releaseTexture(this);
          this._hardwareTexture = null;
        }
      };
      InternalTexture2._Counter = 0;
      return InternalTexture2;
    }(TextureSampler);
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js
var WebGL2ShaderProcessor;
var init_webGL2ShaderProcessors = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js"() {
    init_shaderLanguage();
    WebGL2ShaderProcessor = function() {
      function WebGL2ShaderProcessor2() {
        this.shaderLanguage = ShaderLanguage.GLSL;
      }
      WebGL2ShaderProcessor2.prototype.attributeProcessor = function(attribute) {
        return attribute.replace("attribute", "in");
      };
      WebGL2ShaderProcessor2.prototype.varyingProcessor = function(varying, isFragment) {
        return varying.replace("varying", isFragment ? "in" : "out");
      };
      WebGL2ShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment) {
        var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
        var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
        code = code.replace(regex, "");
        code = code.replace(/texture2D\s*\(/g, "texture(");
        if (isFragment) {
          code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
          code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
          code = code.replace(/textureCube\s*\(/g, "texture(");
          code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
          code = code.replace(/gl_FragColor/g, "glFragColor");
          code = code.replace(/gl_FragData/g, "glFragData");
          code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "out vec4 glFragColor;\n") + "void main(");
        } else {
          var hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
          if (hasMultiviewExtension) {
            return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
          }
        }
        return code;
      };
      return WebGL2ShaderProcessor2;
    }();
  }
});

// node_modules/@babylonjs/core/Buffers/dataBuffer.js
var DataBuffer;
var init_dataBuffer = __esm({
  "node_modules/@babylonjs/core/Buffers/dataBuffer.js"() {
    DataBuffer = function() {
      function DataBuffer2() {
        this.references = 0;
        this.capacity = 0;
        this.is32Bits = false;
        this.uniqueId = DataBuffer2._Counter++;
      }
      Object.defineProperty(DataBuffer2.prototype, "underlyingResource", {
        get: function() {
          return null;
        },
        enumerable: false,
        configurable: true
      });
      DataBuffer2._Counter = 0;
      return DataBuffer2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js
var WebGLDataBuffer;
var init_webGLDataBuffer = __esm({
  "node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js"() {
    init_tslib_es6();
    init_dataBuffer();
    WebGLDataBuffer = function(_super) {
      __extends(WebGLDataBuffer2, _super);
      function WebGLDataBuffer2(resource) {
        var _this = _super.call(this) || this;
        _this._buffer = resource;
        return _this;
      }
      Object.defineProperty(WebGLDataBuffer2.prototype, "underlyingResource", {
        get: function() {
          return this._buffer;
        },
        enumerable: false,
        configurable: true
      });
      return WebGLDataBuffer2;
    }(DataBuffer);
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js
var WebGLPipelineContext;
var init_webGLPipelineContext = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js"() {
    WebGLPipelineContext = function() {
      function WebGLPipelineContext2() {
        this._valueCache = {};
        this.vertexCompilationError = null;
        this.fragmentCompilationError = null;
        this.programLinkError = null;
        this.programValidationError = null;
      }
      Object.defineProperty(WebGLPipelineContext2.prototype, "isAsync", {
        get: function() {
          return this.isParallelCompiled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WebGLPipelineContext2.prototype, "isReady", {
        get: function() {
          if (this.program) {
            if (this.isParallelCompiled) {
              return this.engine._isRenderingStateCompiled(this);
            }
            return true;
          }
          return false;
        },
        enumerable: false,
        configurable: true
      });
      WebGLPipelineContext2.prototype._handlesSpectorRebuildCallback = function(onCompiled) {
        if (onCompiled && this.program) {
          onCompiled(this.program);
        }
      };
      WebGLPipelineContext2.prototype._fillEffectInformation = function(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
        var engine = this.engine;
        if (engine.supportsUniformBuffers) {
          for (var name_1 in uniformBuffersNames) {
            effect.bindUniformBlock(name_1, uniformBuffersNames[name_1]);
          }
        }
        var effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
        effectAvailableUniforms.forEach(function(uniform, index2) {
          uniforms[uniformsNames[index2]] = uniform;
        });
        this._uniforms = uniforms;
        var index;
        for (index = 0; index < samplerList.length; index++) {
          var sampler = effect.getUniform(samplerList[index]);
          if (sampler == null) {
            samplerList.splice(index, 1);
            index--;
          }
        }
        samplerList.forEach(function(name, index2) {
          samplers[name] = index2;
        });
        for (var _i = 0, _a = engine.getAttributes(this, attributesNames); _i < _a.length; _i++) {
          var attr = _a[_i];
          attributes.push(attr);
        }
      };
      WebGLPipelineContext2.prototype.dispose = function() {
        this._uniforms = {};
      };
      WebGLPipelineContext2.prototype._cacheMatrix = function(uniformName, matrix) {
        var cache = this._valueCache[uniformName];
        var flag = matrix.updateFlag;
        if (cache !== void 0 && cache === flag) {
          return false;
        }
        this._valueCache[uniformName] = flag;
        return true;
      };
      WebGLPipelineContext2.prototype._cacheFloat2 = function(uniformName, x, y) {
        var cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 2) {
          cache = [x, y];
          this._valueCache[uniformName] = cache;
          return true;
        }
        var changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        return changed;
      };
      WebGLPipelineContext2.prototype._cacheFloat3 = function(uniformName, x, y, z) {
        var cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 3) {
          cache = [x, y, z];
          this._valueCache[uniformName] = cache;
          return true;
        }
        var changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        if (cache[2] !== z) {
          cache[2] = z;
          changed = true;
        }
        return changed;
      };
      WebGLPipelineContext2.prototype._cacheFloat4 = function(uniformName, x, y, z, w) {
        var cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 4) {
          cache = [x, y, z, w];
          this._valueCache[uniformName] = cache;
          return true;
        }
        var changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        if (cache[2] !== z) {
          cache[2] = z;
          changed = true;
        }
        if (cache[3] !== w) {
          cache[3] = w;
          changed = true;
        }
        return changed;
      };
      WebGLPipelineContext2.prototype.setInt = function(uniformName, value) {
        var cache = this._valueCache[uniformName];
        if (cache !== void 0 && cache === value) {
          return;
        }
        if (this.engine.setInt(this._uniforms[uniformName], value)) {
          this._valueCache[uniformName] = value;
        }
      };
      WebGLPipelineContext2.prototype.setInt2 = function(uniformName, x, y) {
        if (this._cacheFloat2(uniformName, x, y)) {
          if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setInt3 = function(uniformName, x, y, z) {
        if (this._cacheFloat3(uniformName, x, y, z)) {
          if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setInt4 = function(uniformName, x, y, z, w) {
        if (this._cacheFloat4(uniformName, x, y, z, w)) {
          if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setIntArray = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setIntArray2 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray2(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setIntArray3 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray3(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setIntArray4 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray4(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setArray = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setArray2 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray2(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setArray3 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray3(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setArray4 = function(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray4(this._uniforms[uniformName], array);
      };
      WebGLPipelineContext2.prototype.setMatrices = function(uniformName, matrices) {
        if (!matrices) {
          return;
        }
        this._valueCache[uniformName] = null;
        this.engine.setMatrices(this._uniforms[uniformName], matrices);
      };
      WebGLPipelineContext2.prototype.setMatrix = function(uniformName, matrix) {
        if (this._cacheMatrix(uniformName, matrix)) {
          if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setMatrix3x3 = function(uniformName, matrix) {
        this._valueCache[uniformName] = null;
        this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);
      };
      WebGLPipelineContext2.prototype.setMatrix2x2 = function(uniformName, matrix) {
        this._valueCache[uniformName] = null;
        this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);
      };
      WebGLPipelineContext2.prototype.setFloat = function(uniformName, value) {
        var cache = this._valueCache[uniformName];
        if (cache !== void 0 && cache === value) {
          return;
        }
        if (this.engine.setFloat(this._uniforms[uniformName], value)) {
          this._valueCache[uniformName] = value;
        }
      };
      WebGLPipelineContext2.prototype.setVector2 = function(uniformName, vector2) {
        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
          if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setFloat2 = function(uniformName, x, y) {
        if (this._cacheFloat2(uniformName, x, y)) {
          if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setVector3 = function(uniformName, vector3) {
        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setFloat3 = function(uniformName, x, y, z) {
        if (this._cacheFloat3(uniformName, x, y, z)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setVector4 = function(uniformName, vector4) {
        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
        if (this._cacheFloat4(uniformName, x, y, z, w)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setColor3 = function(uniformName, color3) {
        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setColor4 = function(uniformName, color3, alpha) {
        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype.setDirectColor4 = function(uniformName, color4) {
        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
            this._valueCache[uniformName] = null;
          }
        }
      };
      WebGLPipelineContext2.prototype._getVertexShaderCode = function() {
        return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
      };
      WebGLPipelineContext2.prototype._getFragmentShaderCode = function() {
        return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
      };
      return WebGLPipelineContext2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js
var WebGLHardwareTexture;
var init_webGLHardwareTexture = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js"() {
    WebGLHardwareTexture = function() {
      function WebGLHardwareTexture2(existingTexture, context) {
        if (existingTexture === void 0) {
          existingTexture = null;
        }
        this._MSAARenderBuffer = null;
        this._context = context;
        if (!existingTexture) {
          existingTexture = context.createTexture();
          if (!existingTexture) {
            throw new Error("Unable to create webGL texture");
          }
        }
        this.set(existingTexture);
      }
      Object.defineProperty(WebGLHardwareTexture2.prototype, "underlyingResource", {
        get: function() {
          return this._webGLTexture;
        },
        enumerable: false,
        configurable: true
      });
      WebGLHardwareTexture2.prototype.setUsage = function() {
      };
      WebGLHardwareTexture2.prototype.set = function(hardwareTexture) {
        this._webGLTexture = hardwareTexture;
      };
      WebGLHardwareTexture2.prototype.reset = function() {
        this._webGLTexture = null;
        this._MSAARenderBuffer = null;
      };
      WebGLHardwareTexture2.prototype.release = function() {
        if (this._MSAARenderBuffer) {
          this._context.deleteRenderbuffer(this._MSAARenderBuffer);
          this._MSAARenderBuffer = null;
        }
        if (this._webGLTexture) {
          this._context.deleteTexture(this._webGLTexture);
        }
        this.reset();
      };
      return WebGLHardwareTexture2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper;
var init_drawWrapper = __esm({
  "node_modules/@babylonjs/core/Materials/drawWrapper.js"() {
    DrawWrapper = function() {
      function DrawWrapper2(engine, createMaterialContext) {
        if (createMaterialContext === void 0) {
          createMaterialContext = true;
        }
        this.effect = null;
        this.defines = null;
        this.drawContext = engine.createDrawContext();
        if (createMaterialContext) {
          this.materialContext = engine.createMaterialContext();
        }
      }
      DrawWrapper2.IsWrapper = function(effect) {
        return effect.getPipelineContext === void 0;
      };
      DrawWrapper2.GetEffect = function(effect) {
        return effect.getPipelineContext === void 0 ? effect.effect : effect;
      };
      DrawWrapper2.prototype.setEffect = function(effect, defines, resetContext) {
        var _a;
        if (resetContext === void 0) {
          resetContext = true;
        }
        this.effect = effect;
        if (defines !== void 0) {
          this.defines = defines;
        }
        if (resetContext) {
          (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.reset();
        }
      };
      DrawWrapper2.prototype.dispose = function() {
        var _a;
        (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.dispose();
      };
      return DrawWrapper2;
    }();
  }
});

// node_modules/@babylonjs/core/States/stencilStateComposer.js
var StencilStateComposer;
var init_stencilStateComposer = __esm({
  "node_modules/@babylonjs/core/States/stencilStateComposer.js"() {
    StencilStateComposer = function() {
      function StencilStateComposer2(reset) {
        if (reset === void 0) {
          reset = true;
        }
        this._isStencilTestDirty = false;
        this._isStencilMaskDirty = false;
        this._isStencilFuncDirty = false;
        this._isStencilOpDirty = false;
        this.useStencilGlobalOnly = false;
        if (reset) {
          this.reset();
        }
      }
      Object.defineProperty(StencilStateComposer2.prototype, "isDirty", {
        get: function() {
          return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "func", {
        get: function() {
          return this._func;
        },
        set: function(value) {
          if (this._func === value) {
            return;
          }
          this._func = value;
          this._isStencilFuncDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "funcRef", {
        get: function() {
          return this._funcRef;
        },
        set: function(value) {
          if (this._funcRef === value) {
            return;
          }
          this._funcRef = value;
          this._isStencilFuncDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "funcMask", {
        get: function() {
          return this._funcMask;
        },
        set: function(value) {
          if (this._funcMask === value) {
            return;
          }
          this._funcMask = value;
          this._isStencilFuncDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "opStencilFail", {
        get: function() {
          return this._opStencilFail;
        },
        set: function(value) {
          if (this._opStencilFail === value) {
            return;
          }
          this._opStencilFail = value;
          this._isStencilOpDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "opDepthFail", {
        get: function() {
          return this._opDepthFail;
        },
        set: function(value) {
          if (this._opDepthFail === value) {
            return;
          }
          this._opDepthFail = value;
          this._isStencilOpDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "opStencilDepthPass", {
        get: function() {
          return this._opStencilDepthPass;
        },
        set: function(value) {
          if (this._opStencilDepthPass === value) {
            return;
          }
          this._opStencilDepthPass = value;
          this._isStencilOpDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "mask", {
        get: function() {
          return this._mask;
        },
        set: function(value) {
          if (this._mask === value) {
            return;
          }
          this._mask = value;
          this._isStencilMaskDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StencilStateComposer2.prototype, "enabled", {
        get: function() {
          return this._enabled;
        },
        set: function(value) {
          if (this._enabled === value) {
            return;
          }
          this._enabled = value;
          this._isStencilTestDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      StencilStateComposer2.prototype.reset = function() {
        var _a;
        this.stencilMaterial = void 0;
        (_a = this.stencilGlobal) === null || _a === void 0 ? void 0 : _a.reset();
        this._isStencilTestDirty = true;
        this._isStencilMaskDirty = true;
        this._isStencilFuncDirty = true;
        this._isStencilOpDirty = true;
      };
      StencilStateComposer2.prototype.apply = function(gl) {
        var _a;
        if (!gl) {
          return;
        }
        var stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled);
        this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
        this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
        this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
        if (!this.isDirty) {
          return;
        }
        if (this._isStencilTestDirty) {
          if (this.enabled) {
            gl.enable(gl.STENCIL_TEST);
          } else {
            gl.disable(gl.STENCIL_TEST);
          }
          this._isStencilTestDirty = false;
        }
        if (this._isStencilMaskDirty) {
          gl.stencilMask(this.mask);
          this._isStencilMaskDirty = false;
        }
        if (this._isStencilFuncDirty) {
          gl.stencilFunc(this.func, this.funcRef, this.funcMask);
          this._isStencilFuncDirty = false;
        }
        if (this._isStencilOpDirty) {
          gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
          this._isStencilOpDirty = false;
        }
      };
      return StencilStateComposer2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js
var WebGLShaderProcessor;
var init_webGLShaderProcessors = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js"() {
    init_shaderLanguage();
    WebGLShaderProcessor = function() {
      function WebGLShaderProcessor2() {
        this.shaderLanguage = ShaderLanguage.GLSL;
      }
      WebGLShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment, processingContext, engine) {
        if (!engine.getCaps().drawBuffersExtension) {
          var regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
          code = code.replace(regex, "");
        }
        return code;
      };
      return WebGLShaderProcessor2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/thinEngine.js
var BufferPointer, ThinEngine;
var init_thinEngine = __esm({
  "node_modules/@babylonjs/core/Engines/thinEngine.js"() {
    init_tslib_es6();
    init_engineStore();
    init_effect();
    init_devTools();
    init_observable();
    init_depthCullingState();
    init_stencilState();
    init_alphaCullingState();
    init_internalTexture();
    init_logger();
    init_domManagement();
    init_webGLShaderProcessors();
    init_webGL2ShaderProcessors();
    init_webGLDataBuffer();
    init_webGLPipelineContext();
    init_performanceConfigurator();
    init_webGLHardwareTexture();
    init_drawWrapper();
    init_stencilStateComposer();
    init_shaderLanguage();
    BufferPointer = function() {
      function BufferPointer2() {
      }
      return BufferPointer2;
    }();
    ThinEngine = function() {
      function ThinEngine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
        var _this = this;
        this._name = "WebGL";
        this.forcePOTTextures = false;
        this.isFullscreen = false;
        this.cullBackFaces = null;
        this.renderEvenInBackground = true;
        this.preventCacheWipeBetweenFrames = false;
        this.validateShaderPrograms = false;
        this._useReverseDepthBuffer = false;
        this.isNDCHalfZRange = false;
        this.hasOriginBottomLeft = true;
        this.disableUniformBuffers = false;
        this.onDisposeObservable = new Observable();
        this._frameId = 0;
        this._uniformBuffers = new Array();
        this._storageBuffers = new Array();
        this._webGLVersion = 1;
        this._windowIsBackground = false;
        this._highPrecisionShadersAllowed = true;
        this._badOS = false;
        this._badDesktopOS = false;
        this._renderingQueueLaunched = false;
        this._activeRenderLoops = new Array();
        this.onContextLostObservable = new Observable();
        this.onContextRestoredObservable = new Observable();
        this._contextWasLost = false;
        this._doNotHandleContextLost = false;
        this.disableVertexArrayObjects = false;
        this._colorWrite = true;
        this._colorWriteChanged = true;
        this._depthCullingState = new DepthCullingState();
        this._stencilStateComposer = new StencilStateComposer();
        this._stencilState = new StencilState();
        this._alphaState = new AlphaState();
        this._alphaMode = 1;
        this._alphaEquation = 0;
        this._internalTexturesCache = new Array();
        this._renderTargetWrapperCache = new Array();
        this._activeChannel = 0;
        this._currentTextureChannel = -1;
        this._boundTexturesCache = {};
        this._compiledEffects = {};
        this._vertexAttribArraysEnabled = [];
        this._uintIndicesCurrentlySet = false;
        this._currentBoundBuffer = new Array();
        this._currentFramebuffer = null;
        this._dummyFramebuffer = null;
        this._currentBufferPointers = new Array();
        this._currentInstanceLocations = new Array();
        this._currentInstanceBuffers = new Array();
        this._vaoRecordInProgress = false;
        this._mustWipeVertexAttributes = false;
        this._nextFreeTextureSlots = new Array();
        this._maxSimultaneousTextures = 0;
        this._activeRequests = new Array();
        this._adaptToDeviceRatio = false;
        this._transformTextureUrl = null;
        this.hostInformation = {
          isMobile: false
        };
        this.premultipliedAlpha = true;
        this.onBeforeTextureInitObservable = new Observable();
        this._isWebGPU = false;
        this._snapshotRenderingMode = 0;
        this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
        this._unpackFlipYCached = null;
        this.enableUnpackFlipYCached = true;
        this._boundUniforms = {};
        var canvas = null;
        options = options || {};
        this._creationOptions = options;
        this._adaptToDeviceRatio = adaptToDeviceRatio !== null && adaptToDeviceRatio !== void 0 ? adaptToDeviceRatio : false;
        this._stencilStateComposer.stencilGlobal = this._stencilState;
        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
        if (!canvasOrContext) {
          return;
        }
        adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
        if (canvasOrContext.getContext) {
          canvas = canvasOrContext;
          this._renderingCanvas = canvas;
          if (antialias !== void 0) {
            options.antialias = antialias;
          }
          if (options.deterministicLockstep === void 0) {
            options.deterministicLockstep = false;
          }
          if (options.lockstepMaxSteps === void 0) {
            options.lockstepMaxSteps = 4;
          }
          if (options.timeStep === void 0) {
            options.timeStep = 1 / 60;
          }
          if (options.preserveDrawingBuffer === void 0) {
            options.preserveDrawingBuffer = false;
          }
          if (options.audioEngine === void 0) {
            options.audioEngine = true;
          }
          if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioContext !== void 0) {
            this._audioContext = options.audioEngineOptions.audioContext;
          }
          if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioDestination !== void 0) {
            this._audioDestination = options.audioEngineOptions.audioDestination;
          }
          if (options.stencil === void 0) {
            options.stencil = true;
          }
          if (options.premultipliedAlpha === false) {
            this.premultipliedAlpha = false;
          }
          if (options.xrCompatible === void 0) {
            options.xrCompatible = true;
          }
          this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false;
          if (navigator && navigator.userAgent) {
            this._checkForMobile = function() {
              var currentUA = navigator.userAgent;
              _this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
            };
            this._checkForMobile();
            if (IsWindowObjectExist()) {
              window.addEventListener("resize", this._checkForMobile);
            }
            var ua = navigator.userAgent;
            for (var _i = 0, _a = ThinEngine2.ExceptionList; _i < _a.length; _i++) {
              var exception = _a[_i];
              var key = exception.key;
              var targets = exception.targets;
              var check = new RegExp(key);
              if (check.test(ua)) {
                if (exception.capture && exception.captureConstraint) {
                  var capture = exception.capture;
                  var constraint = exception.captureConstraint;
                  var regex = new RegExp(capture);
                  var matches = regex.exec(ua);
                  if (matches && matches.length > 0) {
                    var capturedValue = parseInt(matches[matches.length - 1]);
                    if (capturedValue >= constraint) {
                      continue;
                    }
                  }
                }
                for (var _b = 0, targets_1 = targets; _b < targets_1.length; _b++) {
                  var target = targets_1[_b];
                  switch (target) {
                    case "uniformBuffer":
                      this.disableUniformBuffers = true;
                      break;
                    case "vao":
                      this.disableVertexArrayObjects = true;
                      break;
                  }
                }
              }
            }
          }
          if (!this._doNotHandleContextLost) {
            this._onContextLost = function(evt) {
              evt.preventDefault();
              _this._contextWasLost = true;
              Logger.Warn("WebGL context lost.");
              _this.onContextLostObservable.notifyObservers(_this);
            };
            this._onContextRestored = function() {
              _this._restoreEngineAfterContextLost(_this._initGLContext.bind(_this));
            };
            canvas.addEventListener("webglcontextlost", this._onContextLost, false);
            canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
            options.powerPreference = "high-performance";
          }
          this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          if (this._badDesktopOS) {
            options.xrCompatible = false;
          }
          if (!options.disableWebGL2Support) {
            try {
              this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
              if (this._gl) {
                this._webGLVersion = 2;
                this._shaderPlatformName = "WEBGL2";
                if (!this._gl.deleteQuery) {
                  this._webGLVersion = 1;
                  this._shaderPlatformName = "WEBGL1";
                }
              }
            } catch (e) {
            }
          }
          if (!this._gl) {
            if (!canvas) {
              throw new Error("The provided canvas is null or undefined.");
            }
            try {
              this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
            } catch (e) {
              throw new Error("WebGL not supported");
            }
          }
          if (!this._gl) {
            throw new Error("WebGL not supported");
          }
        } else {
          this._gl = canvasOrContext;
          this._renderingCanvas = this._gl.canvas;
          if (this._gl.renderbufferStorageMultisample) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
          } else {
            this._shaderPlatformName = "WEBGL1";
          }
          var attributes = this._gl.getContextAttributes();
          if (attributes) {
            options.stencil = attributes.stencil;
          }
        }
        this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
        if (options.useHighPrecisionFloats !== void 0) {
          this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
        }
        var devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
        var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
        this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
        this.resize();
        this._isStencilEnable = options.stencil ? true : false;
        this._initGLContext();
        this._initFeatures();
        for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
          this._currentBufferPointers[i] = new BufferPointer();
        }
        this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
        this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
        var versionToLog = "Babylon.js v".concat(ThinEngine2.Version);
        console.log(versionToLog + " - ".concat(this.description));
        if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
          this._renderingCanvas.setAttribute("data-engine", versionToLog);
        }
      }
      Object.defineProperty(ThinEngine2, "NpmPackage", {
        get: function() {
          return "babylonjs@5.5.0";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2, "Version", {
        get: function() {
          return "5.5.0";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "description", {
        get: function() {
          var description = this.name + this.webGLVersion;
          if (this._caps.parallelShaderCompile) {
            description += " - Parallel shader compilation";
          }
          return description;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "name", {
        get: function() {
          return this._name;
        },
        set: function(value) {
          this._name = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "version", {
        get: function() {
          return this._webGLVersion;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2, "ShadersRepository", {
        get: function() {
          return Effect.ShadersRepository;
        },
        set: function(value) {
          Effect.ShadersRepository = value;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype._getShaderProcessor = function(shaderLanguage) {
        return this._shaderProcessor;
      };
      Object.defineProperty(ThinEngine2.prototype, "useReverseDepthBuffer", {
        get: function() {
          return this._useReverseDepthBuffer;
        },
        set: function(useReverse) {
          if (useReverse === this._useReverseDepthBuffer) {
            return;
          }
          this._useReverseDepthBuffer = useReverse;
          if (useReverse) {
            this._depthCullingState.depthFunc = 518;
          } else {
            this._depthCullingState.depthFunc = 515;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "frameId", {
        get: function() {
          return this._frameId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "supportsUniformBuffers", {
        get: function() {
          return this.webGLVersion > 1 && !this.disableUniformBuffers;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype.getCreationOptions = function() {
        return this._creationOptions;
      };
      Object.defineProperty(ThinEngine2.prototype, "_shouldUseHighPrecisionShader", {
        get: function() {
          return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "needPOTTextures", {
        get: function() {
          return this._webGLVersion < 2 || this.forcePOTTextures;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "activeRenderLoops", {
        get: function() {
          return this._activeRenderLoops;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "doNotHandleContextLost", {
        get: function() {
          return this._doNotHandleContextLost;
        },
        set: function(value) {
          this._doNotHandleContextLost = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "_supportsHardwareTextureRescaling", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "framebufferDimensionsObject", {
        set: function(dimensions) {
          this._framebufferDimensionsObject = dimensions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "currentViewport", {
        get: function() {
          return this._cachedViewport;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "emptyTexture", {
        get: function() {
          if (!this._emptyTexture) {
            this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
          }
          return this._emptyTexture;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "emptyTexture3D", {
        get: function() {
          if (!this._emptyTexture3D) {
            this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
          }
          return this._emptyTexture3D;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "emptyTexture2DArray", {
        get: function() {
          if (!this._emptyTexture2DArray) {
            this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
          }
          return this._emptyTexture2DArray;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "emptyCubeTexture", {
        get: function() {
          if (!this._emptyCubeTexture) {
            var faceData = new Uint8Array(4);
            var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
            this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
          }
          return this._emptyCubeTexture;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "isWebGPU", {
        get: function() {
          return this._isWebGPU;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "shaderPlatformName", {
        get: function() {
          return this._shaderPlatformName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "snapshotRendering", {
        get: function() {
          return false;
        },
        set: function(activate) {
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "snapshotRenderingMode", {
        get: function() {
          return this._snapshotRenderingMode;
        },
        set: function(mode) {
          this._snapshotRenderingMode = mode;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype.snapshotRenderingReset = function() {
        this.snapshotRendering = false;
      };
      ThinEngine2._CreateCanvas = function(width, height) {
        if (typeof document === "undefined") {
          return new OffscreenCanvas(width, height);
        }
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      };
      ThinEngine2.prototype.createCanvas = function(width, height) {
        return ThinEngine2._CreateCanvas(width, height);
      };
      ThinEngine2.prototype.createCanvasImage = function() {
        return document.createElement("img");
      };
      ThinEngine2.prototype._restoreEngineAfterContextLost = function(initEngine) {
        var _this = this;
        setTimeout(function() {
          return __awaiter(_this, void 0, void 0, function() {
            var depthTest, depthFunc, depthMask, stencilTest;
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  this._dummyFramebuffer = null;
                  depthTest = this._depthCullingState.depthTest;
                  depthFunc = this._depthCullingState.depthFunc;
                  depthMask = this._depthCullingState.depthMask;
                  stencilTest = this._stencilState.stencilTest;
                  return [4, initEngine()];
                case 1:
                  _b.sent();
                  this._rebuildEffects();
                  (_a = this._rebuildComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
                  this._rebuildInternalTextures();
                  this._rebuildRenderTargetWrappers();
                  this._rebuildBuffers();
                  this.wipeCaches(true);
                  this._depthCullingState.depthTest = depthTest;
                  this._depthCullingState.depthFunc = depthFunc;
                  this._depthCullingState.depthMask = depthMask;
                  this._stencilState.stencilTest = stencilTest;
                  Logger.Warn(this.name + " context successfully restored.");
                  this.onContextRestoredObservable.notifyObservers(this);
                  this._contextWasLost = false;
                  return [2];
              }
            });
          });
        }, 0);
      };
      ThinEngine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
        this._renderingCanvas = canvas;
      };
      ThinEngine2.prototype._getShaderProcessingContext = function(shaderLanguage) {
        return null;
      };
      ThinEngine2.prototype._rebuildInternalTextures = function() {
        var currentState = this._internalTexturesCache.slice();
        for (var _i = 0, currentState_1 = currentState; _i < currentState_1.length; _i++) {
          var internalTexture = currentState_1[_i];
          internalTexture._rebuild();
        }
      };
      ThinEngine2.prototype._rebuildRenderTargetWrappers = function() {
        var currentState = this._renderTargetWrapperCache.slice();
        for (var _i = 0, currentState_2 = currentState; _i < currentState_2.length; _i++) {
          var renderTargetWrapper = currentState_2[_i];
          renderTargetWrapper._rebuild();
        }
      };
      ThinEngine2.prototype._rebuildEffects = function() {
        for (var key in this._compiledEffects) {
          var effect = this._compiledEffects[key];
          effect._pipelineContext = null;
          effect._wasPreviouslyReady = false;
          effect._prepareEffect();
        }
        Effect.ResetCache();
      };
      ThinEngine2.prototype.areAllEffectsReady = function() {
        for (var key in this._compiledEffects) {
          var effect = this._compiledEffects[key];
          if (!effect.isReady()) {
            return false;
          }
        }
        return true;
      };
      ThinEngine2.prototype._rebuildBuffers = function() {
        for (var _i = 0, _a = this._uniformBuffers; _i < _a.length; _i++) {
          var uniformBuffer = _a[_i];
          uniformBuffer._rebuild();
        }
        for (var _b = 0, _c = this._storageBuffers; _b < _c.length; _b++) {
          var storageBuffer = _c[_b];
          storageBuffer._rebuild();
        }
      };
      ThinEngine2.prototype._initGLContext = function() {
        this._caps = {
          maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
          maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
          maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
          maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
          maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
          maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
          maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
          maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
          parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
          standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
          maxAnisotropy: 1,
          astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
          bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
          s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
          s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
          pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
          etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
          textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
          uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
          fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
          highPrecisionShaderSupported: false,
          timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
          supportOcclusionQuery: this._webGLVersion > 1,
          canUseTimestampForTimerQuery: false,
          drawBuffersExtension: false,
          maxMSAASamples: 1,
          colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
          textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
          textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
          textureHalfFloatRender: false,
          textureFloatLinearFiltering: false,
          textureFloatRender: false,
          textureHalfFloatLinearFiltering: false,
          vertexArrayObject: false,
          instancedArrays: false,
          textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
          blendMinMax: false,
          multiview: this._gl.getExtension("OVR_multiview2"),
          oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
          depthTextureExtension: false,
          canUseGLInstanceID: this._webGLVersion > 1,
          canUseGLVertexID: this._webGLVersion > 1,
          supportComputeShaders: false,
          supportSRGBBuffers: false,
          supportTransformFeedbacks: this._webGLVersion > 1,
          textureMaxLevel: this._webGLVersion > 1
        };
        this._glVersion = this._gl.getParameter(this._gl.VERSION);
        var rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
        if (rendererInfo != null) {
          this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
          this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
        }
        if (!this._glVendor) {
          this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
        }
        if (!this._glRenderer) {
          this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
        }
        if (this._gl.HALF_FLOAT_OES !== 36193) {
          this._gl.HALF_FLOAT_OES = 36193;
        }
        if (this._gl.RGBA16F !== 34842) {
          this._gl.RGBA16F = 34842;
        }
        if (this._gl.RGBA32F !== 34836) {
          this._gl.RGBA32F = 34836;
        }
        if (this._gl.DEPTH24_STENCIL8 !== 35056) {
          this._gl.DEPTH24_STENCIL8 = 35056;
        }
        if (this._caps.timerQuery) {
          if (this._webGLVersion === 1) {
            this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
          }
          this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0;
        }
        this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
        this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
        this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
        if (this._caps.astc) {
          this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
        }
        if (this._caps.bptc) {
          this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
        }
        if (this._caps.s3tc_srgb) {
          this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        }
        if (this._webGLVersion > 1) {
          if (this._gl.HALF_FLOAT_OES !== 5131) {
            this._gl.HALF_FLOAT_OES = 5131;
          }
        }
        this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
        if (this._webGLVersion > 1) {
          this._caps.drawBuffersExtension = true;
          this._caps.maxMSAASamples = this._gl.getParameter(this._gl.MAX_SAMPLES);
        } else {
          var drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
          if (drawBuffersExtension !== null) {
            this._caps.drawBuffersExtension = true;
            this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
            this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
            for (var i = 0; i < 16; i++) {
              this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
            }
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.depthTextureExtension = true;
        } else {
          var depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
          if (depthTextureExtension != null) {
            this._caps.depthTextureExtension = true;
            this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
          }
        }
        if (this.disableVertexArrayObjects) {
          this._caps.vertexArrayObject = false;
        } else if (this._webGLVersion > 1) {
          this._caps.vertexArrayObject = true;
        } else {
          var vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
          if (vertexArrayObjectExtension != null) {
            this._caps.vertexArrayObject = true;
            this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
            this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
            this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.instancedArrays = true;
        } else {
          var instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExtension != null) {
            this._caps.instancedArrays = true;
            this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
            this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
            this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
          } else {
            this._caps.instancedArrays = false;
          }
        }
        if (this._gl.getShaderPrecisionFormat) {
          var vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
          var fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
          if (vertexhighp && fragmenthighp) {
            this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.blendMinMax = true;
        } else {
          var blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
          if (blendMinMaxExtension != null) {
            this._caps.blendMinMax = true;
            this._gl.MAX = blendMinMaxExtension.MAX_EXT;
            this._gl.MIN = blendMinMaxExtension.MIN_EXT;
          }
        }
        if (!this._caps.supportSRGBBuffers) {
          if (this._webGLVersion > 1) {
            this._caps.supportSRGBBuffers = true;
          } else {
            var sRGBExtension = this._gl.getExtension("EXT_sRGB");
            if (sRGBExtension != null) {
              this._caps.supportSRGBBuffers = true;
              this._gl.SRGB = sRGBExtension.SRGB_EXT;
              this._gl.SRGB8 = sRGBExtension.SRGB_ALPHA_EXT;
              this._gl.SRGB8_ALPHA8 = sRGBExtension.SRGB_ALPHA_EXT;
            }
          }
          this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
        }
        this._depthCullingState.depthTest = true;
        this._depthCullingState.depthFunc = this._gl.LEQUAL;
        this._depthCullingState.depthMask = true;
        this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
        for (var slot = 0; slot < this._maxSimultaneousTextures; slot++) {
          this._nextFreeTextureSlots.push(slot);
        }
      };
      ThinEngine2.prototype._initFeatures = function() {
        this._features = {
          forceBitmapOverHTMLImageElement: false,
          supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
          supportDepthStencilTexture: this._webGLVersion !== 1,
          supportShadowSamplers: this._webGLVersion !== 1,
          uniformBufferHardCheckMatrix: false,
          allowTexturePrefiltering: this._webGLVersion !== 1,
          trackUbosInFrame: false,
          checkUbosContentBeforeUpload: false,
          supportCSM: this._webGLVersion !== 1,
          basisNeedsPOT: this._webGLVersion === 1,
          support3DTextures: this._webGLVersion !== 1,
          needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
          supportMSAA: this._webGLVersion !== 1,
          supportSSAO2: this._webGLVersion !== 1,
          supportExtendedTextureFormats: this._webGLVersion !== 1,
          supportSwitchCaseInShader: this._webGLVersion !== 1,
          supportSyncTextureRead: true,
          needsInvertingBitmap: true,
          useUBOBindingCache: true,
          needShaderCodeInlining: false,
          needToAlwaysBindUniformBuffers: false,
          supportRenderPasses: false,
          _collectUbosUpdatedInFrame: false
        };
      };
      Object.defineProperty(ThinEngine2.prototype, "webGLVersion", {
        get: function() {
          return this._webGLVersion;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype.getClassName = function() {
        return "ThinEngine";
      };
      Object.defineProperty(ThinEngine2.prototype, "isStencilEnable", {
        get: function() {
          return this._isStencilEnable;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype._prepareWorkingCanvas = function() {
        if (this._workingCanvas) {
          return;
        }
        this._workingCanvas = this.createCanvas(1, 1);
        var context = this._workingCanvas.getContext("2d");
        if (context) {
          this._workingContext = context;
        }
      };
      ThinEngine2.prototype.resetTextureCache = function() {
        for (var key in this._boundTexturesCache) {
          if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {
            continue;
          }
          this._boundTexturesCache[key] = null;
        }
        this._currentTextureChannel = -1;
      };
      ThinEngine2.prototype.getInfo = function() {
        return this.getGlInfo();
      };
      ThinEngine2.prototype.getGlInfo = function() {
        return {
          vendor: this._glVendor,
          renderer: this._glRenderer,
          version: this._glVersion
        };
      };
      ThinEngine2.prototype.setHardwareScalingLevel = function(level) {
        this._hardwareScalingLevel = level;
        this.resize();
      };
      ThinEngine2.prototype.getHardwareScalingLevel = function() {
        return this._hardwareScalingLevel;
      };
      ThinEngine2.prototype.getLoadedTexturesCache = function() {
        return this._internalTexturesCache;
      };
      ThinEngine2.prototype.getCaps = function() {
        return this._caps;
      };
      ThinEngine2.prototype.stopRenderLoop = function(renderFunction) {
        if (!renderFunction) {
          this._activeRenderLoops = [];
          return;
        }
        var index = this._activeRenderLoops.indexOf(renderFunction);
        if (index >= 0) {
          this._activeRenderLoops.splice(index, 1);
        }
      };
      ThinEngine2.prototype._renderLoop = function() {
        if (!this._contextWasLost) {
          var shouldRender = true;
          if (!this.renderEvenInBackground && this._windowIsBackground) {
            shouldRender = false;
          }
          if (shouldRender) {
            this.beginFrame();
            for (var index = 0; index < this._activeRenderLoops.length; index++) {
              var renderFunction = this._activeRenderLoops[index];
              renderFunction();
            }
            this.endFrame();
          }
        }
        if (this._activeRenderLoops.length > 0) {
          this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
        } else {
          this._renderingQueueLaunched = false;
        }
      };
      ThinEngine2.prototype.getRenderingCanvas = function() {
        return this._renderingCanvas;
      };
      ThinEngine2.prototype.getAudioContext = function() {
        return this._audioContext;
      };
      ThinEngine2.prototype.getAudioDestination = function() {
        return this._audioDestination;
      };
      ThinEngine2.prototype.getHostWindow = function() {
        if (!IsWindowObjectExist()) {
          return null;
        }
        if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
          return this._renderingCanvas.ownerDocument.defaultView;
        }
        return window;
      };
      ThinEngine2.prototype.getRenderWidth = function(useScreen) {
        if (useScreen === void 0) {
          useScreen = false;
        }
        if (!useScreen && this._currentRenderTarget) {
          return this._currentRenderTarget.width;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
      };
      ThinEngine2.prototype.getRenderHeight = function(useScreen) {
        if (useScreen === void 0) {
          useScreen = false;
        }
        if (!useScreen && this._currentRenderTarget) {
          return this._currentRenderTarget.height;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
      };
      ThinEngine2.prototype._queueNewFrame = function(bindedRenderFunction, requester) {
        return ThinEngine2.QueueNewFrame(bindedRenderFunction, requester);
      };
      ThinEngine2.prototype.runRenderLoop = function(renderFunction) {
        if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
          return;
        }
        this._activeRenderLoops.push(renderFunction);
        if (!this._renderingQueueLaunched) {
          this._renderingQueueLaunched = true;
          this._boundRenderFunction = this._renderLoop.bind(this);
          this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
        }
      };
      ThinEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
        if (stencil === void 0) {
          stencil = false;
        }
        var useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
        this.stencilStateComposer.useStencilGlobalOnly = true;
        this.applyStates();
        this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
        var mode = 0;
        if (backBuffer && color) {
          this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
          mode |= this._gl.COLOR_BUFFER_BIT;
        }
        if (depth) {
          if (this.useReverseDepthBuffer) {
            this._depthCullingState.depthFunc = this._gl.GEQUAL;
            this._gl.clearDepth(0);
          } else {
            this._gl.clearDepth(1);
          }
          mode |= this._gl.DEPTH_BUFFER_BIT;
        }
        if (stencil) {
          this._gl.clearStencil(0);
          mode |= this._gl.STENCIL_BUFFER_BIT;
        }
        this._gl.clear(mode);
      };
      ThinEngine2.prototype._viewport = function(x, y, width, height) {
        if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
          this._viewportCached.x = x;
          this._viewportCached.y = y;
          this._viewportCached.z = width;
          this._viewportCached.w = height;
          this._gl.viewport(x, y, width, height);
        }
      };
      ThinEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
        var width = requiredWidth || this.getRenderWidth();
        var height = requiredHeight || this.getRenderHeight();
        var x = viewport.x || 0;
        var y = viewport.y || 0;
        this._cachedViewport = viewport;
        this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
      };
      ThinEngine2.prototype.beginFrame = function() {
      };
      ThinEngine2.prototype.endFrame = function() {
        if (this._badOS) {
          this.flushFramebuffer();
        }
        this._frameId++;
      };
      ThinEngine2.prototype.resize = function(forceSetSize) {
        if (forceSetSize === void 0) {
          forceSetSize = false;
        }
        var width;
        var height;
        if (this._adaptToDeviceRatio) {
          var devicePixelRatio_1 = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
          var limitDeviceRatio = this._creationOptions.limitDeviceRatio || devicePixelRatio_1;
          this._hardwareScalingLevel = this._adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio_1) : 1;
        }
        if (IsWindowObjectExist()) {
          width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;
          height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;
        } else {
          width = this._renderingCanvas ? this._renderingCanvas.width : 100;
          height = this._renderingCanvas ? this._renderingCanvas.height : 100;
        }
        this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
      };
      ThinEngine2.prototype.setSize = function(width, height, forceSetSize) {
        if (forceSetSize === void 0) {
          forceSetSize = false;
        }
        if (!this._renderingCanvas) {
          return false;
        }
        width = width | 0;
        height = height | 0;
        if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
          return false;
        }
        this._renderingCanvas.width = width;
        this._renderingCanvas.height = height;
        return true;
      };
      ThinEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {
        var _a, _b, _c, _d, _e;
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lodLevel === void 0) {
          lodLevel = 0;
        }
        if (layer === void 0) {
          layer = 0;
        }
        var webglRTWrapper = texture;
        if (this._currentRenderTarget) {
          this.unBindFramebuffer(this._currentRenderTarget);
        }
        this._currentRenderTarget = texture;
        this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
        var gl = this._gl;
        if (texture.is2DArray) {
          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a = texture.texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, lodLevel, layer);
        } else if (texture.isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b = texture.texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, lodLevel);
        }
        var depthStencilTexture = texture._depthStencilTexture;
        if (depthStencilTexture) {
          var attachment = texture._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          if (texture.is2DArray) {
            gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_c = depthStencilTexture._hardwareTexture) === null || _c === void 0 ? void 0 : _c.underlyingResource, lodLevel, layer);
          } else if (texture.isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_d = depthStencilTexture._hardwareTexture) === null || _d === void 0 ? void 0 : _d.underlyingResource, lodLevel);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_e = depthStencilTexture._hardwareTexture) === null || _e === void 0 ? void 0 : _e.underlyingResource, lodLevel);
          }
        }
        if (this._cachedViewport && !forceFullscreenViewport) {
          this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
        } else {
          if (!requiredWidth) {
            requiredWidth = texture.width;
            if (lodLevel) {
              requiredWidth = requiredWidth / Math.pow(2, lodLevel);
            }
          }
          if (!requiredHeight) {
            requiredHeight = texture.height;
            if (lodLevel) {
              requiredHeight = requiredHeight / Math.pow(2, lodLevel);
            }
          }
          this._viewport(0, 0, requiredWidth, requiredHeight);
        }
        this.wipeCaches();
      };
      ThinEngine2.prototype.setState = function(culling, zOffset, force, reverseSide, cullBackFaces, stencil, zOffsetUnits) {
        var _a, _b;
        if (zOffset === void 0) {
          zOffset = 0;
        }
        if (reverseSide === void 0) {
          reverseSide = false;
        }
        if (zOffsetUnits === void 0) {
          zOffsetUnits = 0;
        }
        if (this._depthCullingState.cull !== culling || force) {
          this._depthCullingState.cull = culling;
        }
        var cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? this._gl.BACK : this._gl.FRONT;
        if (this._depthCullingState.cullFace !== cullFace || force) {
          this._depthCullingState.cullFace = cullFace;
        }
        this.setZOffset(zOffset);
        this.setZOffsetUnits(zOffsetUnits);
        var frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
        if (this._depthCullingState.frontFace !== frontFace || force) {
          this._depthCullingState.frontFace = frontFace;
        }
        this._stencilStateComposer.stencilMaterial = stencil;
      };
      ThinEngine2.prototype.setZOffset = function(value) {
        this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
      };
      ThinEngine2.prototype.getZOffset = function() {
        var zOffset = this._depthCullingState.zOffset;
        return this.useReverseDepthBuffer ? -zOffset : zOffset;
      };
      ThinEngine2.prototype.setZOffsetUnits = function(value) {
        this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
      };
      ThinEngine2.prototype.getZOffsetUnits = function() {
        var zOffsetUnits = this._depthCullingState.zOffsetUnits;
        return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
      };
      ThinEngine2.prototype._bindUnboundFramebuffer = function(framebuffer) {
        if (this._currentFramebuffer !== framebuffer) {
          this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
          this._currentFramebuffer = framebuffer;
        }
      };
      ThinEngine2.prototype._currentFrameBufferIsDefaultFrameBuffer = function() {
        return this._currentFramebuffer === null;
      };
      ThinEngine2.prototype.generateMipmaps = function(texture) {
        this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      };
      ThinEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
        var _a;
        if (disableGenerateMipMaps === void 0) {
          disableGenerateMipMaps = false;
        }
        var webglRTWrapper = texture;
        this._currentRenderTarget = null;
        var gl = this._gl;
        if (webglRTWrapper._MSAAFramebuffer) {
          if (texture.isMulti) {
            this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
            return;
          }
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
          gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        }
        if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
          this.generateMipmaps(texture.texture);
        }
        if (onBeforeUnbind) {
          if (webglRTWrapper._MSAAFramebuffer) {
            this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
          }
          onBeforeUnbind();
        }
        this._bindUnboundFramebuffer(null);
      };
      ThinEngine2.prototype.flushFramebuffer = function() {
        this._gl.flush();
      };
      ThinEngine2.prototype.restoreDefaultFramebuffer = function() {
        if (this._currentRenderTarget) {
          this.unBindFramebuffer(this._currentRenderTarget);
        } else {
          this._bindUnboundFramebuffer(null);
        }
        if (this._cachedViewport) {
          this.setViewport(this._cachedViewport);
        }
        this.wipeCaches();
      };
      ThinEngine2.prototype._resetVertexBufferBinding = function() {
        this.bindArrayBuffer(null);
        this._cachedVertexBuffers = null;
      };
      ThinEngine2.prototype.createVertexBuffer = function(data) {
        return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
      };
      ThinEngine2.prototype._createVertexBuffer = function(data, usage) {
        var vbo = this._gl.createBuffer();
        if (!vbo) {
          throw new Error("Unable to create vertex buffer");
        }
        var dataBuffer = new WebGLDataBuffer(vbo);
        this.bindArrayBuffer(dataBuffer);
        if (data instanceof Array) {
          this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
        } else {
          this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
        }
        this._resetVertexBufferBinding();
        dataBuffer.references = 1;
        return dataBuffer;
      };
      ThinEngine2.prototype.createDynamicVertexBuffer = function(data) {
        return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
      };
      ThinEngine2.prototype._resetIndexBufferBinding = function() {
        this.bindIndexBuffer(null);
        this._cachedIndexBuffer = null;
      };
      ThinEngine2.prototype.createIndexBuffer = function(indices, updatable) {
        var vbo = this._gl.createBuffer();
        var dataBuffer = new WebGLDataBuffer(vbo);
        if (!vbo) {
          throw new Error("Unable to create index buffer");
        }
        this.bindIndexBuffer(dataBuffer);
        var data = this._normalizeIndexData(indices);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
        this._resetIndexBufferBinding();
        dataBuffer.references = 1;
        dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
        return dataBuffer;
      };
      ThinEngine2.prototype._normalizeIndexData = function(indices) {
        var bytesPerElement = indices.BYTES_PER_ELEMENT;
        if (bytesPerElement === 2) {
          return indices;
        }
        if (this._caps.uintIndices) {
          if (indices instanceof Uint32Array) {
            return indices;
          } else {
            for (var index = 0; index < indices.length; index++) {
              if (indices[index] >= 65535) {
                return new Uint32Array(indices);
              }
            }
            return new Uint16Array(indices);
          }
        }
        return new Uint16Array(indices);
      };
      ThinEngine2.prototype.bindArrayBuffer = function(buffer) {
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
      };
      ThinEngine2.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
        var program = pipelineContext.program;
        var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
        this._gl.uniformBlockBinding(program, uniformLocation, index);
      };
      ThinEngine2.prototype.bindIndexBuffer = function(buffer) {
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
      };
      ThinEngine2.prototype._bindBuffer = function(buffer, target) {
        if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
          this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
          this._currentBoundBuffer[target] = buffer;
        }
      };
      ThinEngine2.prototype.updateArrayBuffer = function(data) {
        this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
      };
      ThinEngine2.prototype._vertexAttribPointer = function(buffer, indx, size, type, normalized, stride, offset) {
        var pointer = this._currentBufferPointers[indx];
        if (!pointer) {
          return;
        }
        var changed = false;
        if (!pointer.active) {
          changed = true;
          pointer.active = true;
          pointer.index = indx;
          pointer.size = size;
          pointer.type = type;
          pointer.normalized = normalized;
          pointer.stride = stride;
          pointer.offset = offset;
          pointer.buffer = buffer;
        } else {
          if (pointer.buffer !== buffer) {
            pointer.buffer = buffer;
            changed = true;
          }
          if (pointer.size !== size) {
            pointer.size = size;
            changed = true;
          }
          if (pointer.type !== type) {
            pointer.type = type;
            changed = true;
          }
          if (pointer.normalized !== normalized) {
            pointer.normalized = normalized;
            changed = true;
          }
          if (pointer.stride !== stride) {
            pointer.stride = stride;
            changed = true;
          }
          if (pointer.offset !== offset) {
            pointer.offset = offset;
            changed = true;
          }
        }
        if (changed || this._vaoRecordInProgress) {
          this.bindArrayBuffer(buffer);
          this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
        }
      };
      ThinEngine2.prototype._bindIndexBufferWithCache = function(indexBuffer) {
        if (indexBuffer == null) {
          return;
        }
        if (this._cachedIndexBuffer !== indexBuffer) {
          this._cachedIndexBuffer = indexBuffer;
          this.bindIndexBuffer(indexBuffer);
          this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
        }
      };
      ThinEngine2.prototype._bindVertexBuffersAttributes = function(vertexBuffers, effect, overrideVertexBuffers) {
        var attributes = effect.getAttributesNames();
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this.unbindAllAttributes();
        for (var index = 0; index < attributes.length; index++) {
          var order = effect.getAttributeLocation(index);
          if (order >= 0) {
            var ai = attributes[index];
            var vertexBuffer = null;
            if (overrideVertexBuffers) {
              vertexBuffer = overrideVertexBuffers[ai];
            }
            if (!vertexBuffer) {
              vertexBuffer = vertexBuffers[ai];
            }
            if (!vertexBuffer) {
              continue;
            }
            this._gl.enableVertexAttribArray(order);
            if (!this._vaoRecordInProgress) {
              this._vertexAttribArraysEnabled[order] = true;
            }
            var buffer = vertexBuffer.getBuffer();
            if (buffer) {
              this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
              if (vertexBuffer.getIsInstanced()) {
                this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
                if (!this._vaoRecordInProgress) {
                  this._currentInstanceLocations.push(order);
                  this._currentInstanceBuffers.push(buffer);
                }
              }
            }
          }
        }
      };
      ThinEngine2.prototype.recordVertexArrayObject = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        var vao = this._gl.createVertexArray();
        this._vaoRecordInProgress = true;
        this._gl.bindVertexArray(vao);
        this._mustWipeVertexAttributes = true;
        this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        this.bindIndexBuffer(indexBuffer);
        this._vaoRecordInProgress = false;
        this._gl.bindVertexArray(null);
        return vao;
      };
      ThinEngine2.prototype.bindVertexArrayObject = function(vertexArrayObject, indexBuffer) {
        if (this._cachedVertexArrayObject !== vertexArrayObject) {
          this._cachedVertexArrayObject = vertexArrayObject;
          this._gl.bindVertexArray(vertexArrayObject);
          this._cachedVertexBuffers = null;
          this._cachedIndexBuffer = null;
          this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
          this._mustWipeVertexAttributes = true;
        }
      };
      ThinEngine2.prototype.bindBuffersDirectly = function(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
        if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
          this._cachedVertexBuffers = vertexBuffer;
          this._cachedEffectForVertexBuffers = effect;
          var attributesCount = effect.getAttributesCount();
          this._unbindVertexArrayObject();
          this.unbindAllAttributes();
          var offset = 0;
          for (var index = 0; index < attributesCount; index++) {
            if (index < vertexDeclaration.length) {
              var order = effect.getAttributeLocation(index);
              if (order >= 0) {
                this._gl.enableVertexAttribArray(order);
                this._vertexAttribArraysEnabled[order] = true;
                this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
              }
              offset += vertexDeclaration[index] * 4;
            }
          }
        }
        this._bindIndexBufferWithCache(indexBuffer);
      };
      ThinEngine2.prototype._unbindVertexArrayObject = function() {
        if (!this._cachedVertexArrayObject) {
          return;
        }
        this._cachedVertexArrayObject = null;
        this._gl.bindVertexArray(null);
      };
      ThinEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
          this._cachedVertexBuffers = vertexBuffers;
          this._cachedEffectForVertexBuffers = effect;
          this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        }
        this._bindIndexBufferWithCache(indexBuffer);
      };
      ThinEngine2.prototype.unbindInstanceAttributes = function() {
        var boundBuffer;
        for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
          var instancesBuffer = this._currentInstanceBuffers[i];
          if (boundBuffer != instancesBuffer && instancesBuffer.references) {
            boundBuffer = instancesBuffer;
            this.bindArrayBuffer(instancesBuffer);
          }
          var offsetLocation = this._currentInstanceLocations[i];
          this._gl.vertexAttribDivisor(offsetLocation, 0);
        }
        this._currentInstanceBuffers.length = 0;
        this._currentInstanceLocations.length = 0;
      };
      ThinEngine2.prototype.releaseVertexArrayObject = function(vao) {
        this._gl.deleteVertexArray(vao);
      };
      ThinEngine2.prototype._releaseBuffer = function(buffer) {
        buffer.references--;
        if (buffer.references === 0) {
          this._deleteBuffer(buffer);
          return true;
        }
        return false;
      };
      ThinEngine2.prototype._deleteBuffer = function(buffer) {
        this._gl.deleteBuffer(buffer.underlyingResource);
      };
      ThinEngine2.prototype.updateAndBindInstancesBuffer = function(instancesBuffer, data, offsetLocations) {
        this.bindArrayBuffer(instancesBuffer);
        if (data) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
        }
        if (offsetLocations[0].index !== void 0) {
          this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
        } else {
          for (var index = 0; index < 4; index++) {
            var offsetLocation = offsetLocations[index];
            if (!this._vertexAttribArraysEnabled[offsetLocation]) {
              this._gl.enableVertexAttribArray(offsetLocation);
              this._vertexAttribArraysEnabled[offsetLocation] = true;
            }
            this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
            this._gl.vertexAttribDivisor(offsetLocation, 1);
            this._currentInstanceLocations.push(offsetLocation);
            this._currentInstanceBuffers.push(instancesBuffer);
          }
        }
      };
      ThinEngine2.prototype.bindInstancesBuffer = function(instancesBuffer, attributesInfo, computeStride) {
        if (computeStride === void 0) {
          computeStride = true;
        }
        this.bindArrayBuffer(instancesBuffer);
        var stride = 0;
        if (computeStride) {
          for (var i = 0; i < attributesInfo.length; i++) {
            var ai = attributesInfo[i];
            stride += ai.attributeSize * 4;
          }
        }
        for (var i = 0; i < attributesInfo.length; i++) {
          var ai = attributesInfo[i];
          if (ai.index === void 0) {
            ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
          }
          if (ai.index < 0) {
            continue;
          }
          if (!this._vertexAttribArraysEnabled[ai.index]) {
            this._gl.enableVertexAttribArray(ai.index);
            this._vertexAttribArraysEnabled[ai.index] = true;
          }
          this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
          this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
          this._currentInstanceLocations.push(ai.index);
          this._currentInstanceBuffers.push(instancesBuffer);
        }
      };
      ThinEngine2.prototype.disableInstanceAttributeByName = function(name) {
        if (!this._currentEffect) {
          return;
        }
        var attributeLocation = this._currentEffect.getAttributeLocationByName(name);
        this.disableInstanceAttribute(attributeLocation);
      };
      ThinEngine2.prototype.disableInstanceAttribute = function(attributeLocation) {
        var shouldClean = false;
        var index;
        while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
          this._currentInstanceLocations.splice(index, 1);
          this._currentInstanceBuffers.splice(index, 1);
          shouldClean = true;
          index = this._currentInstanceLocations.indexOf(attributeLocation);
        }
        if (shouldClean) {
          this._gl.vertexAttribDivisor(attributeLocation, 0);
          this.disableAttributeByIndex(attributeLocation);
        }
      };
      ThinEngine2.prototype.disableAttributeByIndex = function(attributeLocation) {
        this._gl.disableVertexAttribArray(attributeLocation);
        this._vertexAttribArraysEnabled[attributeLocation] = false;
        this._currentBufferPointers[attributeLocation].active = false;
      };
      ThinEngine2.prototype.draw = function(useTriangles, indexStart, indexCount, instancesCount) {
        this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
      };
      ThinEngine2.prototype.drawPointClouds = function(verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
      };
      ThinEngine2.prototype.drawUnIndexed = function(useTriangles, verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
      };
      ThinEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
        this.applyStates();
        this._reportDrawCall();
        var drawMode = this._drawMode(fillMode);
        var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
        var mult = this._uintIndicesCurrentlySet ? 4 : 2;
        if (instancesCount) {
          this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
        } else {
          this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
        }
      };
      ThinEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
        this.applyStates();
        this._reportDrawCall();
        var drawMode = this._drawMode(fillMode);
        if (instancesCount) {
          this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
        } else {
          this._gl.drawArrays(drawMode, verticesStart, verticesCount);
        }
      };
      ThinEngine2.prototype._drawMode = function(fillMode) {
        switch (fillMode) {
          case 0:
            return this._gl.TRIANGLES;
          case 2:
            return this._gl.POINTS;
          case 1:
            return this._gl.LINES;
          case 3:
            return this._gl.POINTS;
          case 4:
            return this._gl.LINES;
          case 5:
            return this._gl.LINE_LOOP;
          case 6:
            return this._gl.LINE_STRIP;
          case 7:
            return this._gl.TRIANGLE_STRIP;
          case 8:
            return this._gl.TRIANGLE_FAN;
          default:
            return this._gl.TRIANGLES;
        }
      };
      ThinEngine2.prototype._reportDrawCall = function() {
      };
      ThinEngine2.prototype._releaseEffect = function(effect) {
        if (this._compiledEffects[effect._key]) {
          delete this._compiledEffects[effect._key];
          var pipelineContext = effect.getPipelineContext();
          if (pipelineContext) {
            this._deletePipelineContext(pipelineContext);
          }
        }
      };
      ThinEngine2.prototype._deletePipelineContext = function(pipelineContext) {
        var webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
          webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
          this._gl.deleteProgram(webGLPipelineContext.program);
        }
      };
      ThinEngine2.prototype._getGlobalDefines = function(defines) {
        if (defines) {
          if (this.isNDCHalfZRange) {
            defines["IS_NDC_HALF_ZRANGE"] = "";
          } else {
            delete defines["IS_NDC_HALF_ZRANGE"];
          }
          if (this.useReverseDepthBuffer) {
            defines["USE_REVERSE_DEPTHBUFFER"] = "";
          } else {
            delete defines["USE_REVERSE_DEPTHBUFFER"];
          }
          return;
        } else {
          var s = "";
          if (this.isNDCHalfZRange) {
            s += "#define IS_NDC_HALF_ZRANGE";
          }
          if (this.useReverseDepthBuffer) {
            if (s) {
              s += "\n";
            }
            s += "#define USE_REVERSE_DEPTHBUFFER";
          }
          return s;
        }
      };
      ThinEngine2.prototype.createEffect = function(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage) {
        var _a;
        if (shaderLanguage === void 0) {
          shaderLanguage = ShaderLanguage.GLSL;
        }
        var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
        var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
        var globalDefines = this._getGlobalDefines();
        var fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : "";
        if (globalDefines) {
          fullDefines += globalDefines;
        }
        var name = vertex + "+" + fragment + "@" + fullDefines;
        if (this._compiledEffects[name]) {
          var compiledEffect = this._compiledEffects[name];
          if (onCompiled && compiledEffect.isReady()) {
            onCompiled(compiledEffect);
          }
          return compiledEffect;
        }
        var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);
        this._compiledEffects[name] = effect;
        return effect;
      };
      ThinEngine2._ConcatenateShader = function(source, defines, shaderVersion) {
        if (shaderVersion === void 0) {
          shaderVersion = "";
        }
        return shaderVersion + (defines ? defines + "\n" : "") + source;
      };
      ThinEngine2.prototype._compileShader = function(source, type, defines, shaderVersion) {
        return this._compileRawShader(ThinEngine2._ConcatenateShader(source, defines, shaderVersion), type);
      };
      ThinEngine2.prototype._compileRawShader = function(source, type) {
        var gl = this._gl;
        var shader = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        if (!shader) {
          var error = gl.NO_ERROR;
          var tempError = gl.NO_ERROR;
          while ((tempError = gl.getError()) !== gl.NO_ERROR) {
            error = tempError;
          }
          throw new Error("Something went wrong while creating a gl ".concat(type, " shader object. gl error=").concat(error, ", gl isContextLost=").concat(gl.isContextLost(), ", _contextWasLost=").concat(this._contextWasLost));
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      };
      ThinEngine2.prototype._getShaderSource = function(shader) {
        return this._gl.getShaderSource(shader);
      };
      ThinEngine2.prototype.createRawShaderProgram = function(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) {
          transformFeedbackVaryings = null;
        }
        context = context || this._gl;
        var vertexShader = this._compileRawShader(vertexCode, "vertex");
        var fragmentShader = this._compileRawShader(fragmentCode, "fragment");
        return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
      };
      ThinEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) {
          transformFeedbackVaryings = null;
        }
        context = context || this._gl;
        var shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
        var vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
        var fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
        return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
      };
      ThinEngine2.prototype.inlineShaderCode = function(code) {
        return code;
      };
      ThinEngine2.prototype.createPipelineContext = function(shaderProcessingContext) {
        var pipelineContext = new WebGLPipelineContext();
        pipelineContext.engine = this;
        if (this._caps.parallelShaderCompile) {
          pipelineContext.isParallelCompiled = true;
        }
        return pipelineContext;
      };
      ThinEngine2.prototype.createMaterialContext = function() {
        return void 0;
      };
      ThinEngine2.prototype.createDrawContext = function() {
        return void 0;
      };
      ThinEngine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) {
          transformFeedbackVaryings = null;
        }
        var shaderProgram = context.createProgram();
        pipelineContext.program = shaderProgram;
        if (!shaderProgram) {
          throw new Error("Unable to create program");
        }
        context.attachShader(shaderProgram, vertexShader);
        context.attachShader(shaderProgram, fragmentShader);
        context.linkProgram(shaderProgram);
        pipelineContext.context = context;
        pipelineContext.vertexShader = vertexShader;
        pipelineContext.fragmentShader = fragmentShader;
        if (!pipelineContext.isParallelCompiled) {
          this._finalizePipelineContext(pipelineContext);
        }
        return shaderProgram;
      };
      ThinEngine2.prototype._finalizePipelineContext = function(pipelineContext) {
        var context = pipelineContext.context;
        var vertexShader = pipelineContext.vertexShader;
        var fragmentShader = pipelineContext.fragmentShader;
        var program = pipelineContext.program;
        var linked = context.getProgramParameter(program, context.LINK_STATUS);
        if (!linked) {
          if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
            var log = this._gl.getShaderInfoLog(vertexShader);
            if (log) {
              pipelineContext.vertexCompilationError = log;
              throw new Error("VERTEX SHADER " + log);
            }
          }
          if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
            var log = this._gl.getShaderInfoLog(fragmentShader);
            if (log) {
              pipelineContext.fragmentCompilationError = log;
              throw new Error("FRAGMENT SHADER " + log);
            }
          }
          var error = context.getProgramInfoLog(program);
          if (error) {
            pipelineContext.programLinkError = error;
            throw new Error(error);
          }
        }
        if (this.validateShaderPrograms) {
          context.validateProgram(program);
          var validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
          if (!validated) {
            var error = context.getProgramInfoLog(program);
            if (error) {
              pipelineContext.programValidationError = error;
              throw new Error(error);
            }
          }
        }
        context.deleteShader(vertexShader);
        context.deleteShader(fragmentShader);
        pipelineContext.vertexShader = void 0;
        pipelineContext.fragmentShader = void 0;
        if (pipelineContext.onCompiled) {
          pipelineContext.onCompiled();
          pipelineContext.onCompiled = void 0;
        }
      };
      ThinEngine2.prototype._preparePipelineContext = function(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
        var webGLRenderingState = pipelineContext;
        if (createAsRaw) {
          webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
        } else {
          webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
        }
        webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
      };
      ThinEngine2.prototype._isRenderingStateCompiled = function(pipelineContext) {
        var webGLPipelineContext = pipelineContext;
        if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
          this._finalizePipelineContext(webGLPipelineContext);
          return true;
        }
        return false;
      };
      ThinEngine2.prototype._executeWhenRenderingStateIsCompiled = function(pipelineContext, action) {
        var webGLPipelineContext = pipelineContext;
        if (!webGLPipelineContext.isParallelCompiled) {
          action();
          return;
        }
        var oldHandler = webGLPipelineContext.onCompiled;
        if (oldHandler) {
          webGLPipelineContext.onCompiled = function() {
            oldHandler();
            action();
          };
        } else {
          webGLPipelineContext.onCompiled = action;
        }
      };
      ThinEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
        var results = new Array();
        var webGLPipelineContext = pipelineContext;
        for (var index = 0; index < uniformsNames.length; index++) {
          results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
        }
        return results;
      };
      ThinEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
        var results = [];
        var webGLPipelineContext = pipelineContext;
        for (var index = 0; index < attributesNames.length; index++) {
          try {
            results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
          } catch (e) {
            results.push(-1);
          }
        }
        return results;
      };
      ThinEngine2.prototype.enableEffect = function(effect) {
        effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
        if (!effect || effect === this._currentEffect) {
          return;
        }
        this._stencilStateComposer.stencilMaterial = void 0;
        effect = effect;
        this.bindSamplers(effect);
        this._currentEffect = effect;
        if (effect.onBind) {
          effect.onBind(effect);
        }
        if (effect._onBindObservable) {
          effect._onBindObservable.notifyObservers(effect);
        }
      };
      ThinEngine2.prototype.setInt = function(uniform, value) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1i(uniform, value);
        return true;
      };
      ThinEngine2.prototype.setInt2 = function(uniform, x, y) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform2i(uniform, x, y);
        return true;
      };
      ThinEngine2.prototype.setInt3 = function(uniform, x, y, z) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform3i(uniform, x, y, z);
        return true;
      };
      ThinEngine2.prototype.setInt4 = function(uniform, x, y, z, w) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform4i(uniform, x, y, z, w);
        return true;
      };
      ThinEngine2.prototype.setIntArray = function(uniform, array) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1iv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setIntArray2 = function(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
          return false;
        }
        this._gl.uniform2iv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setIntArray3 = function(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
          return false;
        }
        this._gl.uniform3iv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setIntArray4 = function(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
          return false;
        }
        this._gl.uniform4iv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setArray = function(uniform, array) {
        if (!uniform) {
          return false;
        }
        if (array.length < 1) {
          return false;
        }
        this._gl.uniform1fv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setArray2 = function(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
          return false;
        }
        this._gl.uniform2fv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setArray3 = function(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
          return false;
        }
        this._gl.uniform3fv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setArray4 = function(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
          return false;
        }
        this._gl.uniform4fv(uniform, array);
        return true;
      };
      ThinEngine2.prototype.setMatrices = function(uniform, matrices) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix4fv(uniform, false, matrices);
        return true;
      };
      ThinEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix3fv(uniform, false, matrix);
        return true;
      };
      ThinEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix2fv(uniform, false, matrix);
        return true;
      };
      ThinEngine2.prototype.setFloat = function(uniform, value) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1f(uniform, value);
        return true;
      };
      ThinEngine2.prototype.setFloat2 = function(uniform, x, y) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform2f(uniform, x, y);
        return true;
      };
      ThinEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform3f(uniform, x, y, z);
        return true;
      };
      ThinEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform4f(uniform, x, y, z, w);
        return true;
      };
      ThinEngine2.prototype.applyStates = function() {
        this._depthCullingState.apply(this._gl);
        this._stencilStateComposer.apply(this._gl);
        this._alphaState.apply(this._gl);
        if (this._colorWriteChanged) {
          this._colorWriteChanged = false;
          var enable = this._colorWrite;
          this._gl.colorMask(enable, enable, enable, enable);
        }
      };
      ThinEngine2.prototype.setColorWrite = function(enable) {
        if (enable !== this._colorWrite) {
          this._colorWriteChanged = true;
          this._colorWrite = enable;
        }
      };
      ThinEngine2.prototype.getColorWrite = function() {
        return this._colorWrite;
      };
      Object.defineProperty(ThinEngine2.prototype, "depthCullingState", {
        get: function() {
          return this._depthCullingState;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "alphaState", {
        get: function() {
          return this._alphaState;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "stencilState", {
        get: function() {
          return this._stencilState;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2.prototype, "stencilStateComposer", {
        get: function() {
          return this._stencilStateComposer;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.prototype.clearInternalTexturesCache = function() {
        this._internalTexturesCache = [];
      };
      ThinEngine2.prototype.wipeCaches = function(bruteForce) {
        if (this.preventCacheWipeBetweenFrames && !bruteForce) {
          return;
        }
        this._currentEffect = null;
        this._viewportCached.x = 0;
        this._viewportCached.y = 0;
        this._viewportCached.z = 0;
        this._viewportCached.w = 0;
        this._unbindVertexArrayObject();
        if (bruteForce) {
          this._currentProgram = null;
          this.resetTextureCache();
          this._stencilStateComposer.reset();
          this._depthCullingState.reset();
          this._depthCullingState.depthFunc = this._gl.LEQUAL;
          this._alphaState.reset();
          this._alphaMode = 1;
          this._alphaEquation = 0;
          this._colorWrite = true;
          this._colorWriteChanged = true;
          this._unpackFlipYCached = null;
          this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
          this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
          this._mustWipeVertexAttributes = true;
          this.unbindAllAttributes();
        }
        this._resetVertexBufferBinding();
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
        this.bindIndexBuffer(null);
      };
      ThinEngine2.prototype._getSamplingParameters = function(samplingMode, generateMipMaps) {
        var gl = this._gl;
        var magFilter = gl.NEAREST;
        var minFilter = gl.NEAREST;
        switch (samplingMode) {
          case 11:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_NEAREST;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 3:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_LINEAR;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 8:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_LINEAR;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 4:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_NEAREST;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 5:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_NEAREST;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 6:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_LINEAR;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 7:
            magFilter = gl.NEAREST;
            minFilter = gl.LINEAR;
            break;
          case 1:
            magFilter = gl.NEAREST;
            minFilter = gl.NEAREST;
            break;
          case 9:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_NEAREST;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 10:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_LINEAR;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 2:
            magFilter = gl.LINEAR;
            minFilter = gl.LINEAR;
            break;
          case 12:
            magFilter = gl.LINEAR;
            minFilter = gl.NEAREST;
            break;
        }
        return {
          min: minFilter,
          mag: magFilter
        };
      };
      ThinEngine2.prototype._createTexture = function() {
        var texture = this._gl.createTexture();
        if (!texture) {
          throw new Error("Unable to create texture");
        }
        return texture;
      };
      ThinEngine2.prototype._createHardwareTexture = function() {
        return new WebGLHardwareTexture(this._createTexture(), this._gl);
      };
      ThinEngine2.prototype._createInternalTexture = function(size, options, delayGPUTextureCreation, source) {
        if (delayGPUTextureCreation === void 0) {
          delayGPUTextureCreation = true;
        }
        if (source === void 0) {
          source = InternalTextureSource.Unknown;
        }
        var fullOptions = {};
        if (options !== void 0 && typeof options === "object") {
          fullOptions.generateMipMaps = options.generateMipMaps;
          fullOptions.type = options.type === void 0 ? 0 : options.type;
          fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
          fullOptions.format = options.format === void 0 ? 5 : options.format;
        } else {
          fullOptions.generateMipMaps = options;
          fullOptions.type = 0;
          fullOptions.samplingMode = 3;
          fullOptions.format = 5;
        }
        if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
          fullOptions.samplingMode = 1;
        } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
          fullOptions.samplingMode = 1;
        }
        if (fullOptions.type === 1 && !this._caps.textureFloat) {
          fullOptions.type = 0;
          Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
        }
        var gl = this._gl;
        var texture = new InternalTexture(this, source);
        var width = size.width || size;
        var height = size.height || size;
        var layers = size.layers || 0;
        var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps ? true : false);
        var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
        var sizedFormat = this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format);
        var internalFormat = this._getInternalFormat(fullOptions.format);
        var type = this._getWebGLTextureType(fullOptions.type);
        this._bindTextureDirectly(target, texture);
        if (layers !== 0) {
          texture.is2DArray = true;
          gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, type, null);
        } else {
          gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, type, null);
        }
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (fullOptions.generateMipMaps) {
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.depth = layers;
        texture.isReady = true;
        texture.samples = 1;
        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
        texture.samplingMode = fullOptions.samplingMode;
        texture.type = fullOptions.type;
        texture.format = fullOptions.format;
        this._internalTexturesCache.push(texture);
        return texture;
      };
      ThinEngine2.prototype._getUseSRGBBuffer = function(useSRGBBuffer, noMipmap) {
        return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
      };
      ThinEngine2.prototype._createTextureBase = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer) {
        var _this = this;
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (buffer === void 0) {
          buffer = null;
        }
        if (fallback === void 0) {
          fallback = null;
        }
        if (format === void 0) {
          format = null;
        }
        if (forcedExtension === void 0) {
          forcedExtension = null;
        }
        url = url || "";
        var fromData = url.substr(0, 5) === "data:";
        var fromBlob = url.substr(0, 5) === "blob:";
        var isBase64 = fromData && url.indexOf(";base64,") !== -1;
        var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
        var originalUrl = url;
        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
          url = this._transformTextureUrl(url);
        }
        if (originalUrl !== url) {
          texture._originalUrl = originalUrl;
        }
        var lastDot = url.lastIndexOf(".");
        var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        var loader = null;
        var queryStringIndex = extension.indexOf("?");
        if (queryStringIndex > -1) {
          extension = extension.split("?")[0];
        }
        for (var _i = 0, _a = ThinEngine2._TextureLoaders; _i < _a.length; _i++) {
          var availableLoader = _a[_i];
          if (availableLoader.canLoad(extension, mimeType)) {
            loader = availableLoader;
            break;
          }
        }
        if (scene) {
          scene._addPendingData(texture);
        }
        texture.url = url;
        texture.generateMipMaps = !noMipmap;
        texture.samplingMode = samplingMode;
        texture.invertY = invertY;
        texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
        if (!this._doNotHandleContextLost) {
          texture._buffer = buffer;
        }
        var onLoadObserver = null;
        if (onLoad && !fallback) {
          onLoadObserver = texture.onLoadedObservable.add(onLoad);
        }
        if (!fallback) {
          this._internalTexturesCache.push(texture);
        }
        var onInternalError = function(message, exception) {
          if (scene) {
            scene._removePendingData(texture);
          }
          if (url === originalUrl) {
            if (onLoadObserver) {
              texture.onLoadedObservable.remove(onLoadObserver);
            }
            if (EngineStore.UseFallbackTexture) {
              _this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
            }
            message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
            texture.onErrorObservable.notifyObservers({ message, exception });
            if (onError) {
              onError(message, exception);
            }
          } else {
            Logger.Warn("Failed to load ".concat(url, ", falling back to ").concat(originalUrl));
            _this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
          }
        };
        if (loader) {
          var callback_1 = function(data) {
            loader.loadData(data, texture, function(width, height, loadMipmap, isCompressed, done, loadFailed) {
              if (loadFailed) {
                onInternalError("TextureLoader failed to load data");
              } else {
                prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, function() {
                  done();
                  return false;
                }, samplingMode);
              }
            }, loaderOptions);
          };
          if (!buffer) {
            this._loadFile(url, function(data) {
              return callback_1(new Uint8Array(data));
            }, void 0, scene ? scene.offlineProvider : void 0, true, function(request, exception) {
              onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
            });
          } else {
            if (buffer instanceof ArrayBuffer) {
              callback_1(new Uint8Array(buffer));
            } else if (ArrayBuffer.isView(buffer)) {
              callback_1(buffer);
            } else {
              if (onError) {
                onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
              }
            }
          }
        } else {
          var onload_1 = function(img) {
            if (fromBlob && !_this._doNotHandleContextLost) {
              texture._buffer = img;
            }
            prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
          };
          if (!fromData || isBase64) {
            if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
              onload_1(buffer);
            } else {
              ThinEngine2._FileToolsLoadImage(url, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
            }
          } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
            ThinEngine2._FileToolsLoadImage(buffer, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
          } else if (buffer) {
            onload_1(buffer);
          }
        }
        return texture;
      };
      ThinEngine2.prototype.createTexture = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
        var _this = this;
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (buffer === void 0) {
          buffer = null;
        }
        if (fallback === void 0) {
          fallback = null;
        }
        if (format === void 0) {
          format = null;
        }
        if (forcedExtension === void 0) {
          forcedExtension = null;
        }
        return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), function(potWidth, potHeight, img, extension, texture, continuationCallback) {
          var gl = _this._gl;
          var isPot = img.width === potWidth && img.height === potHeight;
          var internalFormat = format ? _this._getInternalFormat(format, texture._useSRGBBuffer) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;
          var texelFormat = format ? _this._getInternalFormat(format) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : gl.RGBA;
          if (texture._useSRGBBuffer && _this.webGLVersion === 1) {
            texelFormat = internalFormat;
          }
          if (isPot) {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
            return false;
          }
          var maxTextureSize = _this._caps.maxTextureSize;
          if (img.width > maxTextureSize || img.height > maxTextureSize || !_this._supportsHardwareTextureRescaling) {
            _this._prepareWorkingCanvas();
            if (!_this._workingCanvas || !_this._workingContext) {
              return false;
            }
            _this._workingCanvas.width = potWidth;
            _this._workingCanvas.height = potHeight;
            _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
            texture.width = potWidth;
            texture.height = potHeight;
            return false;
          } else {
            var source_1 = new InternalTexture(_this, InternalTextureSource.Temp);
            _this._bindTextureDirectly(gl.TEXTURE_2D, source_1, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
            _this._rescaleTexture(source_1, texture, scene, internalFormat, function() {
              _this._releaseTexture(source_1);
              _this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
              continuationCallback();
            });
          }
          return true;
        }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      };
      ThinEngine2._FileToolsLoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
        throw _WarnImport("FileTools");
      };
      ThinEngine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
      };
      ThinEngine2.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {
        if (compression === void 0) {
          compression = null;
        }
        if (type === void 0) {
          type = 0;
        }
        throw _WarnImport("Engine.RawTexture");
      };
      ThinEngine2.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
        if (compression === void 0) {
          compression = null;
        }
        throw _WarnImport("Engine.RawTexture");
      };
      ThinEngine2.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
        if (compression === void 0) {
          compression = null;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        throw _WarnImport("Engine.RawTexture");
      };
      ThinEngine2.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
        if (compression === void 0) {
          compression = null;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        throw _WarnImport("Engine.RawTexture");
      };
      ThinEngine2.prototype._unpackFlipY = function(value) {
        if (this._unpackFlipYCached !== value) {
          this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
          if (this.enableUnpackFlipYCached) {
            this._unpackFlipYCached = value;
          }
        }
      };
      ThinEngine2.prototype._getUnpackAlignement = function() {
        return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
      };
      ThinEngine2.prototype._getTextureTarget = function(texture) {
        if (texture.isCube) {
          return this._gl.TEXTURE_CUBE_MAP;
        } else if (texture.is3D) {
          return this._gl.TEXTURE_3D;
        } else if (texture.is2DArray || texture.isMultiview) {
          return this._gl.TEXTURE_2D_ARRAY;
        }
        return this._gl.TEXTURE_2D;
      };
      ThinEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture, generateMipMaps) {
        if (generateMipMaps === void 0) {
          generateMipMaps = false;
        }
        var target = this._getTextureTarget(texture);
        var filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
        if (generateMipMaps) {
          texture.generateMipMaps = true;
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture.samplingMode = samplingMode;
      };
      ThinEngine2.prototype.updateTextureDimensions = function(texture, width, height, depth) {
        if (depth === void 0) {
          depth = 1;
        }
      };
      ThinEngine2.prototype.updateTextureWrappingMode = function(texture, wrapU, wrapV, wrapR) {
        if (wrapV === void 0) {
          wrapV = null;
        }
        if (wrapR === void 0) {
          wrapR = null;
        }
        var target = this._getTextureTarget(texture);
        if (wrapU !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
          texture._cachedWrapU = wrapU;
        }
        if (wrapV !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
          texture._cachedWrapV = wrapV;
        }
        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
          texture._cachedWrapR = wrapR;
        }
        this._bindTextureDirectly(target, null);
      };
      ThinEngine2.prototype._setupDepthStencilTexture = function(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples) {
        if (samples === void 0) {
          samples = 1;
        }
        var width = size.width || size;
        var height = size.height || size;
        var layers = size.layers || 0;
        internalTexture.baseWidth = width;
        internalTexture.baseHeight = height;
        internalTexture.width = width;
        internalTexture.height = height;
        internalTexture.is2DArray = layers > 0;
        internalTexture.depth = layers;
        internalTexture.isReady = true;
        internalTexture.samples = samples;
        internalTexture.generateMipMaps = false;
        internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
        internalTexture.type = 0;
        internalTexture._comparisonFunction = comparisonFunction;
        var gl = this._gl;
        var target = this._getTextureTarget(internalTexture);
        var samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (comparisonFunction === 0) {
          gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
          gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
        } else {
          gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
          gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
        }
      };
      ThinEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lod === void 0) {
          lod = 0;
        }
        var gl = this._gl;
        var target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        if (texture._useSRGBBuffer) {
          switch (internalFormat) {
            case 36492:
              internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
              break;
            case 37808:
              internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
              break;
            case 33776:
              if (this._caps.s3tc_srgb) {
                internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            case 33779:
              if (this._caps.s3tc_srgb) {
                internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            default:
              texture._useSRGBBuffer = false;
              break;
          }
        }
        this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
      };
      ThinEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lod === void 0) {
          lod = 0;
        }
        if (useTextureWidthAndHeight === void 0) {
          useTextureWidthAndHeight = false;
        }
        var gl = this._gl;
        var textureType = this._getWebGLTextureType(texture.type);
        var format = this._getInternalFormat(texture.format);
        var internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
        this._unpackFlipY(texture.invertY);
        var target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
        var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
        var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
        var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
        gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
      };
      ThinEngine2.prototype.updateTextureData = function(texture, imageData, xOffset, yOffset, width, height, faceIndex, lod, generateMipMaps) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lod === void 0) {
          lod = 0;
        }
        if (generateMipMaps === void 0) {
          generateMipMaps = false;
        }
        var gl = this._gl;
        var textureType = this._getWebGLTextureType(texture.type);
        var format = this._getInternalFormat(texture.format);
        this._unpackFlipY(texture.invertY);
        var target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        this._bindTextureDirectly(target, texture, true);
        gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
        if (generateMipMaps) {
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
      };
      ThinEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lod === void 0) {
          lod = 0;
        }
        var gl = this._gl;
        var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
        this._bindTextureDirectly(bindTarget, null, true);
      };
      ThinEngine2.prototype._prepareWebGLTextureContinuation = function(texture, scene, noMipmap, isCompressed, samplingMode) {
        var gl = this._gl;
        if (!gl) {
          return;
        }
        var filters = this._getSamplingParameters(samplingMode, !noMipmap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
        if (!noMipmap && !isCompressed) {
          gl.generateMipmap(gl.TEXTURE_2D);
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, null);
        if (scene) {
          scene._removePendingData(texture);
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
      };
      ThinEngine2.prototype._prepareWebGLTexture = function(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode) {
        var _this = this;
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        var maxTextureSize = this.getCaps().maxTextureSize;
        var potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
        var potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
        var gl = this._gl;
        if (!gl) {
          return;
        }
        if (!texture._hardwareTexture) {
          if (scene) {
            scene._removePendingData(texture);
          }
          return;
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
        this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
        texture.baseWidth = img.width;
        texture.baseHeight = img.height;
        texture.width = potWidth;
        texture.height = potHeight;
        texture.isReady = true;
        if (processFunction(potWidth, potHeight, img, extension, texture, function() {
          _this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
        })) {
          return;
        }
        this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
      };
      ThinEngine2.prototype._setupFramebufferDepthAttachments = function(generateStencilBuffer, generateDepthBuffer, width, height, samples) {
        if (samples === void 0) {
          samples = 1;
        }
        var gl = this._gl;
        if (generateStencilBuffer && generateDepthBuffer) {
          return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
        }
        if (generateDepthBuffer) {
          var depthFormat = gl.DEPTH_COMPONENT16;
          if (this._webGLVersion > 1) {
            depthFormat = gl.DEPTH_COMPONENT32F;
          }
          return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
        }
        if (generateStencilBuffer) {
          return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
        }
        return null;
      };
      ThinEngine2.prototype._createRenderBuffer = function(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer) {
        if (unbindBuffer === void 0) {
          unbindBuffer = true;
        }
        var gl = this._gl;
        var renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
        if (samples > 1 && gl.renderbufferStorageMultisample) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
        if (unbindBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        return renderBuffer;
      };
      ThinEngine2.prototype._releaseTexture = function(texture) {
        var _a;
        this._deleteTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource);
        this.unbindAllTextures();
        var index = this._internalTexturesCache.indexOf(texture);
        if (index !== -1) {
          this._internalTexturesCache.splice(index, 1);
        }
        if (texture._lodTextureHigh) {
          texture._lodTextureHigh.dispose();
        }
        if (texture._lodTextureMid) {
          texture._lodTextureMid.dispose();
        }
        if (texture._lodTextureLow) {
          texture._lodTextureLow.dispose();
        }
        if (texture._irradianceTexture) {
          texture._irradianceTexture.dispose();
        }
      };
      ThinEngine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
        var index = this._renderTargetWrapperCache.indexOf(rtWrapper);
        if (index !== -1) {
          this._renderTargetWrapperCache.splice(index, 1);
        }
      };
      ThinEngine2.prototype._deleteTexture = function(texture) {
        if (texture) {
          this._gl.deleteTexture(texture);
        }
      };
      ThinEngine2.prototype._setProgram = function(program) {
        if (this._currentProgram !== program) {
          this._gl.useProgram(program);
          this._currentProgram = program;
        }
      };
      ThinEngine2.prototype.bindSamplers = function(effect) {
        var webGLPipelineContext = effect.getPipelineContext();
        this._setProgram(webGLPipelineContext.program);
        var samplers = effect.getSamplers();
        for (var index = 0; index < samplers.length; index++) {
          var uniform = effect.getUniform(samplers[index]);
          if (uniform) {
            this._boundUniforms[index] = uniform;
          }
        }
        this._currentEffect = null;
      };
      ThinEngine2.prototype._activateCurrentTexture = function() {
        if (this._currentTextureChannel !== this._activeChannel) {
          this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
          this._currentTextureChannel = this._activeChannel;
        }
      };
      ThinEngine2.prototype._bindTextureDirectly = function(target, texture, forTextureDataUpdate, force) {
        var _a, _b;
        if (forTextureDataUpdate === void 0) {
          forTextureDataUpdate = false;
        }
        if (force === void 0) {
          force = false;
        }
        var wasPreviouslyBound = false;
        var isTextureForRendering = texture && texture._associatedChannel > -1;
        if (forTextureDataUpdate && isTextureForRendering) {
          this._activeChannel = texture._associatedChannel;
        }
        var currentTextureBound = this._boundTexturesCache[this._activeChannel];
        if (currentTextureBound !== texture || force) {
          this._activateCurrentTexture();
          if (texture && texture.isMultiview) {
            console.error(target, texture);
            throw "_bindTextureDirectly called with a multiview texture!";
          } else {
            this._gl.bindTexture(target, (_b = (_a = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource) !== null && _b !== void 0 ? _b : null);
          }
          this._boundTexturesCache[this._activeChannel] = texture;
          if (texture) {
            texture._associatedChannel = this._activeChannel;
          }
        } else if (forTextureDataUpdate) {
          wasPreviouslyBound = true;
          this._activateCurrentTexture();
        }
        if (isTextureForRendering && !forTextureDataUpdate) {
          this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
        }
        return wasPreviouslyBound;
      };
      ThinEngine2.prototype._bindTexture = function(channel, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (texture) {
          texture._associatedChannel = channel;
        }
        this._activeChannel = channel;
        var target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
        this._bindTextureDirectly(target, texture);
      };
      ThinEngine2.prototype.unbindAllTextures = function() {
        for (var channel = 0; channel < this._maxSimultaneousTextures; channel++) {
          this._activeChannel = channel;
          this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
          if (this.webGLVersion > 1) {
            this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
            this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
          }
        }
      };
      ThinEngine2.prototype.setTexture = function(channel, uniform, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (uniform) {
          this._boundUniforms[channel] = uniform;
        }
        this._setTexture(channel, texture);
      };
      ThinEngine2.prototype._bindSamplerUniformToChannel = function(sourceSlot, destination) {
        var uniform = this._boundUniforms[sourceSlot];
        if (!uniform || uniform._currentState === destination) {
          return;
        }
        this._gl.uniform1i(uniform, destination);
        uniform._currentState = destination;
      };
      ThinEngine2.prototype._getTextureWrapMode = function(mode) {
        switch (mode) {
          case 1:
            return this._gl.REPEAT;
          case 0:
            return this._gl.CLAMP_TO_EDGE;
          case 2:
            return this._gl.MIRRORED_REPEAT;
        }
        return this._gl.REPEAT;
      };
      ThinEngine2.prototype._setTexture = function(channel, texture, isPartOfTextureArray, depthStencilTexture, name) {
        if (isPartOfTextureArray === void 0) {
          isPartOfTextureArray = false;
        }
        if (depthStencilTexture === void 0) {
          depthStencilTexture = false;
        }
        if (name === void 0) {
          name = "";
        }
        if (!texture) {
          if (this._boundTexturesCache[channel] != null) {
            this._activeChannel = channel;
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
            if (this.webGLVersion > 1) {
              this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
              this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
            }
          }
          return false;
        }
        if (texture.video) {
          this._activeChannel = channel;
          texture.update();
        } else if (texture.delayLoadState === 4) {
          texture.delayLoad();
          return false;
        }
        var internalTexture;
        if (depthStencilTexture) {
          internalTexture = texture.depthStencilTexture;
        } else if (texture.isReady()) {
          internalTexture = texture.getInternalTexture();
        } else if (texture.isCube) {
          internalTexture = this.emptyCubeTexture;
        } else if (texture.is3D) {
          internalTexture = this.emptyTexture3D;
        } else if (texture.is2DArray) {
          internalTexture = this.emptyTexture2DArray;
        } else {
          internalTexture = this.emptyTexture;
        }
        if (!isPartOfTextureArray && internalTexture) {
          internalTexture._associatedChannel = channel;
        }
        var needToBind = true;
        if (this._boundTexturesCache[channel] === internalTexture) {
          if (!isPartOfTextureArray) {
            this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
          }
          needToBind = false;
        }
        this._activeChannel = channel;
        var target = this._getTextureTarget(internalTexture);
        if (needToBind) {
          this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
        }
        if (internalTexture && !internalTexture.isMultiview) {
          if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
            internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
            var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
            texture.wrapU = textureWrapMode;
            texture.wrapV = textureWrapMode;
          }
          if (internalTexture._cachedWrapU !== texture.wrapU) {
            internalTexture._cachedWrapU = texture.wrapU;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
          }
          if (internalTexture._cachedWrapV !== texture.wrapV) {
            internalTexture._cachedWrapV = texture.wrapV;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
          }
          if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
            internalTexture._cachedWrapR = texture.wrapR;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
          }
          this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
        }
        return true;
      };
      ThinEngine2.prototype.setTextureArray = function(channel, uniform, textures, name) {
        if (channel === void 0 || !uniform) {
          return;
        }
        if (!this._textureUnits || this._textureUnits.length !== textures.length) {
          this._textureUnits = new Int32Array(textures.length);
        }
        for (var i = 0; i < textures.length; i++) {
          var texture = textures[i].getInternalTexture();
          if (texture) {
            this._textureUnits[i] = channel + i;
            texture._associatedChannel = channel + i;
          } else {
            this._textureUnits[i] = -1;
          }
        }
        this._gl.uniform1iv(uniform, this._textureUnits);
        for (var index = 0; index < textures.length; index++) {
          this._setTexture(this._textureUnits[index], textures[index], true);
        }
      };
      ThinEngine2.prototype._setAnisotropicLevel = function(target, internalTexture, anisotropicFilteringLevel) {
        var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
        if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
          anisotropicFilteringLevel = 1;
        }
        if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
          this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
          internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
        }
      };
      ThinEngine2.prototype._setTextureParameterFloat = function(target, parameter, value, texture) {
        this._bindTextureDirectly(target, texture, true, true);
        this._gl.texParameterf(target, parameter, value);
      };
      ThinEngine2.prototype._setTextureParameterInteger = function(target, parameter, value, texture) {
        if (texture) {
          this._bindTextureDirectly(target, texture, true, true);
        }
        this._gl.texParameteri(target, parameter, value);
      };
      ThinEngine2.prototype.unbindAllAttributes = function() {
        if (this._mustWipeVertexAttributes) {
          this._mustWipeVertexAttributes = false;
          for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
            this.disableAttributeByIndex(i);
          }
          return;
        }
        for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
          if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
            continue;
          }
          this.disableAttributeByIndex(i);
        }
      };
      ThinEngine2.prototype.releaseEffects = function() {
        for (var name_1 in this._compiledEffects) {
          var webGLPipelineContext = this._compiledEffects[name_1].getPipelineContext();
          this._deletePipelineContext(webGLPipelineContext);
        }
        this._compiledEffects = {};
      };
      ThinEngine2.prototype.dispose = function() {
        var _a;
        this.stopRenderLoop();
        if (this.onBeforeTextureInitObservable) {
          this.onBeforeTextureInitObservable.clear();
        }
        if (this._emptyTexture) {
          this._releaseTexture(this._emptyTexture);
          this._emptyTexture = null;
        }
        if (this._emptyCubeTexture) {
          this._releaseTexture(this._emptyCubeTexture);
          this._emptyCubeTexture = null;
        }
        if (this._dummyFramebuffer) {
          this._gl.deleteFramebuffer(this._dummyFramebuffer);
        }
        this.releaseEffects();
        (_a = this.releaseComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
        this.unbindAllAttributes();
        this._boundUniforms = [];
        if (IsWindowObjectExist()) {
          if (this._renderingCanvas) {
            if (!this._doNotHandleContextLost) {
              this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
              this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
            }
            window.removeEventListener("resize", this._checkForMobile);
          }
        }
        this._workingCanvas = null;
        this._workingContext = null;
        this._currentBufferPointers = [];
        this._renderingCanvas = null;
        this._currentProgram = null;
        this._boundRenderFunction = null;
        Effect.ResetCache();
        for (var _i = 0, _b = this._activeRequests; _i < _b.length; _i++) {
          var request = _b[_i];
          request.abort();
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
      };
      ThinEngine2.prototype.attachContextLostEvent = function(callback) {
        if (this._renderingCanvas) {
          this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
        }
      };
      ThinEngine2.prototype.attachContextRestoredEvent = function(callback) {
        if (this._renderingCanvas) {
          this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
        }
      };
      ThinEngine2.prototype.getError = function() {
        return this._gl.getError();
      };
      ThinEngine2.prototype._canRenderToFloatFramebuffer = function() {
        if (this._webGLVersion > 1) {
          return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(1);
      };
      ThinEngine2.prototype._canRenderToHalfFloatFramebuffer = function() {
        if (this._webGLVersion > 1) {
          return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(2);
      };
      ThinEngine2.prototype._canRenderToFramebuffer = function(type) {
        var gl = this._gl;
        while (gl.getError() !== gl.NO_ERROR) {
        }
        var successful = true;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
        successful = successful && gl.getError() === gl.NO_ERROR;
        if (successful) {
          gl.clear(gl.COLOR_BUFFER_BIT);
          successful = successful && gl.getError() === gl.NO_ERROR;
        }
        if (successful) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          var readFormat = gl.RGBA;
          var readType = gl.UNSIGNED_BYTE;
          var buffer = new Uint8Array(4);
          gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
          successful = successful && gl.getError() === gl.NO_ERROR;
        }
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        while (!successful && gl.getError() !== gl.NO_ERROR) {
        }
        return successful;
      };
      ThinEngine2.prototype._getWebGLTextureType = function(type) {
        if (this._webGLVersion === 1) {
          switch (type) {
            case 1:
              return this._gl.FLOAT;
            case 2:
              return this._gl.HALF_FLOAT_OES;
            case 0:
              return this._gl.UNSIGNED_BYTE;
            case 8:
              return this._gl.UNSIGNED_SHORT_4_4_4_4;
            case 9:
              return this._gl.UNSIGNED_SHORT_5_5_5_1;
            case 10:
              return this._gl.UNSIGNED_SHORT_5_6_5;
          }
          return this._gl.UNSIGNED_BYTE;
        }
        switch (type) {
          case 3:
            return this._gl.BYTE;
          case 0:
            return this._gl.UNSIGNED_BYTE;
          case 4:
            return this._gl.SHORT;
          case 5:
            return this._gl.UNSIGNED_SHORT;
          case 6:
            return this._gl.INT;
          case 7:
            return this._gl.UNSIGNED_INT;
          case 1:
            return this._gl.FLOAT;
          case 2:
            return this._gl.HALF_FLOAT;
          case 8:
            return this._gl.UNSIGNED_SHORT_4_4_4_4;
          case 9:
            return this._gl.UNSIGNED_SHORT_5_5_5_1;
          case 10:
            return this._gl.UNSIGNED_SHORT_5_6_5;
          case 11:
            return this._gl.UNSIGNED_INT_2_10_10_10_REV;
          case 12:
            return this._gl.UNSIGNED_INT_24_8;
          case 13:
            return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
          case 14:
            return this._gl.UNSIGNED_INT_5_9_9_9_REV;
          case 15:
            return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
        }
        return this._gl.UNSIGNED_BYTE;
      };
      ThinEngine2.prototype._getInternalFormat = function(format, useSRGBBuffer) {
        if (useSRGBBuffer === void 0) {
          useSRGBBuffer = false;
        }
        var internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        switch (format) {
          case 0:
            internalFormat = this._gl.ALPHA;
            break;
          case 1:
            internalFormat = this._gl.LUMINANCE;
            break;
          case 2:
            internalFormat = this._gl.LUMINANCE_ALPHA;
            break;
          case 6:
            internalFormat = this._gl.RED;
            break;
          case 7:
            internalFormat = this._gl.RG;
            break;
          case 4:
            internalFormat = useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
            break;
          case 5:
            internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
            break;
        }
        if (this._webGLVersion > 1) {
          switch (format) {
            case 8:
              internalFormat = this._gl.RED_INTEGER;
              break;
            case 9:
              internalFormat = this._gl.RG_INTEGER;
              break;
            case 10:
              internalFormat = this._gl.RGB_INTEGER;
              break;
            case 11:
              internalFormat = this._gl.RGBA_INTEGER;
              break;
          }
        }
        return internalFormat;
      };
      ThinEngine2.prototype._getRGBABufferInternalSizedFormat = function(type, format, useSRGBBuffer) {
        if (useSRGBBuffer === void 0) {
          useSRGBBuffer = false;
        }
        if (this._webGLVersion === 1) {
          if (format !== void 0) {
            switch (format) {
              case 0:
                return this._gl.ALPHA;
              case 1:
                return this._gl.LUMINANCE;
              case 2:
                return this._gl.LUMINANCE_ALPHA;
              case 4:
                return useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
            }
          }
          return this._gl.RGBA;
        }
        switch (type) {
          case 3:
            switch (format) {
              case 6:
                return this._gl.R8_SNORM;
              case 7:
                return this._gl.RG8_SNORM;
              case 4:
                return this._gl.RGB8_SNORM;
              case 8:
                return this._gl.R8I;
              case 9:
                return this._gl.RG8I;
              case 10:
                return this._gl.RGB8I;
              case 11:
                return this._gl.RGBA8I;
              default:
                return this._gl.RGBA8_SNORM;
            }
          case 0:
            switch (format) {
              case 6:
                return this._gl.R8;
              case 7:
                return this._gl.RG8;
              case 4:
                return useSRGBBuffer ? this._gl.SRGB8 : this._gl.RGB8;
              case 5:
                return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
              case 8:
                return this._gl.R8UI;
              case 9:
                return this._gl.RG8UI;
              case 10:
                return this._gl.RGB8UI;
              case 11:
                return this._gl.RGBA8UI;
              case 0:
                return this._gl.ALPHA;
              case 1:
                return this._gl.LUMINANCE;
              case 2:
                return this._gl.LUMINANCE_ALPHA;
              default:
                return this._gl.RGBA8;
            }
          case 4:
            switch (format) {
              case 8:
                return this._gl.R16I;
              case 9:
                return this._gl.RG16I;
              case 10:
                return this._gl.RGB16I;
              case 11:
                return this._gl.RGBA16I;
              default:
                return this._gl.RGBA16I;
            }
          case 5:
            switch (format) {
              case 8:
                return this._gl.R16UI;
              case 9:
                return this._gl.RG16UI;
              case 10:
                return this._gl.RGB16UI;
              case 11:
                return this._gl.RGBA16UI;
              default:
                return this._gl.RGBA16UI;
            }
          case 6:
            switch (format) {
              case 8:
                return this._gl.R32I;
              case 9:
                return this._gl.RG32I;
              case 10:
                return this._gl.RGB32I;
              case 11:
                return this._gl.RGBA32I;
              default:
                return this._gl.RGBA32I;
            }
          case 7:
            switch (format) {
              case 8:
                return this._gl.R32UI;
              case 9:
                return this._gl.RG32UI;
              case 10:
                return this._gl.RGB32UI;
              case 11:
                return this._gl.RGBA32UI;
              default:
                return this._gl.RGBA32UI;
            }
          case 1:
            switch (format) {
              case 6:
                return this._gl.R32F;
              case 7:
                return this._gl.RG32F;
              case 4:
                return this._gl.RGB32F;
              case 5:
                return this._gl.RGBA32F;
              default:
                return this._gl.RGBA32F;
            }
          case 2:
            switch (format) {
              case 6:
                return this._gl.R16F;
              case 7:
                return this._gl.RG16F;
              case 4:
                return this._gl.RGB16F;
              case 5:
                return this._gl.RGBA16F;
              default:
                return this._gl.RGBA16F;
            }
          case 10:
            return this._gl.RGB565;
          case 13:
            return this._gl.R11F_G11F_B10F;
          case 14:
            return this._gl.RGB9_E5;
          case 8:
            return this._gl.RGBA4;
          case 9:
            return this._gl.RGB5_A1;
          case 11:
            switch (format) {
              case 5:
                return this._gl.RGB10_A2;
              case 11:
                return this._gl.RGB10_A2UI;
              default:
                return this._gl.RGB10_A2;
            }
        }
        return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
      };
      ThinEngine2.prototype._getRGBAMultiSampleBufferFormat = function(type) {
        if (type === 1) {
          return this._gl.RGBA32F;
        } else if (type === 2) {
          return this._gl.RGBA16F;
        }
        return this._gl.RGBA8;
      };
      ThinEngine2.prototype._loadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        var _this = this;
        var request = ThinEngine2._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
        this._activeRequests.push(request);
        request.onCompleteObservable.add(function(request2) {
          _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
        });
        return request;
      };
      ThinEngine2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        throw _WarnImport("FileTools");
      };
      ThinEngine2.prototype.readPixels = function(x, y, width, height, hasAlpha, flushRenderer) {
        if (hasAlpha === void 0) {
          hasAlpha = true;
        }
        if (flushRenderer === void 0) {
          flushRenderer = true;
        }
        var numChannels = hasAlpha ? 4 : 3;
        var format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
        var data = new Uint8Array(height * width * numChannels);
        if (flushRenderer) {
          this.flushFramebuffer();
        }
        this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
        return Promise.resolve(data);
      };
      Object.defineProperty(ThinEngine2, "IsSupportedAsync", {
        get: function() {
          return Promise.resolve(this.isSupported());
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinEngine2, "IsSupported", {
        get: function() {
          return this.isSupported();
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.isSupported = function() {
        if (this._HasMajorPerformanceCaveat !== null) {
          return !this._HasMajorPerformanceCaveat;
        }
        if (this._IsSupported === null) {
          try {
            var tempcanvas = this._CreateCanvas(1, 1);
            var gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
            this._IsSupported = gl != null && !!window.WebGLRenderingContext;
          } catch (e) {
            this._IsSupported = false;
          }
        }
        return this._IsSupported;
      };
      Object.defineProperty(ThinEngine2, "HasMajorPerformanceCaveat", {
        get: function() {
          if (this._HasMajorPerformanceCaveat === null) {
            try {
              var tempcanvas = this._CreateCanvas(1, 1);
              var gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
              this._HasMajorPerformanceCaveat = !gl;
            } catch (e) {
              this._HasMajorPerformanceCaveat = false;
            }
          }
          return this._HasMajorPerformanceCaveat;
        },
        enumerable: false,
        configurable: true
      });
      ThinEngine2.CeilingPOT = function(x) {
        x--;
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        x++;
        return x;
      };
      ThinEngine2.FloorPOT = function(x) {
        x = x | x >> 1;
        x = x | x >> 2;
        x = x | x >> 4;
        x = x | x >> 8;
        x = x | x >> 16;
        return x - (x >> 1);
      };
      ThinEngine2.NearestPOT = function(x) {
        var c = ThinEngine2.CeilingPOT(x);
        var f = ThinEngine2.FloorPOT(x);
        return c - x > x - f ? f : c;
      };
      ThinEngine2.GetExponentOfTwo = function(value, max, mode) {
        if (mode === void 0) {
          mode = 2;
        }
        var pot;
        switch (mode) {
          case 1:
            pot = ThinEngine2.FloorPOT(value);
            break;
          case 2:
            pot = ThinEngine2.NearestPOT(value);
            break;
          case 3:
          default:
            pot = ThinEngine2.CeilingPOT(value);
            break;
        }
        return Math.min(pot, max);
      };
      ThinEngine2.QueueNewFrame = function(func, requester) {
        if (!IsWindowObjectExist()) {
          if (typeof requestAnimationFrame !== "undefined") {
            return requestAnimationFrame(func);
          }
          return setTimeout(func, 16);
        }
        if (!requester) {
          requester = window;
        }
        if (requester.requestPostAnimationFrame) {
          return requester.requestPostAnimationFrame(func);
        } else if (requester.requestAnimationFrame) {
          return requester.requestAnimationFrame(func);
        } else if (requester.msRequestAnimationFrame) {
          return requester.msRequestAnimationFrame(func);
        } else if (requester.webkitRequestAnimationFrame) {
          return requester.webkitRequestAnimationFrame(func);
        } else if (requester.mozRequestAnimationFrame) {
          return requester.mozRequestAnimationFrame(func);
        } else if (requester.oRequestAnimationFrame) {
          return requester.oRequestAnimationFrame(func);
        } else {
          return window.setTimeout(func, 16);
        }
      };
      ThinEngine2.prototype.getHostDocument = function() {
        if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
          return this._renderingCanvas.ownerDocument;
        }
        return document;
      };
      ThinEngine2.ExceptionList = [
        { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
        { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
        { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
        { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
        { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
        { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
        { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
        { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] }
      ];
      ThinEngine2._TextureLoaders = [];
      ThinEngine2.CollisionsEpsilon = 1e-3;
      ThinEngine2._IsSupported = null;
      ThinEngine2._HasMajorPerformanceCaveat = null;
      return ThinEngine2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/timingTools.js
var TimingTools;
var init_timingTools = __esm({
  "node_modules/@babylonjs/core/Misc/timingTools.js"() {
    init_domManagement();
    TimingTools = function() {
      function TimingTools2() {
      }
      TimingTools2.SetImmediate = function(action) {
        if (IsWindowObjectExist() && window.setImmediate) {
          window.setImmediate(action);
        } else {
          setTimeout(action, 1);
        }
      };
      return TimingTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/fileTools.js
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var Base64DataUrlRegEx, LoadFileError, RequestFileError, ReadFileError, FileToolsOptions, _CleanUrl, SetCorsBehavior, LoadImage, ReadFile, LoadFile, RequestFile, IsFileURL, IsBase64DataUrl, DecodeBase64UrlToString, initSideEffects, FileTools, _injectLTSFileTools;
var init_fileTools = __esm({
  "node_modules/@babylonjs/core/Misc/fileTools.js"() {
    init_tslib_es6();
    init_webRequest();
    init_domManagement();
    init_observable();
    init_filesInputStore();
    init_retryStrategy();
    init_error();
    init_stringTools();
    init_shaderProcessor();
    init_thinEngine();
    init_engineStore();
    init_logger();
    init_timingTools();
    Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
    LoadFileError = function(_super) {
      __extends(LoadFileError2, _super);
      function LoadFileError2(message, object) {
        var _this = _super.call(this, message, ErrorCodes.LoadFileError) || this;
        _this.name = "LoadFileError";
        BaseError._setPrototypeOf(_this, LoadFileError2.prototype);
        if (object instanceof WebRequest) {
          _this.request = object;
        } else {
          _this.file = object;
        }
        return _this;
      }
      return LoadFileError2;
    }(RuntimeError);
    RequestFileError = function(_super) {
      __extends(RequestFileError2, _super);
      function RequestFileError2(message, request) {
        var _this = _super.call(this, message, ErrorCodes.RequestFileError) || this;
        _this.request = request;
        _this.name = "RequestFileError";
        BaseError._setPrototypeOf(_this, RequestFileError2.prototype);
        return _this;
      }
      return RequestFileError2;
    }(RuntimeError);
    ReadFileError = function(_super) {
      __extends(ReadFileError2, _super);
      function ReadFileError2(message, file) {
        var _this = _super.call(this, message, ErrorCodes.ReadFileError) || this;
        _this.file = file;
        _this.name = "ReadFileError";
        BaseError._setPrototypeOf(_this, ReadFileError2.prototype);
        return _this;
      }
      return ReadFileError2;
    }(RuntimeError);
    FileToolsOptions = {
      DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
      BaseUrl: "",
      CorsBehavior: "anonymous",
      PreprocessUrl: function(url) {
        return url;
      }
    };
    _CleanUrl = function(url) {
      url = url.replace(/#/gm, "%23");
      return url;
    };
    SetCorsBehavior = function(url, element) {
      if (url && url.indexOf("data:") === 0) {
        return;
      }
      if (FileToolsOptions.CorsBehavior) {
        if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
          element.crossOrigin = FileToolsOptions.CorsBehavior;
        } else {
          var result = FileToolsOptions.CorsBehavior(url);
          if (result) {
            element.crossOrigin = result;
          }
        }
      }
    };
    LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
      var _a;
      if (mimeType === void 0) {
        mimeType = "";
      }
      var url;
      var usingObjectURL = false;
      if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        if (typeof Blob !== "undefined") {
          url = URL.createObjectURL(new Blob([input], { type: mimeType }));
          usingObjectURL = true;
        } else {
          url = "data:".concat(mimeType, ";base64,") + EncodeArrayBufferToBase64(input);
        }
      } else if (input instanceof Blob) {
        url = URL.createObjectURL(input);
        usingObjectURL = true;
      } else {
        url = _CleanUrl(input);
        url = FileToolsOptions.PreprocessUrl(input);
      }
      var engine = EngineStore.LastCreatedEngine;
      var onErrorHandler = function(exception) {
        if (onError) {
          var inputText = url || input.toString();
          onError("Error while trying to load image: ".concat(inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."), exception);
        }
      };
      if (typeof Image === "undefined" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {
        LoadFile(url, function(data) {
          engine.createImageBitmap(new Blob([data], { type: mimeType }), __assign({ premultiplyAlpha: "none" }, imageBitmapOptions)).then(function(imgBmp) {
            onLoad(imgBmp);
            if (usingObjectURL) {
              URL.revokeObjectURL(url);
            }
          }).catch(function(reason) {
            if (onError) {
              onError("Error while trying to load image: " + input, reason);
            }
          });
        }, void 0, offlineProvider || void 0, true, function(request, exception) {
          onErrorHandler(exception);
        });
        return null;
      }
      var img = new Image();
      SetCorsBehavior(url, img);
      var loadHandler = function() {
        img.removeEventListener("load", loadHandler);
        img.removeEventListener("error", errorHandler);
        onLoad(img);
        if (usingObjectURL && img.src) {
          URL.revokeObjectURL(img.src);
        }
      };
      var errorHandler = function(err) {
        img.removeEventListener("load", loadHandler);
        img.removeEventListener("error", errorHandler);
        onErrorHandler(err);
        if (usingObjectURL && img.src) {
          URL.revokeObjectURL(img.src);
        }
      };
      img.addEventListener("load", loadHandler);
      img.addEventListener("error", errorHandler);
      var noOfflineSupport = function() {
        img.src = url;
      };
      var loadFromOfflineSupport = function() {
        if (offlineProvider) {
          offlineProvider.loadImage(url, img);
        }
      };
      if (url.substr(0, 5) !== "blob:" && url.substr(0, 5) !== "data:" && offlineProvider && offlineProvider.enableTexturesOffline) {
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
      } else {
        if (url.indexOf("file:") !== -1) {
          var textureName = decodeURIComponent(url.substring(5).toLowerCase());
          if (FilesInputStore.FilesToLoad[textureName]) {
            try {
              var blobURL = void 0;
              try {
                blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
              } catch (ex) {
                blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
              }
              img.src = blobURL;
              usingObjectURL = true;
            } catch (e) {
              img.src = "";
            }
            return img;
          }
        }
        noOfflineSupport();
      }
      return img;
    };
    ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
      var reader = new FileReader();
      var fileRequest = {
        onCompleteObservable: new Observable(),
        abort: function() {
          return reader.abort();
        }
      };
      reader.onloadend = function() {
        return fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      };
      if (onError) {
        reader.onerror = function() {
          onError(new ReadFileError("Unable to read ".concat(file.name), file));
        };
      }
      reader.onload = function(e) {
        onSuccess(e.target["result"]);
      };
      if (onProgress) {
        reader.onprogress = onProgress;
      }
      if (!useArrayBuffer) {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
      return fileRequest;
    };
    LoadFile = function(fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
      if (fileOrUrl.name) {
        return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
          onError(void 0, error);
        } : void 0);
      }
      var url = fileOrUrl;
      if (url.indexOf("file:") !== -1) {
        var fileName = decodeURIComponent(url.substring(5).toLowerCase());
        if (fileName.indexOf("./") === 0) {
          fileName = fileName.substring(2);
        }
        var file = FilesInputStore.FilesToLoad[fileName];
        if (file) {
          return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
            return onError(void 0, new LoadFileError(error.message, error.file));
          } : void 0);
        }
      }
      if (IsBase64DataUrl(url)) {
        var fileRequest_1 = {
          onCompleteObservable: new Observable(),
          abort: function() {
            return function() {
            };
          }
        };
        try {
          onSuccess(useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url));
        } catch (error) {
          if (onError) {
            onError(void 0, error);
          } else {
            Logger.Error(error.message || "Failed to parse the Data URL");
          }
        }
        TimingTools.SetImmediate(function() {
          fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
        });
        return fileRequest_1;
      }
      return RequestFile(url, function(data, request) {
        onSuccess(data, request ? request.responseURL : void 0);
      }, onProgress, offlineProvider, useArrayBuffer, onError ? function(error) {
        onError(error.request, new LoadFileError(error.message, error.request));
      } : void 0, onOpened);
    };
    RequestFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
      url = _CleanUrl(url);
      url = FileToolsOptions.PreprocessUrl(url);
      var loadUrl = FileToolsOptions.BaseUrl + url;
      var aborted = false;
      var fileRequest = {
        onCompleteObservable: new Observable(),
        abort: function() {
          return aborted = true;
        }
      };
      var requestFile = function() {
        var request = new WebRequest();
        var retryHandle = null;
        var onReadyStateChange;
        var unbindEvents = function() {
          if (!request) {
            return;
          }
          if (onProgress) {
            request.removeEventListener("progress", onProgress);
          }
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          request.removeEventListener("loadend", onLoadEnd);
        };
        var onLoadEnd = function() {
          unbindEvents();
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          fileRequest.onCompleteObservable.clear();
          onProgress = void 0;
          onReadyStateChange = null;
          onLoadEnd = null;
          onError = void 0;
          onOpened = void 0;
          onSuccess = void 0;
        };
        fileRequest.abort = function() {
          aborted = true;
          if (onLoadEnd) {
            onLoadEnd();
          }
          if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
            request.abort();
          }
          if (retryHandle !== null) {
            clearTimeout(retryHandle);
            retryHandle = null;
          }
          request = null;
        };
        var handleError = function(error) {
          var message = error.message || "Unknown error";
          if (onError && request) {
            onError(new RequestFileError(message, request));
          } else {
            Logger.Error(message);
          }
        };
        var retryLoop = function(retryIndex) {
          if (!request) {
            return;
          }
          request.open("GET", loadUrl);
          if (onOpened) {
            try {
              onOpened(request);
            } catch (e) {
              handleError(e);
              return;
            }
          }
          if (useArrayBuffer) {
            request.responseType = "arraybuffer";
          }
          if (onProgress) {
            request.addEventListener("progress", onProgress);
          }
          if (onLoadEnd) {
            request.addEventListener("loadend", onLoadEnd);
          }
          onReadyStateChange = function() {
            if (aborted || !request) {
              return;
            }
            if (request.readyState === (XMLHttpRequest.DONE || 4)) {
              if (onReadyStateChange) {
                request.removeEventListener("readystatechange", onReadyStateChange);
              }
              if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
                try {
                  if (onSuccess) {
                    onSuccess(useArrayBuffer ? request.response : request.responseText, request);
                  }
                } catch (e) {
                  handleError(e);
                }
                return;
              }
              var retryStrategy = FileToolsOptions.DefaultRetryStrategy;
              if (retryStrategy) {
                var waitTime = retryStrategy(loadUrl, request, retryIndex);
                if (waitTime !== -1) {
                  unbindEvents();
                  request = new WebRequest();
                  retryHandle = setTimeout(function() {
                    return retryLoop(retryIndex + 1);
                  }, waitTime);
                  return;
                }
              }
              var error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
              if (onError) {
                onError(error);
              }
            }
          };
          request.addEventListener("readystatechange", onReadyStateChange);
          request.send();
        };
        retryLoop(0);
      };
      if (offlineProvider && offlineProvider.enableSceneOffline) {
        var noOfflineSupport_1 = function(request) {
          if (request && request.status > 400) {
            if (onError) {
              onError(request);
            }
          } else {
            requestFile();
          }
        };
        var loadFromOfflineSupport = function() {
          if (offlineProvider) {
            offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, function(data) {
              if (!aborted && onSuccess) {
                onSuccess(data);
              }
              fileRequest.onCompleteObservable.notifyObservers(fileRequest);
            }, onProgress ? function(event) {
              if (!aborted && onProgress) {
                onProgress(event);
              }
            } : void 0, noOfflineSupport_1, useArrayBuffer);
          }
        };
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);
      } else {
        requestFile();
      }
      return fileRequest;
    };
    IsFileURL = function() {
      return typeof location !== "undefined" && location.protocol === "file:";
    };
    IsBase64DataUrl = function(uri) {
      return Base64DataUrlRegEx.test(uri);
    };
    DecodeBase64UrlToString = function(uri) {
      return DecodeBase64ToString(uri.split(",")[1]);
    };
    initSideEffects = function() {
      ThinEngine._FileToolsLoadImage = LoadImage;
      ThinEngine._FileToolsLoadFile = LoadFile;
      ShaderProcessor._FileToolsLoadFile = LoadFile;
    };
    initSideEffects();
    _injectLTSFileTools = function(DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) {
      FileTools = {
        DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
        DecodeBase64UrlToString: DecodeBase64UrlToString2,
        DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
        BaseUrl: FileToolsOptions2.BaseUrl,
        CorsBehavior: FileToolsOptions2.CorsBehavior,
        PreprocessUrl: FileToolsOptions2.PreprocessUrl,
        IsBase64DataUrl: IsBase64DataUrl2,
        IsFileURL: IsFileURL2,
        LoadFile: LoadFile2,
        LoadImage: LoadImage2,
        ReadFile: ReadFile2,
        RequestFile: RequestFile2,
        SetCorsBehavior: SetCorsBehavior2
      };
      Object.defineProperty(FileTools, "DefaultRetryStrategy", {
        get: function() {
          return FileToolsOptions2.DefaultRetryStrategy;
        },
        set: function(value) {
          FileToolsOptions2.DefaultRetryStrategy = value;
        }
      });
      Object.defineProperty(FileTools, "BaseUrl", {
        get: function() {
          return FileToolsOptions2.BaseUrl;
        },
        set: function(value) {
          FileToolsOptions2.BaseUrl = value;
        }
      });
      Object.defineProperty(FileTools, "PreprocessUrl", {
        get: function() {
          return FileToolsOptions2.PreprocessUrl;
        },
        set: function(value) {
          FileToolsOptions2.PreprocessUrl = value;
        }
      });
      Object.defineProperty(FileTools, "CorsBehavior", {
        get: function() {
          return FileToolsOptions2.CorsBehavior;
        },
        set: function(value) {
          FileToolsOptions2.CorsBehavior = value;
        }
      });
    };
    _injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);
  }
});

// node_modules/@babylonjs/core/Misc/promise.js
var PromiseStates, FulFillmentAgregator, InternalPromise, PromisePolyfill;
var init_promise = __esm({
  "node_modules/@babylonjs/core/Misc/promise.js"() {
    (function(PromiseStates2) {
      PromiseStates2[PromiseStates2["Pending"] = 0] = "Pending";
      PromiseStates2[PromiseStates2["Fulfilled"] = 1] = "Fulfilled";
      PromiseStates2[PromiseStates2["Rejected"] = 2] = "Rejected";
    })(PromiseStates || (PromiseStates = {}));
    FulFillmentAgregator = function() {
      function FulFillmentAgregator2() {
        this.count = 0;
        this.target = 0;
        this.results = [];
      }
      return FulFillmentAgregator2;
    }();
    InternalPromise = function() {
      function InternalPromise2(resolver) {
        var _this = this;
        this._state = PromiseStates.Pending;
        this._children = new Array();
        this._rejectWasConsumed = false;
        if (!resolver) {
          return;
        }
        try {
          resolver(function(value) {
            _this._resolve(value);
          }, function(reason) {
            _this._reject(reason);
          });
        } catch (e) {
          this._reject(e);
        }
      }
      Object.defineProperty(InternalPromise2.prototype, "_result", {
        get: function() {
          return this._resultValue;
        },
        set: function(value) {
          this._resultValue = value;
          if (this._parent && this._parent._result === void 0) {
            this._parent._result = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      InternalPromise2.prototype.catch = function(onRejected) {
        return this.then(void 0, onRejected);
      };
      InternalPromise2.prototype.then = function(onFulfilled, onRejected) {
        var _this = this;
        var newPromise = new InternalPromise2();
        newPromise._onFulfilled = onFulfilled;
        newPromise._onRejected = onRejected;
        this._children.push(newPromise);
        newPromise._parent = this;
        if (this._state !== PromiseStates.Pending) {
          setTimeout(function() {
            if (_this._state === PromiseStates.Fulfilled || _this._rejectWasConsumed) {
              newPromise._resolve(_this._result);
            } else {
              newPromise._reject(_this._reason);
            }
          });
        }
        return newPromise;
      };
      InternalPromise2.prototype._moveChildren = function(children) {
        var _a;
        var _this = this;
        (_a = this._children).push.apply(_a, children.splice(0, children.length));
        this._children.forEach(function(child2) {
          child2._parent = _this;
        });
        if (this._state === PromiseStates.Fulfilled) {
          for (var _i = 0, _b = this._children; _i < _b.length; _i++) {
            var child = _b[_i];
            child._resolve(this._result);
          }
        } else if (this._state === PromiseStates.Rejected) {
          for (var _c = 0, _d = this._children; _c < _d.length; _c++) {
            var child = _d[_c];
            child._reject(this._reason);
          }
        }
      };
      InternalPromise2.prototype._resolve = function(value) {
        try {
          this._state = PromiseStates.Fulfilled;
          var returnedValue = null;
          if (this._onFulfilled) {
            returnedValue = this._onFulfilled(value);
          }
          if (returnedValue !== void 0 && returnedValue !== null) {
            if (returnedValue._state !== void 0) {
              var returnedPromise = returnedValue;
              returnedPromise._parent = this;
              returnedPromise._moveChildren(this._children);
              value = returnedPromise._result;
            } else {
              value = returnedValue;
            }
          }
          this._result = value;
          for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var child = _a[_i];
            child._resolve(value);
          }
          this._children.length = 0;
          delete this._onFulfilled;
          delete this._onRejected;
        } catch (e) {
          this._reject(e, true);
        }
      };
      InternalPromise2.prototype._reject = function(reason, onLocalThrow) {
        if (onLocalThrow === void 0) {
          onLocalThrow = false;
        }
        this._state = PromiseStates.Rejected;
        this._reason = reason;
        if (this._onRejected && !onLocalThrow) {
          try {
            this._onRejected(reason);
            this._rejectWasConsumed = true;
          } catch (e) {
            reason = e;
          }
        }
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
          var child = _a[_i];
          if (this._rejectWasConsumed) {
            child._resolve(null);
          } else {
            child._reject(reason);
          }
        }
        this._children.length = 0;
        delete this._onFulfilled;
        delete this._onRejected;
      };
      InternalPromise2.resolve = function(value) {
        var newPromise = new InternalPromise2();
        newPromise._resolve(value);
        return newPromise;
      };
      InternalPromise2._RegisterForFulfillment = function(promise, agregator, index) {
        promise.then(function(value) {
          agregator.results[index] = value;
          agregator.count++;
          if (agregator.count === agregator.target) {
            agregator.rootPromise._resolve(agregator.results);
          }
          return null;
        }, function(reason) {
          if (agregator.rootPromise._state !== PromiseStates.Rejected) {
            agregator.rootPromise._reject(reason);
          }
        });
      };
      InternalPromise2.all = function(promises) {
        var newPromise = new InternalPromise2();
        var agregator = new FulFillmentAgregator();
        agregator.target = promises.length;
        agregator.rootPromise = newPromise;
        if (promises.length) {
          for (var index = 0; index < promises.length; index++) {
            InternalPromise2._RegisterForFulfillment(promises[index], agregator, index);
          }
        } else {
          newPromise._resolve([]);
        }
        return newPromise;
      };
      InternalPromise2.race = function(promises) {
        var newPromise = new InternalPromise2();
        if (promises.length) {
          for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {
            var promise = promises_1[_i];
            promise.then(function(value) {
              if (newPromise) {
                newPromise._resolve(value);
                newPromise = null;
              }
              return null;
            }, function(reason) {
              if (newPromise) {
                newPromise._reject(reason);
                newPromise = null;
              }
            });
          }
        }
        return newPromise;
      };
      return InternalPromise2;
    }();
    PromisePolyfill = function() {
      function PromisePolyfill2() {
      }
      PromisePolyfill2.Apply = function(force) {
        if (force === void 0) {
          force = false;
        }
        if (force || typeof Promise === "undefined") {
          var root = window;
          root.Promise = InternalPromise;
        }
      };
      return PromisePolyfill2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/guid.js
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var GUID;
var init_guid = __esm({
  "node_modules/@babylonjs/core/Misc/guid.js"() {
    GUID = {
      RandomId: RandomGUID
    };
  }
});

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools;
var init_instantiationTools = __esm({
  "node_modules/@babylonjs/core/Misc/instantiationTools.js"() {
    init_logger();
    init_typeStore();
    InstantiationTools = function() {
      function InstantiationTools2() {
      }
      InstantiationTools2.Instantiate = function(className2) {
        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className2]) {
          return this.RegisteredExternalClasses[className2];
        }
        var internalClass = GetClass(className2);
        if (internalClass) {
          return internalClass;
        }
        Logger.Warn(className2 + " not found, you may have missed an import.");
        var arr = className2.split(".");
        var fn = window || this;
        for (var i = 0, len = arr.length; i < len; i++) {
          fn = fn[arr[i]];
        }
        if (typeof fn !== "function") {
          return null;
        }
        return fn;
      };
      InstantiationTools2.RegisteredExternalClasses = {};
      return InstantiationTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/sliceTools.js
var SliceTools;
var init_sliceTools = __esm({
  "node_modules/@babylonjs/core/Misc/sliceTools.js"() {
    SliceTools = function() {
      function SliceTools2() {
      }
      SliceTools2.Slice = function(data, start, end) {
        if (data.slice) {
          return data.slice(start, end);
        }
        return Array.prototype.slice.call(data, start, end);
      };
      SliceTools2.SliceToArray = function(data, start, end) {
        if (Array.isArray(data)) {
          return data.slice(start, end);
        }
        return Array.prototype.slice.call(data, start, end);
      };
      return SliceTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/tools.js
function className(name, module) {
  return function(target) {
    target["__bjsclassName__"] = name;
    target["__bjsmoduleName__"] = module != null ? module : null;
  };
}
var Tools, AsyncLoop;
var init_tools = __esm({
  "node_modules/@babylonjs/core/Misc/tools.js"() {
    init_tslib_es6();
    init_observable();
    init_domManagement();
    init_logger();
    init_deepCopier();
    init_precisionDate();
    init_devTools();
    init_webRequest();
    init_engineStore();
    init_fileTools();
    init_promise();
    init_timingTools();
    init_instantiationTools();
    init_guid();
    init_sliceTools();
    Tools = function() {
      function Tools2() {
      }
      Object.defineProperty(Tools2, "BaseUrl", {
        get: function() {
          return FileToolsOptions.BaseUrl;
        },
        set: function(value) {
          FileToolsOptions.BaseUrl = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "DefaultRetryStrategy", {
        get: function() {
          return FileToolsOptions.DefaultRetryStrategy;
        },
        set: function(strategy) {
          FileToolsOptions.DefaultRetryStrategy = strategy;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "CorsBehavior", {
        get: function() {
          return FileToolsOptions.CorsBehavior;
        },
        set: function(value) {
          FileToolsOptions.CorsBehavior = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "UseFallbackTexture", {
        get: function() {
          return EngineStore.UseFallbackTexture;
        },
        set: function(value) {
          EngineStore.UseFallbackTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "RegisteredExternalClasses", {
        get: function() {
          return InstantiationTools.RegisteredExternalClasses;
        },
        set: function(classes) {
          InstantiationTools.RegisteredExternalClasses = classes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "fallbackTexture", {
        get: function() {
          return EngineStore.FallbackTexture;
        },
        set: function(value) {
          EngineStore.FallbackTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      Tools2.FetchToRef = function(u, v, width, height, pixels, color) {
        var wrappedU = Math.abs(u) * width % width | 0;
        var wrappedV = Math.abs(v) * height % height | 0;
        var position = (wrappedU + wrappedV * width) * 4;
        color.r = pixels[position] / 255;
        color.g = pixels[position + 1] / 255;
        color.b = pixels[position + 2] / 255;
        color.a = pixels[position + 3] / 255;
      };
      Tools2.Mix = function(a, b, alpha) {
        return a * (1 - alpha) + b * alpha;
      };
      Tools2.Instantiate = function(className2) {
        return InstantiationTools.Instantiate(className2);
      };
      Tools2.Slice = function(data, start, end) {
        return SliceTools.Slice(data, start, end);
      };
      Tools2.SliceToArray = function(data, start, end) {
        return SliceTools.SliceToArray(data, start, end);
      };
      Tools2.SetImmediate = function(action) {
        TimingTools.SetImmediate(action);
      };
      Tools2.IsExponentOfTwo = function(value) {
        var count = 1;
        do {
          count *= 2;
        } while (count < value);
        return count === value;
      };
      Tools2.FloatRound = function(value) {
        if (Math.fround) {
          return Math.fround(value);
        }
        return Tools2._TmpFloatArray[0] = value, Tools2._TmpFloatArray[0];
      };
      Tools2.GetFilename = function(path) {
        var index = path.lastIndexOf("/");
        if (index < 0) {
          return path;
        }
        return path.substring(index + 1);
      };
      Tools2.GetFolderPath = function(uri, returnUnchangedIfNoSlash) {
        if (returnUnchangedIfNoSlash === void 0) {
          returnUnchangedIfNoSlash = false;
        }
        var index = uri.lastIndexOf("/");
        if (index < 0) {
          if (returnUnchangedIfNoSlash) {
            return uri;
          }
          return "";
        }
        return uri.substring(0, index + 1);
      };
      Tools2.ToDegrees = function(angle) {
        return angle * 180 / Math.PI;
      };
      Tools2.ToRadians = function(angle) {
        return angle * Math.PI / 180;
      };
      Tools2.MakeArray = function(obj, allowsNullUndefined) {
        if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
          return null;
        }
        return Array.isArray(obj) ? obj : [obj];
      };
      Tools2.GetPointerPrefix = function(engine) {
        var eventPrefix = "pointer";
        if (IsWindowObjectExist() && !window.PointerEvent) {
          eventPrefix = "mouse";
        }
        if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
          eventPrefix = "mouse";
        }
        return eventPrefix;
      };
      Tools2.SetCorsBehavior = function(url, element) {
        SetCorsBehavior(url, element);
      };
      Tools2.CleanUrl = function(url) {
        url = url.replace(/#/gm, "%23");
        return url;
      };
      Object.defineProperty(Tools2, "PreprocessUrl", {
        get: function() {
          return FileToolsOptions.PreprocessUrl;
        },
        set: function(processor) {
          FileToolsOptions.PreprocessUrl = processor;
        },
        enumerable: false,
        configurable: true
      });
      Tools2.LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
        return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
      };
      Tools2.LoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
      };
      Tools2.LoadFileAsync = function(url, useArrayBuffer) {
        if (useArrayBuffer === void 0) {
          useArrayBuffer = true;
        }
        return new Promise(function(resolve, reject) {
          LoadFile(url, function(data) {
            resolve(data);
          }, void 0, void 0, useArrayBuffer, function(request, exception) {
            reject(exception);
          });
        });
      };
      Tools2.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
        if (!IsWindowObjectExist()) {
          return;
        }
        var head = document.getElementsByTagName("head")[0];
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        script.setAttribute("src", scriptUrl);
        if (scriptId) {
          script.id = scriptId;
        }
        script.onload = function() {
          if (onSuccess) {
            onSuccess();
          }
        };
        script.onerror = function(e) {
          if (onError) {
            onError("Unable to load script '".concat(scriptUrl, "'"), e);
          }
        };
        head.appendChild(script);
      };
      Tools2.LoadScriptAsync = function(scriptUrl) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.LoadScript(scriptUrl, function() {
            resolve();
          }, function(message, exception) {
            reject(exception);
          });
        });
      };
      Tools2.ReadFileAsDataURL = function(fileToLoad, callback, progressCallback) {
        var reader = new FileReader();
        var request = {
          onCompleteObservable: new Observable(),
          abort: function() {
            return reader.abort();
          }
        };
        reader.onloadend = function() {
          request.onCompleteObservable.notifyObservers(request);
        };
        reader.onload = function(e) {
          callback(e.target["result"]);
        };
        reader.onprogress = progressCallback;
        reader.readAsDataURL(fileToLoad);
        return request;
      };
      Tools2.ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
        return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
      };
      Tools2.FileAsURL = function(content) {
        var fileBlob = new Blob([content]);
        var url = window.URL || window.webkitURL;
        var link = url.createObjectURL(fileBlob);
        return link;
      };
      Tools2.Format = function(value, decimals) {
        if (decimals === void 0) {
          decimals = 2;
        }
        return value.toFixed(decimals);
      };
      Tools2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
        DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
      };
      Tools2.IsEmpty = function(obj) {
        for (var i in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, i)) {
            return false;
          }
        }
        return true;
      };
      Tools2.RegisterTopRootEvents = function(windowElement, events) {
        for (var index = 0; index < events.length; index++) {
          var event_1 = events[index];
          windowElement.addEventListener(event_1.name, event_1.handler, false);
          try {
            if (window.parent) {
              window.parent.addEventListener(event_1.name, event_1.handler, false);
            }
          } catch (e) {
          }
        }
      };
      Tools2.UnregisterTopRootEvents = function(windowElement, events) {
        for (var index = 0; index < events.length; index++) {
          var event_2 = events[index];
          windowElement.removeEventListener(event_2.name, event_2.handler);
          try {
            if (windowElement.parent) {
              windowElement.parent.removeEventListener(event_2.name, event_2.handler);
            }
          } catch (e) {
          }
        }
      };
      Tools2.DumpFramebuffer = function(width, height, engine, successCallback, mimeType, fileName) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        return __awaiter(this, void 0, void 0, function() {
          var bufferView, data;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, engine.readPixels(0, 0, width, height)];
              case 1:
                bufferView = _a.sent();
                data = new Uint8Array(bufferView.buffer);
                Tools2.DumpData(width, height, data, successCallback, mimeType, fileName, true);
                return [2];
            }
          });
        });
      };
      Tools2.DumpData = function(width, height, data, successCallback, mimeType, fileName, invertY, toArrayBuffer, quality) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (toArrayBuffer === void 0) {
          toArrayBuffer = false;
        }
        if (!Tools2._ScreenshotCanvas) {
          Tools2._ScreenshotCanvas = document.createElement("canvas");
        }
        Tools2._ScreenshotCanvas.width = width;
        Tools2._ScreenshotCanvas.height = height;
        var context = Tools2._ScreenshotCanvas.getContext("2d");
        if (context) {
          if (data instanceof Float32Array) {
            var data2 = new Uint8Array(data.length);
            var n = data.length;
            while (n--) {
              var v = data[n];
              data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);
            }
            data = data2;
          }
          var imageData = context.createImageData(width, height);
          var castData = imageData.data;
          castData.set(data);
          context.putImageData(imageData, 0, 0);
          var canvas = Tools2._ScreenshotCanvas;
          if (invertY) {
            var canvas2 = document.createElement("canvas");
            canvas2.width = width;
            canvas2.height = height;
            var ctx2 = canvas2.getContext("2d");
            if (!ctx2) {
              return;
            }
            ctx2.translate(0, height);
            ctx2.scale(1, -1);
            ctx2.drawImage(Tools2._ScreenshotCanvas, 0, 0);
            canvas = canvas2;
          }
          if (toArrayBuffer) {
            Tools2.ToBlob(canvas, function(blob) {
              var fileReader = new FileReader();
              fileReader.onload = function(event) {
                var arrayBuffer = event.target.result;
                if (successCallback) {
                  successCallback(arrayBuffer);
                }
              };
              fileReader.readAsArrayBuffer(blob);
            }, mimeType, quality);
          } else {
            Tools2.EncodeScreenshotCanvasData(successCallback, mimeType, fileName, canvas, quality);
          }
        }
      };
      Tools2.DumpDataAsync = function(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (toArrayBuffer === void 0) {
          toArrayBuffer = false;
        }
        return new Promise(function(resolve) {
          Tools2.DumpData(width, height, data, function(result) {
            return resolve(result);
          }, mimeType, fileName, invertY, toArrayBuffer, quality);
        });
      };
      Tools2.ToBlob = function(canvas, successCallback, mimeType, quality) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (!canvas.toBlob) {
          canvas.toBlob = function(callback, type, quality2) {
            var _this = this;
            setTimeout(function() {
              var binStr = atob(_this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
              for (var i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
              }
              callback(new Blob([arr]));
            });
          };
        }
        canvas.toBlob(function(blob) {
          successCallback(blob);
        }, mimeType, quality);
      };
      Tools2.EncodeScreenshotCanvasData = function(successCallback, mimeType, fileName, canvas, quality) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (successCallback) {
          var base64Image = (canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas).toDataURL(mimeType, quality);
          successCallback(base64Image);
        } else {
          this.ToBlob(canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas, function(blob) {
            if ("download" in document.createElement("a")) {
              if (!fileName) {
                var date = new Date();
                var stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
                fileName = "screenshot_" + stringDate + ".png";
              }
              Tools2.Download(blob, fileName);
            } else {
              if (blob) {
                var url_1 = URL.createObjectURL(blob);
                var newWindow = window.open("");
                if (!newWindow) {
                  return;
                }
                var img = newWindow.document.createElement("img");
                img.onload = function() {
                  URL.revokeObjectURL(url_1);
                };
                img.src = url_1;
                newWindow.document.body.appendChild(img);
              }
            }
          }, mimeType, quality);
        }
      };
      Tools2.Download = function(blob, fileName) {
        if (navigator && navigator.msSaveBlob) {
          navigator.msSaveBlob(blob, fileName);
          return;
        }
        var url = window.URL.createObjectURL(blob);
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style.display = "none";
        a.href = url;
        a.download = fileName;
        a.addEventListener("click", function() {
          if (a.parentElement) {
            a.parentElement.removeChild(a);
          }
        });
        a.click();
        window.URL.revokeObjectURL(url);
      };
      Tools2.BackCompatCameraNoPreventDefault = function(args) {
        if (typeof args[0] === "boolean") {
          return args[0];
        } else if (typeof args[1] === "boolean") {
          return args[1];
        }
        return false;
      };
      Tools2.CreateScreenshot = function(engine, camera, size, successCallback, mimeType) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        throw _WarnImport("ScreenshotTools");
      };
      Tools2.CreateScreenshotAsync = function(engine, camera, size, mimeType) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        throw _WarnImport("ScreenshotTools");
      };
      Tools2.CreateScreenshotUsingRenderTarget = function(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (samples === void 0) {
          samples = 1;
        }
        if (antialiasing === void 0) {
          antialiasing = false;
        }
        throw _WarnImport("ScreenshotTools");
      };
      Tools2.CreateScreenshotUsingRenderTargetAsync = function(engine, camera, size, mimeType, samples, antialiasing, fileName) {
        if (mimeType === void 0) {
          mimeType = "image/png";
        }
        if (samples === void 0) {
          samples = 1;
        }
        if (antialiasing === void 0) {
          antialiasing = false;
        }
        throw _WarnImport("ScreenshotTools");
      };
      Tools2.RandomId = function() {
        return RandomGUID();
      };
      Tools2.IsBase64 = function(uri) {
        return IsBase64DataUrl(uri);
      };
      Tools2.DecodeBase64 = function(uri) {
        return DecodeBase64UrlToBinary(uri);
      };
      Object.defineProperty(Tools2, "errorsCount", {
        get: function() {
          return Logger.errorsCount;
        },
        enumerable: false,
        configurable: true
      });
      Tools2.Log = function(message) {
        Logger.Log(message);
      };
      Tools2.Warn = function(message) {
        Logger.Warn(message);
      };
      Tools2.Error = function(message) {
        Logger.Error(message);
      };
      Object.defineProperty(Tools2, "LogCache", {
        get: function() {
          return Logger.LogCache;
        },
        enumerable: false,
        configurable: true
      });
      Tools2.ClearLogCache = function() {
        Logger.ClearLogCache();
      };
      Object.defineProperty(Tools2, "LogLevels", {
        set: function(level) {
          Logger.LogLevels = level;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tools2, "PerformanceLogLevel", {
        set: function(level) {
          if ((level & Tools2.PerformanceUserMarkLogLevel) === Tools2.PerformanceUserMarkLogLevel) {
            Tools2.StartPerformanceCounter = Tools2._StartUserMark;
            Tools2.EndPerformanceCounter = Tools2._EndUserMark;
            return;
          }
          if ((level & Tools2.PerformanceConsoleLogLevel) === Tools2.PerformanceConsoleLogLevel) {
            Tools2.StartPerformanceCounter = Tools2._StartPerformanceConsole;
            Tools2.EndPerformanceCounter = Tools2._EndPerformanceConsole;
            return;
          }
          Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
          Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
        },
        enumerable: false,
        configurable: true
      });
      Tools2._StartPerformanceCounterDisabled = function(counterName, condition) {
      };
      Tools2._EndPerformanceCounterDisabled = function(counterName, condition) {
      };
      Tools2._StartUserMark = function(counterName, condition) {
        if (condition === void 0) {
          condition = true;
        }
        if (!Tools2._Performance) {
          if (!IsWindowObjectExist()) {
            return;
          }
          Tools2._Performance = window.performance;
        }
        if (!condition || !Tools2._Performance.mark) {
          return;
        }
        Tools2._Performance.mark(counterName + "-Begin");
      };
      Tools2._EndUserMark = function(counterName, condition) {
        if (condition === void 0) {
          condition = true;
        }
        if (!condition || !Tools2._Performance.mark) {
          return;
        }
        Tools2._Performance.mark(counterName + "-End");
        Tools2._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
      };
      Tools2._StartPerformanceConsole = function(counterName, condition) {
        if (condition === void 0) {
          condition = true;
        }
        if (!condition) {
          return;
        }
        Tools2._StartUserMark(counterName, condition);
        if (console.time) {
          console.time(counterName);
        }
      };
      Tools2._EndPerformanceConsole = function(counterName, condition) {
        if (condition === void 0) {
          condition = true;
        }
        if (!condition) {
          return;
        }
        Tools2._EndUserMark(counterName, condition);
        console.timeEnd(counterName);
      };
      Object.defineProperty(Tools2, "Now", {
        get: function() {
          return PrecisionDate.Now;
        },
        enumerable: false,
        configurable: true
      });
      Tools2.GetClassName = function(object, isType) {
        if (isType === void 0) {
          isType = false;
        }
        var name = null;
        if (!isType && object.getClassName) {
          name = object.getClassName();
        } else {
          if (object instanceof Object) {
            var classObj = isType ? object : Object.getPrototypeOf(object);
            name = classObj.constructor["__bjsclassName__"];
          }
          if (!name) {
            name = typeof object;
          }
        }
        return name;
      };
      Tools2.First = function(array, predicate) {
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
          var el = array_1[_i];
          if (predicate(el)) {
            return el;
          }
        }
        return null;
      };
      Tools2.getFullClassName = function(object, isType) {
        if (isType === void 0) {
          isType = false;
        }
        var className2 = null;
        var moduleName = null;
        if (!isType && object.getClassName) {
          className2 = object.getClassName();
        } else {
          if (object instanceof Object) {
            var classObj = isType ? object : Object.getPrototypeOf(object);
            className2 = classObj.constructor["__bjsclassName__"];
            moduleName = classObj.constructor["__bjsmoduleName__"];
          }
          if (!className2) {
            className2 = typeof object;
          }
        }
        if (!className2) {
          return null;
        }
        return (moduleName != null ? moduleName + "." : "") + className2;
      };
      Tools2.DelayAsync = function(delay) {
        return new Promise(function(resolve) {
          setTimeout(function() {
            resolve();
          }, delay);
        });
      };
      Tools2.IsSafari = function() {
        if (!IsNavigatorAvailable()) {
          return false;
        }
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      };
      Tools2.UseCustomRequestHeaders = false;
      Tools2.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
      Tools2._TmpFloatArray = new Float32Array(1);
      Tools2.GetDOMTextContent = GetDOMTextContent;
      Tools2.GetAbsoluteUrl = typeof document === "object" ? function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
      } : typeof URL === "function" && typeof location === "object" ? function(url) {
        return new URL(url, location.origin).href;
      } : function() {
        throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
      };
      Tools2.NoneLogLevel = Logger.NoneLogLevel;
      Tools2.MessageLogLevel = Logger.MessageLogLevel;
      Tools2.WarningLogLevel = Logger.WarningLogLevel;
      Tools2.ErrorLogLevel = Logger.ErrorLogLevel;
      Tools2.AllLogLevel = Logger.AllLogLevel;
      Tools2.IsWindowObjectExist = IsWindowObjectExist;
      Tools2.PerformanceNoneLogLevel = 0;
      Tools2.PerformanceUserMarkLogLevel = 1;
      Tools2.PerformanceConsoleLogLevel = 2;
      Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
      Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
      return Tools2;
    }();
    AsyncLoop = function() {
      function AsyncLoop2(iterations, func, successCallback, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        this.iterations = iterations;
        this.index = offset - 1;
        this._done = false;
        this._fn = func;
        this._successCallback = successCallback;
      }
      AsyncLoop2.prototype.executeNext = function() {
        if (!this._done) {
          if (this.index + 1 < this.iterations) {
            ++this.index;
            this._fn(this);
          } else {
            this.breakLoop();
          }
        }
      };
      AsyncLoop2.prototype.breakLoop = function() {
        this._done = true;
        this._successCallback();
      };
      AsyncLoop2.Run = function(iterations, fn, successCallback, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var loop = new AsyncLoop2(iterations, fn, successCallback, offset);
        loop.executeNext();
        return loop;
      };
      AsyncLoop2.SyncAsyncForLoop = function(iterations, syncedIterations, fn, callback, breakFunction, timeout) {
        if (timeout === void 0) {
          timeout = 0;
        }
        return AsyncLoop2.Run(Math.ceil(iterations / syncedIterations), function(loop) {
          if (breakFunction && breakFunction()) {
            loop.breakLoop();
          } else {
            setTimeout(function() {
              for (var i = 0; i < syncedIterations; ++i) {
                var iteration = loop.index * syncedIterations + i;
                if (iteration >= iterations) {
                  break;
                }
                fn(iteration);
                if (breakFunction && breakFunction()) {
                  loop.breakLoop();
                  break;
                }
              }
              loop.executeNext();
            }, timeout);
          }
        }, callback);
      };
      return AsyncLoop2;
    }();
    EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
    PromisePolyfill.Apply();
  }
});

// node_modules/@babylonjs/core/Misc/smartArray.js
var SmartArray, SmartArrayNoDuplicate;
var init_smartArray = __esm({
  "node_modules/@babylonjs/core/Misc/smartArray.js"() {
    init_tslib_es6();
    SmartArray = function() {
      function SmartArray2(capacity) {
        this.length = 0;
        this.data = new Array(capacity);
        this._id = SmartArray2._GlobalId++;
      }
      SmartArray2.prototype.push = function(value) {
        this.data[this.length++] = value;
        if (this.length > this.data.length) {
          this.data.length *= 2;
        }
      };
      SmartArray2.prototype.forEach = function(func) {
        for (var index = 0; index < this.length; index++) {
          func(this.data[index]);
        }
      };
      SmartArray2.prototype.sort = function(compareFn) {
        this.data.sort(compareFn);
      };
      SmartArray2.prototype.reset = function() {
        this.length = 0;
      };
      SmartArray2.prototype.dispose = function() {
        this.reset();
        if (this.data) {
          this.data.length = 0;
          this.data = [];
        }
      };
      SmartArray2.prototype.concat = function(array) {
        if (array.length === 0) {
          return;
        }
        if (this.length + array.length > this.data.length) {
          this.data.length = (this.length + array.length) * 2;
        }
        for (var index = 0; index < array.length; index++) {
          this.data[this.length++] = (array.data || array)[index];
        }
      };
      SmartArray2.prototype.indexOf = function(value) {
        var position = this.data.indexOf(value);
        if (position >= this.length) {
          return -1;
        }
        return position;
      };
      SmartArray2.prototype.contains = function(value) {
        return this.indexOf(value) !== -1;
      };
      SmartArray2._GlobalId = 0;
      return SmartArray2;
    }();
    SmartArrayNoDuplicate = function(_super) {
      __extends(SmartArrayNoDuplicate2, _super);
      function SmartArrayNoDuplicate2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._duplicateId = 0;
        return _this;
      }
      SmartArrayNoDuplicate2.prototype.push = function(value) {
        _super.prototype.push.call(this, value);
        if (!value.__smartArrayFlags) {
          value.__smartArrayFlags = {};
        }
        value.__smartArrayFlags[this._id] = this._duplicateId;
      };
      SmartArrayNoDuplicate2.prototype.pushNoDuplicate = function(value) {
        if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
          return false;
        }
        this.push(value);
        return true;
      };
      SmartArrayNoDuplicate2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._duplicateId++;
      };
      SmartArrayNoDuplicate2.prototype.concatWithNoDuplicate = function(array) {
        if (array.length === 0) {
          return;
        }
        if (this.length + array.length > this.data.length) {
          this.data.length = (this.length + array.length) * 2;
        }
        for (var index = 0; index < array.length; index++) {
          var item = (array.data || array)[index];
          this.pushNoDuplicate(item);
        }
      };
      return SmartArrayNoDuplicate2;
    }(SmartArray);
  }
});

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary;
var init_stringDictionary = __esm({
  "node_modules/@babylonjs/core/Misc/stringDictionary.js"() {
    StringDictionary = function() {
      function StringDictionary2() {
        this._count = 0;
        this._data = {};
      }
      StringDictionary2.prototype.copyFrom = function(source) {
        var _this = this;
        this.clear();
        source.forEach(function(t, v) {
          return _this.add(t, v);
        });
      };
      StringDictionary2.prototype.get = function(key) {
        var val = this._data[key];
        if (val !== void 0) {
          return val;
        }
        return void 0;
      };
      StringDictionary2.prototype.getOrAddWithFactory = function(key, factory) {
        var val = this.get(key);
        if (val !== void 0) {
          return val;
        }
        val = factory(key);
        if (val) {
          this.add(key, val);
        }
        return val;
      };
      StringDictionary2.prototype.getOrAdd = function(key, val) {
        var curVal = this.get(key);
        if (curVal !== void 0) {
          return curVal;
        }
        this.add(key, val);
        return val;
      };
      StringDictionary2.prototype.contains = function(key) {
        return this._data[key] !== void 0;
      };
      StringDictionary2.prototype.add = function(key, value) {
        if (this._data[key] !== void 0) {
          return false;
        }
        this._data[key] = value;
        ++this._count;
        return true;
      };
      StringDictionary2.prototype.set = function(key, value) {
        if (this._data[key] === void 0) {
          return false;
        }
        this._data[key] = value;
        return true;
      };
      StringDictionary2.prototype.getAndRemove = function(key) {
        var val = this.get(key);
        if (val !== void 0) {
          delete this._data[key];
          --this._count;
          return val;
        }
        return null;
      };
      StringDictionary2.prototype.remove = function(key) {
        if (this.contains(key)) {
          delete this._data[key];
          --this._count;
          return true;
        }
        return false;
      };
      StringDictionary2.prototype.clear = function() {
        this._data = {};
        this._count = 0;
      };
      Object.defineProperty(StringDictionary2.prototype, "count", {
        get: function() {
          return this._count;
        },
        enumerable: false,
        configurable: true
      });
      StringDictionary2.prototype.forEach = function(callback) {
        for (var cur in this._data) {
          var val = this._data[cur];
          callback(cur, val);
        }
      };
      StringDictionary2.prototype.first = function(callback) {
        for (var cur in this._data) {
          var val = this._data[cur];
          var res = callback(cur, val);
          if (res) {
            return res;
          }
        }
        return null;
      };
      return StringDictionary2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/materialDefines.js
var MaterialDefines;
var init_materialDefines = __esm({
  "node_modules/@babylonjs/core/Materials/materialDefines.js"() {
    MaterialDefines = function() {
      function MaterialDefines2(externalProperties) {
        this._isDirty = true;
        this._areLightsDirty = true;
        this._areLightsDisposed = false;
        this._areAttributesDirty = true;
        this._areTexturesDirty = true;
        this._areFresnelDirty = true;
        this._areMiscDirty = true;
        this._arePrePassDirty = true;
        this._areImageProcessingDirty = true;
        this._normals = false;
        this._uvs = false;
        this._needNormals = false;
        this._needUVs = false;
        this._externalProperties = externalProperties;
        if (externalProperties) {
          for (var prop in externalProperties) {
            if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {
              this._setDefaultValue(prop);
            }
          }
        }
      }
      Object.defineProperty(MaterialDefines2.prototype, "isDirty", {
        get: function() {
          return this._isDirty;
        },
        enumerable: false,
        configurable: true
      });
      MaterialDefines2.prototype.markAsProcessed = function() {
        this._isDirty = false;
        this._areAttributesDirty = false;
        this._areTexturesDirty = false;
        this._areFresnelDirty = false;
        this._areLightsDirty = false;
        this._areLightsDisposed = false;
        this._areMiscDirty = false;
        this._arePrePassDirty = false;
        this._areImageProcessingDirty = false;
      };
      MaterialDefines2.prototype.markAsUnprocessed = function() {
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAllAsDirty = function() {
        this._areTexturesDirty = true;
        this._areAttributesDirty = true;
        this._areLightsDirty = true;
        this._areFresnelDirty = true;
        this._areMiscDirty = true;
        this._areImageProcessingDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsImageProcessingDirty = function() {
        this._areImageProcessingDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsLightDirty = function(disposed) {
        if (disposed === void 0) {
          disposed = false;
        }
        this._areLightsDirty = true;
        this._areLightsDisposed = this._areLightsDisposed || disposed;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsAttributesDirty = function() {
        this._areAttributesDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsTexturesDirty = function() {
        this._areTexturesDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsFresnelDirty = function() {
        this._areFresnelDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsMiscDirty = function() {
        this._areMiscDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.markAsPrePassDirty = function() {
        this._arePrePassDirty = true;
        this._isDirty = true;
      };
      MaterialDefines2.prototype.rebuild = function() {
        this._keys = [];
        for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {
          var key = _a[_i];
          if (key[0] === "_") {
            continue;
          }
          this._keys.push(key);
        }
        if (this._externalProperties) {
          for (var name_1 in this._externalProperties) {
            if (this._keys.indexOf(name_1) === -1) {
              this._keys.push(name_1);
            }
          }
        }
      };
      MaterialDefines2.prototype.isEqual = function(other) {
        if (this._keys.length !== other._keys.length) {
          return false;
        }
        for (var index = 0; index < this._keys.length; index++) {
          var prop = this._keys[index];
          if (this[prop] !== other[prop]) {
            return false;
          }
        }
        return true;
      };
      MaterialDefines2.prototype.cloneTo = function(other) {
        if (this._keys.length !== other._keys.length) {
          other._keys = this._keys.slice(0);
        }
        for (var index = 0; index < this._keys.length; index++) {
          var prop = this._keys[index];
          other[prop] = this[prop];
        }
      };
      MaterialDefines2.prototype.reset = function() {
        var _this = this;
        this._keys.forEach(function(prop) {
          return _this._setDefaultValue(prop);
        });
      };
      MaterialDefines2.prototype._setDefaultValue = function(prop) {
        var _a, _b, _c, _d, _e;
        var type = (_c = (_b = (_a = this._externalProperties) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : typeof this[prop];
        var defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;
        switch (type) {
          case "number":
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;
            break;
          case "string":
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : "";
            break;
          default:
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;
            break;
        }
      };
      MaterialDefines2.prototype.toString = function() {
        var result = "";
        for (var index = 0; index < this._keys.length; index++) {
          var prop = this._keys[index];
          var value = this[prop];
          var type = typeof value;
          switch (type) {
            case "number":
            case "string":
              result += "#define " + prop + " " + value + "\n";
              break;
            default:
              if (value) {
                result += "#define " + prop + "\n";
              }
              break;
          }
        }
        return result;
      };
      return MaterialDefines2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves;
var init_colorCurves = __esm({
  "node_modules/@babylonjs/core/Materials/colorCurves.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    ColorCurves = function() {
      function ColorCurves2() {
        this._dirty = true;
        this._tempColor = new Color4(0, 0, 0, 0);
        this._globalCurve = new Color4(0, 0, 0, 0);
        this._highlightsCurve = new Color4(0, 0, 0, 0);
        this._midtonesCurve = new Color4(0, 0, 0, 0);
        this._shadowsCurve = new Color4(0, 0, 0, 0);
        this._positiveCurve = new Color4(0, 0, 0, 0);
        this._negativeCurve = new Color4(0, 0, 0, 0);
        this._globalHue = 30;
        this._globalDensity = 0;
        this._globalSaturation = 0;
        this._globalExposure = 0;
        this._highlightsHue = 30;
        this._highlightsDensity = 0;
        this._highlightsSaturation = 0;
        this._highlightsExposure = 0;
        this._midtonesHue = 30;
        this._midtonesDensity = 0;
        this._midtonesSaturation = 0;
        this._midtonesExposure = 0;
        this._shadowsHue = 30;
        this._shadowsDensity = 0;
        this._shadowsSaturation = 0;
        this._shadowsExposure = 0;
      }
      Object.defineProperty(ColorCurves2.prototype, "globalHue", {
        get: function() {
          return this._globalHue;
        },
        set: function(value) {
          this._globalHue = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "globalDensity", {
        get: function() {
          return this._globalDensity;
        },
        set: function(value) {
          this._globalDensity = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "globalSaturation", {
        get: function() {
          return this._globalSaturation;
        },
        set: function(value) {
          this._globalSaturation = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "globalExposure", {
        get: function() {
          return this._globalExposure;
        },
        set: function(value) {
          this._globalExposure = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "highlightsHue", {
        get: function() {
          return this._highlightsHue;
        },
        set: function(value) {
          this._highlightsHue = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "highlightsDensity", {
        get: function() {
          return this._highlightsDensity;
        },
        set: function(value) {
          this._highlightsDensity = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "highlightsSaturation", {
        get: function() {
          return this._highlightsSaturation;
        },
        set: function(value) {
          this._highlightsSaturation = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "highlightsExposure", {
        get: function() {
          return this._highlightsExposure;
        },
        set: function(value) {
          this._highlightsExposure = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "midtonesHue", {
        get: function() {
          return this._midtonesHue;
        },
        set: function(value) {
          this._midtonesHue = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "midtonesDensity", {
        get: function() {
          return this._midtonesDensity;
        },
        set: function(value) {
          this._midtonesDensity = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "midtonesSaturation", {
        get: function() {
          return this._midtonesSaturation;
        },
        set: function(value) {
          this._midtonesSaturation = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "midtonesExposure", {
        get: function() {
          return this._midtonesExposure;
        },
        set: function(value) {
          this._midtonesExposure = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "shadowsHue", {
        get: function() {
          return this._shadowsHue;
        },
        set: function(value) {
          this._shadowsHue = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "shadowsDensity", {
        get: function() {
          return this._shadowsDensity;
        },
        set: function(value) {
          this._shadowsDensity = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "shadowsSaturation", {
        get: function() {
          return this._shadowsSaturation;
        },
        set: function(value) {
          this._shadowsSaturation = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorCurves2.prototype, "shadowsExposure", {
        get: function() {
          return this._shadowsExposure;
        },
        set: function(value) {
          this._shadowsExposure = value;
          this._dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      ColorCurves2.prototype.getClassName = function() {
        return "ColorCurves";
      };
      ColorCurves2.Bind = function(colorCurves, effect, positiveUniform, neutralUniform, negativeUniform) {
        if (positiveUniform === void 0) {
          positiveUniform = "vCameraColorCurvePositive";
        }
        if (neutralUniform === void 0) {
          neutralUniform = "vCameraColorCurveNeutral";
        }
        if (negativeUniform === void 0) {
          negativeUniform = "vCameraColorCurveNegative";
        }
        if (colorCurves._dirty) {
          colorCurves._dirty = false;
          colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
          colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
          colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
        }
        if (effect) {
          effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
          effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
          effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
        }
      };
      ColorCurves2.PrepareUniforms = function(uniformsList) {
        uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
      };
      ColorCurves2.prototype._getColorGradingDataToRef = function(hue, density, saturation, exposure, result) {
        if (hue == null) {
          return;
        }
        hue = ColorCurves2._Clamp(hue, 0, 360);
        density = ColorCurves2._Clamp(density, -100, 100);
        saturation = ColorCurves2._Clamp(saturation, -100, 100);
        exposure = ColorCurves2._Clamp(exposure, -100, 100);
        density = ColorCurves2._ApplyColorGradingSliderNonlinear(density);
        density *= 0.5;
        exposure = ColorCurves2._ApplyColorGradingSliderNonlinear(exposure);
        if (density < 0) {
          density *= -1;
          hue = (hue + 180) % 360;
        }
        ColorCurves2._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
        result.scaleToRef(2, result);
        result.a = 1 + 0.01 * saturation;
      };
      ColorCurves2._ApplyColorGradingSliderNonlinear = function(value) {
        value /= 100;
        var x = Math.abs(value);
        x = Math.pow(x, 2);
        if (value < 0) {
          x *= -1;
        }
        x *= 100;
        return x;
      };
      ColorCurves2._FromHSBToRef = function(hue, saturation, brightness, result) {
        var h = ColorCurves2._Clamp(hue, 0, 360);
        var s = ColorCurves2._Clamp(saturation / 100, 0, 1);
        var v = ColorCurves2._Clamp(brightness / 100, 0, 1);
        if (s === 0) {
          result.r = v;
          result.g = v;
          result.b = v;
        } else {
          h /= 60;
          var i = Math.floor(h);
          var f = h - i;
          var p = v * (1 - s);
          var q = v * (1 - s * f);
          var t = v * (1 - s * (1 - f));
          switch (i) {
            case 0:
              result.r = v;
              result.g = t;
              result.b = p;
              break;
            case 1:
              result.r = q;
              result.g = v;
              result.b = p;
              break;
            case 2:
              result.r = p;
              result.g = v;
              result.b = t;
              break;
            case 3:
              result.r = p;
              result.g = q;
              result.b = v;
              break;
            case 4:
              result.r = t;
              result.g = p;
              result.b = v;
              break;
            default:
              result.r = v;
              result.g = p;
              result.b = q;
              break;
          }
        }
        result.a = 1;
      };
      ColorCurves2._Clamp = function(value, min, max) {
        return Math.min(Math.max(value, min), max);
      };
      ColorCurves2.prototype.clone = function() {
        return SerializationHelper.Clone(function() {
          return new ColorCurves2();
        }, this);
      };
      ColorCurves2.prototype.serialize = function() {
        return SerializationHelper.Serialize(this);
      };
      ColorCurves2.Parse = function(source) {
        return SerializationHelper.Parse(function() {
          return new ColorCurves2();
        }, source, null, null);
      };
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_globalHue", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_globalDensity", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_globalSaturation", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_globalExposure", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_highlightsHue", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_highlightsDensity", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_highlightsSaturation", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_highlightsExposure", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_midtonesHue", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_midtonesDensity", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_midtonesSaturation", void 0);
      __decorate([
        serialize()
      ], ColorCurves2.prototype, "_midtonesExposure", void 0);
      return ColorCurves2;
    }();
    SerializationHelper._ColorCurvesParser = ColorCurves.Parse;
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfigurationDefines, ImageProcessingConfiguration;
var init_imageProcessingConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_tools();
    init_math_color();
    init_materialDefines();
    init_colorCurves();
    ImageProcessingConfigurationDefines = function(_super) {
      __extends(ImageProcessingConfigurationDefines2, _super);
      function ImageProcessingConfigurationDefines2() {
        var _this = _super.call(this) || this;
        _this.IMAGEPROCESSING = false;
        _this.VIGNETTE = false;
        _this.VIGNETTEBLENDMODEMULTIPLY = false;
        _this.VIGNETTEBLENDMODEOPAQUE = false;
        _this.TONEMAPPING = false;
        _this.TONEMAPPING_ACES = false;
        _this.CONTRAST = false;
        _this.COLORCURVES = false;
        _this.COLORGRADING = false;
        _this.COLORGRADING3D = false;
        _this.SAMPLER3DGREENDEPTH = false;
        _this.SAMPLER3DBGRMAP = false;
        _this.IMAGEPROCESSINGPOSTPROCESS = false;
        _this.EXPOSURE = false;
        _this.SKIPFINALCOLORCLAMP = false;
        _this.rebuild();
        return _this;
      }
      return ImageProcessingConfigurationDefines2;
    }(MaterialDefines);
    ImageProcessingConfiguration = function() {
      function ImageProcessingConfiguration2() {
        this.colorCurves = new ColorCurves();
        this._colorCurvesEnabled = false;
        this._colorGradingEnabled = false;
        this._colorGradingWithGreenDepth = true;
        this._colorGradingBGR = true;
        this._exposure = 1;
        this._toneMappingEnabled = false;
        this._toneMappingType = ImageProcessingConfiguration2.TONEMAPPING_STANDARD;
        this._contrast = 1;
        this.vignetteStretch = 0;
        this.vignetteCentreX = 0;
        this.vignetteCentreY = 0;
        this.vignetteWeight = 1.5;
        this.vignetteColor = new Color4(0, 0, 0, 0);
        this.vignetteCameraFov = 0.5;
        this._vignetteBlendMode = ImageProcessingConfiguration2.VIGNETTEMODE_MULTIPLY;
        this._vignetteEnabled = false;
        this._skipFinalColorClamp = false;
        this._applyByPostProcess = false;
        this._isEnabled = true;
        this.onUpdateParameters = new Observable();
      }
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorCurvesEnabled", {
        get: function() {
          return this._colorCurvesEnabled;
        },
        set: function(value) {
          if (this._colorCurvesEnabled === value) {
            return;
          }
          this._colorCurvesEnabled = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingTexture", {
        get: function() {
          return this._colorGradingTexture;
        },
        set: function(value) {
          if (this._colorGradingTexture === value) {
            return;
          }
          this._colorGradingTexture = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingEnabled", {
        get: function() {
          return this._colorGradingEnabled;
        },
        set: function(value) {
          if (this._colorGradingEnabled === value) {
            return;
          }
          this._colorGradingEnabled = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingWithGreenDepth", {
        get: function() {
          return this._colorGradingWithGreenDepth;
        },
        set: function(value) {
          if (this._colorGradingWithGreenDepth === value) {
            return;
          }
          this._colorGradingWithGreenDepth = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingBGR", {
        get: function() {
          return this._colorGradingBGR;
        },
        set: function(value) {
          if (this._colorGradingBGR === value) {
            return;
          }
          this._colorGradingBGR = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "exposure", {
        get: function() {
          return this._exposure;
        },
        set: function(value) {
          if (this._exposure === value) {
            return;
          }
          this._exposure = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingEnabled", {
        get: function() {
          return this._toneMappingEnabled;
        },
        set: function(value) {
          if (this._toneMappingEnabled === value) {
            return;
          }
          this._toneMappingEnabled = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingType", {
        get: function() {
          return this._toneMappingType;
        },
        set: function(value) {
          if (this._toneMappingType === value) {
            return;
          }
          this._toneMappingType = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "contrast", {
        get: function() {
          return this._contrast;
        },
        set: function(value) {
          if (this._contrast === value) {
            return;
          }
          this._contrast = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteBlendMode", {
        get: function() {
          return this._vignetteBlendMode;
        },
        set: function(value) {
          if (this._vignetteBlendMode === value) {
            return;
          }
          this._vignetteBlendMode = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteEnabled", {
        get: function() {
          return this._vignetteEnabled;
        },
        set: function(value) {
          if (this._vignetteEnabled === value) {
            return;
          }
          this._vignetteEnabled = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "skipFinalColorClamp", {
        get: function() {
          return this._skipFinalColorClamp;
        },
        set: function(value) {
          if (this._skipFinalColorClamp === value) {
            return;
          }
          this._skipFinalColorClamp = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "applyByPostProcess", {
        get: function() {
          return this._applyByPostProcess;
        },
        set: function(value) {
          if (this._applyByPostProcess === value) {
            return;
          }
          this._applyByPostProcess = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2.prototype, "isEnabled", {
        get: function() {
          return this._isEnabled;
        },
        set: function(value) {
          if (this._isEnabled === value) {
            return;
          }
          this._isEnabled = value;
          this._updateParameters();
        },
        enumerable: false,
        configurable: true
      });
      ImageProcessingConfiguration2.prototype._updateParameters = function() {
        this.onUpdateParameters.notifyObservers(this);
      };
      ImageProcessingConfiguration2.prototype.getClassName = function() {
        return "ImageProcessingConfiguration";
      };
      ImageProcessingConfiguration2.PrepareUniforms = function(uniforms, defines) {
        if (defines.EXPOSURE) {
          uniforms.push("exposureLinear");
        }
        if (defines.CONTRAST) {
          uniforms.push("contrast");
        }
        if (defines.COLORGRADING) {
          uniforms.push("colorTransformSettings");
        }
        if (defines.VIGNETTE) {
          uniforms.push("vInverseScreenSize");
          uniforms.push("vignetteSettings1");
          uniforms.push("vignetteSettings2");
        }
        if (defines.COLORCURVES) {
          ColorCurves.PrepareUniforms(uniforms);
        }
      };
      ImageProcessingConfiguration2.PrepareSamplers = function(samplersList, defines) {
        if (defines.COLORGRADING) {
          samplersList.push("txColorTransform");
        }
      };
      ImageProcessingConfiguration2.prototype.prepareDefines = function(defines, forPostProcess) {
        if (forPostProcess === void 0) {
          forPostProcess = false;
        }
        if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
          defines.VIGNETTE = false;
          defines.TONEMAPPING = false;
          defines.TONEMAPPING_ACES = false;
          defines.CONTRAST = false;
          defines.EXPOSURE = false;
          defines.COLORCURVES = false;
          defines.COLORGRADING = false;
          defines.COLORGRADING3D = false;
          defines.IMAGEPROCESSING = false;
          defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
          defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
          return;
        }
        defines.VIGNETTE = this.vignetteEnabled;
        defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY;
        defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
        defines.TONEMAPPING = this.toneMappingEnabled;
        switch (this._toneMappingType) {
          case ImageProcessingConfiguration2.TONEMAPPING_ACES:
            defines.TONEMAPPING_ACES = true;
            break;
          default:
            defines.TONEMAPPING_ACES = false;
            break;
        }
        defines.CONTRAST = this.contrast !== 1;
        defines.EXPOSURE = this.exposure !== 1;
        defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
        defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
        if (defines.COLORGRADING) {
          defines.COLORGRADING3D = this.colorGradingTexture.is3D;
        } else {
          defines.COLORGRADING3D = false;
        }
        defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
        defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
        defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
        defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
        defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING;
      };
      ImageProcessingConfiguration2.prototype.isReady = function() {
        return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
      };
      ImageProcessingConfiguration2.prototype.bind = function(effect, overrideAspectRatio) {
        if (this._colorCurvesEnabled && this.colorCurves) {
          ColorCurves.Bind(this.colorCurves, effect);
        }
        if (this._vignetteEnabled) {
          var inverseWidth = 1 / effect.getEngine().getRenderWidth();
          var inverseHeight = 1 / effect.getEngine().getRenderHeight();
          effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
          var aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
          var vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
          var vignetteScaleX = vignetteScaleY * aspectRatio;
          var vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
          vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
          vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
          effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCentreX, -vignetteScaleY * this.vignetteCentreY);
          var vignettePower = -2 * this.vignetteWeight;
          effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
        }
        effect.setFloat("exposureLinear", this.exposure);
        effect.setFloat("contrast", this.contrast);
        if (this.colorGradingTexture) {
          effect.setTexture("txColorTransform", this.colorGradingTexture);
          var textureSize = this.colorGradingTexture.getSize().height;
          effect.setFloat4("colorTransformSettings", (textureSize - 1) / textureSize, 0.5 / textureSize, textureSize, this.colorGradingTexture.level);
        }
      };
      ImageProcessingConfiguration2.prototype.clone = function() {
        return SerializationHelper.Clone(function() {
          return new ImageProcessingConfiguration2();
        }, this);
      };
      ImageProcessingConfiguration2.prototype.serialize = function() {
        return SerializationHelper.Serialize(this);
      };
      ImageProcessingConfiguration2.Parse = function(source) {
        return SerializationHelper.Parse(function() {
          return new ImageProcessingConfiguration2();
        }, source, null, null);
      };
      Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_MULTIPLY", {
        get: function() {
          return this._VIGNETTEMODE_MULTIPLY;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_OPAQUE", {
        get: function() {
          return this._VIGNETTEMODE_OPAQUE;
        },
        enumerable: false,
        configurable: true
      });
      ImageProcessingConfiguration2.TONEMAPPING_STANDARD = 0;
      ImageProcessingConfiguration2.TONEMAPPING_ACES = 1;
      ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY = 0;
      ImageProcessingConfiguration2._VIGNETTEMODE_OPAQUE = 1;
      __decorate([
        serializeAsColorCurves()
      ], ImageProcessingConfiguration2.prototype, "colorCurves", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_colorCurvesEnabled", void 0);
      __decorate([
        serializeAsTexture("colorGradingTexture")
      ], ImageProcessingConfiguration2.prototype, "_colorGradingTexture", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_colorGradingEnabled", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_colorGradingWithGreenDepth", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_colorGradingBGR", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_exposure", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_toneMappingEnabled", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_toneMappingType", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_contrast", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "vignetteStretch", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "vignetteCentreX", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "vignetteCentreY", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "vignetteWeight", void 0);
      __decorate([
        serializeAsColor4()
      ], ImageProcessingConfiguration2.prototype, "vignetteColor", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "vignetteCameraFov", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_vignetteBlendMode", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_vignetteEnabled", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_skipFinalColorClamp", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_applyByPostProcess", void 0);
      __decorate([
        serialize()
      ], ImageProcessingConfiguration2.prototype, "_isEnabled", void 0);
      return ImageProcessingConfiguration2;
    }();
    SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js
var init_engine_uniformBuffer = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js"() {
    init_thinEngine();
    init_webGLDataBuffer();
    ThinEngine.prototype.createUniformBuffer = function(elements) {
      var ubo = this._gl.createBuffer();
      if (!ubo) {
        throw new Error("Unable to create uniform buffer");
      }
      var result = new WebGLDataBuffer(ubo);
      this.bindUniformBuffer(result);
      if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
      } else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
      }
      this.bindUniformBuffer(null);
      result.references = 1;
      return result;
    };
    ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
      var ubo = this._gl.createBuffer();
      if (!ubo) {
        throw new Error("Unable to create dynamic uniform buffer");
      }
      var result = new WebGLDataBuffer(ubo);
      this.bindUniformBuffer(result);
      if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
      } else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
      }
      this.bindUniformBuffer(null);
      result.references = 1;
      return result;
    };
    ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
      this.bindUniformBuffer(uniformBuffer);
      if (offset === void 0) {
        offset = 0;
      }
      if (count === void 0) {
        if (elements instanceof Float32Array) {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
        } else {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
        }
      } else {
        if (elements instanceof Float32Array) {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
        } else {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
        }
      }
      this.bindUniformBuffer(null);
    };
    ThinEngine.prototype.bindUniformBuffer = function(buffer) {
      this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
    };
    ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name) {
      this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
    };
    ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
      var program = pipelineContext.program;
      var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
      if (uniformLocation !== 4294967295) {
        this._gl.uniformBlockBinding(program, uniformLocation, index);
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer;
var init_uniformBuffer = __esm({
  "node_modules/@babylonjs/core/Materials/uniformBuffer.js"() {
    init_logger();
    init_tools();
    init_engine_uniformBuffer();
    UniformBuffer = function() {
      function UniformBuffer2(engine, data, dynamic, name, forceNoUniformBuffer) {
        if (forceNoUniformBuffer === void 0) {
          forceNoUniformBuffer = false;
        }
        this._valueCache = {};
        this._engine = engine;
        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
        this._dynamic = dynamic;
        this._name = name !== null && name !== void 0 ? name : "no-name";
        this._data = data || [];
        this._uniformLocations = {};
        this._uniformSizes = {};
        this._uniformArraySizes = {};
        this._uniformLocationPointer = 0;
        this._needSync = false;
        if (this._engine._features.trackUbosInFrame) {
          this._buffers = [];
          this._bufferIndex = -1;
          this._createBufferOnWrite = false;
          this._currentFrameId = 0;
        }
        if (this._noUBO) {
          this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
          this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
          this.updateFloat = this._updateFloatForEffect;
          this.updateFloat2 = this._updateFloat2ForEffect;
          this.updateFloat3 = this._updateFloat3ForEffect;
          this.updateFloat4 = this._updateFloat4ForEffect;
          this.updateFloatArray = this._updateFloatArrayForEffect;
          this.updateArray = this._updateArrayForEffect;
          this.updateIntArray = this._updateIntArrayForEffect;
          this.updateMatrix = this._updateMatrixForEffect;
          this.updateMatrices = this._updateMatricesForEffect;
          this.updateVector3 = this._updateVector3ForEffect;
          this.updateVector4 = this._updateVector4ForEffect;
          this.updateColor3 = this._updateColor3ForEffect;
          this.updateColor4 = this._updateColor4ForEffect;
          this.updateDirectColor4 = this._updateDirectColor4ForEffect;
          this.updateInt = this._updateIntForEffect;
          this.updateInt2 = this._updateInt2ForEffect;
          this.updateInt3 = this._updateInt3ForEffect;
          this.updateInt4 = this._updateInt4ForEffect;
        } else {
          this._engine._uniformBuffers.push(this);
          this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
          this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
          this.updateFloat = this._updateFloatForUniform;
          this.updateFloat2 = this._updateFloat2ForUniform;
          this.updateFloat3 = this._updateFloat3ForUniform;
          this.updateFloat4 = this._updateFloat4ForUniform;
          this.updateFloatArray = this._updateFloatArrayForUniform;
          this.updateArray = this._updateArrayForUniform;
          this.updateIntArray = this._updateIntArrayForUniform;
          this.updateMatrix = this._updateMatrixForUniform;
          this.updateMatrices = this._updateMatricesForUniform;
          this.updateVector3 = this._updateVector3ForUniform;
          this.updateVector4 = this._updateVector4ForUniform;
          this.updateColor3 = this._updateColor3ForUniform;
          this.updateColor4 = this._updateColor4ForUniform;
          this.updateDirectColor4 = this._updateDirectColor4ForUniform;
          this.updateInt = this._updateIntForUniform;
          this.updateInt2 = this._updateInt2ForUniform;
          this.updateInt3 = this._updateInt3ForUniform;
          this.updateInt4 = this._updateInt4ForUniform;
        }
      }
      Object.defineProperty(UniformBuffer2.prototype, "useUbo", {
        get: function() {
          return !this._noUBO;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(UniformBuffer2.prototype, "isSync", {
        get: function() {
          return !this._needSync;
        },
        enumerable: false,
        configurable: true
      });
      UniformBuffer2.prototype.isDynamic = function() {
        return this._dynamic !== void 0;
      };
      UniformBuffer2.prototype.getData = function() {
        return this._bufferData;
      };
      UniformBuffer2.prototype.getBuffer = function() {
        return this._buffer;
      };
      UniformBuffer2.prototype._fillAlignment = function(size) {
        var alignment;
        if (size <= 2) {
          alignment = size;
        } else {
          alignment = 4;
        }
        if (this._uniformLocationPointer % alignment !== 0) {
          var oldPointer = this._uniformLocationPointer;
          this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
          var diff = this._uniformLocationPointer - oldPointer;
          for (var i = 0; i < diff; i++) {
            this._data.push(0);
          }
        }
      };
      UniformBuffer2.prototype.addUniform = function(name, size, arraySize) {
        if (arraySize === void 0) {
          arraySize = 0;
        }
        if (this._noUBO) {
          return;
        }
        if (this._uniformLocations[name] !== void 0) {
          return;
        }
        var data;
        if (arraySize > 0) {
          if (size instanceof Array) {
            throw "addUniform should not be use with Array in UBO: " + name;
          }
          this._fillAlignment(4);
          this._uniformArraySizes[name] = { strideSize: size, arraySize };
          if (size == 16) {
            size = size * arraySize;
          } else {
            var perElementPadding = 4 - size;
            var totalPadding = perElementPadding * arraySize;
            size = size * arraySize + totalPadding;
          }
          data = [];
          for (var i = 0; i < size; i++) {
            data.push(0);
          }
        } else {
          if (size instanceof Array) {
            data = size;
            size = data.length;
          } else {
            size = size;
            data = [];
            for (var i = 0; i < size; i++) {
              data.push(0);
            }
          }
          this._fillAlignment(size);
        }
        this._uniformSizes[name] = size;
        this._uniformLocations[name] = this._uniformLocationPointer;
        this._uniformLocationPointer += size;
        for (var i = 0; i < size; i++) {
          this._data.push(data[i]);
        }
        this._needSync = true;
      };
      UniformBuffer2.prototype.addMatrix = function(name, mat) {
        this.addUniform(name, Array.prototype.slice.call(mat.toArray()));
      };
      UniformBuffer2.prototype.addFloat2 = function(name, x, y) {
        var temp = [x, y];
        this.addUniform(name, temp);
      };
      UniformBuffer2.prototype.addFloat3 = function(name, x, y, z) {
        var temp = [x, y, z];
        this.addUniform(name, temp);
      };
      UniformBuffer2.prototype.addColor3 = function(name, color) {
        var temp = [color.r, color.g, color.b];
        this.addUniform(name, temp);
      };
      UniformBuffer2.prototype.addColor4 = function(name, color, alpha) {
        var temp = [color.r, color.g, color.b, alpha];
        this.addUniform(name, temp);
      };
      UniformBuffer2.prototype.addVector3 = function(name, vector) {
        var temp = [vector.x, vector.y, vector.z];
        this.addUniform(name, temp);
      };
      UniformBuffer2.prototype.addMatrix3x3 = function(name) {
        this.addUniform(name, 12);
      };
      UniformBuffer2.prototype.addMatrix2x2 = function(name) {
        this.addUniform(name, 8);
      };
      UniformBuffer2.prototype.create = function() {
        if (this._noUBO) {
          return;
        }
        if (this._buffer) {
          return;
        }
        this._fillAlignment(4);
        this._bufferData = new Float32Array(this._data);
        this._rebuild();
        this._needSync = true;
      };
      UniformBuffer2.prototype._rebuild = function() {
        if (this._noUBO || !this._bufferData) {
          return;
        }
        if (this._dynamic) {
          this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
        } else {
          this._buffer = this._engine.createUniformBuffer(this._bufferData);
        }
        if (this._engine._features.trackUbosInFrame) {
          this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
          this._bufferIndex = this._buffers.length - 1;
          this._createBufferOnWrite = false;
        }
      };
      Object.defineProperty(UniformBuffer2.prototype, "_numBuffers", {
        get: function() {
          return this._buffers.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(UniformBuffer2.prototype, "_indexBuffer", {
        get: function() {
          return this._bufferIndex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(UniformBuffer2.prototype, "name", {
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      UniformBuffer2.prototype._buffersEqual = function(buf1, buf2) {
        for (var i = 0; i < buf1.length; ++i) {
          if (buf1[i] !== buf2[i]) {
            return false;
          }
        }
        return true;
      };
      UniformBuffer2.prototype._copyBuffer = function(src, dst) {
        for (var i = 0; i < src.length; ++i) {
          dst[i] = src[i];
        }
      };
      UniformBuffer2.prototype.update = function() {
        if (this._noUBO) {
          return;
        }
        this.bindUniformBuffer();
        if (!this._buffer) {
          this.create();
          return;
        }
        if (!this._dynamic && !this._needSync) {
          this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
          return;
        }
        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
          if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
            this._needSync = false;
            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
            return;
          } else {
            this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
          }
        }
        this._engine.updateUniformBuffer(this._buffer, this._bufferData);
        if (this._engine._features._collectUbosUpdatedInFrame) {
          if (!UniformBuffer2._UpdatedUbosInFrame[this._name]) {
            UniformBuffer2._UpdatedUbosInFrame[this._name] = 0;
          }
          UniformBuffer2._UpdatedUbosInFrame[this._name]++;
        }
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      };
      UniformBuffer2.prototype._createNewBuffer = function() {
        if (this._bufferIndex + 1 < this._buffers.length) {
          this._bufferIndex++;
          this._buffer = this._buffers[this._bufferIndex][0];
          this._createBufferOnWrite = false;
          this._needSync = true;
        } else {
          this._rebuild();
        }
      };
      UniformBuffer2.prototype._checkNewFrame = function() {
        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
          this._currentFrameId = this._engine.frameId;
          this._createBufferOnWrite = false;
          if (this._buffers && this._buffers.length > 0) {
            this._needSync = this._bufferIndex !== 0;
            this._bufferIndex = 0;
            this._buffer = this._buffers[this._bufferIndex][0];
          } else {
            this._bufferIndex = -1;
          }
        }
      };
      UniformBuffer2.prototype.updateUniform = function(uniformName, data, size) {
        this._checkNewFrame();
        var location2 = this._uniformLocations[uniformName];
        if (location2 === void 0) {
          if (this._buffer) {
            Logger.Error("Cannot add an uniform after UBO has been created.");
            return;
          }
          this.addUniform(uniformName, size);
          location2 = this._uniformLocations[uniformName];
        }
        if (!this._buffer) {
          this.create();
        }
        if (!this._dynamic) {
          var changed = false;
          for (var i = 0; i < size; i++) {
            if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Tools.FloatRound(data[i])) {
              changed = true;
              if (this._createBufferOnWrite) {
                this._createNewBuffer();
              }
              this._bufferData[location2 + i] = data[i];
            }
          }
          this._needSync = this._needSync || changed;
        } else {
          for (var i = 0; i < size; i++) {
            this._bufferData[location2 + i] = data[i];
          }
        }
      };
      UniformBuffer2.prototype.updateUniformArray = function(uniformName, data, size) {
        this._checkNewFrame();
        var location2 = this._uniformLocations[uniformName];
        if (location2 === void 0) {
          Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform.");
          return;
        }
        if (!this._buffer) {
          this.create();
        }
        var arraySizes = this._uniformArraySizes[uniformName];
        if (!this._dynamic) {
          var changed = false;
          var countToFour = 0;
          var baseStride = 0;
          for (var i = 0; i < size; i++) {
            if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
              changed = true;
              if (this._createBufferOnWrite) {
                this._createNewBuffer();
              }
              this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
            }
            countToFour++;
            if (countToFour === arraySizes.strideSize) {
              for (; countToFour < 4; countToFour++) {
                this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
              }
              countToFour = 0;
              baseStride++;
            }
          }
          this._needSync = this._needSync || changed;
        } else {
          for (var i = 0; i < size; i++) {
            this._bufferData[location2 + i] = data[i];
          }
        }
      };
      UniformBuffer2.prototype._cacheMatrix = function(name, matrix) {
        this._checkNewFrame();
        var cache = this._valueCache[name];
        var flag = matrix.updateFlag;
        if (cache !== void 0 && cache === flag) {
          return false;
        }
        this._valueCache[name] = flag;
        return true;
      };
      UniformBuffer2.prototype._updateMatrix3x3ForUniform = function(name, matrix) {
        for (var i = 0; i < 3; i++) {
          UniformBuffer2._TempBuffer[i * 4] = matrix[i * 3];
          UniformBuffer2._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
          UniformBuffer2._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
          UniformBuffer2._TempBuffer[i * 4 + 3] = 0;
        }
        this.updateUniform(name, UniformBuffer2._TempBuffer, 12);
      };
      UniformBuffer2.prototype._updateMatrix3x3ForEffect = function(name, matrix) {
        this._currentEffect.setMatrix3x3(name, matrix);
      };
      UniformBuffer2.prototype._updateMatrix2x2ForEffect = function(name, matrix) {
        this._currentEffect.setMatrix2x2(name, matrix);
      };
      UniformBuffer2.prototype._updateMatrix2x2ForUniform = function(name, matrix) {
        for (var i = 0; i < 2; i++) {
          UniformBuffer2._TempBuffer[i * 4] = matrix[i * 2];
          UniformBuffer2._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
          UniformBuffer2._TempBuffer[i * 4 + 2] = 0;
          UniformBuffer2._TempBuffer[i * 4 + 3] = 0;
        }
        this.updateUniform(name, UniformBuffer2._TempBuffer, 8);
      };
      UniformBuffer2.prototype._updateFloatForEffect = function(name, x) {
        this._currentEffect.setFloat(name, x);
      };
      UniformBuffer2.prototype._updateFloatForUniform = function(name, x) {
        UniformBuffer2._TempBuffer[0] = x;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 1);
      };
      UniformBuffer2.prototype._updateFloat2ForEffect = function(name, x, y, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setFloat2(name + suffix, x, y);
      };
      UniformBuffer2.prototype._updateFloat2ForUniform = function(name, x, y) {
        UniformBuffer2._TempBuffer[0] = x;
        UniformBuffer2._TempBuffer[1] = y;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 2);
      };
      UniformBuffer2.prototype._updateFloat3ForEffect = function(name, x, y, z, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setFloat3(name + suffix, x, y, z);
      };
      UniformBuffer2.prototype._updateFloat3ForUniform = function(name, x, y, z) {
        UniformBuffer2._TempBuffer[0] = x;
        UniformBuffer2._TempBuffer[1] = y;
        UniformBuffer2._TempBuffer[2] = z;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 3);
      };
      UniformBuffer2.prototype._updateFloat4ForEffect = function(name, x, y, z, w, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setFloat4(name + suffix, x, y, z, w);
      };
      UniformBuffer2.prototype._updateFloat4ForUniform = function(name, x, y, z, w) {
        UniformBuffer2._TempBuffer[0] = x;
        UniformBuffer2._TempBuffer[1] = y;
        UniformBuffer2._TempBuffer[2] = z;
        UniformBuffer2._TempBuffer[3] = w;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 4);
      };
      UniformBuffer2.prototype._updateFloatArrayForEffect = function(name, array) {
        this._currentEffect.setFloatArray(name, array);
      };
      UniformBuffer2.prototype._updateFloatArrayForUniform = function(name, array) {
        this.updateUniformArray(name, array, array.length);
      };
      UniformBuffer2.prototype._updateArrayForEffect = function(name, array) {
        this._currentEffect.setArray(name, array);
      };
      UniformBuffer2.prototype._updateArrayForUniform = function(name, array) {
        this.updateUniformArray(name, array, array.length);
      };
      UniformBuffer2.prototype._updateIntArrayForEffect = function(name, array) {
        this._currentEffect.setIntArray(name, array);
      };
      UniformBuffer2.prototype._updateIntArrayForUniform = function(name, array) {
        UniformBuffer2._TempBufferInt32View.set(array);
        this.updateUniformArray(name, UniformBuffer2._TempBuffer, array.length);
      };
      UniformBuffer2.prototype._updateMatrixForEffect = function(name, mat) {
        this._currentEffect.setMatrix(name, mat);
      };
      UniformBuffer2.prototype._updateMatrixForUniform = function(name, mat) {
        if (this._cacheMatrix(name, mat)) {
          this.updateUniform(name, mat.toArray(), 16);
        }
      };
      UniformBuffer2.prototype._updateMatricesForEffect = function(name, mat) {
        this._currentEffect.setMatrices(name, mat);
      };
      UniformBuffer2.prototype._updateMatricesForUniform = function(name, mat) {
        this.updateUniform(name, mat, mat.length);
      };
      UniformBuffer2.prototype._updateVector3ForEffect = function(name, vector) {
        this._currentEffect.setVector3(name, vector);
      };
      UniformBuffer2.prototype._updateVector3ForUniform = function(name, vector) {
        UniformBuffer2._TempBuffer[0] = vector.x;
        UniformBuffer2._TempBuffer[1] = vector.y;
        UniformBuffer2._TempBuffer[2] = vector.z;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 3);
      };
      UniformBuffer2.prototype._updateVector4ForEffect = function(name, vector) {
        this._currentEffect.setVector4(name, vector);
      };
      UniformBuffer2.prototype._updateVector4ForUniform = function(name, vector) {
        UniformBuffer2._TempBuffer[0] = vector.x;
        UniformBuffer2._TempBuffer[1] = vector.y;
        UniformBuffer2._TempBuffer[2] = vector.z;
        UniformBuffer2._TempBuffer[3] = vector.w;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 4);
      };
      UniformBuffer2.prototype._updateColor3ForEffect = function(name, color, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setColor3(name + suffix, color);
      };
      UniformBuffer2.prototype._updateColor3ForUniform = function(name, color) {
        UniformBuffer2._TempBuffer[0] = color.r;
        UniformBuffer2._TempBuffer[1] = color.g;
        UniformBuffer2._TempBuffer[2] = color.b;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 3);
      };
      UniformBuffer2.prototype._updateColor4ForEffect = function(name, color, alpha, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setColor4(name + suffix, color, alpha);
      };
      UniformBuffer2.prototype._updateDirectColor4ForEffect = function(name, color, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setDirectColor4(name + suffix, color);
      };
      UniformBuffer2.prototype._updateColor4ForUniform = function(name, color, alpha) {
        UniformBuffer2._TempBuffer[0] = color.r;
        UniformBuffer2._TempBuffer[1] = color.g;
        UniformBuffer2._TempBuffer[2] = color.b;
        UniformBuffer2._TempBuffer[3] = alpha;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 4);
      };
      UniformBuffer2.prototype._updateDirectColor4ForUniform = function(name, color) {
        UniformBuffer2._TempBuffer[0] = color.r;
        UniformBuffer2._TempBuffer[1] = color.g;
        UniformBuffer2._TempBuffer[2] = color.b;
        UniformBuffer2._TempBuffer[3] = color.a;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 4);
      };
      UniformBuffer2.prototype._updateIntForEffect = function(name, x, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setInt(name + suffix, x);
      };
      UniformBuffer2.prototype._updateIntForUniform = function(name, x) {
        UniformBuffer2._TempBufferInt32View[0] = x;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 1);
      };
      UniformBuffer2.prototype._updateInt2ForEffect = function(name, x, y, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setInt2(name + suffix, x, y);
      };
      UniformBuffer2.prototype._updateInt2ForUniform = function(name, x, y) {
        UniformBuffer2._TempBufferInt32View[0] = x;
        UniformBuffer2._TempBufferInt32View[1] = y;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 2);
      };
      UniformBuffer2.prototype._updateInt3ForEffect = function(name, x, y, z, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setInt3(name + suffix, x, y, z);
      };
      UniformBuffer2.prototype._updateInt3ForUniform = function(name, x, y, z) {
        UniformBuffer2._TempBufferInt32View[0] = x;
        UniformBuffer2._TempBufferInt32View[1] = y;
        UniformBuffer2._TempBufferInt32View[2] = z;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 3);
      };
      UniformBuffer2.prototype._updateInt4ForEffect = function(name, x, y, z, w, suffix) {
        if (suffix === void 0) {
          suffix = "";
        }
        this._currentEffect.setInt4(name + suffix, x, y, z, w);
      };
      UniformBuffer2.prototype._updateInt4ForUniform = function(name, x, y, z, w) {
        UniformBuffer2._TempBufferInt32View[0] = x;
        UniformBuffer2._TempBufferInt32View[1] = y;
        UniformBuffer2._TempBufferInt32View[2] = z;
        UniformBuffer2._TempBufferInt32View[3] = w;
        this.updateUniform(name, UniformBuffer2._TempBuffer, 4);
      };
      UniformBuffer2.prototype.setTexture = function(name, texture) {
        this._currentEffect.setTexture(name, texture);
      };
      UniformBuffer2.prototype.updateUniformDirectly = function(uniformName, data) {
        this.updateUniform(uniformName, data, data.length);
        this.update();
      };
      UniformBuffer2.prototype.bindToEffect = function(effect, name) {
        this._currentEffect = effect;
        this._currentEffectName = name;
      };
      UniformBuffer2.prototype.bindUniformBuffer = function() {
        if (!this._noUBO && this._buffer && this._currentEffect) {
          this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
        }
      };
      UniformBuffer2.prototype.unbindEffect = function() {
        this._currentEffect = void 0;
        this._currentEffectName = void 0;
      };
      UniformBuffer2.prototype.setDataBuffer = function(dataBuffer) {
        if (!this._buffers) {
          return this._buffer === dataBuffer;
        }
        for (var b = 0; b < this._buffers.length; ++b) {
          var buffer = this._buffers[b];
          if (buffer[0] === dataBuffer) {
            this._bufferIndex = b;
            this._buffer = dataBuffer;
            this._createBufferOnWrite = false;
            this._currentEffect = void 0;
            return true;
          }
        }
        return false;
      };
      UniformBuffer2.prototype.dispose = function() {
        if (this._noUBO) {
          return;
        }
        var uniformBuffers = this._engine._uniformBuffers;
        var index = uniformBuffers.indexOf(this);
        if (index !== -1) {
          uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
          uniformBuffers.pop();
        }
        if (this._engine._features.trackUbosInFrame && this._buffers) {
          for (var i = 0; i < this._buffers.length; ++i) {
            var buffer = this._buffers[i][0];
            this._engine._releaseBuffer(buffer);
          }
        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
          this._buffer = null;
        }
      };
      UniformBuffer2._UpdatedUbosInFrame = {};
      UniformBuffer2._MAX_UNIFORM_SIZE = 256;
      UniformBuffer2._TempBuffer = new Float32Array(UniformBuffer2._MAX_UNIFORM_SIZE);
      UniformBuffer2._TempBufferInt32View = new Uint32Array(UniformBuffer2._TempBuffer.buffer);
      return UniformBuffer2;
    }();
  }
});

// node_modules/@babylonjs/core/Buffers/buffer.js
var Buffer2, VertexBuffer;
var init_buffer = __esm({
  "node_modules/@babylonjs/core/Buffers/buffer.js"() {
    init_dataBuffer();
    init_sliceTools();
    Buffer2 = function() {
      function Buffer3(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor) {
        if (stride === void 0) {
          stride = 0;
        }
        if (postponeInternalCreation === void 0) {
          postponeInternalCreation = false;
        }
        if (instanced === void 0) {
          instanced = false;
        }
        if (useBytes === void 0) {
          useBytes = false;
        }
        this._isAlreadyOwned = false;
        if (engine.getScene) {
          this._engine = engine.getScene().getEngine();
        } else {
          this._engine = engine;
        }
        this._updatable = updatable;
        this._instanced = instanced;
        this._divisor = divisor || 1;
        if (data instanceof DataBuffer) {
          this._data = null;
          this._buffer = data;
        } else {
          this._data = data;
          this._buffer = null;
        }
        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
        if (!postponeInternalCreation) {
          this.create();
        }
      }
      Buffer3.prototype.createVertexBuffer = function(kind, offset, size, stride, instanced, useBytes, divisor) {
        if (useBytes === void 0) {
          useBytes = false;
        }
        var byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
        var byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
        return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
      };
      Buffer3.prototype.isUpdatable = function() {
        return this._updatable;
      };
      Buffer3.prototype.getData = function() {
        return this._data;
      };
      Buffer3.prototype.getBuffer = function() {
        return this._buffer;
      };
      Buffer3.prototype.getStrideSize = function() {
        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
      };
      Buffer3.prototype.create = function(data) {
        if (data === void 0) {
          data = null;
        }
        if (!data && this._buffer) {
          return;
        }
        data = data || this._data;
        if (!data) {
          return;
        }
        if (!this._buffer) {
          if (this._updatable) {
            this._buffer = this._engine.createDynamicVertexBuffer(data);
            this._data = data;
          } else {
            this._buffer = this._engine.createVertexBuffer(data);
          }
        } else if (this._updatable) {
          this._engine.updateDynamicVertexBuffer(this._buffer, data);
          this._data = data;
        }
      };
      Buffer3.prototype._rebuild = function() {
        this._buffer = null;
        this.create(this._data);
      };
      Buffer3.prototype.update = function(data) {
        this.create(data);
      };
      Buffer3.prototype.updateDirectly = function(data, offset, vertexCount, useBytes) {
        if (useBytes === void 0) {
          useBytes = false;
        }
        if (!this._buffer) {
          return;
        }
        if (this._updatable) {
          this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
          if (offset === 0 && vertexCount === void 0) {
            this._data = data;
          } else {
            this._data = null;
          }
        }
      };
      Buffer3.prototype._increaseReferences = function() {
        if (!this._buffer) {
          return;
        }
        if (!this._isAlreadyOwned) {
          this._isAlreadyOwned = true;
          return;
        }
        this._buffer.references++;
      };
      Buffer3.prototype.dispose = function() {
        if (!this._buffer) {
          return;
        }
        if (this._engine._releaseBuffer(this._buffer)) {
          this._buffer = null;
          this._data = null;
        }
      };
      return Buffer3;
    }();
    VertexBuffer = function() {
      function VertexBuffer2(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized, useBytes, divisor, takeBufferOwnership) {
        if (normalized === void 0) {
          normalized = false;
        }
        if (useBytes === void 0) {
          useBytes = false;
        }
        if (divisor === void 0) {
          divisor = 1;
        }
        if (takeBufferOwnership === void 0) {
          takeBufferOwnership = false;
        }
        if (data instanceof Buffer2) {
          this._buffer = data;
          this._ownsBuffer = takeBufferOwnership;
        } else {
          this._buffer = new Buffer2(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
          this._ownsBuffer = true;
        }
        this.uniqueId = VertexBuffer2._Counter++;
        this._kind = kind;
        if (type == void 0) {
          var data_1 = this.getData();
          this.type = VertexBuffer2.FLOAT;
          if (data_1 instanceof Int8Array) {
            this.type = VertexBuffer2.BYTE;
          } else if (data_1 instanceof Uint8Array) {
            this.type = VertexBuffer2.UNSIGNED_BYTE;
          } else if (data_1 instanceof Int16Array) {
            this.type = VertexBuffer2.SHORT;
          } else if (data_1 instanceof Uint16Array) {
            this.type = VertexBuffer2.UNSIGNED_SHORT;
          } else if (data_1 instanceof Int32Array) {
            this.type = VertexBuffer2.INT;
          } else if (data_1 instanceof Uint32Array) {
            this.type = VertexBuffer2.UNSIGNED_INT;
          }
        } else {
          this.type = type;
        }
        var typeByteLength = VertexBuffer2.GetTypeByteLength(this.type);
        if (useBytes) {
          this._size = size || (stride ? stride / typeByteLength : VertexBuffer2.DeduceStride(kind));
          this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
          this.byteOffset = offset || 0;
        } else {
          this._size = size || stride || VertexBuffer2.DeduceStride(kind);
          this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
          this.byteOffset = (offset || 0) * typeByteLength;
        }
        this.normalized = normalized;
        this._instanced = instanced !== void 0 ? instanced : false;
        this._instanceDivisor = instanced ? divisor : 0;
        this._computeHashCode();
      }
      Object.defineProperty(VertexBuffer2.prototype, "instanceDivisor", {
        get: function() {
          return this._instanceDivisor;
        },
        set: function(value) {
          this._instanceDivisor = value;
          if (value == 0) {
            this._instanced = false;
          } else {
            this._instanced = true;
          }
          this._computeHashCode();
        },
        enumerable: false,
        configurable: true
      });
      VertexBuffer2.prototype._computeHashCode = function() {
        this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
      };
      VertexBuffer2.prototype._rebuild = function() {
        if (!this._buffer) {
          return;
        }
        this._buffer._rebuild();
      };
      VertexBuffer2.prototype.getKind = function() {
        return this._kind;
      };
      VertexBuffer2.prototype.isUpdatable = function() {
        return this._buffer.isUpdatable();
      };
      VertexBuffer2.prototype.getData = function() {
        return this._buffer.getData();
      };
      VertexBuffer2.prototype.getFloatData = function(totalVertices, forceCopy) {
        var data = this.getData();
        if (!data) {
          return null;
        }
        var tightlyPackedByteStride = this.getSize() * VertexBuffer2.GetTypeByteLength(this.type);
        var count = totalVertices * this.getSize();
        if (this.type !== VertexBuffer2.FLOAT || this.byteStride !== tightlyPackedByteStride) {
          var copy_1 = new Float32Array(count);
          this.forEach(count, function(value, index) {
            return copy_1[index] = value;
          });
          return copy_1;
        }
        if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {
          if (data instanceof Array) {
            var offset = this.byteOffset / 4;
            return SliceTools.Slice(data, offset, offset + count);
          } else if (data instanceof ArrayBuffer) {
            return new Float32Array(data, this.byteOffset, count);
          } else {
            var offset = data.byteOffset + this.byteOffset;
            if (forceCopy) {
              var result = new Float32Array(count);
              var source = new Float32Array(data.buffer, offset, count);
              result.set(source);
              return result;
            }
            var remainder = offset % 4;
            if (remainder) {
              offset = Math.max(0, offset - remainder);
            }
            return new Float32Array(data.buffer, offset, count);
          }
        }
        if (forceCopy) {
          return SliceTools.Slice(data);
        }
        return data;
      };
      VertexBuffer2.prototype.getBuffer = function() {
        return this._buffer.getBuffer();
      };
      VertexBuffer2.prototype.getStrideSize = function() {
        return this.byteStride / VertexBuffer2.GetTypeByteLength(this.type);
      };
      VertexBuffer2.prototype.getOffset = function() {
        return this.byteOffset / VertexBuffer2.GetTypeByteLength(this.type);
      };
      VertexBuffer2.prototype.getSize = function(sizeInBytes) {
        if (sizeInBytes === void 0) {
          sizeInBytes = false;
        }
        return sizeInBytes ? this._size * VertexBuffer2.GetTypeByteLength(this.type) : this._size;
      };
      VertexBuffer2.prototype.getIsInstanced = function() {
        return this._instanced;
      };
      VertexBuffer2.prototype.getInstanceDivisor = function() {
        return this._instanceDivisor;
      };
      VertexBuffer2.prototype.create = function(data) {
        this._buffer.create(data);
      };
      VertexBuffer2.prototype.update = function(data) {
        this._buffer.update(data);
      };
      VertexBuffer2.prototype.updateDirectly = function(data, offset, useBytes) {
        if (useBytes === void 0) {
          useBytes = false;
        }
        this._buffer.updateDirectly(data, offset, void 0, useBytes);
      };
      VertexBuffer2.prototype.dispose = function() {
        if (this._ownsBuffer) {
          this._buffer.dispose();
        }
      };
      VertexBuffer2.prototype.forEach = function(count, callback) {
        VertexBuffer2.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
      };
      VertexBuffer2.DeduceStride = function(kind) {
        switch (kind) {
          case VertexBuffer2.UVKind:
          case VertexBuffer2.UV2Kind:
          case VertexBuffer2.UV3Kind:
          case VertexBuffer2.UV4Kind:
          case VertexBuffer2.UV5Kind:
          case VertexBuffer2.UV6Kind:
            return 2;
          case VertexBuffer2.NormalKind:
          case VertexBuffer2.PositionKind:
            return 3;
          case VertexBuffer2.ColorKind:
          case VertexBuffer2.MatricesIndicesKind:
          case VertexBuffer2.MatricesIndicesExtraKind:
          case VertexBuffer2.MatricesWeightsKind:
          case VertexBuffer2.MatricesWeightsExtraKind:
          case VertexBuffer2.TangentKind:
            return 4;
          default:
            throw new Error("Invalid kind '" + kind + "'");
        }
      };
      VertexBuffer2.GetTypeByteLength = function(type) {
        switch (type) {
          case VertexBuffer2.BYTE:
          case VertexBuffer2.UNSIGNED_BYTE:
            return 1;
          case VertexBuffer2.SHORT:
          case VertexBuffer2.UNSIGNED_SHORT:
            return 2;
          case VertexBuffer2.INT:
          case VertexBuffer2.UNSIGNED_INT:
          case VertexBuffer2.FLOAT:
            return 4;
          default:
            throw new Error("Invalid type '".concat(type, "'"));
        }
      };
      VertexBuffer2.ForEach = function(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
        if (data instanceof Array) {
          var offset = byteOffset / 4;
          var stride = byteStride / 4;
          for (var index = 0; index < count; index += componentCount) {
            for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
              callback(data[offset + componentIndex], index + componentIndex);
            }
            offset += stride;
          }
        } else {
          var dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
          var componentByteLength = VertexBuffer2.GetTypeByteLength(componentType);
          for (var index = 0; index < count; index += componentCount) {
            var componentByteOffset = byteOffset;
            for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
              var value = VertexBuffer2._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
              callback(value, index + componentIndex);
              componentByteOffset += componentByteLength;
            }
            byteOffset += byteStride;
          }
        }
      };
      VertexBuffer2._GetFloatValue = function(dataView, type, byteOffset, normalized) {
        switch (type) {
          case VertexBuffer2.BYTE: {
            var value = dataView.getInt8(byteOffset);
            if (normalized) {
              value = Math.max(value / 127, -1);
            }
            return value;
          }
          case VertexBuffer2.UNSIGNED_BYTE: {
            var value = dataView.getUint8(byteOffset);
            if (normalized) {
              value = value / 255;
            }
            return value;
          }
          case VertexBuffer2.SHORT: {
            var value = dataView.getInt16(byteOffset, true);
            if (normalized) {
              value = Math.max(value / 32767, -1);
            }
            return value;
          }
          case VertexBuffer2.UNSIGNED_SHORT: {
            var value = dataView.getUint16(byteOffset, true);
            if (normalized) {
              value = value / 65535;
            }
            return value;
          }
          case VertexBuffer2.INT: {
            return dataView.getInt32(byteOffset, true);
          }
          case VertexBuffer2.UNSIGNED_INT: {
            return dataView.getUint32(byteOffset, true);
          }
          case VertexBuffer2.FLOAT: {
            return dataView.getFloat32(byteOffset, true);
          }
          default: {
            throw new Error("Invalid component type ".concat(type));
          }
        }
      };
      VertexBuffer2._Counter = 0;
      VertexBuffer2.BYTE = 5120;
      VertexBuffer2.UNSIGNED_BYTE = 5121;
      VertexBuffer2.SHORT = 5122;
      VertexBuffer2.UNSIGNED_SHORT = 5123;
      VertexBuffer2.INT = 5124;
      VertexBuffer2.UNSIGNED_INT = 5125;
      VertexBuffer2.FLOAT = 5126;
      VertexBuffer2.PositionKind = "position";
      VertexBuffer2.NormalKind = "normal";
      VertexBuffer2.TangentKind = "tangent";
      VertexBuffer2.UVKind = "uv";
      VertexBuffer2.UV2Kind = "uv2";
      VertexBuffer2.UV3Kind = "uv3";
      VertexBuffer2.UV4Kind = "uv4";
      VertexBuffer2.UV5Kind = "uv5";
      VertexBuffer2.UV6Kind = "uv6";
      VertexBuffer2.ColorKind = "color";
      VertexBuffer2.ColorInstanceKind = "instanceColor";
      VertexBuffer2.MatricesIndicesKind = "matricesIndices";
      VertexBuffer2.MatricesWeightsKind = "matricesWeights";
      VertexBuffer2.MatricesIndicesExtraKind = "matricesIndicesExtra";
      VertexBuffer2.MatricesWeightsExtraKind = "matricesWeightsExtra";
      return VertexBuffer2;
    }();
  }
});

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo;
var init_pickingInfo = __esm({
  "node_modules/@babylonjs/core/Collisions/pickingInfo.js"() {
    init_math_vector();
    init_buffer();
    PickingInfo = function() {
      function PickingInfo2() {
        this._pickingUnavailable = false;
        this.hit = false;
        this.distance = 0;
        this.pickedPoint = null;
        this.pickedMesh = null;
        this.bu = 0;
        this.bv = 0;
        this.faceId = -1;
        this.subMeshFaceId = -1;
        this.subMeshId = 0;
        this.pickedSprite = null;
        this.thinInstanceIndex = -1;
        this.ray = null;
        this.originMesh = null;
        this.aimTransform = null;
        this.gripTransform = null;
      }
      PickingInfo2.prototype.getNormal = function(useWorldCoordinates, useVerticesNormals) {
        if (useWorldCoordinates === void 0) {
          useWorldCoordinates = false;
        }
        if (useVerticesNormals === void 0) {
          useVerticesNormals = true;
        }
        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          return null;
        }
        var indices = this.pickedMesh.getIndices();
        if (!indices) {
          return null;
        }
        var result;
        if (useVerticesNormals) {
          var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
          var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);
          var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);
          var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);
          normal0 = normal0.scale(this.bu);
          normal1 = normal1.scale(this.bv);
          normal2 = normal2.scale(1 - this.bu - this.bv);
          result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
        } else {
          var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
          var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);
          var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);
          var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);
          var p1p2 = vertex1.subtract(vertex2);
          var p3p2 = vertex3.subtract(vertex2);
          result = Vector3.Cross(p1p2, p3p2);
        }
        if (useWorldCoordinates) {
          var wm = this.pickedMesh.getWorldMatrix();
          if (this.pickedMesh.nonUniformScaling) {
            TmpVectors.Matrix[0].copyFrom(wm);
            wm = TmpVectors.Matrix[0];
            wm.setTranslationFromFloats(0, 0, 0);
            wm.invert();
            wm.transposeToRef(TmpVectors.Matrix[1]);
            wm = TmpVectors.Matrix[1];
          }
          result = Vector3.TransformNormal(result, wm);
        }
        result.normalize();
        return result;
      };
      PickingInfo2.prototype.getTextureCoordinates = function() {
        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          return null;
        }
        var indices = this.pickedMesh.getIndices();
        if (!indices) {
          return null;
        }
        var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);
        if (!uvs) {
          return null;
        }
        var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
        var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
        var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
        uv0 = uv0.scale(this.bu);
        uv1 = uv1.scale(this.bv);
        uv2 = uv2.scale(1 - this.bu - this.bv);
        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
      };
      return PickingInfo2;
    }();
  }
});

// node_modules/@babylonjs/core/PostProcesses/postProcessManager.js
var PostProcessManager;
var init_postProcessManager = __esm({
  "node_modules/@babylonjs/core/PostProcesses/postProcessManager.js"() {
    init_buffer();
    PostProcessManager = function() {
      function PostProcessManager2(scene) {
        this._vertexBuffers = {};
        this._scene = scene;
      }
      PostProcessManager2.prototype._prepareBuffers = function() {
        if (this._vertexBuffers[VertexBuffer.PositionKind]) {
          return;
        }
        var vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
        this._buildIndexBuffer();
      };
      PostProcessManager2.prototype._buildIndexBuffer = function() {
        var indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
      };
      PostProcessManager2.prototype._rebuild = function() {
        var vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (!vb) {
          return;
        }
        vb._rebuild();
        this._buildIndexBuffer();
      };
      PostProcessManager2.prototype._prepareFrame = function(sourceTexture, postProcesses) {
        if (sourceTexture === void 0) {
          sourceTexture = null;
        }
        if (postProcesses === void 0) {
          postProcesses = null;
        }
        var camera = this._scene.activeCamera;
        if (!camera) {
          return false;
        }
        postProcesses = postProcesses || camera._postProcesses.filter(function(pp) {
          return pp != null;
        });
        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
          return false;
        }
        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
        return true;
      };
      PostProcessManager2.prototype.directRender = function(postProcesses, targetTexture, forceFullscreenViewport, faceIndex, lodLevel, doNotBindFrambuffer) {
        var _a;
        if (targetTexture === void 0) {
          targetTexture = null;
        }
        if (forceFullscreenViewport === void 0) {
          forceFullscreenViewport = false;
        }
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lodLevel === void 0) {
          lodLevel = 0;
        }
        if (doNotBindFrambuffer === void 0) {
          doNotBindFrambuffer = false;
        }
        var engine = this._scene.getEngine();
        for (var index = 0; index < postProcesses.length; index++) {
          if (index < postProcesses.length - 1) {
            postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
          } else {
            if (targetTexture) {
              engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
            } else if (!doNotBindFrambuffer) {
              engine.restoreDefaultFramebuffer();
            }
            (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, "post process ".concat(postProcesses[index].name, " output"));
          }
          var pp = postProcesses[index];
          var effect = pp.apply();
          if (effect) {
            pp.onBeforeRenderObservable.notifyObservers(effect);
            this._prepareBuffers();
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
            engine.drawElementsType(0, 0, 6);
            pp.onAfterRenderObservable.notifyObservers(effect);
          }
        }
        engine.setDepthBuffer(true);
        engine.setDepthWrite(true);
      };
      PostProcessManager2.prototype._finalizeFrame = function(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport) {
        var _a;
        if (forceFullscreenViewport === void 0) {
          forceFullscreenViewport = false;
        }
        var camera = this._scene.activeCamera;
        if (!camera) {
          return;
        }
        postProcesses = postProcesses || camera._postProcesses.filter(function(pp2) {
          return pp2 != null;
        });
        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
          return;
        }
        var engine = this._scene.getEngine();
        for (var index = 0, len = postProcesses.length; index < len; index++) {
          var pp = postProcesses[index];
          if (index < len - 1) {
            pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
          } else {
            if (targetTexture) {
              engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
              pp._outputTexture = targetTexture;
            } else {
              engine.restoreDefaultFramebuffer();
              pp._outputTexture = null;
            }
            (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, "post process ".concat(postProcesses[index].name, " output"));
          }
          if (doNotPresent) {
            break;
          }
          var effect = pp.apply();
          if (effect) {
            pp.onBeforeRenderObservable.notifyObservers(effect);
            this._prepareBuffers();
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
            engine.drawElementsType(0, 0, 6);
            pp.onAfterRenderObservable.notifyObservers(effect);
          }
        }
        engine.setDepthBuffer(true);
        engine.setDepthWrite(true);
        engine.setAlphaMode(0);
      };
      PostProcessManager2.prototype.dispose = function() {
        var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (buffer) {
          buffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
          this._scene.getEngine()._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
      };
      return PostProcessManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Rendering/renderingGroup.js
var RenderingGroup;
var init_renderingGroup = __esm({
  "node_modules/@babylonjs/core/Rendering/renderingGroup.js"() {
    init_smartArray();
    init_math_vector();
    RenderingGroup = function() {
      function RenderingGroup2(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
        if (opaqueSortCompareFn === void 0) {
          opaqueSortCompareFn = null;
        }
        if (alphaTestSortCompareFn === void 0) {
          alphaTestSortCompareFn = null;
        }
        if (transparentSortCompareFn === void 0) {
          transparentSortCompareFn = null;
        }
        this.index = index;
        this._opaqueSubMeshes = new SmartArray(256);
        this._transparentSubMeshes = new SmartArray(256);
        this._alphaTestSubMeshes = new SmartArray(256);
        this._depthOnlySubMeshes = new SmartArray(256);
        this._particleSystems = new SmartArray(256);
        this._spriteManagers = new SmartArray(256);
        this._empty = true;
        this._edgesRenderers = new SmartArrayNoDuplicate(16);
        this._scene = scene;
        this.opaqueSortCompareFn = opaqueSortCompareFn;
        this.alphaTestSortCompareFn = alphaTestSortCompareFn;
        this.transparentSortCompareFn = transparentSortCompareFn;
      }
      Object.defineProperty(RenderingGroup2.prototype, "opaqueSortCompareFn", {
        set: function(value) {
          this._opaqueSortCompareFn = value;
          if (value) {
            this._renderOpaque = this._renderOpaqueSorted;
          } else {
            this._renderOpaque = RenderingGroup2._RenderUnsorted;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderingGroup2.prototype, "alphaTestSortCompareFn", {
        set: function(value) {
          this._alphaTestSortCompareFn = value;
          if (value) {
            this._renderAlphaTest = this._renderAlphaTestSorted;
          } else {
            this._renderAlphaTest = RenderingGroup2._RenderUnsorted;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderingGroup2.prototype, "transparentSortCompareFn", {
        set: function(value) {
          if (value) {
            this._transparentSortCompareFn = value;
          } else {
            this._transparentSortCompareFn = RenderingGroup2.defaultTransparentSortCompare;
          }
          this._renderTransparent = this._renderTransparentSorted;
        },
        enumerable: false,
        configurable: true
      });
      RenderingGroup2.prototype.render = function(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
        if (customRenderFunction) {
          customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
          return;
        }
        var engine = this._scene.getEngine();
        if (this._depthOnlySubMeshes.length !== 0) {
          engine.setColorWrite(false);
          this._renderAlphaTest(this._depthOnlySubMeshes);
          engine.setColorWrite(true);
        }
        if (this._opaqueSubMeshes.length !== 0) {
          this._renderOpaque(this._opaqueSubMeshes);
        }
        if (this._alphaTestSubMeshes.length !== 0) {
          this._renderAlphaTest(this._alphaTestSubMeshes);
        }
        var stencilState = engine.getStencilBuffer();
        engine.setStencilBuffer(false);
        if (renderSprites) {
          this._renderSprites();
        }
        if (renderParticles) {
          this._renderParticles(activeMeshes);
        }
        if (this.onBeforeTransparentRendering) {
          this.onBeforeTransparentRendering();
        }
        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
          engine.setStencilBuffer(stencilState);
          if (this._scene.useOrderIndependentTransparency) {
            var excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
            if (excludedMeshes.length) {
              this._renderTransparent(excludedMeshes);
            }
          } else {
            this._renderTransparent(this._transparentSubMeshes);
          }
          engine.setAlphaMode(0);
        }
        engine.setStencilBuffer(false);
        if (this._edgesRenderers.length) {
          for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
            this._edgesRenderers.data[edgesRendererIndex].render();
          }
          engine.setAlphaMode(0);
        }
        engine.setStencilBuffer(stencilState);
      };
      RenderingGroup2.prototype._renderOpaqueSorted = function(subMeshes) {
        return RenderingGroup2._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
      };
      RenderingGroup2.prototype._renderAlphaTestSorted = function(subMeshes) {
        return RenderingGroup2._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
      };
      RenderingGroup2.prototype._renderTransparentSorted = function(subMeshes) {
        return RenderingGroup2._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
      };
      RenderingGroup2._RenderSorted = function(subMeshes, sortCompareFn, camera, transparent) {
        var subIndex = 0;
        var subMesh;
        var cameraPosition = camera ? camera.globalPosition : RenderingGroup2._ZeroVector;
        for (; subIndex < subMeshes.length; subIndex++) {
          subMesh = subMeshes.data[subIndex];
          subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
          subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
        }
        var sortedArray = subMeshes.data.slice(0, subMeshes.length);
        if (sortCompareFn) {
          sortedArray.sort(sortCompareFn);
        }
        var scene = sortedArray[0].getMesh().getScene();
        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
          subMesh = sortedArray[subIndex];
          if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {
            continue;
          }
          if (transparent) {
            var material = subMesh.getMaterial();
            if (material && material.needDepthPrePass) {
              var engine = material.getScene().getEngine();
              engine.setColorWrite(false);
              engine.setAlphaMode(0);
              subMesh.render(false);
              engine.setColorWrite(true);
            }
          }
          subMesh.render(transparent);
        }
      };
      RenderingGroup2._RenderUnsorted = function(subMeshes) {
        var scene = subMeshes.data[0].getMesh().getScene();
        for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {
          var submesh = subMeshes.data[subIndex];
          if (scene._activeMeshesFrozenButKeepClipping && !submesh.isInFrustum(scene._frustumPlanes)) {
            continue;
          }
          submesh.render(false);
        }
      };
      RenderingGroup2.defaultTransparentSortCompare = function(a, b) {
        if (a._alphaIndex > b._alphaIndex) {
          return 1;
        }
        if (a._alphaIndex < b._alphaIndex) {
          return -1;
        }
        return RenderingGroup2.backToFrontSortCompare(a, b);
      };
      RenderingGroup2.backToFrontSortCompare = function(a, b) {
        if (a._distanceToCamera < b._distanceToCamera) {
          return 1;
        }
        if (a._distanceToCamera > b._distanceToCamera) {
          return -1;
        }
        return 0;
      };
      RenderingGroup2.frontToBackSortCompare = function(a, b) {
        if (a._distanceToCamera < b._distanceToCamera) {
          return -1;
        }
        if (a._distanceToCamera > b._distanceToCamera) {
          return 1;
        }
        return 0;
      };
      RenderingGroup2.prototype.prepare = function() {
        this._opaqueSubMeshes.reset();
        this._transparentSubMeshes.reset();
        this._alphaTestSubMeshes.reset();
        this._depthOnlySubMeshes.reset();
        this._particleSystems.reset();
        this._spriteManagers.reset();
        this._edgesRenderers.reset();
        this._empty = true;
      };
      RenderingGroup2.prototype.dispose = function() {
        this._opaqueSubMeshes.dispose();
        this._transparentSubMeshes.dispose();
        this._alphaTestSubMeshes.dispose();
        this._depthOnlySubMeshes.dispose();
        this._particleSystems.dispose();
        this._spriteManagers.dispose();
        this._edgesRenderers.dispose();
      };
      RenderingGroup2.prototype.dispatch = function(subMesh, mesh, material) {
        if (mesh === void 0) {
          mesh = subMesh.getMesh();
        }
        if (material === void 0) {
          material = subMesh.getMaterial();
        }
        if (material === null || material === void 0) {
          return;
        }
        if (material.needAlphaBlendingForMesh(mesh)) {
          this._transparentSubMeshes.push(subMesh);
        } else if (material.needAlphaTesting()) {
          if (material.needDepthPrePass) {
            this._depthOnlySubMeshes.push(subMesh);
          }
          this._alphaTestSubMeshes.push(subMesh);
        } else {
          if (material.needDepthPrePass) {
            this._depthOnlySubMeshes.push(subMesh);
          }
          this._opaqueSubMeshes.push(subMesh);
        }
        mesh._renderingGroup = this;
        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
          this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
        }
        this._empty = false;
      };
      RenderingGroup2.prototype.dispatchSprites = function(spriteManager) {
        this._spriteManagers.push(spriteManager);
        this._empty = false;
      };
      RenderingGroup2.prototype.dispatchParticles = function(particleSystem) {
        this._particleSystems.push(particleSystem);
        this._empty = false;
      };
      RenderingGroup2.prototype._renderParticles = function(activeMeshes) {
        if (this._particleSystems.length === 0) {
          return;
        }
        var activeCamera = this._scene.activeCamera;
        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
        for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
          var particleSystem = this._particleSystems.data[particleIndex];
          if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
            continue;
          }
          var emitter = particleSystem.emitter;
          if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
            this._scene._activeParticles.addCount(particleSystem.render(), false);
          }
        }
        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
      };
      RenderingGroup2.prototype._renderSprites = function() {
        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
          return;
        }
        var activeCamera = this._scene.activeCamera;
        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
        for (var id = 0; id < this._spriteManagers.length; id++) {
          var spriteManager = this._spriteManagers.data[id];
          if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
            spriteManager.render();
          }
        }
        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
      };
      RenderingGroup2._ZeroVector = Vector3.Zero();
      return RenderingGroup2;
    }();
  }
});

// node_modules/@babylonjs/core/Rendering/renderingManager.js
var RenderingGroupInfo, RenderingManager;
var init_renderingManager = __esm({
  "node_modules/@babylonjs/core/Rendering/renderingManager.js"() {
    init_renderingGroup();
    RenderingGroupInfo = function() {
      function RenderingGroupInfo2() {
      }
      return RenderingGroupInfo2;
    }();
    RenderingManager = function() {
      function RenderingManager2(scene) {
        this._useSceneAutoClearSetup = false;
        this._renderingGroups = new Array();
        this._autoClearDepthStencil = {};
        this._customOpaqueSortCompareFn = {};
        this._customAlphaTestSortCompareFn = {};
        this._customTransparentSortCompareFn = {};
        this._renderingGroupInfo = new RenderingGroupInfo();
        this._scene = scene;
        for (var i = RenderingManager2.MIN_RENDERINGGROUPS; i < RenderingManager2.MAX_RENDERINGGROUPS; i++) {
          this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
        }
      }
      RenderingManager2.prototype._clearDepthStencilBuffer = function(depth, stencil) {
        if (depth === void 0) {
          depth = true;
        }
        if (stencil === void 0) {
          stencil = true;
        }
        if (this._depthStencilBufferAlreadyCleaned) {
          return;
        }
        this._scene.getEngine().clear(null, false, depth, stencil);
        this._depthStencilBufferAlreadyCleaned = true;
      };
      RenderingManager2.prototype.render = function(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
        var info = this._renderingGroupInfo;
        info.scene = this._scene;
        info.camera = this._scene.activeCamera;
        if (this._scene.spriteManagers && renderSprites) {
          for (var index = 0; index < this._scene.spriteManagers.length; index++) {
            var manager = this._scene.spriteManagers[index];
            this.dispatchSprites(manager);
          }
        }
        for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
          this._depthStencilBufferAlreadyCleaned = index === RenderingManager2.MIN_RENDERINGGROUPS;
          var renderingGroup = this._renderingGroups[index];
          if (!renderingGroup || renderingGroup._empty) {
            continue;
          }
          var renderingGroupMask = Math.pow(2, index);
          info.renderingGroupId = index;
          this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
          if (RenderingManager2.AUTOCLEAR) {
            var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
            if (autoClear && autoClear.autoClear) {
              this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
            }
          }
          for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {
            var step = _a[_i];
            step.action(index);
          }
          renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
          for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {
            var step = _c[_b];
            step.action(index);
          }
          this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
        }
      };
      RenderingManager2.prototype.reset = function() {
        for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
          var renderingGroup = this._renderingGroups[index];
          if (renderingGroup) {
            renderingGroup.prepare();
          }
        }
      };
      RenderingManager2.prototype.dispose = function() {
        this.freeRenderingGroups();
        this._renderingGroups.length = 0;
        this._renderingGroupInfo = null;
      };
      RenderingManager2.prototype.freeRenderingGroups = function() {
        for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
          var renderingGroup = this._renderingGroups[index];
          if (renderingGroup) {
            renderingGroup.dispose();
          }
        }
      };
      RenderingManager2.prototype._prepareRenderingGroup = function(renderingGroupId) {
        if (this._renderingGroups[renderingGroupId] === void 0) {
          this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
        }
      };
      RenderingManager2.prototype.dispatchSprites = function(spriteManager) {
        var renderingGroupId = spriteManager.renderingGroupId || 0;
        this._prepareRenderingGroup(renderingGroupId);
        this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);
      };
      RenderingManager2.prototype.dispatchParticles = function(particleSystem) {
        var renderingGroupId = particleSystem.renderingGroupId || 0;
        this._prepareRenderingGroup(renderingGroupId);
        this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);
      };
      RenderingManager2.prototype.dispatch = function(subMesh, mesh, material) {
        if (mesh === void 0) {
          mesh = subMesh.getMesh();
        }
        var renderingGroupId = mesh.renderingGroupId || 0;
        this._prepareRenderingGroup(renderingGroupId);
        this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);
      };
      RenderingManager2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
        if (opaqueSortCompareFn === void 0) {
          opaqueSortCompareFn = null;
        }
        if (alphaTestSortCompareFn === void 0) {
          alphaTestSortCompareFn = null;
        }
        if (transparentSortCompareFn === void 0) {
          transparentSortCompareFn = null;
        }
        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
        if (this._renderingGroups[renderingGroupId]) {
          var group = this._renderingGroups[renderingGroupId];
          group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
          group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
          group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
        }
      };
      RenderingManager2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
        if (depth === void 0) {
          depth = true;
        }
        if (stencil === void 0) {
          stencil = true;
        }
        this._autoClearDepthStencil[renderingGroupId] = {
          autoClear: autoClearDepthStencil,
          depth,
          stencil
        };
      };
      RenderingManager2.prototype.getAutoClearDepthStencilSetup = function(index) {
        return this._autoClearDepthStencil[index];
      };
      RenderingManager2.MAX_RENDERINGGROUPS = 4;
      RenderingManager2.MIN_RENDERINGGROUPS = 0;
      RenderingManager2.AUTOCLEAR = true;
      return RenderingManager2;
    }();
  }
});

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants, Stage;
var init_sceneComponent = __esm({
  "node_modules/@babylonjs/core/sceneComponent.js"() {
    init_tslib_es6();
    SceneComponentConstants = function() {
      function SceneComponentConstants2() {
      }
      SceneComponentConstants2.NAME_EFFECTLAYER = "EffectLayer";
      SceneComponentConstants2.NAME_LAYER = "Layer";
      SceneComponentConstants2.NAME_LENSFLARESYSTEM = "LensFlareSystem";
      SceneComponentConstants2.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
      SceneComponentConstants2.NAME_PARTICLESYSTEM = "ParticleSystem";
      SceneComponentConstants2.NAME_GAMEPAD = "Gamepad";
      SceneComponentConstants2.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
      SceneComponentConstants2.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
      SceneComponentConstants2.NAME_PREPASSRENDERER = "PrePassRenderer";
      SceneComponentConstants2.NAME_DEPTHRENDERER = "DepthRenderer";
      SceneComponentConstants2.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
      SceneComponentConstants2.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
      SceneComponentConstants2.NAME_SPRITE = "Sprite";
      SceneComponentConstants2.NAME_SUBSURFACE = "SubSurface";
      SceneComponentConstants2.NAME_OUTLINERENDERER = "Outline";
      SceneComponentConstants2.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
      SceneComponentConstants2.NAME_SHADOWGENERATOR = "ShadowGenerator";
      SceneComponentConstants2.NAME_OCTREE = "Octree";
      SceneComponentConstants2.NAME_PHYSICSENGINE = "PhysicsEngine";
      SceneComponentConstants2.NAME_AUDIO = "Audio";
      SceneComponentConstants2.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
      SceneComponentConstants2.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
      SceneComponentConstants2.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
      SceneComponentConstants2.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
      SceneComponentConstants2.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
      SceneComponentConstants2.STEP_BEFORECAMERADRAW_PREPASS = 0;
      SceneComponentConstants2.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
      SceneComponentConstants2.STEP_BEFORECAMERADRAW_LAYER = 2;
      SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
      SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
      SceneComponentConstants2.STEP_BEFORERENDERINGMESH_PREPASS = 0;
      SceneComponentConstants2.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
      SceneComponentConstants2.STEP_AFTERRENDERINGMESH_PREPASS = 0;
      SceneComponentConstants2.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
      SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
      SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
      SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
      SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
      SceneComponentConstants2.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
      SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
      SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
      SceneComponentConstants2.STEP_AFTERCAMERADRAW_PREPASS = 0;
      SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
      SceneComponentConstants2.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
      SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
      SceneComponentConstants2.STEP_AFTERCAMERADRAW_LAYER = 4;
      SceneComponentConstants2.STEP_AFTERRENDER_AUDIO = 0;
      SceneComponentConstants2.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
      SceneComponentConstants2.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
      SceneComponentConstants2.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
      SceneComponentConstants2.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
      SceneComponentConstants2.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
      SceneComponentConstants2.STEP_BEFORECLEARSTAGE_PREPASS = 0;
      SceneComponentConstants2.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS = 0;
      SceneComponentConstants2.STEP_POINTERMOVE_SPRITE = 0;
      SceneComponentConstants2.STEP_POINTERDOWN_SPRITE = 0;
      SceneComponentConstants2.STEP_POINTERUP_SPRITE = 0;
      return SceneComponentConstants2;
    }();
    Stage = function(_super) {
      __extends(Stage2, _super);
      function Stage2(items) {
        return _super.apply(this, items) || this;
      }
      Stage2.Create = function() {
        return Object.create(Stage2.prototype);
      };
      Stage2.prototype.registerStep = function(index, component, action) {
        var i = 0;
        var maxIndex = Number.MAX_VALUE;
        for (; i < this.length; i++) {
          var step = this[i];
          maxIndex = step.index;
          if (index < maxIndex) {
            break;
          }
        }
        this.splice(i, 0, { index, component, action: action.bind(component) });
      };
      Stage2.prototype.clear = function() {
        this.length = 0;
      };
      return Stage2;
    }(Array);
  }
});

// node_modules/@babylonjs/core/Events/pointerEvents.js
var PointerEventTypes, PointerInfoBase, PointerInfoPre, PointerInfo;
var init_pointerEvents = __esm({
  "node_modules/@babylonjs/core/Events/pointerEvents.js"() {
    init_tslib_es6();
    init_math_vector();
    PointerEventTypes = function() {
      function PointerEventTypes2() {
      }
      PointerEventTypes2.POINTERDOWN = 1;
      PointerEventTypes2.POINTERUP = 2;
      PointerEventTypes2.POINTERMOVE = 4;
      PointerEventTypes2.POINTERWHEEL = 8;
      PointerEventTypes2.POINTERPICK = 16;
      PointerEventTypes2.POINTERTAP = 32;
      PointerEventTypes2.POINTERDOUBLETAP = 64;
      return PointerEventTypes2;
    }();
    PointerInfoBase = function() {
      function PointerInfoBase2(type, event) {
        this.type = type;
        this.event = event;
      }
      return PointerInfoBase2;
    }();
    PointerInfoPre = function(_super) {
      __extends(PointerInfoPre2, _super);
      function PointerInfoPre2(type, event, localX, localY) {
        var _this = _super.call(this, type, event) || this;
        _this.ray = null;
        _this.skipOnPointerObservable = false;
        _this.localPosition = new Vector2(localX, localY);
        return _this;
      }
      return PointerInfoPre2;
    }(PointerInfoBase);
    PointerInfo = function(_super) {
      __extends(PointerInfo2, _super);
      function PointerInfo2(type, event, pickInfo) {
        var _this = _super.call(this, type, event) || this;
        _this.pickInfo = pickInfo;
        return _this;
      }
      return PointerInfo2;
    }(PointerInfoBase);
  }
});

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes, KeyboardInfo, KeyboardInfoPre;
var init_keyboardEvents = __esm({
  "node_modules/@babylonjs/core/Events/keyboardEvents.js"() {
    init_tslib_es6();
    KeyboardEventTypes = function() {
      function KeyboardEventTypes2() {
      }
      KeyboardEventTypes2.KEYDOWN = 1;
      KeyboardEventTypes2.KEYUP = 2;
      return KeyboardEventTypes2;
    }();
    KeyboardInfo = function() {
      function KeyboardInfo2(type, event) {
        this.type = type;
        this.event = event;
      }
      return KeyboardInfo2;
    }();
    KeyboardInfoPre = function(_super) {
      __extends(KeyboardInfoPre2, _super);
      function KeyboardInfoPre2(type, event) {
        var _this = _super.call(this, type, event) || this;
        _this.type = type;
        _this.event = event;
        _this.skipOnKeyboardObservable = false;
        return _this;
      }
      Object.defineProperty(KeyboardInfoPre2.prototype, "skipOnPointerObservable", {
        get: function() {
          return this.skipOnKeyboardObservable;
        },
        set: function(value) {
          this.skipOnKeyboardObservable = value;
        },
        enumerable: false,
        configurable: true
      });
      return KeyboardInfoPre2;
    }(KeyboardInfo);
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType, PointerInput, NativePointerInput, DualShockInput, DualSenseInput, XboxInput, SwitchInput;
var init_deviceEnums = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js"() {
    (function(DeviceType2) {
      DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
      DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
      DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
      DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
      DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
      DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
      DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
      DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
    })(DeviceType || (DeviceType = {}));
    (function(PointerInput2) {
      PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
      PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
      PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
      PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
      PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
      PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
      PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
      PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
      PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
      PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
      PointerInput2[PointerInput2["Move"] = 12] = "Move";
    })(PointerInput || (PointerInput = {}));
    (function(NativePointerInput2) {
      NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
      NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
      NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
      NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
      NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
      NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
      NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
      NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
      NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
      NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
      NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
      NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
    })(NativePointerInput || (NativePointerInput = {}));
    (function(DualShockInput2) {
      DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
      DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
      DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
      DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
      DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
      DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
      DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
      DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
      DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
      DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
      DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
      DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
      DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
      DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
      DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
      DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
      DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
      DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
      DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
      DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
      DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
      DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(DualShockInput || (DualShockInput = {}));
    (function(DualSenseInput2) {
      DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
      DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
      DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
      DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
      DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
      DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
      DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
      DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
      DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
      DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
      DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
      DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
      DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
      DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
      DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
      DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
      DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
      DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
      DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
      DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
      DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
      DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(DualSenseInput || (DualSenseInput = {}));
    (function(XboxInput2) {
      XboxInput2[XboxInput2["A"] = 0] = "A";
      XboxInput2[XboxInput2["B"] = 1] = "B";
      XboxInput2[XboxInput2["X"] = 2] = "X";
      XboxInput2[XboxInput2["Y"] = 3] = "Y";
      XboxInput2[XboxInput2["LB"] = 4] = "LB";
      XboxInput2[XboxInput2["RB"] = 5] = "RB";
      XboxInput2[XboxInput2["LT"] = 6] = "LT";
      XboxInput2[XboxInput2["RT"] = 7] = "RT";
      XboxInput2[XboxInput2["Back"] = 8] = "Back";
      XboxInput2[XboxInput2["Start"] = 9] = "Start";
      XboxInput2[XboxInput2["LS"] = 10] = "LS";
      XboxInput2[XboxInput2["RS"] = 11] = "RS";
      XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
      XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
      XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
      XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
      XboxInput2[XboxInput2["Home"] = 16] = "Home";
      XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
      XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
      XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
      XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
    })(XboxInput || (XboxInput = {}));
    (function(SwitchInput2) {
      SwitchInput2[SwitchInput2["B"] = 0] = "B";
      SwitchInput2[SwitchInput2["A"] = 1] = "A";
      SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
      SwitchInput2[SwitchInput2["X"] = 3] = "X";
      SwitchInput2[SwitchInput2["L"] = 4] = "L";
      SwitchInput2[SwitchInput2["R"] = 5] = "R";
      SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
      SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
      SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
      SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
      SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
      SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
      SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
      SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
      SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
      SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
      SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
      SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
      SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
      SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
      SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
      SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(SwitchInput || (SwitchInput = {}));
  }
});

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType, EventConstants;
var init_deviceInputEvents = __esm({
  "node_modules/@babylonjs/core/Events/deviceInputEvents.js"() {
    (function(DeviceInputEventType2) {
      DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
      DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
      DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
    })(DeviceInputEventType || (DeviceInputEventType = {}));
    EventConstants = function() {
      function EventConstants2() {
      }
      EventConstants2.DOM_DELTA_PIXEL = 0;
      EventConstants2.DOM_DELTA_LINE = 1;
      EventConstants2.DOM_DELTA_PAGE = 2;
      return EventConstants2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js
var DeviceSource;
var init_deviceSource = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js"() {
    init_observable();
    DeviceSource = function() {
      function DeviceSource2(deviceInputSystem, deviceType, deviceSlot) {
        if (deviceSlot === void 0) {
          deviceSlot = 0;
        }
        this.deviceType = deviceType;
        this.deviceSlot = deviceSlot;
        this.onInputChangedObservable = new Observable();
        this._deviceInputSystem = deviceInputSystem;
      }
      DeviceSource2.prototype.getInput = function(inputIndex) {
        return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
      };
      return DeviceSource2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/Helpers/eventFactory.js
var DeviceEventFactory;
var init_eventFactory = __esm({
  "node_modules/@babylonjs/core/DeviceInput/Helpers/eventFactory.js"() {
    init_deviceInputEvents();
    init_deviceEnums();
    DeviceEventFactory = function() {
      function DeviceEventFactory2() {
      }
      DeviceEventFactory2.CreateDeviceEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        switch (deviceType) {
          case DeviceType.Keyboard:
            return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
          case DeviceType.Mouse:
            if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
              return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
            }
          case DeviceType.Touch:
            return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
          default:
            throw "Unable to generate event for device ".concat(DeviceType[deviceType]);
        }
      };
      DeviceEventFactory2._CreatePointerEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        var evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        if (deviceType === DeviceType.Mouse) {
          evt.deviceType = DeviceType.Mouse;
          evt.pointerId = 1;
          evt.pointerType = "mouse";
        } else {
          evt.deviceType = DeviceType.Touch;
          evt.pointerId = deviceSlot;
          evt.pointerType = "touch";
        }
        if (inputIndex === PointerInput.Move) {
          evt.type = "pointermove";
        } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
          evt.type = currentState === 1 ? "pointerdown" : "pointerup";
          evt.button = inputIndex - 2;
        }
        return evt;
      };
      DeviceEventFactory2._CreateWheelEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        var evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        evt.type = "wheel";
        evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
        evt.deltaX = 0;
        evt.deltaY = 0;
        evt.deltaZ = 0;
        switch (inputIndex) {
          case PointerInput.MouseWheelX:
            evt.deltaX = currentState;
            break;
          case PointerInput.MouseWheelY:
            evt.deltaY = currentState;
            break;
          case PointerInput.MouseWheelZ:
            evt.deltaZ = currentState;
            break;
        }
        return evt;
      };
      DeviceEventFactory2._CreateMouseEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        var evt = this._CreateEvent(elementToAttachTo);
        var pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
        var pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
        if (elementToAttachTo) {
          evt.movementX = 0;
          evt.movementY = 0;
          evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
          evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
        } else {
          evt.movementX = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaHorizontal);
          evt.movementY = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaVertical);
          evt.offsetX = 0;
          evt.offsetY = 0;
        }
        this._CheckNonCharacterKeys(evt, deviceInputSystem);
        evt.clientX = pointerX;
        evt.clientY = pointerY;
        evt.x = pointerX;
        evt.y = pointerY;
        evt.deviceType = deviceType;
        evt.deviceSlot = deviceSlot;
        evt.inputIndex = inputIndex;
        return evt;
      };
      DeviceEventFactory2._CreateKeyboardEvent = function(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        var evt = this._CreateEvent(elementToAttachTo);
        this._CheckNonCharacterKeys(evt, deviceInputSystem);
        evt.deviceType = DeviceType.Keyboard;
        evt.deviceSlot = 0;
        evt.inputIndex = inputIndex;
        evt.type = currentState === 1 ? "keydown" : "keyup";
        evt.key = String.fromCharCode(inputIndex);
        evt.keyCode = inputIndex;
        return evt;
      };
      DeviceEventFactory2._CheckNonCharacterKeys = function(evt, deviceInputSystem) {
        var isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
        var altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
        var ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
        var metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
        var shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
        evt.altKey = altKey;
        evt.ctrlKey = ctrlKey;
        evt.metaKey = metaKey;
        evt.shiftKey = shiftKey;
      };
      DeviceEventFactory2._CreateEvent = function(elementToAttachTo) {
        var evt = {};
        evt.preventDefault = function() {
        };
        evt.target = elementToAttachTo;
        return evt;
      };
      return DeviceEventFactory2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/nativeDeviceInputSystem.js
var NativeDeviceInputSystem;
var init_nativeDeviceInputSystem = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/nativeDeviceInputSystem.js"() {
    init_eventFactory();
    init_deviceEnums();
    NativeDeviceInputSystem = function() {
      function NativeDeviceInputSystem2(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
        var _this = this;
        this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, function(deviceType, deviceSlot, inputIndex, currentState) {
          var evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, _this);
          onInputChanged(deviceType, deviceSlot, evt);
        }) : this._createDummyNativeInput();
      }
      NativeDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
        return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
      };
      NativeDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
        return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
      };
      NativeDeviceInputSystem2.prototype.dispose = function() {
        this._nativeInput.dispose();
      };
      NativeDeviceInputSystem2.prototype._createDummyNativeInput = function() {
        var nativeInput = {
          pollInput: function() {
            return 0;
          },
          isDeviceAvailable: function() {
            return false;
          },
          dispose: function() {
          }
        };
        return nativeInput;
      };
      return NativeDeviceInputSystem2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/webDeviceInputSystem.js
var MAX_KEYCODES, MAX_POINTER_INPUTS, WebDeviceInputSystem;
var init_webDeviceInputSystem = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/webDeviceInputSystem.js"() {
    init_domManagement();
    init_tools();
    init_eventFactory();
    init_deviceEnums();
    MAX_KEYCODES = 255;
    MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
    WebDeviceInputSystem = function() {
      function WebDeviceInputSystem2(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
        var _this = this;
        this._inputs = [];
        this._keyboardActive = false;
        this._pointerActive = false;
        this._usingSafari = Tools.IsSafari();
        this._keyboardDownEvent = function(evt) {
        };
        this._keyboardUpEvent = function(evt) {
        };
        this._keyboardBlurEvent = function(evt) {
        };
        this._pointerMoveEvent = function(evt) {
        };
        this._pointerDownEvent = function(evt) {
        };
        this._pointerUpEvent = function(evt) {
        };
        this._pointerCancelEvent = function(evt) {
        };
        this._pointerWheelEvent = function(evt) {
        };
        this._pointerBlurEvent = function(evt) {
        };
        this._eventsAttached = false;
        this._mouseId = -1;
        this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
        this._maxTouchPoints = 0;
        this._pointerInputClearObserver = null;
        this._gamepadConnectedEvent = function(evt) {
        };
        this._gamepadDisconnectedEvent = function(evt) {
        };
        this._eventPrefix = Tools.GetPointerPrefix(engine);
        this._engine = engine;
        this._onDeviceConnected = onDeviceConnected;
        this._onDeviceDisconnected = onDeviceDisconnected;
        this._onInputChanged = onInputChanged;
        this._enableEvents();
        if (!this._engine._onEngineViewChanged) {
          this._engine._onEngineViewChanged = function() {
            _this._enableEvents();
          };
        }
      }
      WebDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
        var device = this._inputs[deviceType][deviceSlot];
        if (!device) {
          throw "Unable to find device ".concat(DeviceType[deviceType]);
        }
        if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense && navigator.getGamepads) {
          this._updateDevice(deviceType, deviceSlot, inputIndex);
        }
        var currentValue = device[inputIndex];
        if (currentValue === void 0) {
          throw "Unable to find input ".concat(inputIndex, " for device ").concat(DeviceType[deviceType], " in slot ").concat(deviceSlot);
        }
        if (inputIndex === PointerInput.Move) {
          Tools.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.");
        }
        return currentValue;
      };
      WebDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
        return this._inputs[deviceType] !== void 0;
      };
      WebDeviceInputSystem2.prototype.dispose = function() {
        this._onDeviceConnected = function() {
        };
        this._onDeviceDisconnected = function() {
        };
        this._onInputChanged = function() {
        };
        delete this._engine._onEngineViewChanged;
        if (this._elementToAttachTo) {
          this._disableEvents();
        }
      };
      WebDeviceInputSystem2.prototype._enableEvents = function() {
        var inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
        if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
          this._disableEvents();
          if (this._inputs) {
            for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {
              var inputs = _a[_i];
              if (inputs) {
                for (var deviceSlotKey in inputs) {
                  var deviceSlot = +deviceSlotKey;
                  var device = inputs[deviceSlot];
                  if (device) {
                    for (var inputIndex = 0; inputIndex < device.length; inputIndex++) {
                      device[inputIndex] = 0;
                    }
                  }
                }
              }
            }
          }
          this._elementToAttachTo = inputElement;
          this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
          this._handleKeyActions();
          this._handlePointerActions();
          this._handleGamepadActions();
          this._eventsAttached = true;
          this._checkForConnectedDevices();
        }
      };
      WebDeviceInputSystem2.prototype._disableEvents = function() {
        if (this._elementToAttachTo) {
          this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
          this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
          this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
          this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
          this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
          window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
          window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
        }
        if (this._pointerInputClearObserver) {
          this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
        }
        this._eventsAttached = false;
      };
      WebDeviceInputSystem2.prototype._checkForConnectedDevices = function() {
        if (navigator.getGamepads) {
          var gamepads = navigator.getGamepads();
          for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {
            var gamepad = gamepads_1[_i];
            if (gamepad) {
              this._addGamePad(gamepad);
            }
          }
        }
        if (matchMedia("(pointer:fine)").matches) {
          this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
        }
      };
      WebDeviceInputSystem2.prototype._addGamePad = function(gamepad) {
        var deviceType = this._getGamepadDeviceType(gamepad.id);
        var deviceSlot = gamepad.index;
        this._gamepads = this._gamepads || new Array(gamepad.index + 1);
        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
        this._gamepads[deviceSlot] = deviceType;
      };
      WebDeviceInputSystem2.prototype._addPointerDevice = function(deviceType, deviceSlot, currentX, currentY) {
        if (!this._pointerActive) {
          this._pointerActive = true;
        }
        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
        var pointer = this._inputs[deviceType][deviceSlot];
        pointer[0] = currentX;
        pointer[1] = currentY;
      };
      WebDeviceInputSystem2.prototype._registerDevice = function(deviceType, deviceSlot, numberOfInputs) {
        if (deviceSlot === void 0) {
          throw "Unable to register device ".concat(DeviceType[deviceType], " to undefined slot.");
        }
        if (!this._inputs[deviceType]) {
          this._inputs[deviceType] = {};
        }
        if (!this._inputs[deviceType][deviceSlot]) {
          var device = new Array(numberOfInputs);
          for (var i = 0; i < numberOfInputs; i++) {
            device[i] = 0;
          }
          this._inputs[deviceType][deviceSlot] = device;
          this._onDeviceConnected(deviceType, deviceSlot);
        }
      };
      WebDeviceInputSystem2.prototype._unregisterDevice = function(deviceType, deviceSlot) {
        if (this._inputs[deviceType][deviceSlot]) {
          delete this._inputs[deviceType][deviceSlot];
          this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      };
      WebDeviceInputSystem2.prototype._handleKeyActions = function() {
        var _this = this;
        this._keyboardDownEvent = function(evt) {
          if (!_this._keyboardActive) {
            _this._keyboardActive = true;
            _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
          }
          var kbKey = _this._inputs[DeviceType.Keyboard][0];
          if (kbKey) {
            kbKey[evt.keyCode] = 1;
            var deviceEvent = evt;
            deviceEvent.inputIndex = evt.keyCode;
            _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        };
        this._keyboardUpEvent = function(evt) {
          if (!_this._keyboardActive) {
            _this._keyboardActive = true;
            _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
          }
          var kbKey = _this._inputs[DeviceType.Keyboard][0];
          if (kbKey) {
            kbKey[evt.keyCode] = 0;
            var deviceEvent = evt;
            deviceEvent.inputIndex = evt.keyCode;
            _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        };
        this._keyboardBlurEvent = function() {
          if (_this._keyboardActive) {
            var kbKey = _this._inputs[DeviceType.Keyboard][0];
            for (var i = 0; i < kbKey.length; i++) {
              if (kbKey[i] !== 0) {
                kbKey[i] = 0;
                var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, _this, _this._elementToAttachTo);
                _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
              }
            }
          }
        };
        this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
        this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
        this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
      };
      WebDeviceInputSystem2.prototype._handlePointerActions = function() {
        var _this = this;
        this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
        if (!this._activeTouchIds) {
          this._activeTouchIds = new Array(this._maxTouchPoints);
        }
        for (var i = 0; i < this._maxTouchPoints; i++) {
          this._activeTouchIds[i] = -1;
        }
        this._pointerMoveEvent = function(evt) {
          var deviceType = _this._getPointerType(evt);
          var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
          if (!_this._inputs[deviceType]) {
            _this._inputs[deviceType] = {};
          }
          if (!_this._inputs[deviceType][deviceSlot]) {
            _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
          }
          var pointer = _this._inputs[deviceType][deviceSlot];
          if (pointer) {
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            var deviceEvent = evt;
            deviceEvent.inputIndex = PointerInput.Move;
            _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (!_this._usingSafari && evt.button !== -1) {
              deviceEvent.inputIndex = evt.button + 2;
              pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        this._pointerDownEvent = function(evt) {
          var deviceType = _this._getPointerType(evt);
          var deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
          if (deviceType === DeviceType.Touch) {
            var idx = _this._activeTouchIds.indexOf(-1);
            if (idx >= 0) {
              deviceSlot = idx;
              _this._activeTouchIds[idx] = evt.pointerId;
            } else {
              Tools.Warn("Max number of touches exceeded.  Ignoring touches in excess of ".concat(_this._maxTouchPoints));
              return;
            }
          }
          if (!_this._inputs[deviceType]) {
            _this._inputs[deviceType] = {};
          }
          if (!_this._inputs[deviceType][deviceSlot]) {
            _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
          } else if (deviceType === DeviceType.Touch) {
            _this._onDeviceConnected(deviceType, deviceSlot);
          }
          var pointer = _this._inputs[deviceType][deviceSlot];
          if (pointer) {
            var previousHorizontal = pointer[PointerInput.Horizontal];
            var previousVertical = pointer[PointerInput.Vertical];
            if (deviceType === DeviceType.Mouse) {
              if (_this._mouseId === -1) {
                if (evt.pointerId === void 0) {
                  _this._mouseId = _this._isUsingFirefox ? 0 : 1;
                } else {
                  _this._mouseId = evt.pointerId;
                }
              }
              if (!document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
                try {
                  _this._elementToAttachTo.setPointerCapture(_this._mouseId);
                } catch (e) {
                }
              }
            } else {
              if (evt.pointerId && !document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
                try {
                  _this._elementToAttachTo.setPointerCapture(evt.pointerId);
                } catch (e) {
                }
              }
            }
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            pointer[evt.button + 2] = 1;
            var deviceEvent = evt;
            deviceEvent.inputIndex = evt.button + 2;
            _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
              deviceEvent.inputIndex = PointerInput.Move;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        this._pointerUpEvent = function(evt) {
          var _a, _b, _c, _d, _e;
          var deviceType = _this._getPointerType(evt);
          var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
          if (deviceType === DeviceType.Touch) {
            if (deviceSlot === -1) {
              return;
            } else {
              _this._activeTouchIds[deviceSlot] = -1;
            }
          }
          var pointer = (_a = _this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
          if (pointer && pointer[evt.button + 2] !== 0) {
            var previousHorizontal = pointer[PointerInput.Horizontal];
            var previousVertical = pointer[PointerInput.Vertical];
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            pointer[evt.button + 2] = 0;
            var deviceEvent = evt;
            if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
              deviceEvent.inputIndex = PointerInput.Move;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            deviceEvent.inputIndex = evt.button + 2;
            if (deviceType === DeviceType.Mouse && _this._mouseId >= 0 && ((_c = (_b = _this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, _this._mouseId))) {
              _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
            } else if (evt.pointerId && ((_e = (_d = _this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
              _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
            }
            _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (deviceType === DeviceType.Touch) {
              _this._onDeviceDisconnected(deviceType, deviceSlot);
            }
          }
        };
        this._pointerCancelEvent = function(evt) {
          var _a, _b, _c, _d;
          if (evt.pointerType === "mouse") {
            var pointer = _this._inputs[DeviceType.Mouse][0];
            if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {
              _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
            }
            for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
              if (pointer[inputIndex] === 1) {
                pointer[inputIndex] = 0;
                var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
                _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
              }
            }
          } else {
            var deviceSlot = _this._activeTouchIds.indexOf(evt.pointerId);
            if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {
              _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
            }
            _this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
            _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            _this._activeTouchIds[deviceSlot] = -1;
            _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        };
        this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
        var passiveSupported = false;
        var noop = function() {
        };
        try {
          var options = {
            passive: {
              get: function() {
                passiveSupported = true;
              }
            }
          };
          this._elementToAttachTo.addEventListener("test", noop, options);
          this._elementToAttachTo.removeEventListener("test", noop, options);
        } catch (e) {
        }
        this._pointerBlurEvent = function() {
          var _a, _b, _c, _d, _e;
          if (_this.isDeviceAvailable(DeviceType.Mouse)) {
            var pointer = _this._inputs[DeviceType.Mouse][0];
            if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {
              _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
            }
            for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
              if (pointer[inputIndex] === 1) {
                pointer[inputIndex] = 0;
                var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
                _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
              }
            }
          }
          if (_this.isDeviceAvailable(DeviceType.Touch)) {
            var pointer = _this._inputs[DeviceType.Touch];
            for (var deviceSlot = 0; deviceSlot < _this._activeTouchIds.length; deviceSlot++) {
              var pointerId = _this._activeTouchIds[deviceSlot];
              if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {
                _this._elementToAttachTo.releasePointerCapture(pointerId);
              }
              if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
                pointer[deviceSlot][PointerInput.LeftClick] = 0;
                var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
                _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
                _this._activeTouchIds[deviceSlot] = -1;
                _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
              }
            }
          }
        };
        this._pointerWheelEvent = function(evt) {
          var deviceType = DeviceType.Mouse;
          var deviceSlot = 0;
          if (!_this._inputs[deviceType]) {
            _this._inputs[deviceType] = [];
          }
          if (!_this._inputs[deviceType][deviceSlot]) {
            _this._pointerActive = true;
            _this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
          }
          var pointer = _this._inputs[deviceType][deviceSlot];
          if (pointer) {
            pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
            pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
            pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
            var deviceEvent = evt;
            if (pointer[PointerInput.MouseWheelX] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelX;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            if (pointer[PointerInput.MouseWheelY] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelY;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            if (pointer[PointerInput.MouseWheelZ] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelZ;
              _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
        this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function() {
          if (_this.isDeviceAvailable(DeviceType.Mouse)) {
            var pointer = _this._inputs[DeviceType.Mouse][0];
            pointer[PointerInput.MouseWheelX] = 0;
            pointer[PointerInput.MouseWheelY] = 0;
            pointer[PointerInput.MouseWheelZ] = 0;
          }
        });
      };
      WebDeviceInputSystem2.prototype._handleGamepadActions = function() {
        var _this = this;
        this._gamepadConnectedEvent = function(evt) {
          _this._addGamePad(evt.gamepad);
        };
        this._gamepadDisconnectedEvent = function(evt) {
          if (_this._gamepads) {
            var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);
            var deviceSlot = evt.gamepad.index;
            _this._unregisterDevice(deviceType, deviceSlot);
            delete _this._gamepads[deviceSlot];
          }
        };
        window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
        window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
      };
      WebDeviceInputSystem2.prototype._updateDevice = function(deviceType, deviceSlot, inputIndex) {
        var gp = navigator.getGamepads()[deviceSlot];
        if (gp && deviceType === this._gamepads[deviceSlot]) {
          var device = this._inputs[deviceType][deviceSlot];
          if (inputIndex >= gp.buttons.length) {
            device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
          } else {
            device[inputIndex] = gp.buttons[inputIndex].value;
          }
        }
      };
      WebDeviceInputSystem2.prototype._getGamepadDeviceType = function(deviceName) {
        if (deviceName.indexOf("054c") !== -1) {
          return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
        } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
          return DeviceType.Xbox;
        } else if (deviceName.indexOf("057e") !== -1) {
          return DeviceType.Switch;
        }
        return DeviceType.Generic;
      };
      WebDeviceInputSystem2.prototype._getPointerType = function(evt) {
        var deviceType = DeviceType.Mouse;
        if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
          deviceType = DeviceType.Touch;
        }
        return deviceType;
      };
      return WebDeviceInputSystem2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/internalDeviceSourceManager.js
var InternalDeviceSourceManager;
var init_internalDeviceSourceManager = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/internalDeviceSourceManager.js"() {
    init_deviceEnums();
    init_nativeDeviceInputSystem();
    init_webDeviceInputSystem();
    init_deviceSource();
    InternalDeviceSourceManager = function() {
      function InternalDeviceSourceManager2(engine) {
        var _this = this;
        this._registeredManagers = new Array();
        this._refCount = 0;
        this.registerManager = function(manager) {
          for (var deviceType = 0; deviceType < _this._devices.length; deviceType++) {
            var device = _this._devices[deviceType];
            for (var deviceSlotKey in device) {
              var deviceSlot = +deviceSlotKey;
              manager._addDevice(new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot));
            }
          }
          _this._registeredManagers.push(manager);
        };
        this.unregisterManager = function(manager) {
          var idx = _this._registeredManagers.indexOf(manager);
          if (idx > -1) {
            _this._registeredManagers.splice(idx, 1);
          }
        };
        var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
        this._devices = new Array(numberOfDeviceTypes);
        var onDeviceConnected = function(deviceType, deviceSlot) {
          if (!_this._devices[deviceType]) {
            _this._devices[deviceType] = new Array();
          }
          if (!_this._devices[deviceType][deviceSlot]) {
            _this._devices[deviceType][deviceSlot] = deviceSlot;
          }
          for (var _i = 0, _a = _this._registeredManagers; _i < _a.length; _i++) {
            var manager = _a[_i];
            var deviceSource = new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot);
            manager._addDevice(deviceSource);
          }
        };
        var onDeviceDisconnected = function(deviceType, deviceSlot) {
          var _a;
          if ((_a = _this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) {
            delete _this._devices[deviceType][deviceSlot];
          }
          for (var _i = 0, _b = _this._registeredManagers; _i < _b.length; _i++) {
            var manager = _b[_i];
            manager._removeDevice(deviceType, deviceSlot);
          }
        };
        var onInputChanged = function(deviceType, deviceSlot, eventData) {
          if (eventData) {
            for (var _i = 0, _a = _this._registeredManagers; _i < _a.length; _i++) {
              var manager = _a[_i];
              manager._onInputChanged(deviceType, deviceSlot, eventData);
            }
          }
        };
        if (typeof _native !== "undefined") {
          this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
        } else {
          this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
        }
      }
      InternalDeviceSourceManager2.prototype.dispose = function() {
        this._deviceInputSystem.dispose();
      };
      return InternalDeviceSourceManager2;
    }();
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSourceManager;
var init_deviceSourceManager = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js"() {
    init_deviceEnums();
    init_observable();
    init_internalDeviceSourceManager();
    DeviceSourceManager = function() {
      function DeviceSourceManager2(engine) {
        var _this = this;
        var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
        this._devices = new Array(numberOfDeviceTypes);
        this._firstDevice = new Array(numberOfDeviceTypes);
        this._engine = engine;
        if (!this._engine._deviceSourceManager) {
          this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
        }
        this._engine._deviceSourceManager._refCount++;
        this.onDeviceConnectedObservable = new Observable(function(observer) {
          for (var _i = 0, _a = _this._devices; _i < _a.length; _i++) {
            var devices = _a[_i];
            if (devices) {
              for (var _b = 0, devices_1 = devices; _b < devices_1.length; _b++) {
                var device = devices_1[_b];
                if (device) {
                  _this.onDeviceConnectedObservable.notifyObserver(observer, device);
                }
              }
            }
          }
        });
        this.onDeviceDisconnectedObservable = new Observable();
        this._engine._deviceSourceManager.registerManager(this);
        this._onDisposeObserver = engine.onDisposeObservable.add(function() {
          _this.dispose();
        });
      }
      DeviceSourceManager2.prototype.getDeviceSource = function(deviceType, deviceSlot) {
        if (deviceSlot === void 0) {
          if (this._firstDevice[deviceType] === void 0) {
            return null;
          }
          deviceSlot = this._firstDevice[deviceType];
        }
        if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
          return null;
        }
        return this._devices[deviceType][deviceSlot];
      };
      DeviceSourceManager2.prototype.getDeviceSources = function(deviceType) {
        return this._devices[deviceType].filter(function(source) {
          return !!source;
        });
      };
      DeviceSourceManager2.prototype.dispose = function() {
        this.onDeviceConnectedObservable.clear();
        this.onDeviceDisconnectedObservable.clear();
        if (this._engine._deviceSourceManager) {
          this._engine._deviceSourceManager.unregisterManager(this);
          if (--this._engine._deviceSourceManager._refCount < 1) {
            this._engine._deviceSourceManager.dispose();
            delete this._engine._deviceSourceManager;
          }
        }
        this._engine.onDisposeObservable.remove(this._onDisposeObserver);
      };
      DeviceSourceManager2.prototype._addDevice = function(deviceSource) {
        if (!this._devices[deviceSource.deviceType]) {
          this._devices[deviceSource.deviceType] = new Array();
        }
        if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
          this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
          this._updateFirstDevices(deviceSource.deviceType);
        }
        this.onDeviceConnectedObservable.notifyObservers(deviceSource);
      };
      DeviceSourceManager2.prototype._removeDevice = function(deviceType, deviceSlot) {
        var _a, _b;
        var deviceSource = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
        this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
        if ((_b = this._devices[deviceType]) === null || _b === void 0 ? void 0 : _b[deviceSlot]) {
          delete this._devices[deviceType][deviceSlot];
        }
        this._updateFirstDevices(deviceType);
      };
      DeviceSourceManager2.prototype._onInputChanged = function(deviceType, deviceSlot, eventData) {
        var _a, _b;
        (_b = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) === null || _b === void 0 ? void 0 : _b.onInputChangedObservable.notifyObservers(eventData);
      };
      DeviceSourceManager2.prototype._updateFirstDevices = function(type) {
        switch (type) {
          case DeviceType.Keyboard:
          case DeviceType.Mouse:
            this._firstDevice[type] = 0;
            break;
          case DeviceType.Touch:
          case DeviceType.DualSense:
          case DeviceType.DualShock:
          case DeviceType.Xbox:
          case DeviceType.Switch:
          case DeviceType.Generic: {
            delete this._firstDevice[type];
            var devices = this._devices[type];
            if (devices) {
              for (var i = 0; i < devices.length; i++) {
                if (devices[i]) {
                  this._firstDevice[type] = i;
                  break;
                }
              }
            }
            break;
          }
        }
      };
      return DeviceSourceManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/perfCounter.js
var PerfCounter;
var init_perfCounter = __esm({
  "node_modules/@babylonjs/core/Misc/perfCounter.js"() {
    init_precisionDate();
    PerfCounter = function() {
      function PerfCounter2() {
        this._startMonitoringTime = 0;
        this._min = 0;
        this._max = 0;
        this._average = 0;
        this._lastSecAverage = 0;
        this._current = 0;
        this._totalValueCount = 0;
        this._totalAccumulated = 0;
        this._lastSecAccumulated = 0;
        this._lastSecTime = 0;
        this._lastSecValueCount = 0;
      }
      Object.defineProperty(PerfCounter2.prototype, "min", {
        get: function() {
          return this._min;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "max", {
        get: function() {
          return this._max;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "average", {
        get: function() {
          return this._average;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "lastSecAverage", {
        get: function() {
          return this._lastSecAverage;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "current", {
        get: function() {
          return this._current;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "total", {
        get: function() {
          return this._totalAccumulated;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerfCounter2.prototype, "count", {
        get: function() {
          return this._totalValueCount;
        },
        enumerable: false,
        configurable: true
      });
      PerfCounter2.prototype.fetchNewFrame = function() {
        this._totalValueCount++;
        this._current = 0;
        this._lastSecValueCount++;
      };
      PerfCounter2.prototype.addCount = function(newCount, fetchResult) {
        if (!PerfCounter2.Enabled) {
          return;
        }
        this._current += newCount;
        if (fetchResult) {
          this._fetchResult();
        }
      };
      PerfCounter2.prototype.beginMonitoring = function() {
        if (!PerfCounter2.Enabled) {
          return;
        }
        this._startMonitoringTime = PrecisionDate.Now;
      };
      PerfCounter2.prototype.endMonitoring = function(newFrame) {
        if (newFrame === void 0) {
          newFrame = true;
        }
        if (!PerfCounter2.Enabled) {
          return;
        }
        if (newFrame) {
          this.fetchNewFrame();
        }
        var currentTime = PrecisionDate.Now;
        this._current = currentTime - this._startMonitoringTime;
        if (newFrame) {
          this._fetchResult();
        }
      };
      PerfCounter2.prototype._fetchResult = function() {
        this._totalAccumulated += this._current;
        this._lastSecAccumulated += this._current;
        this._min = Math.min(this._min, this._current);
        this._max = Math.max(this._max, this._current);
        this._average = this._totalAccumulated / this._totalValueCount;
        var now = PrecisionDate.Now;
        if (now - this._lastSecTime > 1e3) {
          this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
          this._lastSecTime = now;
          this._lastSecAccumulated = 0;
          this._lastSecValueCount = 0;
        }
      };
      PerfCounter2.Enabled = true;
      return PerfCounter2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.plane.js
var Plane;
var init_math_plane = __esm({
  "node_modules/@babylonjs/core/Maths/math.plane.js"() {
    init_math_vector();
    Plane = function() {
      function Plane2(a, b, c, d) {
        this.normal = new Vector3(a, b, c);
        this.d = d;
      }
      Plane2.prototype.asArray = function() {
        return [this.normal.x, this.normal.y, this.normal.z, this.d];
      };
      Plane2.prototype.clone = function() {
        return new Plane2(this.normal.x, this.normal.y, this.normal.z, this.d);
      };
      Plane2.prototype.getClassName = function() {
        return "Plane";
      };
      Plane2.prototype.getHashCode = function() {
        var hash = this.normal.getHashCode();
        hash = hash * 397 ^ (this.d | 0);
        return hash;
      };
      Plane2.prototype.normalize = function() {
        var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
        var magnitude = 0;
        if (norm !== 0) {
          magnitude = 1 / norm;
        }
        this.normal.x *= magnitude;
        this.normal.y *= magnitude;
        this.normal.z *= magnitude;
        this.d *= magnitude;
        return this;
      };
      Plane2.prototype.transform = function(transformation) {
        var invertedMatrix = Plane2._TmpMatrix;
        transformation.invertToRef(invertedMatrix);
        var m = invertedMatrix.m;
        var x = this.normal.x;
        var y = this.normal.y;
        var z = this.normal.z;
        var d = this.d;
        var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
        var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
        var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
        var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
        return new Plane2(normalX, normalY, normalZ, finalD);
      };
      Plane2.prototype.dotCoordinate = function(point) {
        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
      };
      Plane2.prototype.copyFromPoints = function(point1, point2, point3) {
        var x1 = point2.x - point1.x;
        var y1 = point2.y - point1.y;
        var z1 = point2.z - point1.z;
        var x2 = point3.x - point1.x;
        var y2 = point3.y - point1.y;
        var z2 = point3.z - point1.z;
        var yz = y1 * z2 - z1 * y2;
        var xz = z1 * x2 - x1 * z2;
        var xy = x1 * y2 - y1 * x2;
        var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
        var invPyth;
        if (pyth !== 0) {
          invPyth = 1 / pyth;
        } else {
          invPyth = 0;
        }
        this.normal.x = yz * invPyth;
        this.normal.y = xz * invPyth;
        this.normal.z = xy * invPyth;
        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
        return this;
      };
      Plane2.prototype.isFrontFacingTo = function(direction, epsilon) {
        var dot = Vector3.Dot(this.normal, direction);
        return dot <= epsilon;
      };
      Plane2.prototype.signedDistanceTo = function(point) {
        return Vector3.Dot(point, this.normal) + this.d;
      };
      Plane2.FromArray = function(array) {
        return new Plane2(array[0], array[1], array[2], array[3]);
      };
      Plane2.FromPoints = function(point1, point2, point3) {
        var result = new Plane2(0, 0, 0, 0);
        result.copyFromPoints(point1, point2, point3);
        return result;
      };
      Plane2.FromPositionAndNormal = function(origin, normal) {
        var result = new Plane2(0, 0, 0, 0);
        normal.normalize();
        result.normal = normal;
        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
        return result;
      };
      Plane2.SignedDistanceToPlaneFromPositionAndNormal = function(origin, normal, point) {
        var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
        return Vector3.Dot(point, normal) + d;
      };
      Plane2._TmpMatrix = Matrix.Identity();
      return Plane2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.frustum.js
var Frustum;
var init_math_frustum = __esm({
  "node_modules/@babylonjs/core/Maths/math.frustum.js"() {
    init_math_plane();
    Frustum = function() {
      function Frustum2() {
      }
      Frustum2.GetPlanes = function(transform) {
        var frustumPlanes = [];
        for (var index = 0; index < 6; index++) {
          frustumPlanes.push(new Plane(0, 0, 0, 0));
        }
        Frustum2.GetPlanesToRef(transform, frustumPlanes);
        return frustumPlanes;
      };
      Frustum2.GetNearPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] + m[2];
        frustumPlane.normal.y = m[7] + m[6];
        frustumPlane.normal.z = m[11] + m[10];
        frustumPlane.d = m[15] + m[14];
        frustumPlane.normalize();
      };
      Frustum2.GetFarPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] - m[2];
        frustumPlane.normal.y = m[7] - m[6];
        frustumPlane.normal.z = m[11] - m[10];
        frustumPlane.d = m[15] - m[14];
        frustumPlane.normalize();
      };
      Frustum2.GetLeftPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] + m[0];
        frustumPlane.normal.y = m[7] + m[4];
        frustumPlane.normal.z = m[11] + m[8];
        frustumPlane.d = m[15] + m[12];
        frustumPlane.normalize();
      };
      Frustum2.GetRightPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] - m[0];
        frustumPlane.normal.y = m[7] - m[4];
        frustumPlane.normal.z = m[11] - m[8];
        frustumPlane.d = m[15] - m[12];
        frustumPlane.normalize();
      };
      Frustum2.GetTopPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] - m[1];
        frustumPlane.normal.y = m[7] - m[5];
        frustumPlane.normal.z = m[11] - m[9];
        frustumPlane.d = m[15] - m[13];
        frustumPlane.normalize();
      };
      Frustum2.GetBottomPlaneToRef = function(transform, frustumPlane) {
        var m = transform.m;
        frustumPlane.normal.x = m[3] + m[1];
        frustumPlane.normal.y = m[7] + m[5];
        frustumPlane.normal.z = m[11] + m[9];
        frustumPlane.d = m[15] + m[13];
        frustumPlane.normalize();
      };
      Frustum2.GetPlanesToRef = function(transform, frustumPlanes) {
        Frustum2.GetNearPlaneToRef(transform, frustumPlanes[0]);
        Frustum2.GetFarPlaneToRef(transform, frustumPlanes[1]);
        Frustum2.GetLeftPlaneToRef(transform, frustumPlanes[2]);
        Frustum2.GetRightPlaneToRef(transform, frustumPlanes[3]);
        Frustum2.GetTopPlaneToRef(transform, frustumPlanes[4]);
        Frustum2.GetBottomPlaneToRef(transform, frustumPlanes[5]);
      };
      return Frustum2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/computePressure.js
var ComputePressureObserverWrapper;
var init_computePressure = __esm({
  "node_modules/@babylonjs/core/Misc/computePressure.js"() {
    init_domManagement();
    ComputePressureObserverWrapper = function() {
      function ComputePressureObserverWrapper2(callback, thresholds) {
        if (ComputePressureObserverWrapper2.IsAvailable) {
          this._observer = new window.ComputePressureObserver(callback, thresholds);
        }
      }
      Object.defineProperty(ComputePressureObserverWrapper2, "IsAvailable", {
        get: function() {
          return IsWindowObjectExist() && "ComputePressureObserver" in window;
        },
        enumerable: false,
        configurable: true
      });
      ComputePressureObserverWrapper2.prototype.observe = function() {
        var _a, _b;
        ((_a = this._observer) === null || _a === void 0 ? void 0 : _a.observe) && ((_b = this._observer) === null || _b === void 0 ? void 0 : _b.observe());
      };
      ComputePressureObserverWrapper2.prototype.unobserve = function() {
        var _a, _b;
        ((_a = this._observer) === null || _a === void 0 ? void 0 : _a.unobserve) && ((_b = this._observer) === null || _b === void 0 ? void 0 : _b.unobserve());
      };
      return ComputePressureObserverWrapper2;
    }();
  }
});

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo, InputManager;
var init_scene_inputManager = __esm({
  "node_modules/@babylonjs/core/Inputs/scene.inputManager.js"() {
    init_pointerEvents();
    init_abstractActionManager();
    init_pickingInfo();
    init_math_vector();
    init_actionEvent();
    init_keyboardEvents();
    init_deviceEnums();
    init_deviceSourceManager();
    init_engineStore();
    _ClickInfo = function() {
      function _ClickInfo2() {
        this._singleClick = false;
        this._doubleClick = false;
        this._hasSwiped = false;
        this._ignore = false;
      }
      Object.defineProperty(_ClickInfo2.prototype, "singleClick", {
        get: function() {
          return this._singleClick;
        },
        set: function(b) {
          this._singleClick = b;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(_ClickInfo2.prototype, "doubleClick", {
        get: function() {
          return this._doubleClick;
        },
        set: function(b) {
          this._doubleClick = b;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(_ClickInfo2.prototype, "hasSwiped", {
        get: function() {
          return this._hasSwiped;
        },
        set: function(b) {
          this._hasSwiped = b;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(_ClickInfo2.prototype, "ignore", {
        get: function() {
          return this._ignore;
        },
        set: function(b) {
          this._ignore = b;
        },
        enumerable: false,
        configurable: true
      });
      return _ClickInfo2;
    }();
    InputManager = function() {
      function InputManager2(scene) {
        this._alreadyAttached = false;
        this._meshPickProceed = false;
        this._currentPickResult = null;
        this._previousPickResult = null;
        this._totalPointersPressed = 0;
        this._doubleClickOccured = false;
        this._pointerX = 0;
        this._pointerY = 0;
        this._startingPointerPosition = new Vector2(0, 0);
        this._previousStartingPointerPosition = new Vector2(0, 0);
        this._startingPointerTime = 0;
        this._previousStartingPointerTime = 0;
        this._pointerCaptures = {};
        this._meshUnderPointerId = {};
        this._deviceSourceManager = null;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
      }
      Object.defineProperty(InputManager2.prototype, "meshUnderPointer", {
        get: function() {
          return this._pointerOverMesh;
        },
        enumerable: false,
        configurable: true
      });
      InputManager2.prototype.getMeshUnderPointerByPointerId = function(pointerId) {
        return this._meshUnderPointerId[pointerId] || null;
      };
      Object.defineProperty(InputManager2.prototype, "unTranslatedPointer", {
        get: function() {
          return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InputManager2.prototype, "pointerX", {
        get: function() {
          return this._pointerX;
        },
        set: function(value) {
          this._pointerX = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InputManager2.prototype, "pointerY", {
        get: function() {
          return this._pointerY;
        },
        set: function(value) {
          this._pointerY = value;
        },
        enumerable: false,
        configurable: true
      });
      InputManager2.prototype._updatePointerPosition = function(evt) {
        var canvasRect = this._scene.getEngine().getInputElementClientRect();
        if (!canvasRect) {
          return;
        }
        this._pointerX = evt.clientX - canvasRect.left;
        this._pointerY = evt.clientY - canvasRect.top;
        this._unTranslatedPointerX = this._pointerX;
        this._unTranslatedPointerY = this._pointerY;
      };
      InputManager2.prototype._processPointerMove = function(pickResult, evt) {
        var scene = this._scene;
        var engine = scene.getEngine();
        var canvas = engine.getInputElement();
        if (canvas) {
          canvas.tabIndex = engine.canvasTabIndex;
          if (!scene.doNotHandleCursors) {
            canvas.style.cursor = scene.defaultCursor;
          }
        }
        var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;
        if (isMeshPicked) {
          scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult);
          if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {
            if (!scene.doNotHandleCursors && canvas) {
              if (this._pointerOverMesh.actionManager.hoverCursor) {
                canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;
              } else {
                canvas.style.cursor = scene.hoverCursor;
              }
            }
          }
        } else {
          scene.setPointerOverMesh(null, evt.pointerId, pickResult);
        }
        for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {
          var step = _a[_i];
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
        }
        if (pickResult) {
          var type = evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
          if (scene.onPointerMove) {
            scene.onPointerMove(evt, pickResult, type);
          }
          if (scene.onPointerObservable.hasObservers()) {
            var pi = new PointerInfo(type, evt, pickResult);
            this._setRayOnPointerInfo(pi);
            scene.onPointerObservable.notifyObservers(pi, type);
          }
        }
      };
      InputManager2.prototype._setRayOnPointerInfo = function(pointerInfo) {
        var scene = this._scene;
        if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {
          if (!pointerInfo.pickInfo.ray) {
            pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);
          }
        }
      };
      InputManager2.prototype._checkPrePointerObservable = function(pickResult, evt, type) {
        var scene = this._scene;
        var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
        if (pickResult) {
          pi.ray = pickResult.ray;
          if (pickResult.originMesh) {
            pi.nearInteractionPickingInfo = pickResult;
          }
        }
        scene.onPrePointerObservable.notifyObservers(pi, type);
        if (pi.skipOnPointerObservable) {
          return true;
        } else {
          return false;
        }
      };
      InputManager2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
        var evt = new PointerEvent("pointermove", pointerEventInit);
        evt.inputIndex = PointerInput.Move;
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
          return;
        }
        this._processPointerMove(pickResult, evt);
      };
      InputManager2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
        var evt = new PointerEvent("pointerdown", pointerEventInit);
        evt.inputIndex = evt.button + 2;
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
          return;
        }
        this._processPointerDown(pickResult, evt);
      };
      InputManager2.prototype._processPointerDown = function(pickResult, evt) {
        var _this = this;
        var scene = this._scene;
        if (pickResult && pickResult.hit && pickResult.pickedMesh) {
          this._pickedDownMesh = pickResult.pickedMesh;
          var actionManager_1 = pickResult.pickedMesh._getActionManagerForTrigger();
          if (actionManager_1) {
            if (actionManager_1.hasPickTriggers) {
              actionManager_1.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              switch (evt.button) {
                case 0:
                  actionManager_1.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
                  break;
                case 1:
                  actionManager_1.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
                  break;
                case 2:
                  actionManager_1.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
                  break;
              }
            }
            if (actionManager_1.hasSpecificTrigger(8)) {
              window.setTimeout(function() {
                var pickResult2 = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function(mesh) {
                  return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === _this._pickedDownMesh;
                }, false, scene.cameraToUseForPointers);
                if (pickResult2 && pickResult2.hit && pickResult2.pickedMesh && actionManager_1) {
                  if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager2.LongPressDelay && !_this._isPointerSwiping()) {
                    _this._startingPointerTime = 0;
                    actionManager_1.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
                  }
                }
              }, InputManager2.LongPressDelay);
            }
          }
        } else {
          for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {
            var step = _a[_i];
            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
          }
        }
        if (pickResult) {
          var type = PointerEventTypes.POINTERDOWN;
          if (scene.onPointerDown) {
            scene.onPointerDown(evt, pickResult, type);
          }
          if (scene.onPointerObservable.hasObservers()) {
            var pi = new PointerInfo(type, evt, pickResult);
            this._setRayOnPointerInfo(pi);
            scene.onPointerObservable.notifyObservers(pi, type);
          }
        }
      };
      InputManager2.prototype._isPointerSwiping = function() {
        return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager2.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager2.DragMovementThreshold;
      };
      InputManager2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
        var evt = new PointerEvent("pointerup", pointerEventInit);
        evt.inputIndex = PointerInput.Move;
        var clickInfo = new _ClickInfo();
        if (doubleTap) {
          clickInfo.doubleClick = true;
        } else {
          clickInfo.singleClick = true;
        }
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
          return;
        }
        this._processPointerUp(pickResult, evt, clickInfo);
      };
      InputManager2.prototype._processPointerUp = function(pickResult, evt, clickInfo) {
        var scene = this._scene;
        if (pickResult && pickResult && pickResult.pickedMesh) {
          this._pickedUpMesh = pickResult.pickedMesh;
          if (this._pickedDownMesh === this._pickedUpMesh) {
            if (scene.onPointerPick) {
              scene.onPointerPick(evt, pickResult);
            }
            if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {
              var type_1 = PointerEventTypes.POINTERPICK;
              var pi = new PointerInfo(type_1, evt, pickResult);
              this._setRayOnPointerInfo(pi);
              scene.onPointerObservable.notifyObservers(pi, type_1);
            }
          }
          var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
          if (actionManager && !clickInfo.ignore) {
            actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            if (!clickInfo.hasSwiped && clickInfo.singleClick) {
              actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            }
            var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
            if (clickInfo.doubleClick && doubleClickActionManager) {
              doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            }
          }
        } else {
          if (!clickInfo.ignore) {
            for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {
              var step = _a[_i];
              pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
            }
          }
        }
        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
          var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
          if (pickedDownActionManager) {
            pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
          }
        }
        var type = 0;
        if (scene.onPointerObservable.hasObservers()) {
          if (!clickInfo.ignore && !clickInfo.hasSwiped) {
            if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
              type = PointerEventTypes.POINTERTAP;
            } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
              type = PointerEventTypes.POINTERDOUBLETAP;
            }
            if (type) {
              var pi = new PointerInfo(type, evt, pickResult);
              this._setRayOnPointerInfo(pi);
              scene.onPointerObservable.notifyObservers(pi, type);
            }
          }
          if (!clickInfo.ignore) {
            type = PointerEventTypes.POINTERUP;
            var pi = new PointerInfo(type, evt, pickResult);
            this._setRayOnPointerInfo(pi);
            scene.onPointerObservable.notifyObservers(pi, type);
          }
        }
        if (scene.onPointerUp && !clickInfo.ignore) {
          scene.onPointerUp(evt, pickResult, type);
        }
      };
      InputManager2.prototype.isPointerCaptured = function(pointerId) {
        if (pointerId === void 0) {
          pointerId = 0;
        }
        return this._pointerCaptures[pointerId];
      };
      InputManager2.prototype.attachControl = function(attachUp, attachDown, attachMove, elementToAttachTo) {
        var _this = this;
        if (attachUp === void 0) {
          attachUp = true;
        }
        if (attachDown === void 0) {
          attachDown = true;
        }
        if (attachMove === void 0) {
          attachMove = true;
        }
        if (elementToAttachTo === void 0) {
          elementToAttachTo = null;
        }
        var scene = this._scene;
        var engine = scene.getEngine();
        if (!elementToAttachTo) {
          elementToAttachTo = engine.getInputElement();
        }
        if (this._alreadyAttached) {
          this.detachControl();
        }
        if (elementToAttachTo) {
          this._alreadyAttachedTo = elementToAttachTo;
        }
        this._deviceSourceManager = new DeviceSourceManager(engine);
        this._initActionManager = function(act) {
          if (!_this._meshPickProceed) {
            var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
            _this._currentPickResult = pickResult;
            if (pickResult) {
              act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
            }
            _this._meshPickProceed = true;
          }
          return act;
        };
        this._delayedSimpleClick = function(btn, clickInfo, cb) {
          if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {
            _this._doubleClickOccured = false;
            clickInfo.singleClick = true;
            clickInfo.ignore = false;
            cb(clickInfo, _this._currentPickResult);
          }
        };
        this._initClickEvent = function(obs1, obs2, evt, cb) {
          var clickInfo = new _ClickInfo();
          _this._currentPickResult = null;
          var act = null;
          var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkPicking && AbstractActionManager) {
            act = _this._initActionManager(act, clickInfo);
            if (act) {
              checkPicking = act.hasPickTriggers;
            }
          }
          var needToIgnoreNext = false;
          if (checkPicking) {
            var btn = evt.button;
            clickInfo.hasSwiped = _this._isPointerSwiping();
            if (!clickInfo.hasSwiped) {
              var checkSingleClickImmediately = !InputManager2.ExclusiveDoubleClickMode;
              if (!checkSingleClickImmediately) {
                checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
                if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
                  act = _this._initActionManager(act, clickInfo);
                  if (act) {
                    checkSingleClickImmediately = !act.hasSpecificTrigger(6);
                  }
                }
              }
              if (checkSingleClickImmediately) {
                if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay || btn !== _this._previousButtonPressed) {
                  clickInfo.singleClick = true;
                  cb(clickInfo, _this._currentPickResult);
                  needToIgnoreNext = true;
                }
              } else {
                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager2.DoubleClickDelay);
              }
              var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
              if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
                act = _this._initActionManager(act, clickInfo);
                if (act) {
                  checkDoubleClick = act.hasSpecificTrigger(6);
                }
              }
              if (checkDoubleClick) {
                if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager2.DoubleClickDelay && !_this._doubleClickOccured) {
                  if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {
                    _this._previousStartingPointerTime = 0;
                    _this._doubleClickOccured = true;
                    clickInfo.doubleClick = true;
                    clickInfo.ignore = false;
                    if (InputManager2.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {
                      clearTimeout(_this._previousDelayedSimpleClickTimeout);
                    }
                    _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                    cb(clickInfo, _this._currentPickResult);
                  } else {
                    _this._doubleClickOccured = false;
                    _this._previousStartingPointerTime = _this._startingPointerTime;
                    _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
                    _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
                    _this._previousButtonPressed = btn;
                    if (InputManager2.ExclusiveDoubleClickMode) {
                      if (_this._previousDelayedSimpleClickTimeout) {
                        clearTimeout(_this._previousDelayedSimpleClickTimeout);
                      }
                      _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                      cb(clickInfo, _this._previousPickResult);
                    } else {
                      cb(clickInfo, _this._currentPickResult);
                    }
                  }
                  needToIgnoreNext = true;
                } else {
                  _this._doubleClickOccured = false;
                  _this._previousStartingPointerTime = _this._startingPointerTime;
                  _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
                  _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
                  _this._previousButtonPressed = btn;
                }
              }
            }
          }
          if (!needToIgnoreNext) {
            cb(clickInfo, _this._currentPickResult);
          }
        };
        this._onPointerMove = function(evt) {
          if (evt.pointerId === void 0) {
            evt.pointerId = 0;
          }
          _this._updatePointerPosition(evt);
          if (_this._checkPrePointerObservable(null, evt, evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
            return;
          }
          if (!scene.cameraToUseForPointers && !scene.activeCamera) {
            return;
          }
          if (scene.skipPointerMovePicking) {
            _this._processPointerMove(new PickingInfo(), evt);
            return;
          }
          if (!scene.pointerMovePredicate) {
            scene.pointerMovePredicate = function(mesh) {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
            };
          }
          var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
          _this._processPointerMove(pickResult, evt);
        };
        this._onPointerDown = function(evt) {
          _this._totalPointersPressed++;
          _this._pickedDownMesh = null;
          _this._meshPickProceed = false;
          if (evt.pointerId === void 0) {
            evt.pointerId = 0;
          }
          _this._updatePointerPosition(evt);
          if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
            evt.preventDefault();
            elementToAttachTo.focus();
          }
          _this._startingPointerPosition.x = _this._pointerX;
          _this._startingPointerPosition.y = _this._pointerY;
          _this._startingPointerTime = Date.now();
          if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
            return;
          }
          if (!scene.cameraToUseForPointers && !scene.activeCamera) {
            return;
          }
          _this._pointerCaptures[evt.pointerId] = true;
          if (!scene.pointerDownPredicate) {
            scene.pointerDownPredicate = function(mesh) {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
            };
          }
          _this._pickedDownMesh = null;
          var pickResult;
          if (scene.skipPointerDownPicking) {
            pickResult = new PickingInfo();
          } else {
            pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
          }
          _this._processPointerDown(pickResult, evt);
        };
        this._onPointerUp = function(evt) {
          if (_this._totalPointersPressed === 0) {
            return;
          }
          _this._totalPointersPressed--;
          _this._pickedUpMesh = null;
          _this._meshPickProceed = false;
          if (evt.pointerId === void 0) {
            evt.pointerId = 0;
          }
          _this._updatePointerPosition(evt);
          if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
            evt.preventDefault();
            elementToAttachTo.focus();
          }
          _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function(clickInfo, pickResult) {
            if (scene.onPrePointerObservable.hasObservers()) {
              if (!clickInfo.ignore) {
                if (!clickInfo.hasSwiped) {
                  if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                    if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                      return;
                    }
                  }
                  if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                    if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                      return;
                    }
                  }
                }
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
                  return;
                }
              }
            }
            if (!_this._pointerCaptures[evt.pointerId] && evt.buttons > 0) {
              return;
            }
            _this._pointerCaptures[evt.pointerId] = false;
            if (!scene.cameraToUseForPointers && !scene.activeCamera) {
              return;
            }
            if (!scene.pointerUpPredicate) {
              scene.pointerUpPredicate = function(mesh) {
                return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
              };
            }
            if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {
              _this._initActionManager(null, clickInfo);
            }
            if (!pickResult) {
              pickResult = _this._currentPickResult;
            }
            _this._processPointerUp(pickResult, evt, clickInfo);
            _this._previousPickResult = _this._currentPickResult;
          });
        };
        this._onKeyDown = function(evt) {
          var type = KeyboardEventTypes.KEYDOWN;
          if (scene.onPreKeyboardObservable.hasObservers()) {
            var pi = new KeyboardInfoPre(type, evt);
            scene.onPreKeyboardObservable.notifyObservers(pi, type);
            if (pi.skipOnKeyboardObservable) {
              return;
            }
          }
          if (scene.onKeyboardObservable.hasObservers()) {
            var pi = new KeyboardInfo(type, evt);
            scene.onKeyboardObservable.notifyObservers(pi, type);
          }
          if (scene.actionManager) {
            scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
          }
        };
        this._onKeyUp = function(evt) {
          var type = KeyboardEventTypes.KEYUP;
          if (scene.onPreKeyboardObservable.hasObservers()) {
            var pi = new KeyboardInfoPre(type, evt);
            scene.onPreKeyboardObservable.notifyObservers(pi, type);
            if (pi.skipOnKeyboardObservable) {
              return;
            }
          }
          if (scene.onKeyboardObservable.hasObservers()) {
            var pi = new KeyboardInfo(type, evt);
            scene.onKeyboardObservable.notifyObservers(pi, type);
          }
          if (scene.actionManager) {
            scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
          }
        };
        this._deviceSourceManager.onDeviceConnectedObservable.add(function(deviceSource) {
          if (deviceSource.deviceType === DeviceType.Mouse) {
            deviceSource.onInputChangedObservable.add(function(eventData) {
              if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick) {
                if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
                  _this._onPointerDown(eventData);
                } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
                  _this._onPointerUp(eventData);
                }
              } else if (attachMove) {
                if (eventData.inputIndex === PointerInput.Move) {
                  _this._onPointerMove(eventData);
                } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
                  _this._onPointerMove(eventData);
                }
              }
            });
          } else if (deviceSource.deviceType === DeviceType.Touch) {
            deviceSource.onInputChangedObservable.add(function(eventData) {
              if (eventData.inputIndex === PointerInput.LeftClick) {
                if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
                  _this._onPointerDown(eventData);
                } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
                  _this._onPointerUp(eventData);
                }
              }
              if (attachMove && eventData.inputIndex === PointerInput.Move) {
                _this._onPointerMove(eventData);
              }
            });
          } else if (deviceSource.deviceType === DeviceType.Keyboard) {
            deviceSource.onInputChangedObservable.add(function(eventData) {
              if (eventData.type === "keydown") {
                _this._onKeyDown(eventData);
              } else if (eventData.type === "keyup") {
                _this._onKeyUp(eventData);
              }
            });
          }
        });
        this._alreadyAttached = true;
      };
      InputManager2.prototype.detachControl = function() {
        if (this._alreadyAttached) {
          this._deviceSourceManager.dispose();
          this._deviceSourceManager = null;
          if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
            this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
          }
          this._alreadyAttached = false;
          this._alreadyAttachedTo = null;
        }
      };
      InputManager2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
        if (pointerId === void 0) {
          pointerId = 0;
        }
        if (this._meshUnderPointerId[pointerId] === mesh) {
          return;
        }
        var underPointerMesh = this._meshUnderPointerId[pointerId];
        var actionManager;
        if (underPointerMesh) {
          actionManager = underPointerMesh._getActionManagerForTrigger(10);
          if (actionManager) {
            actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
          }
        }
        if (mesh) {
          this._meshUnderPointerId[pointerId] = mesh;
          this._pointerOverMesh = mesh;
          actionManager = mesh._getActionManagerForTrigger(9);
          if (actionManager) {
            actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, void 0, { pointerId, pickResult }));
          }
        } else {
          delete this._meshUnderPointerId[pointerId];
          this._pointerOverMesh = null;
        }
      };
      InputManager2.prototype.getPointerOverMesh = function() {
        return this._pointerOverMesh;
      };
      InputManager2.prototype._invalidateMesh = function(mesh) {
        if (this._pointerOverMesh === mesh) {
          this._pointerOverMesh = null;
        }
        if (this._pickedDownMesh === mesh) {
          this._pickedDownMesh = null;
        }
        if (this._pickedUpMesh === mesh) {
          this._pickedUpMesh = null;
        }
        for (var pointerId in this._meshUnderPointerId) {
          if (this._meshUnderPointerId[pointerId] === mesh) {
            delete this._meshUnderPointerId[pointerId];
          }
        }
      };
      InputManager2.DragMovementThreshold = 10;
      InputManager2.LongPressDelay = 500;
      InputManager2.DoubleClickDelay = 300;
      InputManager2.ExclusiveDoubleClickMode = false;
      return InputManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js
var UniqueIdGenerator;
var init_uniqueIdGenerator = __esm({
  "node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js"() {
    UniqueIdGenerator = function() {
      function UniqueIdGenerator2() {
      }
      Object.defineProperty(UniqueIdGenerator2, "UniqueId", {
        get: function() {
          var result = this._UniqueIdCounter;
          this._UniqueIdCounter++;
          return result;
        },
        enumerable: false,
        configurable: true
      });
      UniqueIdGenerator2._UniqueIdCounter = 1;
      return UniqueIdGenerator2;
    }();
  }
});

// node_modules/@babylonjs/core/Lights/lightConstants.js
var LightConstants;
var init_lightConstants = __esm({
  "node_modules/@babylonjs/core/Lights/lightConstants.js"() {
    LightConstants = function() {
      function LightConstants2() {
      }
      LightConstants2.CompareLightsPriority = function(a, b) {
        if (a.shadowEnabled !== b.shadowEnabled) {
          return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
        }
        return b.renderPriority - a.renderPriority;
      };
      LightConstants2.FALLOFF_DEFAULT = 0;
      LightConstants2.FALLOFF_PHYSICAL = 1;
      LightConstants2.FALLOFF_GLTF = 2;
      LightConstants2.FALLOFF_STANDARD = 3;
      LightConstants2.LIGHTMAP_DEFAULT = 0;
      LightConstants2.LIGHTMAP_SPECULAR = 1;
      LightConstants2.LIGHTMAP_SHADOWSONLY = 2;
      LightConstants2.INTENSITYMODE_AUTOMATIC = 0;
      LightConstants2.INTENSITYMODE_LUMINOUSPOWER = 1;
      LightConstants2.INTENSITYMODE_LUMINOUSINTENSITY = 2;
      LightConstants2.INTENSITYMODE_ILLUMINANCE = 3;
      LightConstants2.INTENSITYMODE_LUMINANCE = 4;
      LightConstants2.LIGHTTYPEID_POINTLIGHT = 0;
      LightConstants2.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
      LightConstants2.LIGHTTYPEID_SPOTLIGHT = 2;
      LightConstants2.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
      return LightConstants2;
    }();
  }
});

// node_modules/@babylonjs/core/scene.js
var Scene;
var init_scene = __esm({
  "node_modules/@babylonjs/core/scene.js"() {
    init_tslib_es6();
    init_tools();
    init_precisionDate();
    init_observable();
    init_smartArray();
    init_stringDictionary();
    init_tags();
    init_math_vector();
    init_abstractScene();
    init_imageProcessingConfiguration();
    init_uniformBuffer();
    init_pickingInfo();
    init_actionEvent();
    init_postProcessManager();
    init_renderingManager();
    init_sceneComponent();
    init_domManagement();
    init_engineStore();
    init_devTools();
    init_scene_inputManager();
    init_perfCounter();
    init_math_color();
    init_math_frustum();
    init_uniqueIdGenerator();
    init_fileTools();
    init_lightConstants();
    init_computePressure();
    init_sliceTools();
    Scene = function(_super) {
      __extends(Scene2, _super);
      function Scene2(engine, options) {
        var _this = _super.call(this) || this;
        _this._inputManager = new InputManager(_this);
        _this.cameraToUseForPointers = null;
        _this._isScene = true;
        _this._blockEntityCollection = false;
        _this.autoClear = true;
        _this.autoClearDepthAndStencil = true;
        _this.clearColor = new Color4(0.2, 0.2, 0.3, 1);
        _this.ambientColor = new Color3(0, 0, 0);
        _this.environmentIntensity = 1;
        _this._forceWireframe = false;
        _this._skipFrustumClipping = false;
        _this._forcePointsCloud = false;
        _this.animationsEnabled = true;
        _this._animationPropertiesOverride = null;
        _this.useConstantAnimationDeltaTime = false;
        _this.constantlyUpdateMeshUnderPointer = false;
        _this.hoverCursor = "pointer";
        _this.defaultCursor = "";
        _this.doNotHandleCursors = false;
        _this.preventDefaultOnPointerDown = true;
        _this.preventDefaultOnPointerUp = true;
        _this.metadata = null;
        _this.reservedDataStore = null;
        _this.disableOfflineSupportExceptionRules = new Array();
        _this.onDisposeObservable = new Observable();
        _this._onDisposeObserver = null;
        _this.onBeforeRenderObservable = new Observable();
        _this._onBeforeRenderObserver = null;
        _this.onAfterRenderObservable = new Observable();
        _this.onAfterRenderCameraObservable = new Observable();
        _this._onAfterRenderObserver = null;
        _this.onBeforeAnimationsObservable = new Observable();
        _this.onAfterAnimationsObservable = new Observable();
        _this.onBeforeDrawPhaseObservable = new Observable();
        _this.onAfterDrawPhaseObservable = new Observable();
        _this.onReadyObservable = new Observable();
        _this.onBeforeCameraRenderObservable = new Observable();
        _this._onBeforeCameraRenderObserver = null;
        _this.onAfterCameraRenderObservable = new Observable();
        _this._onAfterCameraRenderObserver = null;
        _this.onBeforeActiveMeshesEvaluationObservable = new Observable();
        _this.onAfterActiveMeshesEvaluationObservable = new Observable();
        _this.onBeforeParticlesRenderingObservable = new Observable();
        _this.onAfterParticlesRenderingObservable = new Observable();
        _this.onDataLoadedObservable = new Observable();
        _this.onNewCameraAddedObservable = new Observable();
        _this.onCameraRemovedObservable = new Observable();
        _this.onNewLightAddedObservable = new Observable();
        _this.onLightRemovedObservable = new Observable();
        _this.onNewGeometryAddedObservable = new Observable();
        _this.onGeometryRemovedObservable = new Observable();
        _this.onNewTransformNodeAddedObservable = new Observable();
        _this.onTransformNodeRemovedObservable = new Observable();
        _this.onNewMeshAddedObservable = new Observable();
        _this.onMeshRemovedObservable = new Observable();
        _this.onNewSkeletonAddedObservable = new Observable();
        _this.onSkeletonRemovedObservable = new Observable();
        _this.onNewMaterialAddedObservable = new Observable();
        _this.onNewMultiMaterialAddedObservable = new Observable();
        _this.onMaterialRemovedObservable = new Observable();
        _this.onMultiMaterialRemovedObservable = new Observable();
        _this.onNewTextureAddedObservable = new Observable();
        _this.onTextureRemovedObservable = new Observable();
        _this.onBeforeRenderTargetsRenderObservable = new Observable();
        _this.onAfterRenderTargetsRenderObservable = new Observable();
        _this.onBeforeStepObservable = new Observable();
        _this.onAfterStepObservable = new Observable();
        _this.onActiveCameraChanged = new Observable();
        _this.onBeforeRenderingGroupObservable = new Observable();
        _this.onAfterRenderingGroupObservable = new Observable();
        _this.onMeshImportedObservable = new Observable();
        _this.onAnimationFileImportedObservable = new Observable();
        _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
        _this.skipPointerMovePicking = false;
        _this.skipPointerDownPicking = false;
        _this.onPrePointerObservable = new Observable();
        _this.onPointerObservable = new Observable();
        _this.onPreKeyboardObservable = new Observable();
        _this.onKeyboardObservable = new Observable();
        _this._useRightHandedSystem = false;
        _this._timeAccumulator = 0;
        _this._currentStepId = 0;
        _this._currentInternalStep = 0;
        _this._fogEnabled = true;
        _this._fogMode = Scene2.FOGMODE_NONE;
        _this.fogColor = new Color3(0.2, 0.2, 0.3);
        _this.fogDensity = 0.1;
        _this.fogStart = 0;
        _this.fogEnd = 1e3;
        _this.needsPreviousWorldMatrices = false;
        _this._shadowsEnabled = true;
        _this._lightsEnabled = true;
        _this.activeCameras = new Array();
        _this._texturesEnabled = true;
        _this.physicsEnabled = true;
        _this.particlesEnabled = true;
        _this.spritesEnabled = true;
        _this._skeletonsEnabled = true;
        _this.lensFlaresEnabled = true;
        _this.collisionsEnabled = true;
        _this.gravity = new Vector3(0, -9.807, 0);
        _this.postProcessesEnabled = true;
        _this.renderTargetsEnabled = true;
        _this.dumpNextRenderTargets = false;
        _this.customRenderTargets = new Array();
        _this.importedMeshesFiles = new Array();
        _this.probesEnabled = true;
        _this._meshesForIntersections = new SmartArrayNoDuplicate(256);
        _this.proceduralTexturesEnabled = true;
        _this._totalVertices = new PerfCounter();
        _this._activeIndices = new PerfCounter();
        _this._activeParticles = new PerfCounter();
        _this._activeBones = new PerfCounter();
        _this._animationTime = 0;
        _this.animationTimeScale = 1;
        _this._renderId = 0;
        _this._frameId = 0;
        _this._executeWhenReadyTimeoutId = null;
        _this._intermediateRendering = false;
        _this._defaultFrameBufferCleared = false;
        _this._viewUpdateFlag = -1;
        _this._projectionUpdateFlag = -1;
        _this._toBeDisposed = new Array(256);
        _this._activeRequests = new Array();
        _this._pendingData = new Array();
        _this._isDisposed = false;
        _this.dispatchAllSubMeshesOfActiveMeshes = false;
        _this._activeMeshes = new SmartArray(256);
        _this._processedMaterials = new SmartArray(256);
        _this._renderTargets = new SmartArrayNoDuplicate(256);
        _this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
        _this._activeParticleSystems = new SmartArray(256);
        _this._activeSkeletons = new SmartArrayNoDuplicate(32);
        _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
        _this._activeAnimatables = new Array();
        _this._transformMatrix = Matrix.Zero();
        _this.requireLightSorting = false;
        _this._components = [];
        _this._serializableComponents = [];
        _this._transientComponents = [];
        _this._beforeCameraUpdateStage = Stage.Create();
        _this._beforeClearStage = Stage.Create();
        _this._beforeRenderTargetClearStage = Stage.Create();
        _this._gatherRenderTargetsStage = Stage.Create();
        _this._gatherActiveCameraRenderTargetsStage = Stage.Create();
        _this._isReadyForMeshStage = Stage.Create();
        _this._beforeEvaluateActiveMeshStage = Stage.Create();
        _this._evaluateSubMeshStage = Stage.Create();
        _this._preActiveMeshStage = Stage.Create();
        _this._cameraDrawRenderTargetStage = Stage.Create();
        _this._beforeCameraDrawStage = Stage.Create();
        _this._beforeRenderTargetDrawStage = Stage.Create();
        _this._beforeRenderingGroupDrawStage = Stage.Create();
        _this._beforeRenderingMeshStage = Stage.Create();
        _this._afterRenderingMeshStage = Stage.Create();
        _this._afterRenderingGroupDrawStage = Stage.Create();
        _this._afterCameraDrawStage = Stage.Create();
        _this._afterRenderTargetDrawStage = Stage.Create();
        _this._afterRenderStage = Stage.Create();
        _this._pointerMoveStage = Stage.Create();
        _this._pointerDownStage = Stage.Create();
        _this._pointerUpStage = Stage.Create();
        _this._geometriesByUniqueId = null;
        _this._defaultMeshCandidates = {
          data: [],
          length: 0
        };
        _this._defaultSubMeshCandidates = {
          data: [],
          length: 0
        };
        _this._preventFreeActiveMeshesAndRenderingGroups = false;
        _this._activeMeshesFrozen = false;
        _this._activeMeshesFrozenButKeepClipping = false;
        _this._skipEvaluateActiveMeshesCompletely = false;
        _this._allowPostProcessClearColor = true;
        _this.getDeterministicFrameTime = function() {
          return _this._engine.getTimeStep();
        };
        _this._blockMaterialDirtyMechanism = false;
        _this._perfCollector = null;
        _this.onComputePressureChanged = new Observable();
        var fullOptions = __assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);
        _this._engine = engine || EngineStore.LastCreatedEngine;
        if (!fullOptions.virtual) {
          EngineStore._LastCreatedScene = _this;
          _this._engine.scenes.push(_this);
        } else {
          _this._engine._virtualScenes.push(_this);
        }
        _this._uid = null;
        _this._renderingManager = new RenderingManager(_this);
        if (PostProcessManager) {
          _this.postProcessManager = new PostProcessManager(_this);
        }
        if (IsWindowObjectExist()) {
          _this.attachControl();
        }
        _this._createUbo();
        if (ImageProcessingConfiguration) {
          _this._imageProcessingConfiguration = new ImageProcessingConfiguration();
        }
        _this.setDefaultCandidateProviders();
        if (fullOptions.useGeometryUniqueIdsMap) {
          _this._geometriesByUniqueId = {};
        }
        _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
        _this.useClonedMeshMap = fullOptions.useClonedMeshMap;
        if (!options || !options.virtual) {
          _this._engine.onNewSceneAddedObservable.notifyObservers(_this);
        }
        if (ComputePressureObserverWrapper.IsAvailable) {
          _this._computePressureObserver = new ComputePressureObserverWrapper(function(update) {
            _this.onComputePressureChanged.notifyObservers(update);
          }, {
            cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],
            cpuSpeedThresholds: [0.5]
          });
          _this._computePressureObserver.observe();
        }
        return _this;
      }
      Scene2.DefaultMaterialFactory = function(scene) {
        throw _WarnImport("StandardMaterial");
      };
      Scene2.CollisionCoordinatorFactory = function() {
        throw _WarnImport("DefaultCollisionCoordinator");
      };
      Object.defineProperty(Scene2.prototype, "environmentTexture", {
        get: function() {
          return this._environmentTexture;
        },
        set: function(value) {
          if (this._environmentTexture === value) {
            return;
          }
          this._environmentTexture = value;
          this.markAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "imageProcessingConfiguration", {
        get: function() {
          return this._imageProcessingConfiguration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "forceWireframe", {
        get: function() {
          return this._forceWireframe;
        },
        set: function(value) {
          if (this._forceWireframe === value) {
            return;
          }
          this._forceWireframe = value;
          this.markAllMaterialsAsDirty(16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "skipFrustumClipping", {
        get: function() {
          return this._skipFrustumClipping;
        },
        set: function(value) {
          if (this._skipFrustumClipping === value) {
            return;
          }
          this._skipFrustumClipping = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "forcePointsCloud", {
        get: function() {
          return this._forcePointsCloud;
        },
        set: function(value) {
          if (this._forcePointsCloud === value) {
            return;
          }
          this._forcePointsCloud = value;
          this.markAllMaterialsAsDirty(16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "animationPropertiesOverride", {
        get: function() {
          return this._animationPropertiesOverride;
        },
        set: function(value) {
          this._animationPropertiesOverride = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "onDispose", {
        set: function(callback) {
          if (this._onDisposeObserver) {
            this.onDisposeObservable.remove(this._onDisposeObserver);
          }
          this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "beforeRender", {
        set: function(callback) {
          if (this._onBeforeRenderObserver) {
            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
          }
          if (callback) {
            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "afterRender", {
        set: function(callback) {
          if (this._onAfterRenderObserver) {
            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
          }
          if (callback) {
            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "beforeCameraRender", {
        set: function(callback) {
          if (this._onBeforeCameraRenderObserver) {
            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
          }
          this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "afterCameraRender", {
        set: function(callback) {
          if (this._onAfterCameraRenderObserver) {
            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
          }
          this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "unTranslatedPointer", {
        get: function() {
          return this._inputManager.unTranslatedPointer;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2, "DragMovementThreshold", {
        get: function() {
          return InputManager.DragMovementThreshold;
        },
        set: function(value) {
          InputManager.DragMovementThreshold = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2, "LongPressDelay", {
        get: function() {
          return InputManager.LongPressDelay;
        },
        set: function(value) {
          InputManager.LongPressDelay = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2, "DoubleClickDelay", {
        get: function() {
          return InputManager.DoubleClickDelay;
        },
        set: function(value) {
          InputManager.DoubleClickDelay = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2, "ExclusiveDoubleClickMode", {
        get: function() {
          return InputManager.ExclusiveDoubleClickMode;
        },
        set: function(value) {
          InputManager.ExclusiveDoubleClickMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.bindEyePosition = function(effect, variableName, isVector3) {
        var _a;
        if (variableName === void 0) {
          variableName = "vEyePosition";
        }
        if (isVector3 === void 0) {
          isVector3 = false;
        }
        var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;
        var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
        if (effect) {
          if (isVector3) {
            effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);
          } else {
            effect.setVector4(variableName, TmpVectors.Vector4[0]);
          }
        }
        return TmpVectors.Vector4[0];
      };
      Scene2.prototype.finalizeSceneUbo = function() {
        var ubo = this.getSceneUniformBuffer();
        var eyePosition = this.bindEyePosition(null);
        ubo.updateFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);
        ubo.update();
        return ubo;
      };
      Object.defineProperty(Scene2.prototype, "useRightHandedSystem", {
        get: function() {
          return this._useRightHandedSystem;
        },
        set: function(value) {
          if (this._useRightHandedSystem === value) {
            return;
          }
          this._useRightHandedSystem = value;
          this.markAllMaterialsAsDirty(16);
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.setStepId = function(newStepId) {
        this._currentStepId = newStepId;
      };
      Scene2.prototype.getStepId = function() {
        return this._currentStepId;
      };
      Scene2.prototype.getInternalStep = function() {
        return this._currentInternalStep;
      };
      Object.defineProperty(Scene2.prototype, "fogEnabled", {
        get: function() {
          return this._fogEnabled;
        },
        set: function(value) {
          if (this._fogEnabled === value) {
            return;
          }
          this._fogEnabled = value;
          this.markAllMaterialsAsDirty(16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "fogMode", {
        get: function() {
          return this._fogMode;
        },
        set: function(value) {
          if (this._fogMode === value) {
            return;
          }
          this._fogMode = value;
          this.markAllMaterialsAsDirty(16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "prePass", {
        get: function() {
          return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "shadowsEnabled", {
        get: function() {
          return this._shadowsEnabled;
        },
        set: function(value) {
          if (this._shadowsEnabled === value) {
            return;
          }
          this._shadowsEnabled = value;
          this.markAllMaterialsAsDirty(2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "lightsEnabled", {
        get: function() {
          return this._lightsEnabled;
        },
        set: function(value) {
          if (this._lightsEnabled === value) {
            return;
          }
          this._lightsEnabled = value;
          this.markAllMaterialsAsDirty(2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "activeCamera", {
        get: function() {
          return this._activeCamera;
        },
        set: function(value) {
          if (value === this._activeCamera) {
            return;
          }
          this._activeCamera = value;
          this.onActiveCameraChanged.notifyObservers(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "defaultMaterial", {
        get: function() {
          if (!this._defaultMaterial) {
            this._defaultMaterial = Scene2.DefaultMaterialFactory(this);
          }
          return this._defaultMaterial;
        },
        set: function(value) {
          this._defaultMaterial = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "texturesEnabled", {
        get: function() {
          return this._texturesEnabled;
        },
        set: function(value) {
          if (this._texturesEnabled === value) {
            return;
          }
          this._texturesEnabled = value;
          this.markAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "skeletonsEnabled", {
        get: function() {
          return this._skeletonsEnabled;
        },
        set: function(value) {
          if (this._skeletonsEnabled === value) {
            return;
          }
          this._skeletonsEnabled = value;
          this.markAllMaterialsAsDirty(8);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "collisionCoordinator", {
        get: function() {
          if (!this._collisionCoordinator) {
            this._collisionCoordinator = Scene2.CollisionCoordinatorFactory();
            this._collisionCoordinator.init(this);
          }
          return this._collisionCoordinator;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "frustumPlanes", {
        get: function() {
          return this._frustumPlanes;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype._registerTransientComponents = function() {
        if (this._transientComponents.length > 0) {
          for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {
            var component = _a[_i];
            component.register();
          }
          this._transientComponents = [];
        }
      };
      Scene2.prototype._addComponent = function(component) {
        this._components.push(component);
        this._transientComponents.push(component);
        var serializableComponent = component;
        if (serializableComponent.addFromContainer && serializableComponent.serialize) {
          this._serializableComponents.push(serializableComponent);
        }
      };
      Scene2.prototype._getComponent = function(name) {
        for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
          var component = _a[_i];
          if (component.name === name) {
            return component;
          }
        }
        return null;
      };
      Scene2.prototype.getClassName = function() {
        return "Scene";
      };
      Scene2.prototype._getDefaultMeshCandidates = function() {
        this._defaultMeshCandidates.data = this.meshes;
        this._defaultMeshCandidates.length = this.meshes.length;
        return this._defaultMeshCandidates;
      };
      Scene2.prototype._getDefaultSubMeshCandidates = function(mesh) {
        this._defaultSubMeshCandidates.data = mesh.subMeshes;
        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
        return this._defaultSubMeshCandidates;
      };
      Scene2.prototype.setDefaultCandidateProviders = function() {
        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
        this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
        this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
        this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
      };
      Object.defineProperty(Scene2.prototype, "meshUnderPointer", {
        get: function() {
          return this._inputManager.meshUnderPointer;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "pointerX", {
        get: function() {
          return this._inputManager.pointerX;
        },
        set: function(value) {
          this._inputManager.pointerX = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scene2.prototype, "pointerY", {
        get: function() {
          return this._inputManager.pointerY;
        },
        set: function(value) {
          this._inputManager.pointerY = value;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.getCachedMaterial = function() {
        return this._cachedMaterial;
      };
      Scene2.prototype.getCachedEffect = function() {
        return this._cachedEffect;
      };
      Scene2.prototype.getCachedVisibility = function() {
        return this._cachedVisibility;
      };
      Scene2.prototype.isCachedMaterialInvalid = function(material, effect, visibility) {
        if (visibility === void 0) {
          visibility = 1;
        }
        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
      };
      Scene2.prototype.getEngine = function() {
        return this._engine;
      };
      Scene2.prototype.getTotalVertices = function() {
        return this._totalVertices.current;
      };
      Object.defineProperty(Scene2.prototype, "totalVerticesPerfCounter", {
        get: function() {
          return this._totalVertices;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.getActiveIndices = function() {
        return this._activeIndices.current;
      };
      Object.defineProperty(Scene2.prototype, "totalActiveIndicesPerfCounter", {
        get: function() {
          return this._activeIndices;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.getActiveParticles = function() {
        return this._activeParticles.current;
      };
      Object.defineProperty(Scene2.prototype, "activeParticlesPerfCounter", {
        get: function() {
          return this._activeParticles;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.getActiveBones = function() {
        return this._activeBones.current;
      };
      Object.defineProperty(Scene2.prototype, "activeBonesPerfCounter", {
        get: function() {
          return this._activeBones;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.getActiveMeshes = function() {
        return this._activeMeshes;
      };
      Scene2.prototype.getAnimationRatio = function() {
        return this._animationRatio !== void 0 ? this._animationRatio : 1;
      };
      Scene2.prototype.getRenderId = function() {
        return this._renderId;
      };
      Scene2.prototype.getFrameId = function() {
        return this._frameId;
      };
      Scene2.prototype.incrementRenderId = function() {
        this._renderId++;
      };
      Scene2.prototype._createUbo = function() {
        this.setSceneUniformBuffer(this.createSceneUniformBuffer());
      };
      Scene2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
        return this;
      };
      Scene2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
        return this;
      };
      Scene2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
        return this;
      };
      Scene2.prototype.isPointerCaptured = function(pointerId) {
        if (pointerId === void 0) {
          pointerId = 0;
        }
        return this._inputManager.isPointerCaptured(pointerId);
      };
      Scene2.prototype.attachControl = function(attachUp, attachDown, attachMove) {
        if (attachUp === void 0) {
          attachUp = true;
        }
        if (attachDown === void 0) {
          attachDown = true;
        }
        if (attachMove === void 0) {
          attachMove = true;
        }
        this._inputManager.attachControl(attachUp, attachDown, attachMove);
      };
      Scene2.prototype.detachControl = function() {
        this._inputManager.detachControl();
      };
      Scene2.prototype.isReady = function(checkRenderTargets) {
        if (checkRenderTargets === void 0) {
          checkRenderTargets = true;
        }
        if (this._isDisposed) {
          return false;
        }
        var index;
        var engine = this.getEngine();
        var isReady = true;
        if (this._pendingData.length > 0) {
          isReady = false;
        }
        if (checkRenderTargets) {
          this._processedMaterials.reset();
          this._materialsRenderTargets.reset();
        }
        for (index = 0; index < this.meshes.length; index++) {
          var mesh = this.meshes[index];
          if (!mesh.isEnabled()) {
            continue;
          }
          if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
            continue;
          }
          if (!mesh.isReady(true)) {
            isReady = false;
            continue;
          }
          var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
          for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {
            var step = _a[_i];
            if (!step.action(mesh, hardwareInstancedRendering)) {
              isReady = false;
            }
          }
          if (!checkRenderTargets) {
            continue;
          }
          var mat = mesh.material || this.defaultMaterial;
          if (mat) {
            if (mat._storeEffectOnSubMeshes) {
              for (var _b = 0, _c = mesh.subMeshes; _b < _c.length; _b++) {
                var subMesh = _c[_b];
                var material = subMesh.getMaterial();
                if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
                  if (this._processedMaterials.indexOf(material) === -1) {
                    this._processedMaterials.push(material);
                    this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
                  }
                }
              }
            } else {
              if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
                if (this._processedMaterials.indexOf(mat) === -1) {
                  this._processedMaterials.push(mat);
                  this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
                }
              }
            }
          }
        }
        if (!isReady) {
          return false;
        }
        if (!engine.areAllEffectsReady()) {
          return false;
        }
        if (checkRenderTargets) {
          for (index = 0; index < this._materialsRenderTargets.length; ++index) {
            var rtt = this._materialsRenderTargets.data[index];
            if (!rtt.isReadyForRendering()) {
              return false;
            }
          }
        }
        for (index = 0; index < this.geometries.length; index++) {
          var geometry = this.geometries[index];
          if (geometry.delayLoadState === 2) {
            return false;
          }
        }
        if (this.activeCameras && this.activeCameras.length > 0) {
          for (var _d = 0, _e = this.activeCameras; _d < _e.length; _d++) {
            var camera = _e[_d];
            if (!camera.isReady(true)) {
              return false;
            }
          }
        } else if (this.activeCamera) {
          if (!this.activeCamera.isReady(true)) {
            return false;
          }
        }
        for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
          var particleSystem = _g[_f];
          if (!particleSystem.isReady()) {
            return false;
          }
        }
        return true;
      };
      Scene2.prototype.resetCachedMaterial = function() {
        this._cachedMaterial = null;
        this._cachedEffect = null;
        this._cachedVisibility = null;
      };
      Scene2.prototype.registerBeforeRender = function(func) {
        this.onBeforeRenderObservable.add(func);
      };
      Scene2.prototype.unregisterBeforeRender = function(func) {
        this.onBeforeRenderObservable.removeCallback(func);
      };
      Scene2.prototype.registerAfterRender = function(func) {
        this.onAfterRenderObservable.add(func);
      };
      Scene2.prototype.unregisterAfterRender = function(func) {
        this.onAfterRenderObservable.removeCallback(func);
      };
      Scene2.prototype._executeOnceBeforeRender = function(func) {
        var _this = this;
        var execFunc = function() {
          func();
          setTimeout(function() {
            _this.unregisterBeforeRender(execFunc);
          });
        };
        this.registerBeforeRender(execFunc);
      };
      Scene2.prototype.executeOnceBeforeRender = function(func, timeout) {
        var _this = this;
        if (timeout !== void 0) {
          setTimeout(function() {
            _this._executeOnceBeforeRender(func);
          }, timeout);
        } else {
          this._executeOnceBeforeRender(func);
        }
      };
      Scene2.prototype._addPendingData = function(data) {
        this._pendingData.push(data);
      };
      Scene2.prototype._removePendingData = function(data) {
        var wasLoading = this.isLoading;
        var index = this._pendingData.indexOf(data);
        if (index !== -1) {
          this._pendingData.splice(index, 1);
        }
        if (wasLoading && !this.isLoading) {
          this.onDataLoadedObservable.notifyObservers(this);
        }
      };
      Scene2.prototype.getWaitingItemsCount = function() {
        return this._pendingData.length;
      };
      Object.defineProperty(Scene2.prototype, "isLoading", {
        get: function() {
          return this._pendingData.length > 0;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.executeWhenReady = function(func, checkRenderTargets) {
        var _this = this;
        if (checkRenderTargets === void 0) {
          checkRenderTargets = false;
        }
        this.onReadyObservable.add(func);
        if (this._executeWhenReadyTimeoutId !== null) {
          return;
        }
        this._executeWhenReadyTimeoutId = setTimeout(function() {
          _this._checkIsReady(checkRenderTargets);
        }, 150);
      };
      Scene2.prototype.whenReadyAsync = function(checkRenderTargets) {
        var _this = this;
        if (checkRenderTargets === void 0) {
          checkRenderTargets = false;
        }
        return new Promise(function(resolve) {
          _this.executeWhenReady(function() {
            resolve();
          }, checkRenderTargets);
        });
      };
      Scene2.prototype._checkIsReady = function(checkRenderTargets) {
        var _this = this;
        if (checkRenderTargets === void 0) {
          checkRenderTargets = false;
        }
        this._registerTransientComponents();
        if (this.isReady(checkRenderTargets)) {
          this.onReadyObservable.notifyObservers(this);
          this.onReadyObservable.clear();
          this._executeWhenReadyTimeoutId = null;
          return;
        }
        if (this._isDisposed) {
          this.onReadyObservable.clear();
          this._executeWhenReadyTimeoutId = null;
          return;
        }
        this._executeWhenReadyTimeoutId = setTimeout(function() {
          _this._checkIsReady(checkRenderTargets);
        }, 100);
      };
      Object.defineProperty(Scene2.prototype, "animatables", {
        get: function() {
          return this._activeAnimatables;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.resetLastAnimationTimeFrame = function() {
        this._animationTimeLast = PrecisionDate.Now;
      };
      Scene2.prototype.getViewMatrix = function() {
        return this._viewMatrix;
      };
      Scene2.prototype.getProjectionMatrix = function() {
        return this._projectionMatrix;
      };
      Scene2.prototype.getTransformMatrix = function() {
        return this._transformMatrix;
      };
      Scene2.prototype.setTransformMatrix = function(viewL, projectionL, viewR, projectionR) {
        if (!viewR && !projectionR && this._multiviewSceneUbo) {
          this._multiviewSceneUbo.dispose();
          this._multiviewSceneUbo = null;
        }
        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
          return;
        }
        this._viewUpdateFlag = viewL.updateFlag;
        this._projectionUpdateFlag = projectionL.updateFlag;
        this._viewMatrix = viewL;
        this._projectionMatrix = projectionL;
        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        if (!this._frustumPlanes) {
          this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
        } else {
          Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
        }
        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
          this._updateMultiviewUbo(viewR, projectionR);
        } else if (this._sceneUbo.useUbo) {
          this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
          this._sceneUbo.updateMatrix("view", this._viewMatrix);
          this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
        }
      };
      Scene2.prototype.getSceneUniformBuffer = function() {
        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
      };
      Scene2.prototype.createSceneUniformBuffer = function(name) {
        var sceneUbo = new UniformBuffer(this._engine, void 0, false, name !== null && name !== void 0 ? name : "scene");
        sceneUbo.addUniform("viewProjection", 16);
        sceneUbo.addUniform("view", 16);
        sceneUbo.addUniform("projection", 16);
        sceneUbo.addUniform("vEyePosition", 4);
        return sceneUbo;
      };
      Scene2.prototype.setSceneUniformBuffer = function(ubo) {
        this._sceneUbo = ubo;
        this._viewUpdateFlag = -1;
        this._projectionUpdateFlag = -1;
      };
      Scene2.prototype.getUniqueId = function() {
        return UniqueIdGenerator.UniqueId;
      };
      Scene2.prototype.addMesh = function(newMesh, recursive) {
        var _this = this;
        if (recursive === void 0) {
          recursive = false;
        }
        if (this._blockEntityCollection) {
          return;
        }
        this.meshes.push(newMesh);
        newMesh._resyncLightSources();
        if (!newMesh.parent) {
          newMesh._addToSceneRootNodes();
        }
        this.onNewMeshAddedObservable.notifyObservers(newMesh);
        if (recursive) {
          newMesh.getChildMeshes().forEach(function(m) {
            _this.addMesh(m);
          });
        }
      };
      Scene2.prototype.removeMesh = function(toRemove, recursive) {
        var _this = this;
        if (recursive === void 0) {
          recursive = false;
        }
        var index = this.meshes.indexOf(toRemove);
        if (index !== -1) {
          this.meshes[index] = this.meshes[this.meshes.length - 1];
          this.meshes.pop();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this._inputManager._invalidateMesh(toRemove);
        this.onMeshRemovedObservable.notifyObservers(toRemove);
        if (recursive) {
          toRemove.getChildMeshes().forEach(function(m) {
            _this.removeMesh(m);
          });
        }
        return index;
      };
      Scene2.prototype.addTransformNode = function(newTransformNode) {
        if (this._blockEntityCollection) {
          return;
        }
        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
          return;
        }
        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
        this.transformNodes.push(newTransformNode);
        if (!newTransformNode.parent) {
          newTransformNode._addToSceneRootNodes();
        }
        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
      };
      Scene2.prototype.removeTransformNode = function(toRemove) {
        var index = toRemove._indexInSceneTransformNodesArray;
        if (index !== -1) {
          if (index !== this.transformNodes.length - 1) {
            var lastNode = this.transformNodes[this.transformNodes.length - 1];
            this.transformNodes[index] = lastNode;
            lastNode._indexInSceneTransformNodesArray = index;
          }
          toRemove._indexInSceneTransformNodesArray = -1;
          this.transformNodes.pop();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.removeSkeleton = function(toRemove) {
        var index = this.skeletons.indexOf(toRemove);
        if (index !== -1) {
          this.skeletons.splice(index, 1);
          this.onSkeletonRemovedObservable.notifyObservers(toRemove);
          this._executeActiveContainerCleanup(this._activeSkeletons);
        }
        return index;
      };
      Scene2.prototype.removeMorphTargetManager = function(toRemove) {
        var index = this.morphTargetManagers.indexOf(toRemove);
        if (index !== -1) {
          this.morphTargetManagers.splice(index, 1);
        }
        return index;
      };
      Scene2.prototype.removeLight = function(toRemove) {
        var index = this.lights.indexOf(toRemove);
        if (index !== -1) {
          for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
            var mesh = _a[_i];
            mesh._removeLightSource(toRemove, false);
          }
          this.lights.splice(index, 1);
          this.sortLightsByPriority();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this.onLightRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.removeCamera = function(toRemove) {
        var index = this.cameras.indexOf(toRemove);
        if (index !== -1) {
          this.cameras.splice(index, 1);
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        if (this.activeCameras) {
          var index2 = this.activeCameras.indexOf(toRemove);
          if (index2 !== -1) {
            this.activeCameras.splice(index2, 1);
          }
        }
        if (this.activeCamera === toRemove) {
          if (this.cameras.length > 0) {
            this.activeCamera = this.cameras[0];
          } else {
            this.activeCamera = null;
          }
        }
        this.onCameraRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.removeParticleSystem = function(toRemove) {
        var index = this.particleSystems.indexOf(toRemove);
        if (index !== -1) {
          this.particleSystems.splice(index, 1);
          this._executeActiveContainerCleanup(this._activeParticleSystems);
        }
        return index;
      };
      Scene2.prototype.removeAnimation = function(toRemove) {
        var index = this.animations.indexOf(toRemove);
        if (index !== -1) {
          this.animations.splice(index, 1);
        }
        return index;
      };
      Scene2.prototype.stopAnimation = function(target, animationName, targetMask) {
      };
      Scene2.prototype.removeAnimationGroup = function(toRemove) {
        var index = this.animationGroups.indexOf(toRemove);
        if (index !== -1) {
          this.animationGroups.splice(index, 1);
        }
        return index;
      };
      Scene2.prototype.removeMultiMaterial = function(toRemove) {
        var index = this.multiMaterials.indexOf(toRemove);
        if (index !== -1) {
          this.multiMaterials.splice(index, 1);
        }
        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.removeMaterial = function(toRemove) {
        var index = toRemove._indexInSceneMaterialArray;
        if (index !== -1 && index < this.materials.length) {
          if (index !== this.materials.length - 1) {
            var lastMaterial = this.materials[this.materials.length - 1];
            this.materials[index] = lastMaterial;
            lastMaterial._indexInSceneMaterialArray = index;
          }
          toRemove._indexInSceneMaterialArray = -1;
          this.materials.pop();
        }
        this.onMaterialRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.removeActionManager = function(toRemove) {
        var index = this.actionManagers.indexOf(toRemove);
        if (index !== -1) {
          this.actionManagers.splice(index, 1);
        }
        return index;
      };
      Scene2.prototype.removeTexture = function(toRemove) {
        var index = this.textures.indexOf(toRemove);
        if (index !== -1) {
          this.textures.splice(index, 1);
        }
        this.onTextureRemovedObservable.notifyObservers(toRemove);
        return index;
      };
      Scene2.prototype.addLight = function(newLight) {
        if (this._blockEntityCollection) {
          return;
        }
        this.lights.push(newLight);
        this.sortLightsByPriority();
        if (!newLight.parent) {
          newLight._addToSceneRootNodes();
        }
        for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          if (mesh.lightSources.indexOf(newLight) === -1) {
            mesh.lightSources.push(newLight);
            mesh._resyncLightSources();
          }
        }
        this.onNewLightAddedObservable.notifyObservers(newLight);
      };
      Scene2.prototype.sortLightsByPriority = function() {
        if (this.requireLightSorting) {
          this.lights.sort(LightConstants.CompareLightsPriority);
        }
      };
      Scene2.prototype.addCamera = function(newCamera) {
        if (this._blockEntityCollection) {
          return;
        }
        this.cameras.push(newCamera);
        this.onNewCameraAddedObservable.notifyObservers(newCamera);
        if (!newCamera.parent) {
          newCamera._addToSceneRootNodes();
        }
      };
      Scene2.prototype.addSkeleton = function(newSkeleton) {
        if (this._blockEntityCollection) {
          return;
        }
        this.skeletons.push(newSkeleton);
        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
      };
      Scene2.prototype.addParticleSystem = function(newParticleSystem) {
        if (this._blockEntityCollection) {
          return;
        }
        this.particleSystems.push(newParticleSystem);
      };
      Scene2.prototype.addAnimation = function(newAnimation) {
        if (this._blockEntityCollection) {
          return;
        }
        this.animations.push(newAnimation);
      };
      Scene2.prototype.addAnimationGroup = function(newAnimationGroup) {
        if (this._blockEntityCollection) {
          return;
        }
        this.animationGroups.push(newAnimationGroup);
      };
      Scene2.prototype.addMultiMaterial = function(newMultiMaterial) {
        if (this._blockEntityCollection) {
          return;
        }
        this.multiMaterials.push(newMultiMaterial);
        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
      };
      Scene2.prototype.addMaterial = function(newMaterial) {
        if (this._blockEntityCollection) {
          return;
        }
        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
          return;
        }
        newMaterial._indexInSceneMaterialArray = this.materials.length;
        this.materials.push(newMaterial);
        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
      };
      Scene2.prototype.addMorphTargetManager = function(newMorphTargetManager) {
        if (this._blockEntityCollection) {
          return;
        }
        this.morphTargetManagers.push(newMorphTargetManager);
      };
      Scene2.prototype.addGeometry = function(newGeometry) {
        if (this._blockEntityCollection) {
          return;
        }
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
        }
        this.geometries.push(newGeometry);
      };
      Scene2.prototype.addActionManager = function(newActionManager) {
        this.actionManagers.push(newActionManager);
      };
      Scene2.prototype.addTexture = function(newTexture) {
        if (this._blockEntityCollection) {
          return;
        }
        this.textures.push(newTexture);
        this.onNewTextureAddedObservable.notifyObservers(newTexture);
      };
      Scene2.prototype.switchActiveCamera = function(newCamera, attachControl) {
        if (attachControl === void 0) {
          attachControl = true;
        }
        var canvas = this._engine.getInputElement();
        if (!canvas) {
          return;
        }
        if (this.activeCamera) {
          this.activeCamera.detachControl();
        }
        this.activeCamera = newCamera;
        if (attachControl) {
          newCamera.attachControl();
        }
      };
      Scene2.prototype.setActiveCameraById = function(id) {
        var camera = this.getCameraById(id);
        if (camera) {
          this.activeCamera = camera;
          return camera;
        }
        return null;
      };
      Scene2.prototype.setActiveCameraByName = function(name) {
        var camera = this.getCameraByName(name);
        if (camera) {
          this.activeCamera = camera;
          return camera;
        }
        return null;
      };
      Scene2.prototype.getAnimationGroupByName = function(name) {
        for (var index = 0; index < this.animationGroups.length; index++) {
          if (this.animationGroups[index].name === name) {
            return this.animationGroups[index];
          }
        }
        return null;
      };
      Scene2.prototype.getMaterialByUniqueID = function(uniqueId) {
        for (var index = 0; index < this.materials.length; index++) {
          if (this.materials[index].uniqueId === uniqueId) {
            return this.materials[index];
          }
        }
        return null;
      };
      Scene2.prototype.getMaterialById = function(id) {
        for (var index = 0; index < this.materials.length; index++) {
          if (this.materials[index].id === id) {
            return this.materials[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLastMaterialById = function(id, allowMultiMaterials) {
        if (allowMultiMaterials === void 0) {
          allowMultiMaterials = false;
        }
        for (var index = this.materials.length - 1; index >= 0; index--) {
          if (this.materials[index].id === id) {
            return this.materials[index];
          }
        }
        if (allowMultiMaterials) {
          for (var index = this.multiMaterials.length - 1; index >= 0; index--) {
            if (this.multiMaterials[index].id === id) {
              return this.multiMaterials[index];
            }
          }
        }
        return null;
      };
      Scene2.prototype.getMaterialByName = function(name) {
        for (var index = 0; index < this.materials.length; index++) {
          if (this.materials[index].name === name) {
            return this.materials[index];
          }
        }
        return null;
      };
      Scene2.prototype.getTextureByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.textures.length; index++) {
          if (this.textures[index].uniqueId === uniqueId) {
            return this.textures[index];
          }
        }
        return null;
      };
      Scene2.prototype.getTextureByName = function(name) {
        for (var index = 0; index < this.textures.length; index++) {
          if (this.textures[index].name === name) {
            return this.textures[index];
          }
        }
        return null;
      };
      Scene2.prototype.getCameraById = function(id) {
        for (var index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].id === id) {
            return this.cameras[index];
          }
        }
        return null;
      };
      Scene2.prototype.getCameraByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].uniqueId === uniqueId) {
            return this.cameras[index];
          }
        }
        return null;
      };
      Scene2.prototype.getCameraByName = function(name) {
        for (var index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].name === name) {
            return this.cameras[index];
          }
        }
        return null;
      };
      Scene2.prototype.getBoneById = function(id) {
        for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
          var skeleton = this.skeletons[skeletonIndex];
          for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
            if (skeleton.bones[boneIndex].id === id) {
              return skeleton.bones[boneIndex];
            }
          }
        }
        return null;
      };
      Scene2.prototype.getBoneByName = function(name) {
        for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
          var skeleton = this.skeletons[skeletonIndex];
          for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
            if (skeleton.bones[boneIndex].name === name) {
              return skeleton.bones[boneIndex];
            }
          }
        }
        return null;
      };
      Scene2.prototype.getLightByName = function(name) {
        for (var index = 0; index < this.lights.length; index++) {
          if (this.lights[index].name === name) {
            return this.lights[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLightById = function(id) {
        for (var index = 0; index < this.lights.length; index++) {
          if (this.lights[index].id === id) {
            return this.lights[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLightByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.lights.length; index++) {
          if (this.lights[index].uniqueId === uniqueId) {
            return this.lights[index];
          }
        }
        return null;
      };
      Scene2.prototype.getParticleSystemById = function(id) {
        for (var index = 0; index < this.particleSystems.length; index++) {
          if (this.particleSystems[index].id === id) {
            return this.particleSystems[index];
          }
        }
        return null;
      };
      Scene2.prototype.getGeometryById = function(id) {
        for (var index = 0; index < this.geometries.length; index++) {
          if (this.geometries[index].id === id) {
            return this.geometries[index];
          }
        }
        return null;
      };
      Scene2.prototype._getGeometryByUniqueId = function(uniqueId) {
        if (this._geometriesByUniqueId) {
          var index = this._geometriesByUniqueId[uniqueId];
          if (index !== void 0) {
            return this.geometries[index];
          }
        } else {
          for (var index = 0; index < this.geometries.length; index++) {
            if (this.geometries[index].uniqueId === uniqueId) {
              return this.geometries[index];
            }
          }
        }
        return null;
      };
      Scene2.prototype.pushGeometry = function(geometry, force) {
        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
          return false;
        }
        this.addGeometry(geometry);
        this.onNewGeometryAddedObservable.notifyObservers(geometry);
        return true;
      };
      Scene2.prototype.removeGeometry = function(geometry) {
        var index;
        if (this._geometriesByUniqueId) {
          index = this._geometriesByUniqueId[geometry.uniqueId];
          if (index === void 0) {
            return false;
          }
        } else {
          index = this.geometries.indexOf(geometry);
          if (index < 0) {
            return false;
          }
        }
        if (index !== this.geometries.length - 1) {
          var lastGeometry = this.geometries[this.geometries.length - 1];
          if (lastGeometry) {
            this.geometries[index] = lastGeometry;
            if (this._geometriesByUniqueId) {
              this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
              this._geometriesByUniqueId[geometry.uniqueId] = void 0;
            }
          }
        }
        this.geometries.pop();
        this.onGeometryRemovedObservable.notifyObservers(geometry);
        return true;
      };
      Scene2.prototype.getGeometries = function() {
        return this.geometries;
      };
      Scene2.prototype.getMeshById = function(id) {
        for (var index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getMeshesById = function(id) {
        return this.meshes.filter(function(m) {
          return m.id === id;
        });
      };
      Scene2.prototype.getTransformNodeById = function(id) {
        for (var index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].id === id) {
            return this.transformNodes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getTransformNodeByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].uniqueId === uniqueId) {
            return this.transformNodes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getTransformNodesById = function(id) {
        return this.transformNodes.filter(function(m) {
          return m.id === id;
        });
      };
      Scene2.prototype.getMeshByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].uniqueId === uniqueId) {
            return this.meshes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLastMeshById = function(id) {
        for (var index = this.meshes.length - 1; index >= 0; index--) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLastEntryById = function(id) {
        var index;
        for (index = this.meshes.length - 1; index >= 0; index--) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        for (index = this.transformNodes.length - 1; index >= 0; index--) {
          if (this.transformNodes[index].id === id) {
            return this.transformNodes[index];
          }
        }
        for (index = this.cameras.length - 1; index >= 0; index--) {
          if (this.cameras[index].id === id) {
            return this.cameras[index];
          }
        }
        for (index = this.lights.length - 1; index >= 0; index--) {
          if (this.lights[index].id === id) {
            return this.lights[index];
          }
        }
        return null;
      };
      Scene2.prototype.getNodeById = function(id) {
        var mesh = this.getMeshById(id);
        if (mesh) {
          return mesh;
        }
        var transformNode = this.getTransformNodeById(id);
        if (transformNode) {
          return transformNode;
        }
        var light = this.getLightById(id);
        if (light) {
          return light;
        }
        var camera = this.getCameraById(id);
        if (camera) {
          return camera;
        }
        var bone = this.getBoneById(id);
        if (bone) {
          return bone;
        }
        return null;
      };
      Scene2.prototype.getNodeByName = function(name) {
        var mesh = this.getMeshByName(name);
        if (mesh) {
          return mesh;
        }
        var transformNode = this.getTransformNodeByName(name);
        if (transformNode) {
          return transformNode;
        }
        var light = this.getLightByName(name);
        if (light) {
          return light;
        }
        var camera = this.getCameraByName(name);
        if (camera) {
          return camera;
        }
        var bone = this.getBoneByName(name);
        if (bone) {
          return bone;
        }
        return null;
      };
      Scene2.prototype.getMeshByName = function(name) {
        for (var index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].name === name) {
            return this.meshes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getTransformNodeByName = function(name) {
        for (var index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].name === name) {
            return this.transformNodes[index];
          }
        }
        return null;
      };
      Scene2.prototype.getLastSkeletonById = function(id) {
        for (var index = this.skeletons.length - 1; index >= 0; index--) {
          if (this.skeletons[index].id === id) {
            return this.skeletons[index];
          }
        }
        return null;
      };
      Scene2.prototype.getSkeletonByUniqueId = function(uniqueId) {
        for (var index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].uniqueId === uniqueId) {
            return this.skeletons[index];
          }
        }
        return null;
      };
      Scene2.prototype.getSkeletonById = function(id) {
        for (var index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].id === id) {
            return this.skeletons[index];
          }
        }
        return null;
      };
      Scene2.prototype.getSkeletonByName = function(name) {
        for (var index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].name === name) {
            return this.skeletons[index];
          }
        }
        return null;
      };
      Scene2.prototype.getMorphTargetManagerById = function(id) {
        for (var index = 0; index < this.morphTargetManagers.length; index++) {
          if (this.morphTargetManagers[index].uniqueId === id) {
            return this.morphTargetManagers[index];
          }
        }
        return null;
      };
      Scene2.prototype.getMorphTargetById = function(id) {
        for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
          var morphTargetManager = this.morphTargetManagers[managerIndex];
          for (var index = 0; index < morphTargetManager.numTargets; ++index) {
            var target = morphTargetManager.getTarget(index);
            if (target.id === id) {
              return target;
            }
          }
        }
        return null;
      };
      Scene2.prototype.getMorphTargetByName = function(name) {
        for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
          var morphTargetManager = this.morphTargetManagers[managerIndex];
          for (var index = 0; index < morphTargetManager.numTargets; ++index) {
            var target = morphTargetManager.getTarget(index);
            if (target.name === name) {
              return target;
            }
          }
        }
        return null;
      };
      Scene2.prototype.getPostProcessByName = function(name) {
        for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
          var postProcess = this.postProcesses[postProcessIndex];
          if (postProcess.name === name) {
            return postProcess;
          }
        }
        return null;
      };
      Scene2.prototype.isActiveMesh = function(mesh) {
        return this._activeMeshes.indexOf(mesh) !== -1;
      };
      Object.defineProperty(Scene2.prototype, "uid", {
        get: function() {
          if (!this._uid) {
            this._uid = Tools.RandomId();
          }
          return this._uid;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.addExternalData = function(key, data) {
        if (!this._externalData) {
          this._externalData = new StringDictionary();
        }
        return this._externalData.add(key, data);
      };
      Scene2.prototype.getExternalData = function(key) {
        if (!this._externalData) {
          return null;
        }
        return this._externalData.get(key);
      };
      Scene2.prototype.getOrAddExternalDataWithFactory = function(key, factory) {
        if (!this._externalData) {
          this._externalData = new StringDictionary();
        }
        return this._externalData.getOrAddWithFactory(key, factory);
      };
      Scene2.prototype.removeExternalData = function(key) {
        return this._externalData.remove(key);
      };
      Scene2.prototype._evaluateSubMesh = function(subMesh, mesh, initialMesh) {
        if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {
          for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {
            var step = _a[_i];
            step.action(mesh, subMesh);
          }
          var material = subMesh.getMaterial();
          if (material !== null && material !== void 0) {
            if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
            this._renderingManager.dispatch(subMesh, mesh, material);
          }
        }
      };
      Scene2.prototype.freeProcessedMaterials = function() {
        this._processedMaterials.dispose();
      };
      Object.defineProperty(Scene2.prototype, "blockfreeActiveMeshesAndRenderingGroups", {
        get: function() {
          return this._preventFreeActiveMeshesAndRenderingGroups;
        },
        set: function(value) {
          if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
            return;
          }
          if (value) {
            this.freeActiveMeshes();
            this.freeRenderingGroups();
          }
          this._preventFreeActiveMeshesAndRenderingGroups = value;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.freeActiveMeshes = function() {
        if (this.blockfreeActiveMeshesAndRenderingGroups) {
          return;
        }
        this._activeMeshes.dispose();
        if (this.activeCamera && this.activeCamera._activeMeshes) {
          this.activeCamera._activeMeshes.dispose();
        }
        if (this.activeCameras) {
          for (var i = 0; i < this.activeCameras.length; i++) {
            var activeCamera = this.activeCameras[i];
            if (activeCamera && activeCamera._activeMeshes) {
              activeCamera._activeMeshes.dispose();
            }
          }
        }
      };
      Scene2.prototype.freeRenderingGroups = function() {
        if (this.blockfreeActiveMeshesAndRenderingGroups) {
          return;
        }
        if (this._renderingManager) {
          this._renderingManager.freeRenderingGroups();
        }
        if (this.textures) {
          for (var i = 0; i < this.textures.length; i++) {
            var texture = this.textures[i];
            if (texture && texture.renderList) {
              texture.freeRenderingGroups();
            }
          }
        }
      };
      Scene2.prototype._isInIntermediateRendering = function() {
        return this._intermediateRendering;
      };
      Scene2.prototype.freezeActiveMeshes = function(skipEvaluateActiveMeshes, onSuccess, onError, freezeMeshes, keepFrustumCulling) {
        var _this = this;
        if (skipEvaluateActiveMeshes === void 0) {
          skipEvaluateActiveMeshes = false;
        }
        if (freezeMeshes === void 0) {
          freezeMeshes = true;
        }
        if (keepFrustumCulling === void 0) {
          keepFrustumCulling = false;
        }
        this.executeWhenReady(function() {
          if (!_this.activeCamera) {
            onError && onError("No active camera found");
            return;
          }
          if (!_this._frustumPlanes) {
            _this.updateTransformMatrix();
          }
          _this._evaluateActiveMeshes();
          _this._activeMeshesFrozen = true;
          _this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
          _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
          if (freezeMeshes) {
            for (var index = 0; index < _this._activeMeshes.length; index++) {
              _this._activeMeshes.data[index]._freeze();
            }
          }
          onSuccess && onSuccess();
        });
        return this;
      };
      Scene2.prototype.unfreezeActiveMeshes = function() {
        for (var index = 0; index < this.meshes.length; index++) {
          var mesh = this.meshes[index];
          if (mesh._internalAbstractMeshDataInfo) {
            mesh._internalAbstractMeshDataInfo._isActive = false;
          }
        }
        for (var index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._unFreeze();
        }
        this._activeMeshesFrozen = false;
        return this;
      };
      Scene2.prototype._executeActiveContainerCleanup = function(container) {
        var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
          return;
        }
        this.onBeforeRenderObservable.addOnce(function() {
          return container.dispose();
        });
      };
      Scene2.prototype._evaluateActiveMeshes = function() {
        var _a;
        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
          if (this._activeMeshes.length > 0) {
            (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();
            this._activeMeshes.reset();
            this._renderingManager.reset();
            this._processedMaterials.reset();
            this._activeParticleSystems.reset();
            this._activeSkeletons.reset();
            this._softwareSkinnedMeshes.reset();
          }
          return;
        }
        if (this._activeMeshesFrozen && this._activeMeshes.length) {
          if (!this._skipEvaluateActiveMeshesCompletely) {
            var len_1 = this._activeMeshes.length;
            for (var i = 0; i < len_1; i++) {
              var mesh = this._activeMeshes.data[i];
              mesh.computeWorldMatrix();
            }
          }
          if (this._activeParticleSystems) {
            var psLength = this._activeParticleSystems.length;
            for (var i = 0; i < psLength; i++) {
              this._activeParticleSystems.data[i].animate();
            }
          }
          return;
        }
        if (!this.activeCamera) {
          return;
        }
        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
        this.activeCamera._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
        this._materialsRenderTargets.reset();
        for (var _i = 0, _b = this._beforeEvaluateActiveMeshStage; _i < _b.length; _i++) {
          var step = _b[_i];
          step.action();
        }
        var meshes = this.getActiveMeshCandidates();
        var len = meshes.length;
        for (var i = 0; i < len; i++) {
          var mesh = meshes.data[i];
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
          if (mesh.isBlocked) {
            continue;
          }
          this._totalVertices.addCount(mesh.getTotalVertices(), false);
          if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
            continue;
          }
          mesh.computeWorldMatrix();
          if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
            this._meshesForIntersections.pushNoDuplicate(mesh);
          }
          var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
          mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
          if (meshToRender === void 0 || meshToRender === null) {
            continue;
          }
          if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
            meshToRender.computeWorldMatrix();
          }
          mesh._preActivate();
          if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
            this._activeMeshes.push(mesh);
            this.activeCamera._activeMeshes.push(mesh);
            if (meshToRender !== mesh) {
              meshToRender._activate(this._renderId, false);
            }
            for (var _c = 0, _d = this._preActiveMeshStage; _c < _d.length; _c++) {
              var step = _d[_c];
              step.action(mesh);
            }
            if (mesh._activate(this._renderId, false)) {
              if (!mesh.isAnInstance) {
                meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
              } else {
                if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                  meshToRender = mesh;
                }
              }
              meshToRender._internalAbstractMeshDataInfo._isActive = true;
              this._activeMesh(mesh, meshToRender);
            }
            mesh._postActivate();
          }
        }
        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
        if (this.particlesEnabled) {
          this.onBeforeParticlesRenderingObservable.notifyObservers(this);
          for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
            var particleSystem = this.particleSystems[particleIndex];
            if (!particleSystem.isStarted() || !particleSystem.emitter) {
              continue;
            }
            var emitter = particleSystem.emitter;
            if (!emitter.position || emitter.isEnabled()) {
              this._activeParticleSystems.push(particleSystem);
              particleSystem.animate();
              this._renderingManager.dispatchParticles(particleSystem);
            }
          }
          this.onAfterParticlesRenderingObservable.notifyObservers(this);
        }
      };
      Scene2.prototype._activeMesh = function(sourceMesh, mesh) {
        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
          if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
            mesh.skeleton.prepare();
            this._activeBones.addCount(mesh.skeleton.bones.length, false);
          }
          if (!mesh.computeBonesUsingShaders) {
            this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
          }
        }
        if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
          var subMeshes = this.getActiveSubMeshCandidates(mesh);
          var len = subMeshes.length;
          for (var i = 0; i < len; i++) {
            var subMesh = subMeshes.data[i];
            this._evaluateSubMesh(subMesh, mesh, sourceMesh);
          }
        }
      };
      Scene2.prototype.updateTransformMatrix = function(force) {
        if (!this.activeCamera) {
          return;
        }
        if (this.activeCamera._renderingMultiview) {
          var leftCamera = this.activeCamera._rigCameras[0];
          var rightCamera = this.activeCamera._rigCameras[1];
          this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
        } else {
          this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
        }
      };
      Scene2.prototype._bindFrameBuffer = function(camera, clear) {
        if (clear === void 0) {
          clear = true;
        }
        if (camera && camera._multiviewTexture) {
          camera._multiviewTexture._bindFrameBuffer();
        } else if (camera && camera.outputRenderTarget) {
          camera.outputRenderTarget._bindFrameBuffer();
        } else {
          if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
            this._engine.restoreDefaultFramebuffer();
          }
        }
        if (clear) {
          this._clearFrameBuffer(camera);
        }
      };
      Scene2.prototype._clearFrameBuffer = function(camera) {
        if (camera && camera._multiviewTexture) {
        } else if (camera && camera.outputRenderTarget) {
          var rtt = camera.outputRenderTarget;
          if (rtt.onClearObservable.hasObservers()) {
            rtt.onClearObservable.notifyObservers(this._engine);
          } else if (!rtt.skipInitialClear) {
            this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);
            rtt._cleared = true;
          }
        } else {
          if (!this._defaultFrameBufferCleared) {
            this._defaultFrameBufferCleared = true;
            this._clear();
          } else {
            this._engine.clear(null, false, true, true);
          }
        }
      };
      Scene2.prototype._renderForCamera = function(camera, rigParent, bindFrameBuffer) {
        var _a, _b, _c;
        if (bindFrameBuffer === void 0) {
          bindFrameBuffer = true;
        }
        if (camera && camera._skipRendering) {
          return;
        }
        var engine = this._engine;
        this._activeCamera = camera;
        if (!this.activeCamera) {
          throw new Error("Active camera not set");
        }
        engine.setViewport(this.activeCamera.viewport);
        this.resetCachedMaterial();
        this._renderId++;
        if (!this.prePass && bindFrameBuffer) {
          var skipInitialClear = true;
          if (camera._renderingMultiview && camera.outputRenderTarget) {
            skipInitialClear = camera.outputRenderTarget.skipInitialClear;
            if (this.autoClear) {
              camera.outputRenderTarget.skipInitialClear = false;
            }
          }
          this._bindFrameBuffer(this._activeCamera);
          if (camera._renderingMultiview && camera.outputRenderTarget) {
            camera.outputRenderTarget.skipInitialClear = skipInitialClear;
          }
        }
        this.updateTransformMatrix();
        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
        this._evaluateActiveMeshes();
        for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
          var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
          mesh.applySkeleton(mesh.skeleton);
        }
        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
          this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
        }
        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
          this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
        }
        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
          this._renderTargets.pushNoDuplicate(this.environmentTexture);
        }
        for (var _i = 0, _d = this._gatherActiveCameraRenderTargetsStage; _i < _d.length; _i++) {
          var step = _d[_i];
          step.action(this._renderTargets);
        }
        var needRebind = false;
        if (this.renderTargetsEnabled) {
          this._intermediateRendering = true;
          if (this._renderTargets.length > 0) {
            Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
            for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
              var renderTarget = this._renderTargets.data[renderIndex];
              if (renderTarget._shouldRender()) {
                this._renderId++;
                var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
                renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
                needRebind = true;
              }
            }
            Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
            this._renderId++;
          }
          for (var _e = 0, _f = this._cameraDrawRenderTargetStage; _e < _f.length; _e++) {
            var step = _f[_e];
            needRebind = step.action(this.activeCamera) || needRebind;
          }
          this._intermediateRendering = false;
        }
        this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;
        if (needRebind && !this.prePass) {
          this._bindFrameBuffer(this._activeCamera, false);
        }
        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
          this.postProcessManager._prepareFrame();
        }
        for (var _g = 0, _h = this._beforeCameraDrawStage; _g < _h.length; _g++) {
          var step = _h[_g];
          step.action(this.activeCamera);
        }
        this.onBeforeDrawPhaseObservable.notifyObservers(this);
        if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {
          this.finalizeSceneUbo();
        }
        this._renderingManager.render(null, null, true, true);
        this.onAfterDrawPhaseObservable.notifyObservers(this);
        for (var _j = 0, _k = this._afterCameraDrawStage; _j < _k.length; _j++) {
          var step = _k[_j];
          step.action(this.activeCamera);
        }
        if (this.postProcessManager && !camera._multiviewTexture) {
          var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
          this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
        }
        this._renderTargets.reset();
        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
      };
      Scene2.prototype._processSubCameras = function(camera, bindFrameBuffer) {
        if (bindFrameBuffer === void 0) {
          bindFrameBuffer = true;
        }
        if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
          if (camera._renderingMultiview && !this._multiviewSceneUbo) {
            this._createMultiviewUbo();
          }
          this._renderForCamera(camera, void 0, bindFrameBuffer);
          this.onAfterRenderCameraObservable.notifyObservers(camera);
          return;
        }
        if (camera._useMultiviewToSingleView) {
          this._renderMultiviewToSingleView(camera);
        } else {
          this.onBeforeCameraRenderObservable.notifyObservers(camera);
          for (var index = 0; index < camera._rigCameras.length; index++) {
            this._renderForCamera(camera._rigCameras[index], camera);
          }
        }
        this._activeCamera = camera;
        this.updateTransformMatrix();
        this.onAfterRenderCameraObservable.notifyObservers(camera);
      };
      Scene2.prototype._checkIntersections = function() {
        for (var index = 0; index < this._meshesForIntersections.length; index++) {
          var sourceMesh = this._meshesForIntersections.data[index];
          if (!sourceMesh.actionManager) {
            continue;
          }
          var _loop_1 = function(actionIndex2) {
            var action = sourceMesh.actionManager.actions[actionIndex2];
            if (action.trigger === 12 || action.trigger === 13) {
              var parameters = action.getTriggerParameter();
              var otherMesh_1 = parameters.mesh ? parameters.mesh : parameters;
              var areIntersecting = otherMesh_1.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
              var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh_1);
              if (areIntersecting && currentIntersectionInProgress === -1) {
                if (action.trigger === 12) {
                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh_1));
                  sourceMesh._intersectionsInProgress.push(otherMesh_1);
                } else if (action.trigger === 13) {
                  sourceMesh._intersectionsInProgress.push(otherMesh_1);
                }
              } else if (!areIntersecting && currentIntersectionInProgress > -1) {
                if (action.trigger === 13) {
                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh_1));
                }
                if (!sourceMesh.actionManager.hasSpecificTrigger(13, function(parameter) {
                  var parameterMesh = parameter.mesh ? parameter.mesh : parameter;
                  return otherMesh_1 === parameterMesh;
                }) || action.trigger === 13) {
                  sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
                }
              }
            }
          };
          for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
            _loop_1(actionIndex);
          }
        }
      };
      Scene2.prototype._advancePhysicsEngineStep = function(step) {
      };
      Scene2.prototype._animate = function() {
      };
      Scene2.prototype.animate = function() {
        if (this._engine.isDeterministicLockStep()) {
          var deltaTime = Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime)) + this._timeAccumulator;
          var defaultFrameTime = this._engine.getTimeStep();
          var defaultFPS = 1e3 / defaultFrameTime / 1e3;
          var stepsTaken = 0;
          var maxSubSteps = this._engine.getLockstepMaxSteps();
          var internalSteps = Math.floor(deltaTime / defaultFrameTime);
          internalSteps = Math.min(internalSteps, maxSubSteps);
          while (deltaTime > 0 && stepsTaken < internalSteps) {
            this.onBeforeStepObservable.notifyObservers(this);
            this._animationRatio = defaultFrameTime * defaultFPS;
            this._animate();
            this.onAfterAnimationsObservable.notifyObservers(this);
            if (this.physicsEnabled) {
              this._advancePhysicsEngineStep(defaultFrameTime);
            }
            this.onAfterStepObservable.notifyObservers(this);
            this._currentStepId++;
            stepsTaken++;
            deltaTime -= defaultFrameTime;
          }
          this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
        } else {
          var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime));
          this._animationRatio = deltaTime * (60 / 1e3);
          this._animate();
          this.onAfterAnimationsObservable.notifyObservers(this);
          if (this.physicsEnabled) {
            this._advancePhysicsEngineStep(deltaTime);
          }
        }
      };
      Scene2.prototype._clear = function() {
        if (this.autoClearDepthAndStencil || this.autoClear) {
          this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
        }
      };
      Scene2.prototype._checkCameraRenderTarget = function(camera) {
        var _a;
        if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {
          camera.outputRenderTarget._cleared = false;
        }
        if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {
          for (var i = 0; i < camera.rigCameras.length; ++i) {
            var rtt = camera.rigCameras[i].outputRenderTarget;
            if (rtt) {
              rtt._cleared = false;
            }
          }
        }
      };
      Scene2.prototype.resetDrawCache = function(passId) {
        if (!this.meshes) {
          return;
        }
        for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh.resetDrawCache(passId);
        }
      };
      Scene2.prototype.render = function(updateCameras, ignoreAnimations) {
        var _a, _b, _c;
        if (updateCameras === void 0) {
          updateCameras = true;
        }
        if (ignoreAnimations === void 0) {
          ignoreAnimations = false;
        }
        if (this.isDisposed) {
          return;
        }
        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
          this._checkIsReady();
        }
        this._frameId++;
        this._defaultFrameBufferCleared = false;
        this._checkCameraRenderTarget(this.activeCamera);
        if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {
          this.activeCameras.forEach(this._checkCameraRenderTarget);
        }
        this._registerTransientComponents();
        this._activeParticles.fetchNewFrame();
        this._totalVertices.fetchNewFrame();
        this._activeIndices.fetchNewFrame();
        this._activeBones.fetchNewFrame();
        this._meshesForIntersections.reset();
        this.resetCachedMaterial();
        this.onBeforeAnimationsObservable.notifyObservers(this);
        if (this.actionManager) {
          this.actionManager.processTrigger(11);
        }
        if (!ignoreAnimations) {
          this.animate();
        }
        for (var _i = 0, _d = this._beforeCameraUpdateStage; _i < _d.length; _i++) {
          var step = _d[_i];
          step.action();
        }
        if (updateCameras) {
          if (this.activeCameras && this.activeCameras.length > 0) {
            for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
              var camera = this.activeCameras[cameraIndex];
              camera.update();
              if (camera.cameraRigMode !== 0) {
                for (var index = 0; index < camera._rigCameras.length; index++) {
                  camera._rigCameras[index].update();
                }
              }
            }
          } else if (this.activeCamera) {
            this.activeCamera.update();
            if (this.activeCamera.cameraRigMode !== 0) {
              for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {
                this.activeCamera._rigCameras[index].update();
              }
            }
          }
        }
        this.onBeforeRenderObservable.notifyObservers(this);
        var engine = this.getEngine();
        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
        var currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;
        if (this.renderTargetsEnabled) {
          Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
          this._intermediateRendering = true;
          for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
            var renderTarget = this.customRenderTargets[customIndex];
            if (renderTarget._shouldRender()) {
              this._renderId++;
              this.activeCamera = renderTarget.activeCamera || this.activeCamera;
              if (!this.activeCamera) {
                throw new Error("Active camera not set");
              }
              engine.setViewport(this.activeCamera.viewport);
              this.updateTransformMatrix();
              renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
            }
          }
          Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
          this._intermediateRendering = false;
          this._renderId++;
        }
        this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;
        this.activeCamera = currentActiveCamera;
        if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
          this._bindFrameBuffer(this._activeCamera, false);
        }
        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
        for (var _e = 0, _f = this._beforeClearStage; _e < _f.length; _e++) {
          var step = _f[_e];
          step.action();
        }
        this._clearFrameBuffer(this.activeCamera);
        for (var _g = 0, _h = this._gatherRenderTargetsStage; _g < _h.length; _g++) {
          var step = _h[_g];
          step.action(this._renderTargets);
        }
        if (this.activeCameras && this.activeCameras.length > 0) {
          for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
            this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
          }
        } else {
          if (!this.activeCamera) {
            throw new Error("No camera defined");
          }
          this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
        }
        this._checkIntersections();
        for (var _j = 0, _k = this._afterRenderStage; _j < _k.length; _j++) {
          var step = _k[_j];
          step.action();
        }
        if (this.afterRender) {
          this.afterRender();
        }
        this.onAfterRenderObservable.notifyObservers(this);
        if (this._toBeDisposed.length) {
          for (var index = 0; index < this._toBeDisposed.length; index++) {
            var data = this._toBeDisposed[index];
            if (data) {
              data.dispose();
            }
          }
          this._toBeDisposed = [];
        }
        if (this.dumpNextRenderTargets) {
          this.dumpNextRenderTargets = false;
        }
        this._activeBones.addCount(0, true);
        this._activeIndices.addCount(0, true);
        this._activeParticles.addCount(0, true);
        this._engine.restoreDefaultFramebuffer();
      };
      Scene2.prototype.freezeMaterials = function() {
        for (var i = 0; i < this.materials.length; i++) {
          this.materials[i].freeze();
        }
      };
      Scene2.prototype.unfreezeMaterials = function() {
        for (var i = 0; i < this.materials.length; i++) {
          this.materials[i].unfreeze();
        }
      };
      Scene2.prototype.dispose = function() {
        var _a;
        if (this.isDisposed) {
          return;
        }
        this.beforeRender = null;
        this.afterRender = null;
        this.metadata = null;
        this.skeletons = [];
        this.morphTargetManagers = [];
        this._transientComponents = [];
        this._isReadyForMeshStage.clear();
        this._beforeEvaluateActiveMeshStage.clear();
        this._evaluateSubMeshStage.clear();
        this._preActiveMeshStage.clear();
        this._cameraDrawRenderTargetStage.clear();
        this._beforeCameraDrawStage.clear();
        this._beforeRenderTargetDrawStage.clear();
        this._beforeRenderingGroupDrawStage.clear();
        this._beforeRenderingMeshStage.clear();
        this._afterRenderingMeshStage.clear();
        this._afterRenderingGroupDrawStage.clear();
        this._afterCameraDrawStage.clear();
        this._afterRenderTargetDrawStage.clear();
        this._afterRenderStage.clear();
        this._beforeCameraUpdateStage.clear();
        this._beforeClearStage.clear();
        this._gatherRenderTargetsStage.clear();
        this._gatherActiveCameraRenderTargetsStage.clear();
        this._pointerMoveStage.clear();
        this._pointerDownStage.clear();
        this._pointerUpStage.clear();
        this.importedMeshesFiles = new Array();
        if (this.stopAllAnimations) {
          this.stopAllAnimations();
        }
        this.resetCachedMaterial();
        if (this.activeCamera) {
          this.activeCamera._activeMeshes.dispose();
          this.activeCamera = null;
        }
        this._activeMeshes.dispose();
        this._renderingManager.dispose();
        this._processedMaterials.dispose();
        this._activeParticleSystems.dispose();
        this._activeSkeletons.dispose();
        this._softwareSkinnedMeshes.dispose();
        this._renderTargets.dispose();
        this._materialsRenderTargets.dispose();
        this._registeredForLateAnimationBindings.dispose();
        this._meshesForIntersections.dispose();
        this._toBeDisposed = [];
        var activeRequests = this._activeRequests.slice();
        for (var _i = 0, activeRequests_1 = activeRequests; _i < activeRequests_1.length; _i++) {
          var request = activeRequests_1[_i];
          request.abort();
        }
        this._activeRequests = [];
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onBeforeRenderObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onBeforeRenderTargetsRenderObservable.clear();
        this.onAfterRenderTargetsRenderObservable.clear();
        this.onAfterStepObservable.clear();
        this.onBeforeStepObservable.clear();
        this.onBeforeActiveMeshesEvaluationObservable.clear();
        this.onAfterActiveMeshesEvaluationObservable.clear();
        this.onBeforeParticlesRenderingObservable.clear();
        this.onAfterParticlesRenderingObservable.clear();
        this.onBeforeDrawPhaseObservable.clear();
        this.onAfterDrawPhaseObservable.clear();
        this.onBeforeAnimationsObservable.clear();
        this.onAfterAnimationsObservable.clear();
        this.onDataLoadedObservable.clear();
        this.onBeforeRenderingGroupObservable.clear();
        this.onAfterRenderingGroupObservable.clear();
        this.onMeshImportedObservable.clear();
        this.onBeforeCameraRenderObservable.clear();
        this.onAfterCameraRenderObservable.clear();
        this.onReadyObservable.clear();
        this.onNewCameraAddedObservable.clear();
        this.onCameraRemovedObservable.clear();
        this.onNewLightAddedObservable.clear();
        this.onLightRemovedObservable.clear();
        this.onNewGeometryAddedObservable.clear();
        this.onGeometryRemovedObservable.clear();
        this.onNewTransformNodeAddedObservable.clear();
        this.onTransformNodeRemovedObservable.clear();
        this.onNewMeshAddedObservable.clear();
        this.onMeshRemovedObservable.clear();
        this.onNewSkeletonAddedObservable.clear();
        this.onSkeletonRemovedObservable.clear();
        this.onNewMaterialAddedObservable.clear();
        this.onNewMultiMaterialAddedObservable.clear();
        this.onMaterialRemovedObservable.clear();
        this.onMultiMaterialRemovedObservable.clear();
        this.onNewTextureAddedObservable.clear();
        this.onTextureRemovedObservable.clear();
        this.onPrePointerObservable.clear();
        this.onPointerObservable.clear();
        this.onPreKeyboardObservable.clear();
        this.onKeyboardObservable.clear();
        this.onActiveCameraChanged.clear();
        this.onComputePressureChanged.clear();
        (_a = this._computePressureObserver) === null || _a === void 0 ? void 0 : _a.unobserve();
        this._computePressureObserver = void 0;
        this.detachControl();
        var canvas = this._engine.getInputElement();
        if (canvas) {
          for (var index_1 = 0; index_1 < this.cameras.length; index_1++) {
            this.cameras[index_1].detachControl();
          }
        }
        this._disposeList(this.animationGroups);
        this._disposeList(this.lights);
        this._disposeList(this.meshes, function(item) {
          return item.dispose(true);
        });
        this._disposeList(this.transformNodes, function(item) {
          return item.dispose(true);
        });
        this._disposeList(this.cameras);
        if (this._defaultMaterial) {
          this._defaultMaterial.dispose();
        }
        this._disposeList(this.multiMaterials);
        this._disposeList(this.materials);
        this._disposeList(this.particleSystems);
        this._disposeList(this.postProcesses);
        this._disposeList(this.textures);
        this._disposeList(this.morphTargetManagers);
        this._sceneUbo.dispose();
        if (this._multiviewSceneUbo) {
          this._multiviewSceneUbo.dispose();
        }
        this.postProcessManager.dispose();
        this._disposeList(this._components);
        var index = this._engine.scenes.indexOf(this);
        if (index > -1) {
          this._engine.scenes.splice(index, 1);
        }
        if (EngineStore._LastCreatedScene === this) {
          if (this._engine.scenes.length > 0) {
            EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];
          } else {
            EngineStore._LastCreatedScene = null;
          }
        }
        index = this._engine._virtualScenes.indexOf(this);
        if (index > -1) {
          this._engine._virtualScenes.splice(index, 1);
        }
        this._engine.wipeCaches(true);
        this._isDisposed = true;
      };
      Scene2.prototype._disposeList = function(items, callback) {
        var itemsCopy = SliceTools.Slice(items, 0);
        callback = callback !== null && callback !== void 0 ? callback : function(item2) {
          return item2.dispose();
        };
        for (var _i = 0, itemsCopy_1 = itemsCopy; _i < itemsCopy_1.length; _i++) {
          var item = itemsCopy_1[_i];
          callback(item);
        }
        items.length = 0;
      };
      Object.defineProperty(Scene2.prototype, "isDisposed", {
        get: function() {
          return this._isDisposed;
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.clearCachedVertexData = function() {
        for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
          var mesh = this.meshes[meshIndex];
          var geometry = mesh.geometry;
          if (geometry) {
            geometry.clearCachedData();
          }
        }
      };
      Scene2.prototype.cleanCachedTextureBuffer = function() {
        for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
          var baseTexture = _a[_i];
          var buffer = baseTexture._buffer;
          if (buffer) {
            baseTexture._buffer = null;
          }
        }
      };
      Scene2.prototype.getWorldExtends = function(filterPredicate) {
        var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        filterPredicate = filterPredicate || function() {
          return true;
        };
        this.meshes.filter(filterPredicate).forEach(function(mesh) {
          mesh.computeWorldMatrix(true);
          if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
            return;
          }
          var boundingInfo = mesh.getBoundingInfo();
          var minBox = boundingInfo.boundingBox.minimumWorld;
          var maxBox = boundingInfo.boundingBox.maximumWorld;
          Vector3.CheckExtends(minBox, min, max);
          Vector3.CheckExtends(maxBox, min, max);
        });
        return {
          min,
          max
        };
      };
      Scene2.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
        if (cameraViewSpace === void 0) {
          cameraViewSpace = false;
        }
        throw _WarnImport("Ray");
      };
      Scene2.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {
        if (cameraViewSpace === void 0) {
          cameraViewSpace = false;
        }
        if (enableDistantPicking === void 0) {
          enableDistantPicking = false;
        }
        throw _WarnImport("Ray");
      };
      Scene2.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
        throw _WarnImport("Ray");
      };
      Scene2.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
        throw _WarnImport("Ray");
      };
      Scene2.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate) {
        var pi = new PickingInfo();
        pi._pickingUnavailable = true;
        return pi;
      };
      Scene2.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
        var pi = new PickingInfo();
        pi._pickingUnavailable = true;
        return pi;
      };
      Scene2.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
        throw _WarnImport("Ray");
      };
      Scene2.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
        throw _WarnImport("Ray");
      };
      Scene2.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
        throw _WarnImport("Ray");
      };
      Scene2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
      };
      Scene2.prototype.getPointerOverMesh = function() {
        return this._inputManager.getPointerOverMesh();
      };
      Scene2.prototype._rebuildGeometries = function() {
        for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {
          var geometry = _a[_i];
          geometry._rebuild();
        }
        for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {
          var mesh = _c[_b];
          mesh._rebuild();
        }
        if (this.postProcessManager) {
          this.postProcessManager._rebuild();
        }
        for (var _d = 0, _e = this._components; _d < _e.length; _d++) {
          var component = _e[_d];
          component.rebuild();
        }
        for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
          var system = _g[_f];
          system.rebuild();
        }
        if (this.spriteManagers) {
          for (var _h = 0, _j = this.spriteManagers; _h < _j.length; _h++) {
            var spriteMgr = _j[_h];
            spriteMgr.rebuild();
          }
        }
      };
      Scene2.prototype._rebuildTextures = function() {
        for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
          var texture = _a[_i];
          texture._rebuild();
        }
        this.markAllMaterialsAsDirty(1);
      };
      Scene2.prototype._getByTags = function(list, tagsQuery, forEach) {
        if (tagsQuery === void 0) {
          return list;
        }
        var listByTags = [];
        forEach = forEach || function(item2) {
          return;
        };
        for (var i in list) {
          var item = list[i];
          if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
            listByTags.push(item);
            forEach(item);
          }
        }
        return listByTags;
      };
      Scene2.prototype.getMeshesByTags = function(tagsQuery, forEach) {
        return this._getByTags(this.meshes, tagsQuery, forEach);
      };
      Scene2.prototype.getCamerasByTags = function(tagsQuery, forEach) {
        return this._getByTags(this.cameras, tagsQuery, forEach);
      };
      Scene2.prototype.getLightsByTags = function(tagsQuery, forEach) {
        return this._getByTags(this.lights, tagsQuery, forEach);
      };
      Scene2.prototype.getMaterialByTags = function(tagsQuery, forEach) {
        return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
      };
      Scene2.prototype.getTransformNodesByTags = function(tagsQuery, forEach) {
        return this._getByTags(this.transformNodes, tagsQuery, forEach);
      };
      Scene2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
        if (opaqueSortCompareFn === void 0) {
          opaqueSortCompareFn = null;
        }
        if (alphaTestSortCompareFn === void 0) {
          alphaTestSortCompareFn = null;
        }
        if (transparentSortCompareFn === void 0) {
          transparentSortCompareFn = null;
        }
        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
      };
      Scene2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
        if (depth === void 0) {
          depth = true;
        }
        if (stencil === void 0) {
          stencil = true;
        }
        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
      };
      Scene2.prototype.getAutoClearDepthStencilSetup = function(index) {
        return this._renderingManager.getAutoClearDepthStencilSetup(index);
      };
      Object.defineProperty(Scene2.prototype, "blockMaterialDirtyMechanism", {
        get: function() {
          return this._blockMaterialDirtyMechanism;
        },
        set: function(value) {
          if (this._blockMaterialDirtyMechanism === value) {
            return;
          }
          this._blockMaterialDirtyMechanism = value;
          if (!value) {
            this.markAllMaterialsAsDirty(63);
          }
        },
        enumerable: false,
        configurable: true
      });
      Scene2.prototype.markAllMaterialsAsDirty = function(flag, predicate) {
        if (this._blockMaterialDirtyMechanism) {
          return;
        }
        for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {
          var material = _a[_i];
          if (predicate && !predicate(material)) {
            continue;
          }
          material.markAsDirty(flag);
        }
      };
      Scene2.prototype._loadFile = function(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
        var _this = this;
        var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
        this._activeRequests.push(request);
        request.onCompleteObservable.add(function(request2) {
          _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
        });
        return request;
      };
      Scene2.prototype._loadFileAsync = function(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._loadFile(fileOrUrl, function(data) {
            resolve(data);
          }, onProgress, useOfflineSupport, useArrayBuffer, function(request, exception) {
            reject(exception);
          }, onOpened);
        });
      };
      Scene2.prototype._requestFile = function(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
        var _this = this;
        var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
        this._activeRequests.push(request);
        request.onCompleteObservable.add(function(request2) {
          _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
        });
        return request;
      };
      Scene2.prototype._requestFileAsync = function(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._requestFile(url, function(data) {
            resolve(data);
          }, onProgress, useOfflineSupport, useArrayBuffer, function(error) {
            reject(error);
          }, onOpened);
        });
      };
      Scene2.prototype._readFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
        var _this = this;
        var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
        this._activeRequests.push(request);
        request.onCompleteObservable.add(function(request2) {
          _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
        });
        return request;
      };
      Scene2.prototype._readFileAsync = function(file, onProgress, useArrayBuffer) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._readFile(file, function(data) {
            resolve(data);
          }, onProgress, useArrayBuffer, function(error) {
            reject(error);
          });
        });
      };
      Scene2.prototype.getPerfCollector = function() {
        throw _WarnImport("performanceViewerSceneExtension");
      };
      Scene2.FOGMODE_NONE = 0;
      Scene2.FOGMODE_EXP = 1;
      Scene2.FOGMODE_EXP2 = 2;
      Scene2.FOGMODE_LINEAR = 3;
      Scene2.MinDeltaTime = 1;
      Scene2.MaxDeltaTime = 1e3;
      return Scene2;
    }(AbstractScene);
    Scene.prototype.setActiveCameraByID = function(id) {
      return this.setActiveCameraById(id);
    };
    Scene.prototype.getLastMaterialByID = function(id) {
      return this.getLastMaterialById(id);
    };
    Scene.prototype.getMaterialByID = function(id) {
      return this.getMaterialById(id);
    };
    Scene.prototype.getTextureByUniqueID = function(uniqueId) {
      return this.getTextureByUniqueId(uniqueId);
    };
    Scene.prototype.getCameraByID = function(id) {
      return this.getCameraById(id);
    };
    Scene.prototype.getCameraByUniqueID = function(uniqueId) {
      return this.getCameraByUniqueId(uniqueId);
    };
    Scene.prototype.getBoneByID = function(id) {
      return this.getBoneById(id);
    };
    Scene.prototype.getLightByID = function(id) {
      return this.getLightById(id);
    };
    Scene.prototype.getLightByUniqueID = function(uniqueId) {
      return this.getLightByUniqueId(uniqueId);
    };
    Scene.prototype.getParticleSystemByID = function(id) {
      return this.getParticleSystemById(id);
    };
    Scene.prototype.getGeometryByID = function(id) {
      return this.getGeometryById(id);
    };
    Scene.prototype.getMeshByID = function(id) {
      return this.getMeshById(id);
    };
    Scene.prototype.getMeshesByID = function(id) {
      return this.getMeshesById(id);
    };
    Scene.prototype.getTransformNodeByID = function(id) {
      return this.getTransformNodeById(id);
    };
    Scene.prototype.getTransformNodeByUniqueID = function(uniqueId) {
      return this.getTransformNodeByUniqueId(uniqueId);
    };
    Scene.prototype.getTransformNodesByID = function(id) {
      return this.getTransformNodesById(id);
    };
    Scene.prototype.getMeshByUniqueID = function(uniqueId) {
      return this.getMeshByUniqueId(uniqueId);
    };
    Scene.prototype.getLastMeshByID = function(id) {
      return this.getLastMeshById(id);
    };
    Scene.prototype.getLastEntryByID = function(id) {
      return this.getLastEntryById(id);
    };
    Scene.prototype.getNodeByID = function(id) {
      return this.getNodeById(id);
    };
    Scene.prototype.getLastSkeletonByID = function(id) {
      return this.getLastSkeletonById(id);
    };
  }
});

// node_modules/@babylonjs/core/Misc/performanceMonitor.js
var PerformanceMonitor, RollingAverage;
var init_performanceMonitor = __esm({
  "node_modules/@babylonjs/core/Misc/performanceMonitor.js"() {
    init_precisionDate();
    PerformanceMonitor = function() {
      function PerformanceMonitor2(frameSampleSize) {
        if (frameSampleSize === void 0) {
          frameSampleSize = 30;
        }
        this._enabled = true;
        this._rollingFrameTime = new RollingAverage(frameSampleSize);
      }
      PerformanceMonitor2.prototype.sampleFrame = function(timeMs) {
        if (timeMs === void 0) {
          timeMs = PrecisionDate.Now;
        }
        if (!this._enabled) {
          return;
        }
        if (this._lastFrameTimeMs != null) {
          var dt = timeMs - this._lastFrameTimeMs;
          this._rollingFrameTime.add(dt);
        }
        this._lastFrameTimeMs = timeMs;
      };
      Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTime", {
        get: function() {
          return this._rollingFrameTime.average;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTimeVariance", {
        get: function() {
          return this._rollingFrameTime.variance;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFrameTime", {
        get: function() {
          return this._rollingFrameTime.history(0);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerformanceMonitor2.prototype, "averageFPS", {
        get: function() {
          return 1e3 / this._rollingFrameTime.average;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFPS", {
        get: function() {
          var history = this._rollingFrameTime.history(0);
          if (history === 0) {
            return 0;
          }
          return 1e3 / history;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PerformanceMonitor2.prototype, "isSaturated", {
        get: function() {
          return this._rollingFrameTime.isSaturated();
        },
        enumerable: false,
        configurable: true
      });
      PerformanceMonitor2.prototype.enable = function() {
        this._enabled = true;
      };
      PerformanceMonitor2.prototype.disable = function() {
        this._enabled = false;
        this._lastFrameTimeMs = null;
      };
      Object.defineProperty(PerformanceMonitor2.prototype, "isEnabled", {
        get: function() {
          return this._enabled;
        },
        enumerable: false,
        configurable: true
      });
      PerformanceMonitor2.prototype.reset = function() {
        this._lastFrameTimeMs = null;
        this._rollingFrameTime.reset();
      };
      return PerformanceMonitor2;
    }();
    RollingAverage = function() {
      function RollingAverage2(length) {
        this._samples = new Array(length);
        this.reset();
      }
      RollingAverage2.prototype.add = function(v) {
        var delta;
        if (this.isSaturated()) {
          var bottomValue = this._samples[this._pos];
          delta = bottomValue - this.average;
          this.average -= delta / (this._sampleCount - 1);
          this._m2 -= delta * (bottomValue - this.average);
        } else {
          this._sampleCount++;
        }
        delta = v - this.average;
        this.average += delta / this._sampleCount;
        this._m2 += delta * (v - this.average);
        this.variance = this._m2 / (this._sampleCount - 1);
        this._samples[this._pos] = v;
        this._pos++;
        this._pos %= this._samples.length;
      };
      RollingAverage2.prototype.history = function(i) {
        if (i >= this._sampleCount || i >= this._samples.length) {
          return 0;
        }
        var i0 = this._wrapPosition(this._pos - 1);
        return this._samples[this._wrapPosition(i0 - i)];
      };
      RollingAverage2.prototype.isSaturated = function() {
        return this._sampleCount >= this._samples.length;
      };
      RollingAverage2.prototype.reset = function() {
        this.average = 0;
        this.variance = 0;
        this._sampleCount = 0;
        this._pos = 0;
        this._m2 = 0;
      };
      RollingAverage2.prototype._wrapPosition = function(i) {
        var max = this._samples.length;
        return (i % max + max) % max;
      };
      return RollingAverage2;
    }();
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes, copyBuffer) {
  if (sizeInBytes === void 0) {
    sizeInBytes = false;
  }
  switch (type) {
    case 3: {
      var buffer_1 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_1.set(new Int8Array(copyBuffer));
      }
      return buffer_1;
    }
    case 0: {
      var buffer_2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_2.set(new Uint8Array(copyBuffer));
      }
      return buffer_2;
    }
    case 4: {
      var buffer_3 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_3.set(new Int16Array(copyBuffer));
      }
      return buffer_3;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      var buffer_4 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_4.set(new Uint16Array(copyBuffer));
      }
      return buffer_4;
    }
    case 6: {
      var buffer_5 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_5.set(new Int32Array(copyBuffer));
      }
      return buffer_5;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      var buffer_6 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_6.set(new Uint32Array(copyBuffer));
      }
      return buffer_6;
    }
    case 1: {
      var buffer_7 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_7.set(new Float32Array(copyBuffer));
      }
      return buffer_7;
    }
  }
  var buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
var init_engine_readTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js"() {
    init_thinEngine();
    ThinEngine.prototype._readTexturePixelsSync = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y) {
      var _a, _b;
      if (faceIndex === void 0) {
        faceIndex = -1;
      }
      if (level === void 0) {
        level = 0;
      }
      if (buffer === void 0) {
        buffer = null;
      }
      if (flushRenderer === void 0) {
        flushRenderer = true;
      }
      if (noDataConversion === void 0) {
        noDataConversion = false;
      }
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      var gl = this._gl;
      if (!gl) {
        throw new Error("Engine does not have gl rendering context.");
      }
      if (!this._dummyFramebuffer) {
        var dummy = gl.createFramebuffer();
        if (!dummy) {
          throw new Error("Unable to create dummy framebuffer");
        }
        this._dummyFramebuffer = dummy;
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
      if (faceIndex > -1) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);
      }
      var readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
      if (!noDataConversion) {
        switch (readType) {
          case gl.UNSIGNED_BYTE:
            if (!buffer) {
              buffer = new Uint8Array(4 * width * height);
            }
            readType = gl.UNSIGNED_BYTE;
            break;
          default:
            if (!buffer) {
              buffer = new Float32Array(4 * width * height);
            }
            readType = gl.FLOAT;
            break;
        }
      } else if (!buffer) {
        buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);
      }
      if (flushRenderer) {
        this.flushFramebuffer();
      }
      gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
      return buffer;
    };
    ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y) {
      if (faceIndex === void 0) {
        faceIndex = -1;
      }
      if (level === void 0) {
        level = 0;
      }
      if (buffer === void 0) {
        buffer = null;
      }
      if (flushRenderer === void 0) {
        flushRenderer = true;
      }
      if (noDataConversion === void 0) {
        noDataConversion = false;
      }
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js
var init_engine_alpha = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js"() {
    init_thinEngine();
    ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
      this._alphaState.setAlphaBlendConstants(r, g, b, a);
    };
    ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
      if (noDepthWriteChange === void 0) {
        noDepthWriteChange = false;
      }
      if (this._alphaMode === mode) {
        return;
      }
      switch (mode) {
        case 0:
          this._alphaState.alphaBlend = false;
          break;
        case 7:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 8:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 2:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 6:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 1:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 3:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 4:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 5:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 9:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 10:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 11:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 12:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 13:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 14:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 15:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 16:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 17:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
      }
      if (!noDepthWriteChange) {
        this.depthCullingState.depthMask = mode === 0;
      }
      this._alphaMode = mode;
    };
    ThinEngine.prototype.getAlphaMode = function() {
      return this._alphaMode;
    };
    ThinEngine.prototype.setAlphaEquation = function(equation) {
      if (this._alphaEquation === equation) {
        return;
      }
      switch (equation) {
        case 0:
          this._alphaState.setAlphaEquationParameters(32774, 32774);
          break;
        case 1:
          this._alphaState.setAlphaEquationParameters(32778, 32778);
          break;
        case 2:
          this._alphaState.setAlphaEquationParameters(32779, 32779);
          break;
        case 3:
          this._alphaState.setAlphaEquationParameters(32776, 32776);
          break;
        case 4:
          this._alphaState.setAlphaEquationParameters(32775, 32775);
          break;
        case 5:
          this._alphaState.setAlphaEquationParameters(32775, 32774);
          break;
      }
      this._alphaEquation = equation;
    };
    ThinEngine.prototype.getAlphaEquation = function() {
      return this._alphaEquation;
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js
var init_engine_dynamicBuffer = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js"() {
    init_thinEngine();
    ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
      this.bindIndexBuffer(indexBuffer);
      var arrayBuffer;
      if (indices instanceof Uint16Array || indices instanceof Uint32Array) {
        arrayBuffer = indices;
      } else {
        arrayBuffer = indexBuffer.is32Bits ? new Uint32Array(indices) : new Uint16Array(indices);
      }
      this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.DYNAMIC_DRAW);
      this._resetIndexBufferBinding();
    };
    ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
      this.bindArrayBuffer(vertexBuffer);
      if (byteOffset === void 0) {
        byteOffset = 0;
      }
      var dataLength = data.byteLength || data.length;
      if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
        } else {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
      } else {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
        } else {
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data, byteOffset, byteLength);
          } else {
            data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
          }
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
        }
      }
      this._resetVertexBufferBinding();
    };
  }
});

// node_modules/@babylonjs/core/Engines/engine.js
var Engine;
var init_engine = __esm({
  "node_modules/@babylonjs/core/Engines/engine.js"() {
    init_tslib_es6();
    init_observable();
    init_internalTexture();
    init_domManagement();
    init_engineStore();
    init_devTools();
    init_thinEngine();
    init_performanceMonitor();
    init_perfCounter();
    init_webGLDataBuffer();
    init_logger();
    init_webGLHardwareTexture();
    init_engine_alpha();
    init_engine_readTexture();
    init_engine_dynamicBuffer();
    Engine = function(_super) {
      __extends(Engine2, _super);
      function Engine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
        if (adaptToDeviceRatio === void 0) {
          adaptToDeviceRatio = false;
        }
        var _this = _super.call(this, canvasOrContext, antialias, options, adaptToDeviceRatio) || this;
        _this.enableOfflineSupport = false;
        _this.disableManifestCheck = false;
        _this.scenes = new Array();
        _this._virtualScenes = new Array();
        _this.onNewSceneAddedObservable = new Observable();
        _this.postProcesses = new Array();
        _this.isPointerLock = false;
        _this.onResizeObservable = new Observable();
        _this.onCanvasBlurObservable = new Observable();
        _this.onCanvasFocusObservable = new Observable();
        _this.onCanvasPointerOutObservable = new Observable();
        _this.onBeginFrameObservable = new Observable();
        _this.customAnimationFrameRequester = null;
        _this.onEndFrameObservable = new Observable();
        _this.onBeforeShaderCompilationObservable = new Observable();
        _this.onAfterShaderCompilationObservable = new Observable();
        _this._deterministicLockstep = false;
        _this._lockstepMaxSteps = 4;
        _this._timeStep = 1 / 60;
        _this._fps = 60;
        _this._deltaTime = 0;
        _this._drawCalls = new PerfCounter();
        _this.canvasTabIndex = 1;
        _this.disablePerformanceMonitorInBackground = false;
        _this._performanceMonitor = new PerformanceMonitor();
        _this._compatibilityMode = true;
        _this.currentRenderPassId = 0;
        _this._renderPassNames = ["main"];
        Engine2.Instances.push(_this);
        if (!canvasOrContext) {
          return _this;
        }
        _this._features.supportRenderPasses = true;
        options = _this._creationOptions;
        if (canvasOrContext.getContext) {
          var canvas_1 = canvasOrContext;
          _this._sharedInit(canvas_1, !!options.doNotHandleTouchAction, options.audioEngine);
          if (IsWindowObjectExist()) {
            var anyDoc_1 = document;
            _this._onFullscreenChange = function() {
              if (anyDoc_1.fullscreen !== void 0) {
                _this.isFullscreen = anyDoc_1.fullscreen;
              } else if (anyDoc_1.mozFullScreen !== void 0) {
                _this.isFullscreen = anyDoc_1.mozFullScreen;
              } else if (anyDoc_1.webkitIsFullScreen !== void 0) {
                _this.isFullscreen = anyDoc_1.webkitIsFullScreen;
              } else if (anyDoc_1.msIsFullScreen !== void 0) {
                _this.isFullscreen = anyDoc_1.msIsFullScreen;
              }
              if (_this.isFullscreen && _this._pointerLockRequested && canvas_1) {
                Engine2._RequestPointerlock(canvas_1);
              }
            };
            document.addEventListener("fullscreenchange", _this._onFullscreenChange, false);
            document.addEventListener("mozfullscreenchange", _this._onFullscreenChange, false);
            document.addEventListener("webkitfullscreenchange", _this._onFullscreenChange, false);
            document.addEventListener("msfullscreenchange", _this._onFullscreenChange, false);
            _this._onPointerLockChange = function() {
              _this.isPointerLock = anyDoc_1.mozPointerLockElement === canvas_1 || anyDoc_1.webkitPointerLockElement === canvas_1 || anyDoc_1.msPointerLockElement === canvas_1 || anyDoc_1.pointerLockElement === canvas_1;
            };
            document.addEventListener("pointerlockchange", _this._onPointerLockChange, false);
            document.addEventListener("mspointerlockchange", _this._onPointerLockChange, false);
            document.addEventListener("mozpointerlockchange", _this._onPointerLockChange, false);
            document.addEventListener("webkitpointerlockchange", _this._onPointerLockChange, false);
            if (!Engine2.audioEngine && options.audioEngine && Engine2.AudioEngineFactory) {
              Engine2.audioEngine = Engine2.AudioEngineFactory(_this.getRenderingCanvas(), _this.getAudioContext(), _this.getAudioDestination());
            }
          }
          _this._connectVREvents();
          _this.enableOfflineSupport = Engine2.OfflineProviderFactory !== void 0;
          _this._deterministicLockstep = !!options.deterministicLockstep;
          _this._lockstepMaxSteps = options.lockstepMaxSteps || 0;
          _this._timeStep = options.timeStep || 1 / 60;
        }
        _this._prepareVRComponent();
        if (options.autoEnableWebVR) {
          _this.initWebVR();
        }
        return _this;
      }
      Object.defineProperty(Engine2, "NpmPackage", {
        get: function() {
          return ThinEngine.NpmPackage;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2, "Version", {
        get: function() {
          return ThinEngine.Version;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2, "Instances", {
        get: function() {
          return EngineStore.Instances;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2, "LastCreatedEngine", {
        get: function() {
          return EngineStore.LastCreatedEngine;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2, "LastCreatedScene", {
        get: function() {
          return EngineStore.LastCreatedScene;
        },
        enumerable: false,
        configurable: true
      });
      Engine2.prototype._createImageBitmapFromSource = function(imageSource, options) {
        var _this = this;
        var promise = new Promise(function(resolve, reject) {
          var image = new Image();
          image.onload = function() {
            image.decode().then(function() {
              _this.createImageBitmap(image, options).then(function(imageBitmap) {
                resolve(imageBitmap);
              });
            });
          };
          image.onerror = function() {
            reject("Error loading image ".concat(image.src));
          };
          image.src = imageSource;
        });
        return promise;
      };
      Engine2.prototype.createImageBitmap = function(image, options) {
        return createImageBitmap(image, options);
      };
      Engine2.prototype.resizeImageBitmap = function(image, bufferWidth, bufferHeight) {
        var canvas = this.createCanvas(bufferWidth, bufferHeight);
        var context = canvas.getContext("2d");
        if (!context) {
          throw new Error("Unable to get 2d context for resizeImageBitmap");
        }
        context.drawImage(image, 0, 0);
        var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
        return buffer;
      };
      Engine2.MarkAllMaterialsAsDirty = function(flag, predicate) {
        for (var engineIndex = 0; engineIndex < Engine2.Instances.length; engineIndex++) {
          var engine = Engine2.Instances[engineIndex];
          for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
            engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
          }
        }
      };
      Engine2.DefaultLoadingScreenFactory = function(canvas) {
        throw _WarnImport("LoadingScreen");
      };
      Object.defineProperty(Engine2.prototype, "_supportsHardwareTextureRescaling", {
        get: function() {
          return !!Engine2._RescalePostProcessFactory;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2.prototype, "performanceMonitor", {
        get: function() {
          return this._performanceMonitor;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2.prototype, "compatibilityMode", {
        get: function() {
          return this._compatibilityMode;
        },
        set: function(mode) {
          this._compatibilityMode = true;
        },
        enumerable: false,
        configurable: true
      });
      Engine2.prototype.getInputElement = function() {
        return this._renderingCanvas;
      };
      Engine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
        var _this = this;
        _super.prototype._sharedInit.call(this, canvas, doNotHandleTouchAction, audioEngine);
        this._onCanvasFocus = function() {
          _this.onCanvasFocusObservable.notifyObservers(_this);
        };
        this._onCanvasBlur = function() {
          _this.onCanvasBlurObservable.notifyObservers(_this);
        };
        canvas.addEventListener("focus", this._onCanvasFocus);
        canvas.addEventListener("blur", this._onCanvasBlur);
        this._onBlur = function() {
          if (_this.disablePerformanceMonitorInBackground) {
            _this._performanceMonitor.disable();
          }
          _this._windowIsBackground = true;
        };
        this._onFocus = function() {
          if (_this.disablePerformanceMonitorInBackground) {
            _this._performanceMonitor.enable();
          }
          _this._windowIsBackground = false;
        };
        this._onCanvasPointerOut = function(ev) {
          if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
            _this.onCanvasPointerOutObservable.notifyObservers(ev);
          }
        };
        if (IsWindowObjectExist()) {
          var hostWindow = this.getHostWindow();
          if (hostWindow) {
            hostWindow.addEventListener("blur", this._onBlur);
            hostWindow.addEventListener("focus", this._onFocus);
          }
        }
        canvas.addEventListener("pointerout", this._onCanvasPointerOut);
        if (!doNotHandleTouchAction) {
          this._disableTouchAction();
        }
        if (!Engine2.audioEngine && audioEngine && Engine2.AudioEngineFactory) {
          Engine2.audioEngine = Engine2.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
        }
      };
      Engine2.prototype.getAspectRatio = function(viewportOwner, useScreen) {
        if (useScreen === void 0) {
          useScreen = false;
        }
        var viewport = viewportOwner.viewport;
        return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
      };
      Engine2.prototype.getScreenAspectRatio = function() {
        return this.getRenderWidth(true) / this.getRenderHeight(true);
      };
      Engine2.prototype.getRenderingCanvasClientRect = function() {
        if (!this._renderingCanvas) {
          return null;
        }
        return this._renderingCanvas.getBoundingClientRect();
      };
      Engine2.prototype.getInputElementClientRect = function() {
        if (!this._renderingCanvas) {
          return null;
        }
        return this.getInputElement().getBoundingClientRect();
      };
      Engine2.prototype.isDeterministicLockStep = function() {
        return this._deterministicLockstep;
      };
      Engine2.prototype.getLockstepMaxSteps = function() {
        return this._lockstepMaxSteps;
      };
      Engine2.prototype.getTimeStep = function() {
        return this._timeStep * 1e3;
      };
      Engine2.prototype.generateMipMapsForCubemap = function(texture, unbind) {
        if (unbind === void 0) {
          unbind = true;
        }
        if (texture.generateMipMaps) {
          var gl = this._gl;
          this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          if (unbind) {
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
          }
        }
      };
      Engine2.prototype.getDepthBuffer = function() {
        return this._depthCullingState.depthTest;
      };
      Engine2.prototype.setDepthBuffer = function(enable) {
        this._depthCullingState.depthTest = enable;
      };
      Engine2.prototype.getDepthWrite = function() {
        return this._depthCullingState.depthMask;
      };
      Engine2.prototype.setDepthWrite = function(enable) {
        this._depthCullingState.depthMask = enable;
      };
      Engine2.prototype.getStencilBuffer = function() {
        return this._stencilState.stencilTest;
      };
      Engine2.prototype.setStencilBuffer = function(enable) {
        this._stencilState.stencilTest = enable;
      };
      Engine2.prototype.getStencilMask = function() {
        return this._stencilState.stencilMask;
      };
      Engine2.prototype.setStencilMask = function(mask) {
        this._stencilState.stencilMask = mask;
      };
      Engine2.prototype.getStencilFunction = function() {
        return this._stencilState.stencilFunc;
      };
      Engine2.prototype.getStencilFunctionReference = function() {
        return this._stencilState.stencilFuncRef;
      };
      Engine2.prototype.getStencilFunctionMask = function() {
        return this._stencilState.stencilFuncMask;
      };
      Engine2.prototype.setStencilFunction = function(stencilFunc) {
        this._stencilState.stencilFunc = stencilFunc;
      };
      Engine2.prototype.setStencilFunctionReference = function(reference) {
        this._stencilState.stencilFuncRef = reference;
      };
      Engine2.prototype.setStencilFunctionMask = function(mask) {
        this._stencilState.stencilFuncMask = mask;
      };
      Engine2.prototype.getStencilOperationFail = function() {
        return this._stencilState.stencilOpStencilFail;
      };
      Engine2.prototype.getStencilOperationDepthFail = function() {
        return this._stencilState.stencilOpDepthFail;
      };
      Engine2.prototype.getStencilOperationPass = function() {
        return this._stencilState.stencilOpStencilDepthPass;
      };
      Engine2.prototype.setStencilOperationFail = function(operation) {
        this._stencilState.stencilOpStencilFail = operation;
      };
      Engine2.prototype.setStencilOperationDepthFail = function(operation) {
        this._stencilState.stencilOpDepthFail = operation;
      };
      Engine2.prototype.setStencilOperationPass = function(operation) {
        this._stencilState.stencilOpStencilDepthPass = operation;
      };
      Engine2.prototype.setDitheringState = function(value) {
        if (value) {
          this._gl.enable(this._gl.DITHER);
        } else {
          this._gl.disable(this._gl.DITHER);
        }
      };
      Engine2.prototype.setRasterizerState = function(value) {
        if (value) {
          this._gl.disable(this._gl.RASTERIZER_DISCARD);
        } else {
          this._gl.enable(this._gl.RASTERIZER_DISCARD);
        }
      };
      Engine2.prototype.getDepthFunction = function() {
        return this._depthCullingState.depthFunc;
      };
      Engine2.prototype.setDepthFunction = function(depthFunc) {
        this._depthCullingState.depthFunc = depthFunc;
      };
      Engine2.prototype.setDepthFunctionToGreater = function() {
        this.setDepthFunction(516);
      };
      Engine2.prototype.setDepthFunctionToGreaterOrEqual = function() {
        this.setDepthFunction(518);
      };
      Engine2.prototype.setDepthFunctionToLess = function() {
        this.setDepthFunction(513);
      };
      Engine2.prototype.setDepthFunctionToLessOrEqual = function() {
        this.setDepthFunction(515);
      };
      Engine2.prototype.cacheStencilState = function() {
        this._cachedStencilBuffer = this.getStencilBuffer();
        this._cachedStencilFunction = this.getStencilFunction();
        this._cachedStencilMask = this.getStencilMask();
        this._cachedStencilOperationPass = this.getStencilOperationPass();
        this._cachedStencilOperationFail = this.getStencilOperationFail();
        this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
        this._cachedStencilReference = this.getStencilFunctionReference();
      };
      Engine2.prototype.restoreStencilState = function() {
        this.setStencilFunction(this._cachedStencilFunction);
        this.setStencilMask(this._cachedStencilMask);
        this.setStencilBuffer(this._cachedStencilBuffer);
        this.setStencilOperationPass(this._cachedStencilOperationPass);
        this.setStencilOperationFail(this._cachedStencilOperationFail);
        this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
        this.setStencilFunctionReference(this._cachedStencilReference);
      };
      Engine2.prototype.setDirectViewport = function(x, y, width, height) {
        var currentViewport = this._cachedViewport;
        this._cachedViewport = null;
        this._viewport(x, y, width, height);
        return currentViewport;
      };
      Engine2.prototype.scissorClear = function(x, y, width, height, clearColor) {
        this.enableScissor(x, y, width, height);
        this.clear(clearColor, true, true, true);
        this.disableScissor();
      };
      Engine2.prototype.enableScissor = function(x, y, width, height) {
        var gl = this._gl;
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(x, y, width, height);
      };
      Engine2.prototype.disableScissor = function() {
        var gl = this._gl;
        gl.disable(gl.SCISSOR_TEST);
      };
      Engine2.prototype._reportDrawCall = function(numDrawCalls) {
        if (numDrawCalls === void 0) {
          numDrawCalls = 1;
        }
        this._drawCalls.addCount(numDrawCalls, false);
      };
      Engine2.prototype.initWebVR = function() {
        throw _WarnImport("WebVRCamera");
      };
      Engine2.prototype._prepareVRComponent = function() {
      };
      Engine2.prototype._connectVREvents = function(canvas, document2) {
      };
      Engine2.prototype._submitVRFrame = function() {
      };
      Engine2.prototype.disableVR = function() {
      };
      Engine2.prototype.isVRPresenting = function() {
        return false;
      };
      Engine2.prototype._requestVRFrame = function() {
      };
      Engine2.prototype._loadFileAsync = function(url, offlineProvider, useArrayBuffer) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._loadFile(url, function(data) {
            resolve(data);
          }, void 0, offlineProvider, useArrayBuffer, function(request, exception) {
            reject(exception);
          });
        });
      };
      Engine2.prototype.getVertexShaderSource = function(program) {
        var shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
          return null;
        }
        return this._gl.getShaderSource(shaders[0]);
      };
      Engine2.prototype.getFragmentShaderSource = function(program) {
        var shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
          return null;
        }
        return this._gl.getShaderSource(shaders[1]);
      };
      Engine2.prototype.setDepthStencilTexture = function(channel, uniform, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (uniform) {
          this._boundUniforms[channel] = uniform;
        }
        if (!texture || !texture.depthStencilTexture) {
          this._setTexture(channel, null, void 0, void 0, name);
        } else {
          this._setTexture(channel, texture, false, true, name);
        }
      };
      Engine2.prototype.setTextureFromPostProcess = function(channel, postProcess, name) {
        var _a;
        var postProcessInput = null;
        if (postProcess) {
          if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
            postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
          } else if (postProcess._forcedOutputTexture) {
            postProcessInput = postProcess._forcedOutputTexture;
          }
        }
        this._bindTexture(channel, (_a = postProcessInput === null || postProcessInput === void 0 ? void 0 : postProcessInput.texture) !== null && _a !== void 0 ? _a : null, name);
      };
      Engine2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess, name) {
        var _a, _b;
        this._bindTexture(channel, (_b = (_a = postProcess === null || postProcess === void 0 ? void 0 : postProcess._outputTexture) === null || _a === void 0 ? void 0 : _a.texture) !== null && _b !== void 0 ? _b : null, name);
      };
      Engine2.prototype._rebuildBuffers = function() {
        for (var _i = 0, _a = this.scenes; _i < _a.length; _i++) {
          var scene = _a[_i];
          scene.resetCachedMaterial();
          scene._rebuildGeometries();
          scene._rebuildTextures();
        }
        for (var _b = 0, _c = this._virtualScenes; _b < _c.length; _b++) {
          var scene = _c[_b];
          scene.resetCachedMaterial();
          scene._rebuildGeometries();
          scene._rebuildTextures();
        }
        _super.prototype._rebuildBuffers.call(this);
      };
      Engine2.prototype._renderFrame = function() {
        for (var index = 0; index < this._activeRenderLoops.length; index++) {
          var renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
      };
      Engine2.prototype._renderLoop = function() {
        if (!this._contextWasLost) {
          var shouldRender = true;
          if (!this.renderEvenInBackground && this._windowIsBackground) {
            shouldRender = false;
          }
          if (shouldRender) {
            this.beginFrame();
            if (!this._renderViews()) {
              this._renderFrame();
            }
            this.endFrame();
          }
        }
        if (this._activeRenderLoops.length > 0) {
          if (this.customAnimationFrameRequester) {
            this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
            this._frameHandler = this.customAnimationFrameRequester.requestID;
          } else if (this.isVRPresenting()) {
            this._requestVRFrame();
          } else {
            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
          }
        } else {
          this._renderingQueueLaunched = false;
        }
      };
      Engine2.prototype._renderViews = function() {
        return false;
      };
      Engine2.prototype.switchFullscreen = function(requestPointerLock) {
        if (this.isFullscreen) {
          this.exitFullscreen();
        } else {
          this.enterFullscreen(requestPointerLock);
        }
      };
      Engine2.prototype.enterFullscreen = function(requestPointerLock) {
        if (!this.isFullscreen) {
          this._pointerLockRequested = requestPointerLock;
          if (this._renderingCanvas) {
            Engine2._RequestFullscreen(this._renderingCanvas);
          }
        }
      };
      Engine2.prototype.exitFullscreen = function() {
        if (this.isFullscreen) {
          Engine2._ExitFullscreen();
        }
      };
      Engine2.prototype.enterPointerlock = function() {
        if (this._renderingCanvas) {
          Engine2._RequestPointerlock(this._renderingCanvas);
        }
      };
      Engine2.prototype.exitPointerlock = function() {
        Engine2._ExitPointerlock();
      };
      Engine2.prototype.beginFrame = function() {
        this._measureFps();
        this.onBeginFrameObservable.notifyObservers(this);
        _super.prototype.beginFrame.call(this);
      };
      Engine2.prototype.endFrame = function() {
        _super.prototype.endFrame.call(this);
        this._submitVRFrame();
        this.onEndFrameObservable.notifyObservers(this);
      };
      Engine2.prototype.resize = function(forceSetSize) {
        if (forceSetSize === void 0) {
          forceSetSize = false;
        }
        if (this.isVRPresenting()) {
          return;
        }
        _super.prototype.resize.call(this, forceSetSize);
      };
      Engine2.prototype.setSize = function(width, height, forceSetSize) {
        if (forceSetSize === void 0) {
          forceSetSize = false;
        }
        if (!this._renderingCanvas) {
          return false;
        }
        if (!_super.prototype.setSize.call(this, width, height, forceSetSize)) {
          return false;
        }
        if (this.scenes) {
          for (var index = 0; index < this.scenes.length; index++) {
            var scene = this.scenes[index];
            for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
              var cam = scene.cameras[camIndex];
              cam._currentRenderId = 0;
            }
          }
          if (this.onResizeObservable.hasObservers()) {
            this.onResizeObservable.notifyObservers(this);
          }
        }
        return true;
      };
      Engine2.prototype._deletePipelineContext = function(pipelineContext) {
        var webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
          if (webGLPipelineContext.transformFeedback) {
            this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
            webGLPipelineContext.transformFeedback = null;
          }
        }
        _super.prototype._deletePipelineContext.call(this, pipelineContext);
      };
      Engine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) {
          transformFeedbackVaryings = null;
        }
        context = context || this._gl;
        this.onBeforeShaderCompilationObservable.notifyObservers(this);
        var program = _super.prototype.createShaderProgram.call(this, pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
        this.onAfterShaderCompilationObservable.notifyObservers(this);
        return program;
      };
      Engine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) {
          transformFeedbackVaryings = null;
        }
        var shaderProgram = context.createProgram();
        pipelineContext.program = shaderProgram;
        if (!shaderProgram) {
          throw new Error("Unable to create program");
        }
        context.attachShader(shaderProgram, vertexShader);
        context.attachShader(shaderProgram, fragmentShader);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
          var transformFeedback = this.createTransformFeedback();
          this.bindTransformFeedback(transformFeedback);
          this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
          pipelineContext.transformFeedback = transformFeedback;
        }
        context.linkProgram(shaderProgram);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
          this.bindTransformFeedback(null);
        }
        pipelineContext.context = context;
        pipelineContext.vertexShader = vertexShader;
        pipelineContext.fragmentShader = fragmentShader;
        if (!pipelineContext.isParallelCompiled) {
          this._finalizePipelineContext(pipelineContext);
        }
        return shaderProgram;
      };
      Engine2.prototype._releaseTexture = function(texture) {
        _super.prototype._releaseTexture.call(this, texture);
      };
      Engine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
        _super.prototype._releaseRenderTargetWrapper.call(this, rtWrapper);
        this.scenes.forEach(function(scene) {
          scene.postProcesses.forEach(function(postProcess) {
            if (postProcess._outputTexture === rtWrapper) {
              postProcess._outputTexture = null;
            }
          });
          scene.cameras.forEach(function(camera) {
            camera._postProcesses.forEach(function(postProcess) {
              if (postProcess) {
                if (postProcess._outputTexture === rtWrapper) {
                  postProcess._outputTexture = null;
                }
              }
            });
          });
        });
      };
      Engine2.prototype.getRenderPassNames = function() {
        return this._renderPassNames;
      };
      Engine2.prototype.getCurrentRenderPassName = function() {
        return this._renderPassNames[this.currentRenderPassId];
      };
      Engine2.prototype.createRenderPassId = function(name) {
        var id = ++Engine2._RenderPassIdCounter;
        this._renderPassNames[id] = name !== null && name !== void 0 ? name : "NONAME";
        return id;
      };
      Engine2.prototype.releaseRenderPassId = function(id) {
        this._renderPassNames[id] = void 0;
        for (var s = 0; s < this.scenes.length; ++s) {
          var scene = this.scenes[s];
          for (var m = 0; m < scene.meshes.length; ++m) {
            var mesh = scene.meshes[m];
            if (mesh.subMeshes) {
              for (var b = 0; b < mesh.subMeshes.length; ++b) {
                var subMesh = mesh.subMeshes[b];
                subMesh._removeDrawWrapper(id);
              }
            }
          }
        }
      };
      Engine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
        var _this = this;
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        var rtt = this.createRenderTargetTexture({
          width: destination.width,
          height: destination.height
        }, {
          generateMipMaps: false,
          type: 0,
          samplingMode: 2,
          generateDepthBuffer: false,
          generateStencilBuffer: false
        });
        if (!this._rescalePostProcess && Engine2._RescalePostProcessFactory) {
          this._rescalePostProcess = Engine2._RescalePostProcessFactory(this);
        }
        this._rescalePostProcess.externalTextureSamplerBinding = true;
        this._rescalePostProcess.getEffect().executeWhenCompiled(function() {
          _this._rescalePostProcess.onApply = function(effect) {
            effect._bindTexture("textureSampler", source);
          };
          var hostingScene = scene;
          if (!hostingScene) {
            hostingScene = _this.scenes[_this.scenes.length - 1];
          }
          hostingScene.postProcessManager.directRender([_this._rescalePostProcess], rtt, true);
          _this._bindTextureDirectly(_this._gl.TEXTURE_2D, destination, true);
          _this._gl.copyTexImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
          _this.unBindFramebuffer(rtt);
          rtt.dispose();
          if (onComplete) {
            onComplete();
          }
        });
      };
      Engine2.prototype.getFps = function() {
        return this._fps;
      };
      Engine2.prototype.getDeltaTime = function() {
        return this._deltaTime;
      };
      Engine2.prototype._measureFps = function() {
        this._performanceMonitor.sampleFrame();
        this._fps = this._performanceMonitor.averageFPS;
        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
      };
      Engine2.prototype.wrapWebGLTexture = function(texture) {
        var hardwareTexture = new WebGLHardwareTexture(texture, this._gl);
        var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
        internalTexture._hardwareTexture = hardwareTexture;
        internalTexture.isReady = true;
        return internalTexture;
      };
      Engine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (lod === void 0) {
          lod = 0;
        }
        var gl = this._gl;
        var textureType = this._getWebGLTextureType(texture.type);
        var format = this._getInternalFormat(texture.format);
        var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
        var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._unpackFlipY(texture.invertY);
        var target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        gl.texImage2D(target, lod, internalFormat, format, textureType, image);
        this._bindTextureDirectly(bindTarget, null, true);
      };
      Engine2.prototype.updateTextureComparisonFunction = function(texture, comparisonFunction) {
        if (this.webGLVersion === 1) {
          Logger.Error("WebGL 1 does not support texture comparison.");
          return;
        }
        var gl = this._gl;
        if (texture.isCube) {
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
          if (comparisonFunction === 0) {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
          } else {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          }
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        } else {
          this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
          if (comparisonFunction === 0) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
          } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          }
          this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        }
        texture._comparisonFunction = comparisonFunction;
      };
      Engine2.prototype.createInstancesBuffer = function(capacity) {
        var buffer = this._gl.createBuffer();
        if (!buffer) {
          throw new Error("Unable to create instance buffer");
        }
        var result = new WebGLDataBuffer(buffer);
        result.capacity = capacity;
        this.bindArrayBuffer(result);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
        result.references = 1;
        return result;
      };
      Engine2.prototype.deleteInstancesBuffer = function(buffer) {
        this._gl.deleteBuffer(buffer);
      };
      Engine2.prototype._clientWaitAsync = function(sync, flags, intervalms) {
        if (flags === void 0) {
          flags = 0;
        }
        if (intervalms === void 0) {
          intervalms = 10;
        }
        var gl = this._gl;
        return new Promise(function(resolve, reject) {
          var check = function() {
            var res = gl.clientWaitSync(sync, flags, 0);
            if (res == gl.WAIT_FAILED) {
              reject();
              return;
            }
            if (res == gl.TIMEOUT_EXPIRED) {
              setTimeout(check, intervalms);
              return;
            }
            resolve();
          };
          check();
        });
      };
      Engine2.prototype._readPixelsAsync = function(x, y, w, h, format, type, outputBuffer) {
        if (this._webGLVersion < 2) {
          throw new Error("_readPixelsAsync only work on WebGL2+");
        }
        var gl = this._gl;
        var buf = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
        gl.readPixels(x, y, w, h, format, type, 0);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        if (!sync) {
          return null;
        }
        gl.flush();
        return this._clientWaitAsync(sync, 0, 10).then(function() {
          gl.deleteSync(sync);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
          gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          gl.deleteBuffer(buf);
          return outputBuffer;
        });
      };
      Engine2.prototype.dispose = function() {
        this.hideLoadingUI();
        this.onNewSceneAddedObservable.clear();
        while (this.postProcesses.length) {
          this.postProcesses[0].dispose();
        }
        if (this._rescalePostProcess) {
          this._rescalePostProcess.dispose();
        }
        while (this.scenes.length) {
          this.scenes[0].dispose();
        }
        while (this._virtualScenes.length) {
          this._virtualScenes[0].dispose();
        }
        if (Engine2.Instances.length === 1 && Engine2.audioEngine) {
          Engine2.audioEngine.dispose();
          Engine2.audioEngine = null;
        }
        this.disableVR();
        if (IsWindowObjectExist()) {
          window.removeEventListener("blur", this._onBlur);
          window.removeEventListener("focus", this._onFocus);
          if (this._renderingCanvas) {
            this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
            this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
            this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
          }
          if (IsDocumentAvailable()) {
            document.removeEventListener("fullscreenchange", this._onFullscreenChange);
            document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
            document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
            document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
            document.removeEventListener("pointerlockchange", this._onPointerLockChange);
            document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
            document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
            document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
          }
        }
        _super.prototype.dispose.call(this);
        var index = Engine2.Instances.indexOf(this);
        if (index >= 0) {
          Engine2.Instances.splice(index, 1);
        }
        this.onResizeObservable.clear();
        this.onCanvasBlurObservable.clear();
        this.onCanvasFocusObservable.clear();
        this.onCanvasPointerOutObservable.clear();
        this.onBeginFrameObservable.clear();
        this.onEndFrameObservable.clear();
      };
      Engine2.prototype._disableTouchAction = function() {
        if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
          return;
        }
        this._renderingCanvas.setAttribute("touch-action", "none");
        this._renderingCanvas.style.touchAction = "none";
        this._renderingCanvas.style.msTouchAction = "none";
      };
      Engine2.prototype.displayLoadingUI = function() {
        if (!IsWindowObjectExist()) {
          return;
        }
        var loadingScreen = this.loadingScreen;
        if (loadingScreen) {
          loadingScreen.displayLoadingUI();
        }
      };
      Engine2.prototype.hideLoadingUI = function() {
        if (!IsWindowObjectExist()) {
          return;
        }
        var loadingScreen = this._loadingScreen;
        if (loadingScreen) {
          loadingScreen.hideLoadingUI();
        }
      };
      Object.defineProperty(Engine2.prototype, "loadingScreen", {
        get: function() {
          if (!this._loadingScreen && this._renderingCanvas) {
            this._loadingScreen = Engine2.DefaultLoadingScreenFactory(this._renderingCanvas);
          }
          return this._loadingScreen;
        },
        set: function(loadingScreen) {
          this._loadingScreen = loadingScreen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2.prototype, "loadingUIText", {
        set: function(text) {
          this.loadingScreen.loadingUIText = text;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Engine2.prototype, "loadingUIBackgroundColor", {
        set: function(color) {
          this.loadingScreen.loadingUIBackgroundColor = color;
        },
        enumerable: false,
        configurable: true
      });
      Engine2.prototype.createVideoElement = function(constraints) {
        return document.createElement("video");
      };
      Engine2._RequestPointerlock = function(element) {
        element.requestPointerLock = element.requestPointerLock || element.msRequestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        if (element.requestPointerLock) {
          element.requestPointerLock();
          element.focus();
        }
      };
      Engine2._ExitPointerlock = function() {
        var anyDoc = document;
        document.exitPointerLock = document.exitPointerLock || anyDoc.msExitPointerLock || anyDoc.mozExitPointerLock || anyDoc.webkitExitPointerLock;
        if (document.exitPointerLock) {
          document.exitPointerLock();
        }
      };
      Engine2._RequestFullscreen = function(element) {
        var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;
        if (!requestFunction) {
          return;
        }
        requestFunction.call(element);
      };
      Engine2._ExitFullscreen = function() {
        var anyDoc = document;
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (anyDoc.mozCancelFullScreen) {
          anyDoc.mozCancelFullScreen();
        } else if (anyDoc.webkitCancelFullScreen) {
          anyDoc.webkitCancelFullScreen();
        } else if (anyDoc.msCancelFullScreen) {
          anyDoc.msCancelFullScreen();
        }
      };
      Engine2.prototype.getFontOffset = function(font) {
        var text = document.createElement("span");
        text.innerHTML = "Hg";
        text.setAttribute("style", "font: ".concat(font, " !important"));
        var block = document.createElement("div");
        block.style.display = "inline-block";
        block.style.width = "1px";
        block.style.height = "0px";
        block.style.verticalAlign = "bottom";
        var div = document.createElement("div");
        div.style.whiteSpace = "nowrap";
        div.appendChild(text);
        div.appendChild(block);
        document.body.appendChild(div);
        var fontAscent = 0;
        var fontHeight = 0;
        try {
          fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
          block.style.verticalAlign = "baseline";
          fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
        } finally {
          document.body.removeChild(div);
        }
        return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
      };
      Engine2.ALPHA_DISABLE = 0;
      Engine2.ALPHA_ADD = 1;
      Engine2.ALPHA_COMBINE = 2;
      Engine2.ALPHA_SUBTRACT = 3;
      Engine2.ALPHA_MULTIPLY = 4;
      Engine2.ALPHA_MAXIMIZED = 5;
      Engine2.ALPHA_ONEONE = 6;
      Engine2.ALPHA_PREMULTIPLIED = 7;
      Engine2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
      Engine2.ALPHA_INTERPOLATE = 9;
      Engine2.ALPHA_SCREENMODE = 10;
      Engine2.DELAYLOADSTATE_NONE = 0;
      Engine2.DELAYLOADSTATE_LOADED = 1;
      Engine2.DELAYLOADSTATE_LOADING = 2;
      Engine2.DELAYLOADSTATE_NOTLOADED = 4;
      Engine2.NEVER = 512;
      Engine2.ALWAYS = 519;
      Engine2.LESS = 513;
      Engine2.EQUAL = 514;
      Engine2.LEQUAL = 515;
      Engine2.GREATER = 516;
      Engine2.GEQUAL = 518;
      Engine2.NOTEQUAL = 517;
      Engine2.KEEP = 7680;
      Engine2.REPLACE = 7681;
      Engine2.INCR = 7682;
      Engine2.DECR = 7683;
      Engine2.INVERT = 5386;
      Engine2.INCR_WRAP = 34055;
      Engine2.DECR_WRAP = 34056;
      Engine2.TEXTURE_CLAMP_ADDRESSMODE = 0;
      Engine2.TEXTURE_WRAP_ADDRESSMODE = 1;
      Engine2.TEXTURE_MIRROR_ADDRESSMODE = 2;
      Engine2.TEXTUREFORMAT_ALPHA = 0;
      Engine2.TEXTUREFORMAT_LUMINANCE = 1;
      Engine2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
      Engine2.TEXTUREFORMAT_RGB = 4;
      Engine2.TEXTUREFORMAT_RGBA = 5;
      Engine2.TEXTUREFORMAT_RED = 6;
      Engine2.TEXTUREFORMAT_R = 6;
      Engine2.TEXTUREFORMAT_RG = 7;
      Engine2.TEXTUREFORMAT_RED_INTEGER = 8;
      Engine2.TEXTUREFORMAT_R_INTEGER = 8;
      Engine2.TEXTUREFORMAT_RG_INTEGER = 9;
      Engine2.TEXTUREFORMAT_RGB_INTEGER = 10;
      Engine2.TEXTUREFORMAT_RGBA_INTEGER = 11;
      Engine2.TEXTURETYPE_UNSIGNED_BYTE = 0;
      Engine2.TEXTURETYPE_UNSIGNED_INT = 0;
      Engine2.TEXTURETYPE_FLOAT = 1;
      Engine2.TEXTURETYPE_HALF_FLOAT = 2;
      Engine2.TEXTURETYPE_BYTE = 3;
      Engine2.TEXTURETYPE_SHORT = 4;
      Engine2.TEXTURETYPE_UNSIGNED_SHORT = 5;
      Engine2.TEXTURETYPE_INT = 6;
      Engine2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
      Engine2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
      Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
      Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
      Engine2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
      Engine2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
      Engine2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
      Engine2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
      Engine2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
      Engine2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
      Engine2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
      Engine2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
      Engine2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
      Engine2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
      Engine2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
      Engine2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
      Engine2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
      Engine2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
      Engine2.TEXTURE_NEAREST_LINEAR = 7;
      Engine2.TEXTURE_NEAREST_NEAREST = 1;
      Engine2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
      Engine2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
      Engine2.TEXTURE_LINEAR_LINEAR = 2;
      Engine2.TEXTURE_LINEAR_NEAREST = 12;
      Engine2.TEXTURE_EXPLICIT_MODE = 0;
      Engine2.TEXTURE_SPHERICAL_MODE = 1;
      Engine2.TEXTURE_PLANAR_MODE = 2;
      Engine2.TEXTURE_CUBIC_MODE = 3;
      Engine2.TEXTURE_PROJECTION_MODE = 4;
      Engine2.TEXTURE_SKYBOX_MODE = 5;
      Engine2.TEXTURE_INVCUBIC_MODE = 6;
      Engine2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
      Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
      Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
      Engine2.SCALEMODE_FLOOR = 1;
      Engine2.SCALEMODE_NEAREST = 2;
      Engine2.SCALEMODE_CEILING = 3;
      Engine2._RescalePostProcessFactory = null;
      Engine2._RenderPassIdCounter = 0;
      return Engine2;
    }(ThinEngine);
  }
});

export {
  __esm,
  __commonJS,
  __export,
  __toCommonJS,
  AbstractScene,
  init_abstractScene,
  AbstractActionManager,
  init_abstractActionManager,
  EventState,
  Observer,
  MultiObserver,
  Observable,
  init_observable,
  Scalar,
  init_math_scalar,
  ToGammaSpace,
  ToLinearSpace,
  PHI,
  Epsilon,
  init_math_constants,
  ArrayTools,
  init_arrayTools,
  RegisterClass,
  GetClass,
  init_typeStore,
  PerformanceConfigurator,
  init_performanceConfigurator,
  EngineStore,
  init_engineStore,
  Vector2,
  Vector3,
  Vector4,
  Quaternion,
  Matrix,
  TmpVectors,
  init_math_vector,
  Color3,
  Color4,
  TmpColors,
  init_math_color,
  ActionEvent,
  init_actionEvent,
  __extends,
  __assign,
  __decorate,
  __awaiter,
  __generator,
  __spreadArray,
  init_tslib_es6,
  Logger,
  init_logger,
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber,
  StringTools,
  init_stringTools,
  DeepCopier,
  init_deepCopier,
  AndOrNotEvaluator,
  init_andOrNotEvaluator,
  Tags,
  init_tags,
  _WarnImport,
  init_devTools,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  SerializationHelper,
  nativeOverride,
  init_decorators,
  WebRequest,
  init_webRequest,
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent,
  DomManagement,
  init_domManagement,
  PrecisionDate,
  init_precisionDate,
  FilesInputStore,
  init_filesInputStore,
  RetryStrategy,
  init_retryStrategy,
  BaseError,
  ErrorCodes,
  RuntimeError,
  init_error,
  ShaderLanguage,
  init_shaderLanguage,
  ShaderProcessor,
  init_shaderProcessor,
  ShaderStore,
  init_shaderStore,
  Effect,
  init_effect,
  DepthCullingState,
  init_depthCullingState,
  StencilState,
  init_stencilState,
  AlphaState,
  init_alphaCullingState,
  TextureSampler,
  init_textureSampler,
  InternalTextureSource,
  InternalTexture,
  init_internalTexture,
  WebGL2ShaderProcessor,
  init_webGL2ShaderProcessors,
  DataBuffer,
  init_dataBuffer,
  WebGLDataBuffer,
  init_webGLDataBuffer,
  WebGLPipelineContext,
  init_webGLPipelineContext,
  WebGLHardwareTexture,
  init_webGLHardwareTexture,
  DrawWrapper,
  init_drawWrapper,
  StencilStateComposer,
  init_stencilStateComposer,
  ThinEngine,
  init_thinEngine,
  TimingTools,
  init_timingTools,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileToolsOptions,
  SetCorsBehavior,
  LoadImage,
  ReadFile,
  LoadFile,
  RequestFile,
  IsFileURL,
  IsBase64DataUrl,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  FileTools,
  _injectLTSFileTools,
  init_fileTools,
  PromisePolyfill,
  init_promise,
  InstantiationTools,
  init_instantiationTools,
  RandomGUID,
  GUID,
  init_guid,
  Tools,
  className,
  AsyncLoop,
  init_tools,
  SmartArray,
  SmartArrayNoDuplicate,
  init_smartArray,
  StringDictionary,
  init_stringDictionary,
  MaterialDefines,
  init_materialDefines,
  ColorCurves,
  init_colorCurves,
  ImageProcessingConfigurationDefines,
  ImageProcessingConfiguration,
  init_imageProcessingConfiguration,
  init_engine_uniformBuffer,
  UniformBuffer,
  init_uniformBuffer,
  Buffer2 as Buffer,
  VertexBuffer,
  init_buffer,
  PickingInfo,
  init_pickingInfo,
  PostProcessManager,
  init_postProcessManager,
  RenderingGroup,
  init_renderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  init_renderingManager,
  SceneComponentConstants,
  Stage,
  init_sceneComponent,
  PointerEventTypes,
  PointerInfoBase,
  PointerInfoPre,
  PointerInfo,
  init_pointerEvents,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  init_keyboardEvents,
  DeviceType,
  PointerInput,
  NativePointerInput,
  DualShockInput,
  DualSenseInput,
  XboxInput,
  SwitchInput,
  init_deviceEnums,
  DeviceInputEventType,
  EventConstants,
  init_deviceInputEvents,
  DeviceSource,
  init_deviceSource,
  DeviceSourceManager,
  init_deviceSourceManager,
  PerfCounter,
  init_perfCounter,
  Plane,
  init_math_plane,
  Frustum,
  init_math_frustum,
  UniqueIdGenerator,
  init_uniqueIdGenerator,
  LightConstants,
  init_lightConstants,
  ComputePressureObserverWrapper,
  init_computePressure,
  Scene,
  init_scene,
  PerformanceMonitor,
  RollingAverage,
  init_performanceMonitor,
  init_engine_alpha,
  allocateAndCopyTypedBuffer,
  init_engine_readTexture,
  init_engine_dynamicBuffer,
  Engine,
  init_engine
};
//# sourceMappingURL=chunk-VALTYTUV.js.map

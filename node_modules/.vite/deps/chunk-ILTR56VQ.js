import {
  AbstractScene,
  ArrayTools,
  AsyncLoop,
  Buffer,
  Color3,
  Color4,
  Decode,
  DeepCopier,
  DrawWrapper,
  EncodeArrayBufferToBase64,
  Engine,
  EngineStore,
  Epsilon,
  ErrorCodes,
  EventConstants,
  Frustum,
  GetClass,
  ImageProcessingConfiguration,
  InstantiationTools,
  InternalTexture,
  InternalTextureSource,
  IsBase64DataUrl,
  KeyboardEventTypes,
  LightConstants,
  LoadImage,
  Logger,
  MaterialDefines,
  Matrix,
  Observable,
  PickingInfo,
  Plane,
  PointerEventTypes,
  PostProcessManager,
  Quaternion,
  RandomGUID,
  RegisterClass,
  RenderingManager,
  RuntimeError,
  Scalar,
  Scene,
  SceneComponentConstants,
  SerializationHelper,
  ShaderStore,
  SmartArray,
  StartsWith,
  Tags,
  ThinEngine,
  TimingTools,
  TmpColors,
  TmpVectors,
  ToLinearSpace,
  Tools,
  UniformBuffer,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  WebRequest,
  _WarnImport,
  __assign,
  __awaiter,
  __decorate,
  __esm,
  __extends,
  __generator,
  expandToProperty,
  init_abstractScene,
  init_arrayTools,
  init_buffer,
  init_decorators,
  init_deepCopier,
  init_devTools,
  init_deviceInputEvents,
  init_drawWrapper,
  init_engine,
  init_engineStore,
  init_engine_readTexture,
  init_error,
  init_fileTools,
  init_guid,
  init_imageProcessingConfiguration,
  init_instantiationTools,
  init_internalTexture,
  init_keyboardEvents,
  init_lightConstants,
  init_logger,
  init_materialDefines,
  init_math_color,
  init_math_constants,
  init_math_frustum,
  init_math_plane,
  init_math_scalar,
  init_math_vector,
  init_observable,
  init_pickingInfo,
  init_pointerEvents,
  init_postProcessManager,
  init_renderingManager,
  init_scene,
  init_sceneComponent,
  init_shaderStore,
  init_smartArray,
  init_stringTools,
  init_tags,
  init_thinEngine,
  init_timingTools,
  init_tools,
  init_tslib_es6,
  init_typeStore,
  init_uniformBuffer,
  init_webRequest,
  nativeOverride,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-VALTYTUV.js";

// node_modules/@babylonjs/core/Animations/animationKey.js
var AnimationKeyInterpolation;
var init_animationKey = __esm({
  "node_modules/@babylonjs/core/Animations/animationKey.js"() {
    (function(AnimationKeyInterpolation2) {
      AnimationKeyInterpolation2[AnimationKeyInterpolation2["NONE"] = 0] = "NONE";
      AnimationKeyInterpolation2[AnimationKeyInterpolation2["STEP"] = 1] = "STEP";
    })(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));
  }
});

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange;
var init_animationRange = __esm({
  "node_modules/@babylonjs/core/Animations/animationRange.js"() {
    AnimationRange = function() {
      function AnimationRange2(name105, from, to) {
        this.name = name105;
        this.from = from;
        this.to = to;
      }
      AnimationRange2.prototype.clone = function() {
        return new AnimationRange2(this.name, this.from, this.to);
      };
      return AnimationRange2;
    }();
  }
});

// node_modules/@babylonjs/core/node.js
var _InternalNodeDataInfo, Node;
var init_node = __esm({
  "node_modules/@babylonjs/core/node.js"() {
    init_tslib_es6();
    init_math_vector();
    init_decorators();
    init_observable();
    init_engineStore();
    init_devTools();
    _InternalNodeDataInfo = function() {
      function _InternalNodeDataInfo2() {
        this._doNotSerialize = false;
        this._isDisposed = false;
        this._sceneRootNodesIndex = -1;
        this._isEnabled = true;
        this._isParentEnabled = true;
        this._isReady = true;
        this._onEnabledStateChangedObservable = new Observable();
        this._onClonedObservable = new Observable();
      }
      return _InternalNodeDataInfo2;
    }();
    Node = function() {
      function Node2(name105, scene) {
        if (scene === void 0) {
          scene = null;
        }
        this._isDirty = false;
        this._nodeDataStorage = new _InternalNodeDataInfo();
        this.state = "";
        this.metadata = null;
        this.reservedDataStore = null;
        this._parentContainer = null;
        this.animations = new Array();
        this._ranges = {};
        this.onReady = null;
        this._currentRenderId = -1;
        this._parentUpdateId = -1;
        this._childUpdateId = -1;
        this._waitingParentId = null;
        this._cache = {};
        this._parentNode = null;
        this._children = null;
        this._worldMatrix = Matrix.Identity();
        this._worldMatrixDeterminant = 0;
        this._worldMatrixDeterminantIsDirty = true;
        this._animationPropertiesOverride = null;
        this._isNode = true;
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this._behaviors = new Array();
        this.name = name105;
        this.id = name105;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.uniqueId = this._scene.getUniqueId();
        this._initCache();
      }
      Node2.AddNodeConstructor = function(type, constructorFunc) {
        this._NodeConstructors[type] = constructorFunc;
      };
      Node2.Construct = function(type, name105, scene, options) {
        var constructorFunc = this._NodeConstructors[type];
        if (!constructorFunc) {
          return null;
        }
        return constructorFunc(name105, scene, options);
      };
      Object.defineProperty(Node2.prototype, "doNotSerialize", {
        get: function() {
          if (this._nodeDataStorage._doNotSerialize) {
            return true;
          }
          if (this._parentNode) {
            return this._parentNode.doNotSerialize;
          }
          return false;
        },
        set: function(value) {
          this._nodeDataStorage._doNotSerialize = value;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.isDisposed = function() {
        return this._nodeDataStorage._isDisposed;
      };
      Object.defineProperty(Node2.prototype, "parent", {
        get: function() {
          return this._parentNode;
        },
        set: function(parent) {
          if (this._parentNode === parent) {
            return;
          }
          var previousParentNode = this._parentNode;
          if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
            var index = this._parentNode._children.indexOf(this);
            if (index !== -1) {
              this._parentNode._children.splice(index, 1);
            }
            if (!parent && !this._nodeDataStorage._isDisposed) {
              this._addToSceneRootNodes();
            }
          }
          this._parentNode = parent;
          if (this._parentNode) {
            if (this._parentNode._children === void 0 || this._parentNode._children === null) {
              this._parentNode._children = new Array();
            }
            this._parentNode._children.push(this);
            if (!previousParentNode) {
              this._removeFromSceneRootNodes();
            }
          }
          this._syncParentEnabledState();
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype._addToSceneRootNodes = function() {
        if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
          this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
          this._scene.rootNodes.push(this);
        }
      };
      Node2.prototype._removeFromSceneRootNodes = function() {
        if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
          var rootNodes = this._scene.rootNodes;
          var lastIdx = rootNodes.length - 1;
          rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
          rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
          this._scene.rootNodes.pop();
          this._nodeDataStorage._sceneRootNodesIndex = -1;
        }
      };
      Object.defineProperty(Node2.prototype, "animationPropertiesOverride", {
        get: function() {
          if (!this._animationPropertiesOverride) {
            return this._scene.animationPropertiesOverride;
          }
          return this._animationPropertiesOverride;
        },
        set: function(value) {
          this._animationPropertiesOverride = value;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.getClassName = function() {
        return "Node";
      };
      Object.defineProperty(Node2.prototype, "onDispose", {
        set: function(callback) {
          if (this._onDisposeObserver) {
            this.onDisposeObservable.remove(this._onDisposeObserver);
          }
          this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "onEnabledStateChangedObservable", {
        get: function() {
          return this._nodeDataStorage._onEnabledStateChangedObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "onClonedObservable", {
        get: function() {
          return this._nodeDataStorage._onClonedObservable;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.getScene = function() {
        return this._scene;
      };
      Node2.prototype.getEngine = function() {
        return this._scene.getEngine();
      };
      Node2.prototype.addBehavior = function(behavior, attachImmediately) {
        var _this = this;
        if (attachImmediately === void 0) {
          attachImmediately = false;
        }
        var index = this._behaviors.indexOf(behavior);
        if (index !== -1) {
          return this;
        }
        behavior.init();
        if (this._scene.isLoading && !attachImmediately) {
          this._scene.onDataLoadedObservable.addOnce(function() {
            behavior.attach(_this);
          });
        } else {
          behavior.attach(this);
        }
        this._behaviors.push(behavior);
        return this;
      };
      Node2.prototype.removeBehavior = function(behavior) {
        var index = this._behaviors.indexOf(behavior);
        if (index === -1) {
          return this;
        }
        this._behaviors[index].detach();
        this._behaviors.splice(index, 1);
        return this;
      };
      Object.defineProperty(Node2.prototype, "behaviors", {
        get: function() {
          return this._behaviors;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.getBehaviorByName = function(name105) {
        for (var _i = 0, _a = this._behaviors; _i < _a.length; _i++) {
          var behavior = _a[_i];
          if (behavior.name === name105) {
            return behavior;
          }
        }
        return null;
      };
      Node2.prototype.getWorldMatrix = function() {
        if (this._currentRenderId !== this._scene.getRenderId()) {
          this.computeWorldMatrix();
        }
        return this._worldMatrix;
      };
      Node2.prototype._getWorldMatrixDeterminant = function() {
        if (this._worldMatrixDeterminantIsDirty) {
          this._worldMatrixDeterminantIsDirty = false;
          this._worldMatrixDeterminant = this._worldMatrix.determinant();
        }
        return this._worldMatrixDeterminant;
      };
      Object.defineProperty(Node2.prototype, "worldMatrixFromCache", {
        get: function() {
          return this._worldMatrix;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype._initCache = function() {
        this._cache = {};
        this._cache.parent = void 0;
      };
      Node2.prototype.updateCache = function(force) {
        if (!force && this.isSynchronized()) {
          return;
        }
        this._cache.parent = this.parent;
        this._updateCache();
      };
      Node2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
        if (initialCall === void 0) {
          initialCall = true;
        }
        if (!this.parent) {
          return null;
        }
        return this.parent._getActionManagerForTrigger(trigger, false);
      };
      Node2.prototype._updateCache = function(ignoreParentClass) {
      };
      Node2.prototype._isSynchronized = function() {
        return true;
      };
      Node2.prototype._markSyncedWithParent = function() {
        if (this._parentNode) {
          this._parentUpdateId = this._parentNode._childUpdateId;
        }
      };
      Node2.prototype.isSynchronizedWithParent = function() {
        if (!this._parentNode) {
          return true;
        }
        if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
          return false;
        }
        return this._parentNode.isSynchronized();
      };
      Node2.prototype.isSynchronized = function() {
        if (this._cache.parent !== this._parentNode) {
          this._cache.parent = this._parentNode;
          return false;
        }
        if (this._parentNode && !this.isSynchronizedWithParent()) {
          return false;
        }
        return this._isSynchronized();
      };
      Node2.prototype.isReady = function(completeCheck) {
        if (completeCheck === void 0) {
          completeCheck = false;
        }
        return this._nodeDataStorage._isReady;
      };
      Node2.prototype.markAsDirty = function(property) {
        this._currentRenderId = Number.MAX_VALUE;
        this._isDirty = true;
        return this;
      };
      Node2.prototype.isEnabled = function(checkAncestors) {
        if (checkAncestors === void 0) {
          checkAncestors = true;
        }
        if (checkAncestors === false) {
          return this._nodeDataStorage._isEnabled;
        }
        if (!this._nodeDataStorage._isEnabled) {
          return false;
        }
        return this._nodeDataStorage._isParentEnabled;
      };
      Node2.prototype._syncParentEnabledState = function() {
        this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
        if (this._children) {
          this._children.forEach(function(c) {
            c._syncParentEnabledState();
          });
        }
      };
      Node2.prototype.setEnabled = function(value) {
        if (this._nodeDataStorage._isEnabled === value) {
          return;
        }
        this._nodeDataStorage._isEnabled = value;
        this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
        this._syncParentEnabledState();
      };
      Node2.prototype.isDescendantOf = function(ancestor) {
        if (this.parent) {
          if (this.parent === ancestor) {
            return true;
          }
          return this.parent.isDescendantOf(ancestor);
        }
        return false;
      };
      Node2.prototype._getDescendants = function(results, directDescendantsOnly, predicate) {
        if (directDescendantsOnly === void 0) {
          directDescendantsOnly = false;
        }
        if (!this._children) {
          return;
        }
        for (var index = 0; index < this._children.length; index++) {
          var item = this._children[index];
          if (!predicate || predicate(item)) {
            results.push(item);
          }
          if (!directDescendantsOnly) {
            item._getDescendants(results, false, predicate);
          }
        }
      };
      Node2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
        var results = new Array();
        this._getDescendants(results, directDescendantsOnly, predicate);
        return results;
      };
      Node2.prototype.getChildMeshes = function(directDescendantsOnly, predicate) {
        var results = [];
        this._getDescendants(results, directDescendantsOnly, function(node) {
          return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
        });
        return results;
      };
      Node2.prototype.getChildren = function(predicate, directDescendantsOnly) {
        if (directDescendantsOnly === void 0) {
          directDescendantsOnly = true;
        }
        return this.getDescendants(directDescendantsOnly, predicate);
      };
      Node2.prototype._setReady = function(state) {
        if (state === this._nodeDataStorage._isReady) {
          return;
        }
        if (!state) {
          this._nodeDataStorage._isReady = false;
          return;
        }
        if (this.onReady) {
          this.onReady(this);
        }
        this._nodeDataStorage._isReady = true;
      };
      Node2.prototype.getAnimationByName = function(name105) {
        for (var i = 0; i < this.animations.length; i++) {
          var animation = this.animations[i];
          if (animation.name === name105) {
            return animation;
          }
        }
        return null;
      };
      Node2.prototype.createAnimationRange = function(name105, from, to) {
        if (!this._ranges[name105]) {
          this._ranges[name105] = Node2._AnimationRangeFactory(name105, from, to);
          for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
            if (this.animations[i]) {
              this.animations[i].createRange(name105, from, to);
            }
          }
        }
      };
      Node2.prototype.deleteAnimationRange = function(name105, deleteFrames) {
        if (deleteFrames === void 0) {
          deleteFrames = true;
        }
        for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
          if (this.animations[i]) {
            this.animations[i].deleteRange(name105, deleteFrames);
          }
        }
        this._ranges[name105] = null;
      };
      Node2.prototype.getAnimationRange = function(name105) {
        return this._ranges[name105] || null;
      };
      Node2.prototype.getAnimationRanges = function() {
        var animationRanges = [];
        var name105;
        for (name105 in this._ranges) {
          animationRanges.push(this._ranges[name105]);
        }
        return animationRanges;
      };
      Node2.prototype.beginAnimation = function(name105, loop, speedRatio, onAnimationEnd) {
        var range = this.getAnimationRange(name105);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      };
      Node2.prototype.serializeAnimationRanges = function() {
        var serializationRanges = [];
        for (var name_1 in this._ranges) {
          var localRange = this._ranges[name_1];
          if (!localRange) {
            continue;
          }
          var range = {};
          range.name = name_1;
          range.from = localRange.from;
          range.to = localRange.to;
          serializationRanges.push(range);
        }
        return serializationRanges;
      };
      Node2.prototype.computeWorldMatrix = function(force) {
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        return this._worldMatrix;
      };
      Node2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        this._nodeDataStorage._isDisposed = true;
        if (!doNotRecurse) {
          var nodes = this.getDescendants(true);
          for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            node.dispose(doNotRecurse, disposeMaterialAndTextures);
          }
        }
        if (!this.parent) {
          this._removeFromSceneRootNodes();
        } else {
          this.parent = null;
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onEnabledStateChangedObservable.clear();
        this.onClonedObservable.clear();
        for (var _a = 0, _b = this._behaviors; _a < _b.length; _a++) {
          var behavior = _b[_a];
          behavior.detach();
        }
        this._behaviors = [];
        this.metadata = null;
      };
      Node2.ParseAnimationRanges = function(node, parsedNode, scene) {
        if (parsedNode.ranges) {
          for (var index = 0; index < parsedNode.ranges.length; index++) {
            var data = parsedNode.ranges[index];
            node.createAnimationRange(data.name, data.from, data.to);
          }
        }
      };
      Node2.prototype.getHierarchyBoundingVectors = function(includeDescendants, predicate) {
        if (includeDescendants === void 0) {
          includeDescendants = true;
        }
        if (predicate === void 0) {
          predicate = null;
        }
        this.getScene().incrementRenderId();
        this.computeWorldMatrix(true);
        var min;
        var max;
        var thisAbstractMesh = this;
        if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
          var boundingInfo = thisAbstractMesh.getBoundingInfo();
          min = boundingInfo.boundingBox.minimumWorld.clone();
          max = boundingInfo.boundingBox.maximumWorld.clone();
        } else {
          min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        if (includeDescendants) {
          var descendants = this.getDescendants(false);
          for (var _i = 0, descendants_1 = descendants; _i < descendants_1.length; _i++) {
            var descendant = descendants_1[_i];
            var childMesh = descendant;
            childMesh.computeWorldMatrix(true);
            if (predicate && !predicate(childMesh)) {
              continue;
            }
            if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
              continue;
            }
            var childBoundingInfo = childMesh.getBoundingInfo();
            var boundingBox = childBoundingInfo.boundingBox;
            var minBox = boundingBox.minimumWorld;
            var maxBox = boundingBox.maximumWorld;
            Vector3.CheckExtends(minBox, min, max);
            Vector3.CheckExtends(maxBox, min, max);
          }
        }
        return {
          min,
          max
        };
      };
      Node2._AnimationRangeFactory = function(name105, from, to) {
        throw _WarnImport("AnimationRange");
      };
      Node2._NodeConstructors = {};
      __decorate([
        serialize()
      ], Node2.prototype, "name", void 0);
      __decorate([
        serialize()
      ], Node2.prototype, "id", void 0);
      __decorate([
        serialize()
      ], Node2.prototype, "uniqueId", void 0);
      __decorate([
        serialize()
      ], Node2.prototype, "state", void 0);
      __decorate([
        serialize()
      ], Node2.prototype, "metadata", void 0);
      return Node2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.size.js
var Size;
var init_math_size = __esm({
  "node_modules/@babylonjs/core/Maths/math.size.js"() {
    Size = function() {
      function Size2(width, height) {
        this.width = width;
        this.height = height;
      }
      Size2.prototype.toString = function() {
        return "{W: ".concat(this.width, ", H: ").concat(this.height, "}");
      };
      Size2.prototype.getClassName = function() {
        return "Size";
      };
      Size2.prototype.getHashCode = function() {
        var hash = this.width | 0;
        hash = hash * 397 ^ (this.height | 0);
        return hash;
      };
      Size2.prototype.copyFrom = function(src) {
        this.width = src.width;
        this.height = src.height;
      };
      Size2.prototype.copyFromFloats = function(width, height) {
        this.width = width;
        this.height = height;
        return this;
      };
      Size2.prototype.set = function(width, height) {
        return this.copyFromFloats(width, height);
      };
      Size2.prototype.multiplyByFloats = function(w, h) {
        return new Size2(this.width * w, this.height * h);
      };
      Size2.prototype.clone = function() {
        return new Size2(this.width, this.height);
      };
      Size2.prototype.equals = function(other) {
        if (!other) {
          return false;
        }
        return this.width === other.width && this.height === other.height;
      };
      Object.defineProperty(Size2.prototype, "surface", {
        get: function() {
          return this.width * this.height;
        },
        enumerable: false,
        configurable: true
      });
      Size2.Zero = function() {
        return new Size2(0, 0);
      };
      Size2.prototype.add = function(otherSize) {
        var r = new Size2(this.width + otherSize.width, this.height + otherSize.height);
        return r;
      };
      Size2.prototype.subtract = function(otherSize) {
        var r = new Size2(this.width - otherSize.width, this.height - otherSize.height);
        return r;
      };
      Size2.Lerp = function(start, end, amount) {
        var w = start.width + (end.width - start.width) * amount;
        var h = start.height + (end.height - start.height) * amount;
        return new Size2(w, h);
      };
      return Size2;
    }();
  }
});

// node_modules/@babylonjs/core/Animations/animation.js
var _IAnimationState, Animation;
var init_animation = __esm({
  "node_modules/@babylonjs/core/Animations/animation.js"() {
    init_math_vector();
    init_math_color();
    init_math_scalar();
    init_decorators();
    init_typeStore();
    init_animationKey();
    init_animationRange();
    init_node();
    init_math_size();
    init_webRequest();
    _IAnimationState = function() {
      function _IAnimationState2() {
      }
      return _IAnimationState2;
    }();
    Animation = function() {
      function Animation2(name105, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
        this.name = name105;
        this.targetProperty = targetProperty;
        this.framePerSecond = framePerSecond;
        this.dataType = dataType;
        this.loopMode = loopMode;
        this.enableBlending = enableBlending;
        this._easingFunction = null;
        this._runtimeAnimations = new Array();
        this._events = new Array();
        this.blendingSpeed = 0.01;
        this._ranges = {};
        this.targetPropertyPath = targetProperty.split(".");
        this.dataType = dataType;
        this.loopMode = loopMode === void 0 ? Animation2.ANIMATIONLOOPMODE_CYCLE : loopMode;
        this.uniqueId = Animation2._UniqueIdGenerator++;
      }
      Animation2._PrepareAnimation = function(name105, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
        var dataType = void 0;
        if (!isNaN(parseFloat(from)) && isFinite(from)) {
          dataType = Animation2.ANIMATIONTYPE_FLOAT;
        } else if (from instanceof Quaternion) {
          dataType = Animation2.ANIMATIONTYPE_QUATERNION;
        } else if (from instanceof Vector3) {
          dataType = Animation2.ANIMATIONTYPE_VECTOR3;
        } else if (from instanceof Vector2) {
          dataType = Animation2.ANIMATIONTYPE_VECTOR2;
        } else if (from instanceof Color3) {
          dataType = Animation2.ANIMATIONTYPE_COLOR3;
        } else if (from instanceof Color4) {
          dataType = Animation2.ANIMATIONTYPE_COLOR4;
        } else if (from instanceof Size) {
          dataType = Animation2.ANIMATIONTYPE_SIZE;
        }
        if (dataType == void 0) {
          return null;
        }
        var animation = new Animation2(name105, targetProperty, framePerSecond, dataType, loopMode);
        var keys = [
          { frame: 0, value: from },
          { frame: totalFrame, value: to }
        ];
        animation.setKeys(keys);
        if (easingFunction !== void 0) {
          animation.setEasingFunction(easingFunction);
        }
        return animation;
      };
      Animation2.CreateAnimation = function(property, animationType, framePerSecond, easingFunction) {
        var animation = new Animation2(property + "Animation", property, framePerSecond, animationType, Animation2.ANIMATIONLOOPMODE_CONSTANT);
        animation.setEasingFunction(easingFunction);
        return animation;
      };
      Animation2.CreateAndStartAnimation = function(name105, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {
        var animation = Animation2._PrepareAnimation(name105, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        if (target.getScene) {
          scene = target.getScene();
        }
        if (!scene) {
          return null;
        }
        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      };
      Animation2.CreateAndStartHierarchyAnimation = function(name105, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
        var animation = Animation2._PrepareAnimation(name105, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        var scene = node.getScene();
        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      };
      Animation2.CreateMergeAndStartAnimation = function(name105, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
        var animation = Animation2._PrepareAnimation(name105, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        node.animations.push(animation);
        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      };
      Animation2.MakeAnimationAdditive = function(sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {
        if (referenceFrame === void 0) {
          referenceFrame = 0;
        }
        if (cloneOriginal === void 0) {
          cloneOriginal = false;
        }
        var animation = sourceAnimation;
        if (cloneOriginal) {
          animation = sourceAnimation.clone();
          animation.name = clonedName || animation.name;
        }
        if (!animation._keys.length) {
          return animation;
        }
        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;
        var startIndex = 0;
        var firstKey = animation._keys[0];
        var endIndex = animation._keys.length - 1;
        var lastKey = animation._keys[endIndex];
        var valueStore = {
          referenceValue: firstKey.value,
          referencePosition: TmpVectors.Vector3[0],
          referenceQuaternion: TmpVectors.Quaternion[0],
          referenceScaling: TmpVectors.Vector3[1],
          keyPosition: TmpVectors.Vector3[2],
          keyQuaternion: TmpVectors.Quaternion[1],
          keyScaling: TmpVectors.Vector3[3]
        };
        var referenceFound = false;
        var from = firstKey.frame;
        var to = lastKey.frame;
        if (range) {
          var rangeValue = animation.getRange(range);
          if (rangeValue) {
            from = rangeValue.from;
            to = rangeValue.to;
          }
        }
        var fromKeyFound = firstKey.frame === from;
        var toKeyFound = lastKey.frame === to;
        if (animation._keys.length === 1) {
          var value = animation._getKeyValue(animation._keys[0]);
          valueStore.referenceValue = value.clone ? value.clone() : value;
          referenceFound = true;
        } else if (referenceFrame <= firstKey.frame) {
          var value = animation._getKeyValue(firstKey.value);
          valueStore.referenceValue = value.clone ? value.clone() : value;
          referenceFound = true;
        } else if (referenceFrame >= lastKey.frame) {
          var value = animation._getKeyValue(lastKey.value);
          valueStore.referenceValue = value.clone ? value.clone() : value;
          referenceFound = true;
        }
        var index = 0;
        while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {
          var currentKey = animation._keys[index];
          var nextKey = animation._keys[index + 1];
          if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {
            var value = void 0;
            if (referenceFrame === currentKey.frame) {
              value = animation._getKeyValue(currentKey.value);
            } else if (referenceFrame === nextKey.frame) {
              value = animation._getKeyValue(nextKey.value);
            } else {
              var animationState = {
                key: index,
                repeatCount: 0,
                loopMode: this.ANIMATIONLOOPMODE_CONSTANT
              };
              value = animation._interpolate(referenceFrame, animationState);
            }
            valueStore.referenceValue = value.clone ? value.clone() : value;
            referenceFound = true;
          }
          if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {
            if (from === currentKey.frame) {
              startIndex = index;
            } else if (from === nextKey.frame) {
              startIndex = index + 1;
            } else {
              var animationState = {
                key: index,
                repeatCount: 0,
                loopMode: this.ANIMATIONLOOPMODE_CONSTANT
              };
              var value = animation._interpolate(from, animationState);
              var key = {
                frame: from,
                value: value.clone ? value.clone() : value
              };
              animation._keys.splice(index + 1, 0, key);
              startIndex = index + 1;
            }
            fromKeyFound = true;
          }
          if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {
            if (to === currentKey.frame) {
              endIndex = index;
            } else if (to === nextKey.frame) {
              endIndex = index + 1;
            } else {
              var animationState = {
                key: index,
                repeatCount: 0,
                loopMode: this.ANIMATIONLOOPMODE_CONSTANT
              };
              var value = animation._interpolate(to, animationState);
              var key = {
                frame: to,
                value: value.clone ? value.clone() : value
              };
              animation._keys.splice(index + 1, 0, key);
              endIndex = index + 1;
            }
            toKeyFound = true;
          }
          index++;
        }
        if (animation.dataType === Animation2.ANIMATIONTYPE_QUATERNION) {
          valueStore.referenceValue.normalize().conjugateInPlace();
        } else if (animation.dataType === Animation2.ANIMATIONTYPE_MATRIX) {
          valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
          valueStore.referenceQuaternion.normalize().conjugateInPlace();
        }
        for (index = startIndex; index <= endIndex; index++) {
          var key = animation._keys[index];
          if (index && animation.dataType !== Animation2.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
            continue;
          }
          switch (animation.dataType) {
            case Animation2.ANIMATIONTYPE_MATRIX:
              key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
              valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
              valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
              valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
              Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
              break;
            case Animation2.ANIMATIONTYPE_QUATERNION:
              valueStore.referenceValue.multiplyToRef(key.value, key.value);
              break;
            case Animation2.ANIMATIONTYPE_VECTOR2:
            case Animation2.ANIMATIONTYPE_VECTOR3:
            case Animation2.ANIMATIONTYPE_COLOR3:
            case Animation2.ANIMATIONTYPE_COLOR4:
              key.value.subtractToRef(valueStore.referenceValue, key.value);
              break;
            case Animation2.ANIMATIONTYPE_SIZE:
              key.value.width -= valueStore.referenceValue.width;
              key.value.height -= valueStore.referenceValue.height;
              break;
            default:
              key.value -= valueStore.referenceValue;
          }
        }
        return animation;
      };
      Animation2.TransitionTo = function(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {
        if (onAnimationEnd === void 0) {
          onAnimationEnd = null;
        }
        if (duration <= 0) {
          host[property] = targetValue;
          if (onAnimationEnd) {
            onAnimationEnd();
          }
          return null;
        }
        var endFrame = frameRate * (duration / 1e3);
        transition.setKeys([
          {
            frame: 0,
            value: host[property].clone ? host[property].clone() : host[property]
          },
          {
            frame: endFrame,
            value: targetValue
          }
        ]);
        if (!host.animations) {
          host.animations = [];
        }
        host.animations.push(transition);
        var animation = scene.beginAnimation(host, 0, endFrame, false);
        animation.onAnimationEnd = onAnimationEnd;
        return animation;
      };
      Object.defineProperty(Animation2.prototype, "runtimeAnimations", {
        get: function() {
          return this._runtimeAnimations;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "hasRunningRuntimeAnimations", {
        get: function() {
          for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {
            var runtimeAnimation = _a[_i];
            if (!runtimeAnimation.isStopped()) {
              return true;
            }
          }
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Animation2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name + ", property: " + this.targetProperty;
        ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
        ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
        ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
        if (fullDetails) {
          ret += ", Ranges: {";
          var first = true;
          for (var name_1 in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name_1;
          }
          ret += "}";
        }
        return ret;
      };
      Animation2.prototype.addEvent = function(event) {
        this._events.push(event);
        this._events.sort(function(a, b) {
          return a.frame - b.frame;
        });
      };
      Animation2.prototype.removeEvents = function(frame) {
        for (var index = 0; index < this._events.length; index++) {
          if (this._events[index].frame === frame) {
            this._events.splice(index, 1);
            index--;
          }
        }
      };
      Animation2.prototype.getEvents = function() {
        return this._events;
      };
      Animation2.prototype.createRange = function(name105, from, to) {
        if (!this._ranges[name105]) {
          this._ranges[name105] = new AnimationRange(name105, from, to);
        }
      };
      Animation2.prototype.deleteRange = function(name105, deleteFrames) {
        if (deleteFrames === void 0) {
          deleteFrames = true;
        }
        var range = this._ranges[name105];
        if (!range) {
          return;
        }
        if (deleteFrames) {
          var from = range.from;
          var to = range.to;
          for (var key = this._keys.length - 1; key >= 0; key--) {
            if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
              this._keys.splice(key, 1);
            }
          }
        }
        this._ranges[name105] = null;
      };
      Animation2.prototype.getRange = function(name105) {
        return this._ranges[name105];
      };
      Animation2.prototype.getKeys = function() {
        return this._keys;
      };
      Animation2.prototype.getHighestFrame = function() {
        var ret = 0;
        for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {
          if (ret < this._keys[key].frame) {
            ret = this._keys[key].frame;
          }
        }
        return ret;
      };
      Animation2.prototype.getEasingFunction = function() {
        return this._easingFunction;
      };
      Animation2.prototype.setEasingFunction = function(easingFunction) {
        this._easingFunction = easingFunction;
      };
      Animation2.prototype.floatInterpolateFunction = function(startValue, endValue, gradient) {
        return Scalar.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.floatInterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      };
      Animation2.prototype.quaternionInterpolateFunction = function(startValue, endValue, gradient) {
        return Quaternion.Slerp(startValue, endValue, gradient);
      };
      Animation2.prototype.quaternionInterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
      };
      Animation2.prototype.vector3InterpolateFunction = function(startValue, endValue, gradient) {
        return Vector3.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.vector3InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      };
      Animation2.prototype.vector2InterpolateFunction = function(startValue, endValue, gradient) {
        return Vector2.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.vector2InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      };
      Animation2.prototype.sizeInterpolateFunction = function(startValue, endValue, gradient) {
        return Size.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.color3InterpolateFunction = function(startValue, endValue, gradient) {
        return Color3.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.color3InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      };
      Animation2.prototype.color4InterpolateFunction = function(startValue, endValue, gradient) {
        return Color4.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.color4InterpolateFunctionWithTangents = function(startValue, outTangent, endValue, inTangent, gradient) {
        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      };
      Animation2.prototype._getKeyValue = function(value) {
        if (typeof value === "function") {
          return value();
        }
        return value;
      };
      Animation2.prototype.evaluate = function(currentFrame) {
        return this._interpolate(currentFrame, {
          key: 0,
          repeatCount: 0,
          loopMode: Animation2.ANIMATIONLOOPMODE_CONSTANT
        });
      };
      Animation2.prototype._interpolate = function(currentFrame, state) {
        if (state.loopMode === Animation2.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
          return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
        }
        var keys = this._keys;
        if (keys.length === 1) {
          return this._getKeyValue(keys[0].value);
        }
        var startKeyIndex = state.key;
        if (keys[startKeyIndex].frame >= currentFrame) {
          while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {
            startKeyIndex--;
          }
        }
        for (var key = startKeyIndex; key < keys.length - 1; key++) {
          var endKey = keys[key + 1];
          if (endKey.frame >= currentFrame) {
            state.key = key;
            var startKey = keys[key];
            var startValue = this._getKeyValue(startKey.value);
            var endValue = this._getKeyValue(endKey.value);
            if (startKey.interpolation === AnimationKeyInterpolation.STEP) {
              if (endKey.frame > currentFrame) {
                return startValue;
              } else {
                return endValue;
              }
            }
            var useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
            var frameDelta = endKey.frame - startKey.frame;
            var gradient = (currentFrame - startKey.frame) / frameDelta;
            var easingFunction = this.getEasingFunction();
            if (easingFunction !== null) {
              gradient = easingFunction.ease(gradient);
            }
            switch (this.dataType) {
              case Animation2.ANIMATIONTYPE_FLOAT: {
                var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return floatValue;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return state.offsetValue * state.repeatCount + floatValue;
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_QUATERNION: {
                var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return quatValue;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));
                }
                return quatValue;
              }
              case Animation2.ANIMATIONTYPE_VECTOR3: {
                var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return vec3Value;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return vec3Value.add(state.offsetValue.scale(state.repeatCount));
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_VECTOR2: {
                var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return vec2Value;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return vec2Value.add(state.offsetValue.scale(state.repeatCount));
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_SIZE: {
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return this.sizeInterpolateFunction(startValue, endValue, gradient);
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_COLOR3: {
                var color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return color3Value;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return color3Value.add(state.offsetValue.scale(state.repeatCount));
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_COLOR4: {
                var color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT:
                    return color4Value;
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE:
                    return color4Value.add(state.offsetValue.scale(state.repeatCount));
                }
                break;
              }
              case Animation2.ANIMATIONTYPE_MATRIX: {
                switch (state.loopMode) {
                  case Animation2.ANIMATIONLOOPMODE_CYCLE:
                  case Animation2.ANIMATIONLOOPMODE_CONSTANT: {
                    if (Animation2.AllowMatricesInterpolation) {
                      return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
                    }
                    return startValue;
                  }
                  case Animation2.ANIMATIONLOOPMODE_RELATIVE: {
                    return startValue;
                  }
                }
                break;
              }
              default:
                break;
            }
            break;
          }
        }
        return this._getKeyValue(keys[keys.length - 1].value);
      };
      Animation2.prototype.matrixInterpolateFunction = function(startValue, endValue, gradient, result) {
        if (Animation2.AllowMatrixDecomposeForInterpolation) {
          if (result) {
            Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
            return result;
          }
          return Matrix.DecomposeLerp(startValue, endValue, gradient);
        }
        if (result) {
          Matrix.LerpToRef(startValue, endValue, gradient, result);
          return result;
        }
        return Matrix.Lerp(startValue, endValue, gradient);
      };
      Animation2.prototype.clone = function() {
        var clone = new Animation2(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
        clone.enableBlending = this.enableBlending;
        clone.blendingSpeed = this.blendingSpeed;
        if (this._keys) {
          clone.setKeys(this._keys);
        }
        if (this._ranges) {
          clone._ranges = {};
          for (var name_2 in this._ranges) {
            var range = this._ranges[name_2];
            if (!range) {
              continue;
            }
            clone._ranges[name_2] = range.clone();
          }
        }
        return clone;
      };
      Animation2.prototype.setKeys = function(values) {
        this._keys = values.slice(0);
      };
      Animation2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.property = this.targetProperty;
        serializationObject.framePerSecond = this.framePerSecond;
        serializationObject.dataType = this.dataType;
        serializationObject.loopBehavior = this.loopMode;
        serializationObject.enableBlending = this.enableBlending;
        serializationObject.blendingSpeed = this.blendingSpeed;
        var dataType = this.dataType;
        serializationObject.keys = [];
        var keys = this.getKeys();
        for (var index = 0; index < keys.length; index++) {
          var animationKey = keys[index];
          var key = {};
          key.frame = animationKey.frame;
          switch (dataType) {
            case Animation2.ANIMATIONTYPE_FLOAT:
              key.values = [animationKey.value];
              if (animationKey.inTangent !== void 0) {
                key.values.push(animationKey.inTangent);
              }
              if (animationKey.outTangent !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.outTangent);
              }
              if (animationKey.interpolation !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                if (animationKey.outTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.interpolation);
              }
              break;
            case Animation2.ANIMATIONTYPE_QUATERNION:
            case Animation2.ANIMATIONTYPE_MATRIX:
            case Animation2.ANIMATIONTYPE_VECTOR3:
            case Animation2.ANIMATIONTYPE_COLOR3:
            case Animation2.ANIMATIONTYPE_COLOR4:
              key.values = animationKey.value.asArray();
              if (animationKey.inTangent != void 0) {
                key.values.push(animationKey.inTangent.asArray());
              }
              if (animationKey.outTangent != void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.outTangent.asArray());
              }
              if (animationKey.interpolation !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                if (animationKey.outTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.interpolation);
              }
              break;
          }
          serializationObject.keys.push(key);
        }
        serializationObject.ranges = [];
        for (var name_3 in this._ranges) {
          var source = this._ranges[name_3];
          if (!source) {
            continue;
          }
          var range = {};
          range.name = name_3;
          range.from = source.from;
          range.to = source.to;
          serializationObject.ranges.push(range);
        }
        return serializationObject;
      };
      Animation2._UniversalLerp = function(left, right, amount) {
        var constructor = left.constructor;
        if (constructor.Lerp) {
          return constructor.Lerp(left, right, amount);
        } else if (constructor.Slerp) {
          return constructor.Slerp(left, right, amount);
        } else if (left.toFixed) {
          return left * (1 - amount) + amount * right;
        } else {
          return right;
        }
      };
      Animation2.Parse = function(parsedAnimation) {
        var animation = new Animation2(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
        var dataType = parsedAnimation.dataType;
        var keys = [];
        var data;
        var index;
        if (parsedAnimation.enableBlending) {
          animation.enableBlending = parsedAnimation.enableBlending;
        }
        if (parsedAnimation.blendingSpeed) {
          animation.blendingSpeed = parsedAnimation.blendingSpeed;
        }
        for (index = 0; index < parsedAnimation.keys.length; index++) {
          var key = parsedAnimation.keys[index];
          var inTangent = void 0;
          var outTangent = void 0;
          var interpolation = void 0;
          switch (dataType) {
            case Animation2.ANIMATIONTYPE_FLOAT:
              data = key.values[0];
              if (key.values.length >= 2) {
                inTangent = key.values[1];
              }
              if (key.values.length >= 3) {
                outTangent = key.values[2];
              }
              if (key.values.length >= 4) {
                interpolation = key.values[3];
              }
              break;
            case Animation2.ANIMATIONTYPE_QUATERNION:
              data = Quaternion.FromArray(key.values);
              if (key.values.length >= 8) {
                var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
                if (!_inTangent.equals(Quaternion.Zero())) {
                  inTangent = _inTangent;
                }
              }
              if (key.values.length >= 12) {
                var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
                if (!_outTangent.equals(Quaternion.Zero())) {
                  outTangent = _outTangent;
                }
              }
              if (key.values.length >= 13) {
                interpolation = key.values[12];
              }
              break;
            case Animation2.ANIMATIONTYPE_MATRIX:
              data = Matrix.FromArray(key.values);
              if (key.values.length >= 17) {
                interpolation = key.values[16];
              }
              break;
            case Animation2.ANIMATIONTYPE_COLOR3:
              data = Color3.FromArray(key.values);
              if (key.values[3]) {
                inTangent = Color3.FromArray(key.values[3]);
              }
              if (key.values[4]) {
                outTangent = Color3.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                interpolation = key.values[5];
              }
              break;
            case Animation2.ANIMATIONTYPE_COLOR4:
              data = Color4.FromArray(key.values);
              if (key.values[4]) {
                inTangent = Color4.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                outTangent = Color4.FromArray(key.values[5]);
              }
              if (key.values[6]) {
                interpolation = Color4.FromArray(key.values[6]);
              }
              break;
            case Animation2.ANIMATIONTYPE_VECTOR3:
            default:
              data = Vector3.FromArray(key.values);
              if (key.values[3]) {
                inTangent = Vector3.FromArray(key.values[3]);
              }
              if (key.values[4]) {
                outTangent = Vector3.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                interpolation = key.values[5];
              }
              break;
          }
          var keyData = {};
          keyData.frame = key.frame;
          keyData.value = data;
          if (inTangent != void 0) {
            keyData.inTangent = inTangent;
          }
          if (outTangent != void 0) {
            keyData.outTangent = outTangent;
          }
          if (interpolation != void 0) {
            keyData.interpolation = interpolation;
          }
          keys.push(keyData);
        }
        animation.setKeys(keys);
        if (parsedAnimation.ranges) {
          for (index = 0; index < parsedAnimation.ranges.length; index++) {
            data = parsedAnimation.ranges[index];
            animation.createRange(data.name, data.from, data.to);
          }
        }
        return animation;
      };
      Animation2.AppendSerializedAnimations = function(source, destination) {
        SerializationHelper.AppendSerializedAnimations(source, destination);
      };
      Animation2.ParseFromFileAsync = function(name105, url) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var request = new WebRequest();
          request.addEventListener("readystatechange", function() {
            if (request.readyState == 4) {
              if (request.status == 200) {
                var serializationObject = JSON.parse(request.responseText);
                if (serializationObject.animations) {
                  serializationObject = serializationObject.animations;
                }
                if (serializationObject.length) {
                  var output = new Array();
                  for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {
                    var serializedAnimation = serializationObject_1[_i];
                    output.push(_this.Parse(serializedAnimation));
                  }
                  resolve(output);
                } else {
                  var output = _this.Parse(serializationObject);
                  if (name105) {
                    output.name = name105;
                  }
                  resolve(output);
                }
              } else {
                reject("Unable to load the animation");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      };
      Animation2.CreateFromSnippetAsync = function(snippetId) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var request = new WebRequest();
          request.addEventListener("readystatechange", function() {
            if (request.readyState == 4) {
              if (request.status == 200) {
                var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                if (snippet.animations) {
                  var serializationObject = JSON.parse(snippet.animations);
                  var outputs = new Array();
                  for (var _i = 0, _a = serializationObject.animations; _i < _a.length; _i++) {
                    var serializedAnimation = _a[_i];
                    var output = _this.Parse(serializedAnimation);
                    output.snippetId = snippetId;
                    outputs.push(output);
                  }
                  resolve(outputs);
                } else {
                  var serializationObject = JSON.parse(snippet.animation);
                  var output = _this.Parse(serializationObject);
                  output.snippetId = snippetId;
                  resolve(output);
                }
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      };
      Animation2._UniqueIdGenerator = 0;
      Animation2.AllowMatricesInterpolation = false;
      Animation2.AllowMatrixDecomposeForInterpolation = true;
      Animation2.SnippetUrl = "https://snippet.babylonjs.com";
      Animation2.ANIMATIONTYPE_FLOAT = 0;
      Animation2.ANIMATIONTYPE_VECTOR3 = 1;
      Animation2.ANIMATIONTYPE_QUATERNION = 2;
      Animation2.ANIMATIONTYPE_MATRIX = 3;
      Animation2.ANIMATIONTYPE_COLOR3 = 4;
      Animation2.ANIMATIONTYPE_COLOR4 = 7;
      Animation2.ANIMATIONTYPE_VECTOR2 = 5;
      Animation2.ANIMATIONTYPE_SIZE = 6;
      Animation2.ANIMATIONLOOPMODE_RELATIVE = 0;
      Animation2.ANIMATIONLOOPMODE_CYCLE = 1;
      Animation2.ANIMATIONLOOPMODE_CONSTANT = 2;
      return Animation2;
    }();
    RegisterClass("BABYLON.Animation", Animation);
    Node._AnimationRangeFactory = function(name105, from, to) {
      return new AnimationRange(name105, from, to);
    };
  }
});

// node_modules/@babylonjs/core/Maths/math.axis.js
var Space, Axis, Coordinate;
var init_math_axis = __esm({
  "node_modules/@babylonjs/core/Maths/math.axis.js"() {
    init_math_vector();
    (function(Space2) {
      Space2[Space2["LOCAL"] = 0] = "LOCAL";
      Space2[Space2["WORLD"] = 1] = "WORLD";
      Space2[Space2["BONE"] = 2] = "BONE";
    })(Space || (Space = {}));
    Axis = function() {
      function Axis2() {
      }
      Axis2.X = new Vector3(1, 0, 0);
      Axis2.Y = new Vector3(0, 1, 0);
      Axis2.Z = new Vector3(0, 0, 1);
      return Axis2;
    }();
    (function(Coordinate2) {
      Coordinate2[Coordinate2["X"] = 0] = "X";
      Coordinate2[Coordinate2["Y"] = 1] = "Y";
      Coordinate2[Coordinate2["Z"] = 2] = "Z";
    })(Coordinate || (Coordinate = {}));
  }
});

// node_modules/@babylonjs/core/Bones/bone.js
var Bone;
var init_bone = __esm({
  "node_modules/@babylonjs/core/Bones/bone.js"() {
    init_tslib_es6();
    init_math_vector();
    init_arrayTools();
    init_node();
    init_math_axis();
    Bone = function(_super) {
      __extends(Bone2, _super);
      function Bone2(name105, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {
        if (parentBone === void 0) {
          parentBone = null;
        }
        if (localMatrix === void 0) {
          localMatrix = null;
        }
        if (restPose === void 0) {
          restPose = null;
        }
        if (baseMatrix === void 0) {
          baseMatrix = null;
        }
        if (index === void 0) {
          index = null;
        }
        var _this = _super.call(this, name105, skeleton.getScene()) || this;
        _this.name = name105;
        _this.children = new Array();
        _this.animations = new Array();
        _this._index = null;
        _this._absoluteTransform = new Matrix();
        _this._invertedAbsoluteTransform = new Matrix();
        _this._scalingDeterminant = 1;
        _this._worldTransform = new Matrix();
        _this._needToDecompose = true;
        _this._needToCompose = false;
        _this._linkedTransformNode = null;
        _this._waitingTransformNodeId = null;
        _this._skeleton = skeleton;
        _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();
        _this._restPose = restPose ? restPose : _this._localMatrix.clone();
        _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();
        _this._index = index;
        skeleton.bones.push(_this);
        _this.setParent(parentBone, false);
        if (baseMatrix || localMatrix) {
          _this._updateDifferenceMatrix();
        }
        return _this;
      }
      Object.defineProperty(Bone2.prototype, "_matrix", {
        get: function() {
          this._compose();
          return this._localMatrix;
        },
        set: function(value) {
          this._needToCompose = false;
          if (value.updateFlag === this._localMatrix.updateFlag) {
            return;
          }
          this._localMatrix.copyFrom(value);
          this._markAsDirtyAndDecompose();
        },
        enumerable: false,
        configurable: true
      });
      Bone2.prototype.getClassName = function() {
        return "Bone";
      };
      Bone2.prototype.getSkeleton = function() {
        return this._skeleton;
      };
      Object.defineProperty(Bone2.prototype, "parent", {
        get: function() {
          return this._parentNode;
        },
        set: function(newParent) {
          this.setParent(newParent);
        },
        enumerable: false,
        configurable: true
      });
      Bone2.prototype.getParent = function() {
        return this.parent;
      };
      Bone2.prototype.getChildren = function() {
        return this.children;
      };
      Bone2.prototype.getIndex = function() {
        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;
      };
      Bone2.prototype.setParent = function(parent, updateDifferenceMatrix) {
        if (updateDifferenceMatrix === void 0) {
          updateDifferenceMatrix = true;
        }
        if (this.parent === parent) {
          return;
        }
        if (this.parent) {
          var index = this.parent.children.indexOf(this);
          if (index !== -1) {
            this.parent.children.splice(index, 1);
          }
        }
        this._parentNode = parent;
        if (this.parent) {
          this.parent.children.push(this);
        }
        if (updateDifferenceMatrix) {
          this._updateDifferenceMatrix();
        }
        this.markAsDirty();
      };
      Bone2.prototype.getLocalMatrix = function() {
        this._compose();
        return this._localMatrix;
      };
      Bone2.prototype.getBaseMatrix = function() {
        return this._baseMatrix;
      };
      Bone2.prototype.getRestPose = function() {
        return this._restPose;
      };
      Bone2.prototype.setRestPose = function(matrix) {
        this._restPose.copyFrom(matrix);
      };
      Bone2.prototype.getBindPose = function() {
        return this._baseMatrix;
      };
      Bone2.prototype.setBindPose = function(matrix) {
        this.updateMatrix(matrix);
      };
      Bone2.prototype.getWorldMatrix = function() {
        return this._worldTransform;
      };
      Bone2.prototype.returnToRest = function() {
        var _a;
        if (this._linkedTransformNode) {
          var localScaling = TmpVectors.Vector3[0];
          var localRotation = TmpVectors.Quaternion[0];
          var localPosition = TmpVectors.Vector3[1];
          this.getRestPose().decompose(localScaling, localRotation, localPosition);
          this._linkedTransformNode.position.copyFrom(localPosition);
          this._linkedTransformNode.rotationQuaternion = (_a = this._linkedTransformNode.rotationQuaternion) !== null && _a !== void 0 ? _a : Quaternion.Identity();
          this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);
          this._linkedTransformNode.scaling.copyFrom(localScaling);
        } else {
          this._matrix = this._restPose;
        }
      };
      Bone2.prototype.getInvertedAbsoluteTransform = function() {
        return this._invertedAbsoluteTransform;
      };
      Bone2.prototype.getAbsoluteTransform = function() {
        return this._absoluteTransform;
      };
      Bone2.prototype.linkTransformNode = function(transformNode) {
        if (this._linkedTransformNode) {
          this._skeleton._numBonesWithLinkedTransformNode--;
        }
        this._linkedTransformNode = transformNode;
        if (this._linkedTransformNode) {
          this._skeleton._numBonesWithLinkedTransformNode++;
        }
      };
      Bone2.prototype.getTransformNode = function() {
        return this._linkedTransformNode;
      };
      Object.defineProperty(Bone2.prototype, "position", {
        get: function() {
          this._decompose();
          return this._localPosition;
        },
        set: function(newPosition) {
          this._decompose();
          this._localPosition.copyFrom(newPosition);
          this._markAsDirtyAndCompose();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bone2.prototype, "rotation", {
        get: function() {
          return this.getRotation();
        },
        set: function(newRotation) {
          this.setRotation(newRotation);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bone2.prototype, "rotationQuaternion", {
        get: function() {
          this._decompose();
          return this._localRotation;
        },
        set: function(newRotation) {
          this.setRotationQuaternion(newRotation);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bone2.prototype, "scaling", {
        get: function() {
          return this.getScale();
        },
        set: function(newScaling) {
          this.setScale(newScaling);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bone2.prototype, "animationPropertiesOverride", {
        get: function() {
          return this._skeleton.animationPropertiesOverride;
        },
        enumerable: false,
        configurable: true
      });
      Bone2.prototype._decompose = function() {
        if (!this._needToDecompose) {
          return;
        }
        this._needToDecompose = false;
        if (!this._localScaling) {
          this._localScaling = Vector3.Zero();
          this._localRotation = Quaternion.Zero();
          this._localPosition = Vector3.Zero();
        }
        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);
      };
      Bone2.prototype._compose = function() {
        if (!this._needToCompose) {
          return;
        }
        if (!this._localScaling) {
          this._needToCompose = false;
          return;
        }
        this._needToCompose = false;
        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);
      };
      Bone2.prototype.updateMatrix = function(matrix, updateDifferenceMatrix, updateLocalMatrix) {
        if (updateDifferenceMatrix === void 0) {
          updateDifferenceMatrix = true;
        }
        if (updateLocalMatrix === void 0) {
          updateLocalMatrix = true;
        }
        this._baseMatrix.copyFrom(matrix);
        if (updateDifferenceMatrix) {
          this._updateDifferenceMatrix();
        }
        if (updateLocalMatrix) {
          this._matrix = matrix;
        } else {
          this.markAsDirty();
        }
      };
      Bone2.prototype._updateDifferenceMatrix = function(rootMatrix, updateChildren) {
        if (updateChildren === void 0) {
          updateChildren = true;
        }
        if (!rootMatrix) {
          rootMatrix = this._baseMatrix;
        }
        if (this.parent) {
          rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);
        } else {
          this._absoluteTransform.copyFrom(rootMatrix);
        }
        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);
        if (updateChildren) {
          for (var index = 0; index < this.children.length; index++) {
            this.children[index]._updateDifferenceMatrix();
          }
        }
        this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;
      };
      Bone2.prototype.markAsDirty = function() {
        this._currentRenderId++;
        this._childUpdateId++;
        this._skeleton._markAsDirty();
        return this;
      };
      Bone2.prototype._markAsDirtyAndCompose = function() {
        this.markAsDirty();
        this._needToCompose = true;
      };
      Bone2.prototype._markAsDirtyAndDecompose = function() {
        this.markAsDirty();
        this._needToDecompose = true;
      };
      Bone2.prototype.translate = function(vec, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var lm = this.getLocalMatrix();
        if (space == Space.LOCAL) {
          lm.addAtIndex(12, vec.x);
          lm.addAtIndex(13, vec.y);
          lm.addAtIndex(14, vec.z);
        } else {
          var wm = null;
          if (tNode) {
            wm = tNode.getWorldMatrix();
          }
          this._skeleton.computeAbsoluteTransforms();
          var tmat = Bone2._TmpMats[0];
          var tvec = Bone2._TmpVecs[0];
          if (this.parent) {
            if (tNode && wm) {
              tmat.copyFrom(this.parent.getAbsoluteTransform());
              tmat.multiplyToRef(wm, tmat);
            } else {
              tmat.copyFrom(this.parent.getAbsoluteTransform());
            }
          } else {
            Matrix.IdentityToRef(tmat);
          }
          tmat.setTranslationFromFloats(0, 0, 0);
          tmat.invert();
          Vector3.TransformCoordinatesToRef(vec, tmat, tvec);
          lm.addAtIndex(12, tvec.x);
          lm.addAtIndex(13, tvec.y);
          lm.addAtIndex(14, tvec.z);
        }
        this._markAsDirtyAndDecompose();
      };
      Bone2.prototype.setPosition = function(position, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var lm = this.getLocalMatrix();
        if (space == Space.LOCAL) {
          lm.setTranslationFromFloats(position.x, position.y, position.z);
        } else {
          var wm = null;
          if (tNode) {
            wm = tNode.getWorldMatrix();
          }
          this._skeleton.computeAbsoluteTransforms();
          var tmat = Bone2._TmpMats[0];
          var vec = Bone2._TmpVecs[0];
          if (this.parent) {
            if (tNode && wm) {
              tmat.copyFrom(this.parent.getAbsoluteTransform());
              tmat.multiplyToRef(wm, tmat);
            } else {
              tmat.copyFrom(this.parent.getAbsoluteTransform());
            }
            tmat.invert();
          } else {
            Matrix.IdentityToRef(tmat);
          }
          Vector3.TransformCoordinatesToRef(position, tmat, vec);
          lm.setTranslationFromFloats(vec.x, vec.y, vec.z);
        }
        this._markAsDirtyAndDecompose();
      };
      Bone2.prototype.setAbsolutePosition = function(position, tNode) {
        this.setPosition(position, Space.WORLD, tNode);
      };
      Bone2.prototype.scale = function(x, y, z, scaleChildren) {
        if (scaleChildren === void 0) {
          scaleChildren = false;
        }
        var locMat = this.getLocalMatrix();
        var scaleMat = Bone2._TmpMats[0];
        Matrix.ScalingToRef(x, y, z, scaleMat);
        scaleMat.multiplyToRef(locMat, locMat);
        scaleMat.invert();
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
          var child = _a[_i];
          var cm = child.getLocalMatrix();
          cm.multiplyToRef(scaleMat, cm);
          cm.multiplyAtIndex(12, x);
          cm.multiplyAtIndex(13, y);
          cm.multiplyAtIndex(14, z);
          child._markAsDirtyAndDecompose();
        }
        this._markAsDirtyAndDecompose();
        if (scaleChildren) {
          for (var _b = 0, _c = this.children; _b < _c.length; _b++) {
            var child = _c[_b];
            child.scale(x, y, z, scaleChildren);
          }
        }
      };
      Bone2.prototype.setScale = function(scale) {
        this._decompose();
        this._localScaling.copyFrom(scale);
        this._markAsDirtyAndCompose();
      };
      Bone2.prototype.getScale = function() {
        this._decompose();
        return this._localScaling;
      };
      Bone2.prototype.getScaleToRef = function(result) {
        this._decompose();
        result.copyFrom(this._localScaling);
      };
      Bone2.prototype.setYawPitchRoll = function(yaw, pitch, roll, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space === Space.LOCAL) {
          var quat = Bone2._TmpQuat;
          Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        var rotMatInv = Bone2._TmpMats[0];
        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {
          return;
        }
        var rotMat = Bone2._TmpMats[1];
        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      };
      Bone2.prototype.rotate = function(axis, amount, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var rmat = Bone2._TmpMats[0];
        rmat.setTranslationFromFloats(0, 0, 0);
        Matrix.RotationAxisToRef(axis, amount, rmat);
        this._rotateWithMatrix(rmat, space, tNode);
      };
      Bone2.prototype.setAxisAngle = function(axis, angle, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space === Space.LOCAL) {
          var quat = Bone2._TmpQuat;
          Quaternion.RotationAxisToRef(axis, angle, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        var rotMatInv = Bone2._TmpMats[0];
        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {
          return;
        }
        var rotMat = Bone2._TmpMats[1];
        Matrix.RotationAxisToRef(axis, angle, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      };
      Bone2.prototype.setRotation = function(rotation, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);
      };
      Bone2.prototype.setRotationQuaternion = function(quat, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space === Space.LOCAL) {
          this._decompose();
          this._localRotation.copyFrom(quat);
          this._markAsDirtyAndCompose();
          return;
        }
        var rotMatInv = Bone2._TmpMats[0];
        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {
          return;
        }
        var rotMat = Bone2._TmpMats[1];
        Matrix.FromQuaternionToRef(quat, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      };
      Bone2.prototype.setRotationMatrix = function(rotMat, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space === Space.LOCAL) {
          var quat = Bone2._TmpQuat;
          Quaternion.FromRotationMatrixToRef(rotMat, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        var rotMatInv = Bone2._TmpMats[0];
        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {
          return;
        }
        var rotMat2 = Bone2._TmpMats[1];
        rotMat2.copyFrom(rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat2);
        this._rotateWithMatrix(rotMat2, space, tNode);
      };
      Bone2.prototype._rotateWithMatrix = function(rmat, space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var lmat = this.getLocalMatrix();
        var lx = lmat.m[12];
        var ly = lmat.m[13];
        var lz = lmat.m[14];
        var parent = this.getParent();
        var parentScale = Bone2._TmpMats[3];
        var parentScaleInv = Bone2._TmpMats[4];
        if (parent && space == Space.WORLD) {
          if (tNode) {
            parentScale.copyFrom(tNode.getWorldMatrix());
            parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);
          } else {
            parentScale.copyFrom(parent.getAbsoluteTransform());
          }
          parentScaleInv.copyFrom(parentScale);
          parentScaleInv.invert();
          lmat.multiplyToRef(parentScale, lmat);
          lmat.multiplyToRef(rmat, lmat);
          lmat.multiplyToRef(parentScaleInv, lmat);
        } else {
          if (space == Space.WORLD && tNode) {
            parentScale.copyFrom(tNode.getWorldMatrix());
            parentScaleInv.copyFrom(parentScale);
            parentScaleInv.invert();
            lmat.multiplyToRef(parentScale, lmat);
            lmat.multiplyToRef(rmat, lmat);
            lmat.multiplyToRef(parentScaleInv, lmat);
          } else {
            lmat.multiplyToRef(rmat, lmat);
          }
        }
        lmat.setTranslationFromFloats(lx, ly, lz);
        this.computeAbsoluteTransforms();
        this._markAsDirtyAndDecompose();
      };
      Bone2.prototype._getNegativeRotationToRef = function(rotMatInv, tNode) {
        var scaleMatrix = Bone2._TmpMats[2];
        rotMatInv.copyFrom(this.getAbsoluteTransform());
        if (tNode) {
          rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);
          Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);
        } else {
          Matrix.IdentityToRef(scaleMatrix);
        }
        rotMatInv.invert();
        if (isNaN(rotMatInv.m[0])) {
          return false;
        }
        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);
        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);
        return true;
      };
      Bone2.prototype.getPosition = function(space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (tNode === void 0) {
          tNode = null;
        }
        var pos = Vector3.Zero();
        this.getPositionToRef(space, tNode, pos);
        return pos;
      };
      Bone2.prototype.getPositionToRef = function(space, tNode, result) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space == Space.LOCAL) {
          var lm = this.getLocalMatrix();
          result.x = lm.m[12];
          result.y = lm.m[13];
          result.z = lm.m[14];
        } else {
          var wm = null;
          if (tNode) {
            wm = tNode.getWorldMatrix();
          }
          this._skeleton.computeAbsoluteTransforms();
          var tmat = Bone2._TmpMats[0];
          if (tNode && wm) {
            tmat.copyFrom(this.getAbsoluteTransform());
            tmat.multiplyToRef(wm, tmat);
          } else {
            tmat = this.getAbsoluteTransform();
          }
          result.x = tmat.m[12];
          result.y = tmat.m[13];
          result.z = tmat.m[14];
        }
      };
      Bone2.prototype.getAbsolutePosition = function(tNode) {
        if (tNode === void 0) {
          tNode = null;
        }
        var pos = Vector3.Zero();
        this.getPositionToRef(Space.WORLD, tNode, pos);
        return pos;
      };
      Bone2.prototype.getAbsolutePositionToRef = function(tNode, result) {
        this.getPositionToRef(Space.WORLD, tNode, result);
      };
      Bone2.prototype.computeAbsoluteTransforms = function() {
        this._compose();
        if (this.parent) {
          this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);
        } else {
          this._absoluteTransform.copyFrom(this._localMatrix);
          var poseMatrix = this._skeleton.getPoseMatrix();
          if (poseMatrix) {
            this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);
          }
        }
        var children = this.children;
        var len = children.length;
        for (var i = 0; i < len; i++) {
          children[i].computeAbsoluteTransforms();
        }
      };
      Bone2.prototype.getDirection = function(localAxis, tNode) {
        if (tNode === void 0) {
          tNode = null;
        }
        var result = Vector3.Zero();
        this.getDirectionToRef(localAxis, tNode, result);
        return result;
      };
      Bone2.prototype.getDirectionToRef = function(localAxis, tNode, result) {
        if (tNode === void 0) {
          tNode = null;
        }
        var wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteTransforms();
        var mat = Bone2._TmpMats[0];
        mat.copyFrom(this.getAbsoluteTransform());
        if (tNode && wm) {
          mat.multiplyToRef(wm, mat);
        }
        Vector3.TransformNormalToRef(localAxis, mat, result);
        result.normalize();
      };
      Bone2.prototype.getRotation = function(space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (tNode === void 0) {
          tNode = null;
        }
        var result = Vector3.Zero();
        this.getRotationToRef(space, tNode, result);
        return result;
      };
      Bone2.prototype.getRotationToRef = function(space, tNode, result) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (tNode === void 0) {
          tNode = null;
        }
        var quat = Bone2._TmpQuat;
        this.getRotationQuaternionToRef(space, tNode, quat);
        quat.toEulerAnglesToRef(result);
      };
      Bone2.prototype.getRotationQuaternion = function(space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (tNode === void 0) {
          tNode = null;
        }
        var result = Quaternion.Identity();
        this.getRotationQuaternionToRef(space, tNode, result);
        return result;
      };
      Bone2.prototype.getRotationQuaternionToRef = function(space, tNode, result) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (tNode === void 0) {
          tNode = null;
        }
        if (space == Space.LOCAL) {
          this._decompose();
          result.copyFrom(this._localRotation);
        } else {
          var mat = Bone2._TmpMats[0];
          var amat = this.getAbsoluteTransform();
          if (tNode) {
            amat.multiplyToRef(tNode.getWorldMatrix(), mat);
          } else {
            mat.copyFrom(amat);
          }
          mat.multiplyAtIndex(0, this._scalingDeterminant);
          mat.multiplyAtIndex(1, this._scalingDeterminant);
          mat.multiplyAtIndex(2, this._scalingDeterminant);
          mat.decompose(void 0, result, void 0);
        }
      };
      Bone2.prototype.getRotationMatrix = function(space, tNode) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var result = Matrix.Identity();
        this.getRotationMatrixToRef(space, tNode, result);
        return result;
      };
      Bone2.prototype.getRotationMatrixToRef = function(space, tNode, result) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (space == Space.LOCAL) {
          this.getLocalMatrix().getRotationMatrixToRef(result);
        } else {
          var mat = Bone2._TmpMats[0];
          var amat = this.getAbsoluteTransform();
          if (tNode) {
            amat.multiplyToRef(tNode.getWorldMatrix(), mat);
          } else {
            mat.copyFrom(amat);
          }
          mat.multiplyAtIndex(0, this._scalingDeterminant);
          mat.multiplyAtIndex(1, this._scalingDeterminant);
          mat.multiplyAtIndex(2, this._scalingDeterminant);
          mat.getRotationMatrixToRef(result);
        }
      };
      Bone2.prototype.getAbsolutePositionFromLocal = function(position, tNode) {
        if (tNode === void 0) {
          tNode = null;
        }
        var result = Vector3.Zero();
        this.getAbsolutePositionFromLocalToRef(position, tNode, result);
        return result;
      };
      Bone2.prototype.getAbsolutePositionFromLocalToRef = function(position, tNode, result) {
        if (tNode === void 0) {
          tNode = null;
        }
        var wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteTransforms();
        var tmat = Bone2._TmpMats[0];
        if (tNode && wm) {
          tmat.copyFrom(this.getAbsoluteTransform());
          tmat.multiplyToRef(wm, tmat);
        } else {
          tmat = this.getAbsoluteTransform();
        }
        Vector3.TransformCoordinatesToRef(position, tmat, result);
      };
      Bone2.prototype.getLocalPositionFromAbsolute = function(position, tNode) {
        if (tNode === void 0) {
          tNode = null;
        }
        var result = Vector3.Zero();
        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);
        return result;
      };
      Bone2.prototype.getLocalPositionFromAbsoluteToRef = function(position, tNode, result) {
        if (tNode === void 0) {
          tNode = null;
        }
        var wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteTransforms();
        var tmat = Bone2._TmpMats[0];
        tmat.copyFrom(this.getAbsoluteTransform());
        if (tNode && wm) {
          tmat.multiplyToRef(wm, tmat);
        }
        tmat.invert();
        Vector3.TransformCoordinatesToRef(position, tmat, result);
      };
      Bone2.prototype.setCurrentPoseAsRest = function() {
        this.setRestPose(this.getLocalMatrix());
      };
      Bone2._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);
      Bone2._TmpQuat = Quaternion.Identity();
      Bone2._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);
      return Bone2;
    }(Node);
  }
});

// node_modules/@babylonjs/core/Maths/math.path.js
var Orientation, BezierCurve, Angle, Arc2, Path2, Path3D, Curve3;
var init_math_path = __esm({
  "node_modules/@babylonjs/core/Maths/math.path.js"() {
    init_math_scalar();
    init_math_vector();
    init_math_constants();
    (function(Orientation2) {
      Orientation2[Orientation2["CW"] = 0] = "CW";
      Orientation2[Orientation2["CCW"] = 1] = "CCW";
    })(Orientation || (Orientation = {}));
    BezierCurve = function() {
      function BezierCurve2() {
      }
      BezierCurve2.Interpolate = function(t, x1, y1, x2, y2) {
        var f0 = 1 - 3 * x2 + 3 * x1;
        var f1 = 3 * x2 - 6 * x1;
        var f2 = 3 * x1;
        var refinedT = t;
        for (var i = 0; i < 5; i++) {
          var refinedT2 = refinedT * refinedT;
          var refinedT3 = refinedT2 * refinedT;
          var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
          var slope = 1 / (3 * f0 * refinedT2 + 2 * f1 * refinedT + f2);
          refinedT -= (x - t) * slope;
          refinedT = Math.min(1, Math.max(0, refinedT));
        }
        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
      };
      return BezierCurve2;
    }();
    Angle = function() {
      function Angle2(radians) {
        this._radians = radians;
        if (this._radians < 0) {
          this._radians += 2 * Math.PI;
        }
      }
      Angle2.prototype.degrees = function() {
        return this._radians * 180 / Math.PI;
      };
      Angle2.prototype.radians = function() {
        return this._radians;
      };
      Angle2.BetweenTwoPoints = function(a, b) {
        var delta = b.subtract(a);
        var theta = Math.atan2(delta.y, delta.x);
        return new Angle2(theta);
      };
      Angle2.FromRadians = function(radians) {
        return new Angle2(radians);
      };
      Angle2.FromDegrees = function(degrees) {
        return new Angle2(degrees * Math.PI / 180);
      };
      return Angle2;
    }();
    Arc2 = function() {
      function Arc22(startPoint, midPoint, endPoint) {
        this.startPoint = startPoint;
        this.midPoint = midPoint;
        this.endPoint = endPoint;
        var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);
        var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;
        var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;
        var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);
        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);
        this.radius = this.centerPoint.subtract(this.startPoint).length();
        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);
        var a1 = this.startAngle.degrees();
        var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();
        var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
        if (a2 - a1 > 180) {
          a2 -= 360;
        }
        if (a2 - a1 < -180) {
          a2 += 360;
        }
        if (a3 - a2 > 180) {
          a3 -= 360;
        }
        if (a3 - a2 < -180) {
          a3 += 360;
        }
        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;
        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);
      }
      return Arc22;
    }();
    Path2 = function() {
      function Path22(x, y) {
        this._points = new Array();
        this._length = 0;
        this.closed = false;
        this._points.push(new Vector2(x, y));
      }
      Path22.prototype.addLineTo = function(x, y) {
        if (this.closed) {
          return this;
        }
        var newPoint = new Vector2(x, y);
        var previousPoint = this._points[this._points.length - 1];
        this._points.push(newPoint);
        this._length += newPoint.subtract(previousPoint).length();
        return this;
      };
      Path22.prototype.addArcTo = function(midX, midY, endX, endY, numberOfSegments) {
        if (numberOfSegments === void 0) {
          numberOfSegments = 36;
        }
        if (this.closed) {
          return this;
        }
        var startPoint = this._points[this._points.length - 1];
        var midPoint = new Vector2(midX, midY);
        var endPoint = new Vector2(endX, endY);
        var arc = new Arc2(startPoint, midPoint, endPoint);
        var increment = arc.angle.radians() / numberOfSegments;
        if (arc.orientation === Orientation.CW) {
          increment *= -1;
        }
        var currentAngle = arc.startAngle.radians() + increment;
        for (var i = 0; i < numberOfSegments; i++) {
          var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;
          var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;
          this.addLineTo(x, y);
          currentAngle += increment;
        }
        return this;
      };
      Path22.prototype.close = function() {
        this.closed = true;
        return this;
      };
      Path22.prototype.length = function() {
        var result = this._length;
        if (this.closed) {
          var lastPoint = this._points[this._points.length - 1];
          var firstPoint = this._points[0];
          result += firstPoint.subtract(lastPoint).length();
        }
        return result;
      };
      Path22.prototype.getPoints = function() {
        return this._points;
      };
      Path22.prototype.getPointAtLengthPosition = function(normalizedLengthPosition) {
        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {
          return Vector2.Zero();
        }
        var lengthPosition = normalizedLengthPosition * this.length();
        var previousOffset = 0;
        for (var i = 0; i < this._points.length; i++) {
          var j = (i + 1) % this._points.length;
          var a = this._points[i];
          var b = this._points[j];
          var bToA = b.subtract(a);
          var nextOffset = bToA.length() + previousOffset;
          if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {
            var dir = bToA.normalize();
            var localOffset = lengthPosition - previousOffset;
            return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);
          }
          previousOffset = nextOffset;
        }
        return Vector2.Zero();
      };
      Path22.StartingAt = function(x, y) {
        return new Path22(x, y);
      };
      return Path22;
    }();
    Path3D = function() {
      function Path3D2(path, firstNormal, raw, alignTangentsWithPath) {
        if (firstNormal === void 0) {
          firstNormal = null;
        }
        if (alignTangentsWithPath === void 0) {
          alignTangentsWithPath = false;
        }
        this.path = path;
        this._curve = new Array();
        this._distances = new Array();
        this._tangents = new Array();
        this._normals = new Array();
        this._binormals = new Array();
        this._pointAtData = {
          id: 0,
          point: Vector3.Zero(),
          previousPointArrayIndex: 0,
          position: 0,
          subPosition: 0,
          interpolateReady: false,
          interpolationMatrix: Matrix.Identity()
        };
        for (var p = 0; p < path.length; p++) {
          this._curve[p] = path[p].clone();
        }
        this._raw = raw || false;
        this._alignTangentsWithPath = alignTangentsWithPath;
        this._compute(firstNormal, alignTangentsWithPath);
      }
      Path3D2.prototype.getCurve = function() {
        return this._curve;
      };
      Path3D2.prototype.getPoints = function() {
        return this._curve;
      };
      Path3D2.prototype.length = function() {
        return this._distances[this._distances.length - 1];
      };
      Path3D2.prototype.getTangents = function() {
        return this._tangents;
      };
      Path3D2.prototype.getNormals = function() {
        return this._normals;
      };
      Path3D2.prototype.getBinormals = function() {
        return this._binormals;
      };
      Path3D2.prototype.getDistances = function() {
        return this._distances;
      };
      Path3D2.prototype.getPointAt = function(position) {
        return this._updatePointAtData(position).point;
      };
      Path3D2.prototype.getTangentAt = function(position, interpolated) {
        if (interpolated === void 0) {
          interpolated = false;
        }
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];
      };
      Path3D2.prototype.getNormalAt = function(position, interpolated) {
        if (interpolated === void 0) {
          interpolated = false;
        }
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];
      };
      Path3D2.prototype.getBinormalAt = function(position, interpolated) {
        if (interpolated === void 0) {
          interpolated = false;
        }
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];
      };
      Path3D2.prototype.getDistanceAt = function(position) {
        return this.length() * position;
      };
      Path3D2.prototype.getPreviousPointIndexAt = function(position) {
        this._updatePointAtData(position);
        return this._pointAtData.previousPointArrayIndex;
      };
      Path3D2.prototype.getSubPositionAt = function(position) {
        this._updatePointAtData(position);
        return this._pointAtData.subPosition;
      };
      Path3D2.prototype.getClosestPositionTo = function(target) {
        var smallestDistance = Number.MAX_VALUE;
        var closestPosition = 0;
        for (var i = 0; i < this._curve.length - 1; i++) {
          var point = this._curve[i + 0];
          var tangent = this._curve[i + 1].subtract(point).normalize();
          var subLength = this._distances[i + 1] - this._distances[i + 0];
          var subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0) * Vector3.Distance(point, target) / subLength, 1);
          var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);
          if (distance < smallestDistance) {
            smallestDistance = distance;
            closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();
          }
        }
        return closestPosition;
      };
      Path3D2.prototype.slice = function(start, end) {
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = 1;
        }
        if (start < 0) {
          start = 1 - start * -1 % 1;
        }
        if (end < 0) {
          end = 1 - end * -1 % 1;
        }
        if (start > end) {
          var _start = start;
          start = end;
          end = _start;
        }
        var curvePoints = this.getCurve();
        var startPoint = this.getPointAt(start);
        var startIndex = this.getPreviousPointIndexAt(start);
        var endPoint = this.getPointAt(end);
        var endIndex = this.getPreviousPointIndexAt(end) + 1;
        var slicePoints = [];
        if (start !== 0) {
          startIndex++;
          slicePoints.push(startPoint);
        }
        slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));
        if (end !== 1 || start === 1) {
          slicePoints.push(endPoint);
        }
        return new Path3D2(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);
      };
      Path3D2.prototype.update = function(path, firstNormal, alignTangentsWithPath) {
        if (firstNormal === void 0) {
          firstNormal = null;
        }
        if (alignTangentsWithPath === void 0) {
          alignTangentsWithPath = false;
        }
        for (var p = 0; p < path.length; p++) {
          this._curve[p].x = path[p].x;
          this._curve[p].y = path[p].y;
          this._curve[p].z = path[p].z;
        }
        this._compute(firstNormal, alignTangentsWithPath);
        return this;
      };
      Path3D2.prototype._compute = function(firstNormal, alignTangentsWithPath) {
        if (alignTangentsWithPath === void 0) {
          alignTangentsWithPath = false;
        }
        var l = this._curve.length;
        if (l < 2) {
          return;
        }
        this._tangents[0] = this._getFirstNonNullVector(0);
        if (!this._raw) {
          this._tangents[0].normalize();
        }
        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);
        if (!this._raw) {
          this._tangents[l - 1].normalize();
        }
        var tg0 = this._tangents[0];
        var pp0 = this._normalVector(tg0, firstNormal);
        this._normals[0] = pp0;
        if (!this._raw) {
          this._normals[0].normalize();
        }
        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);
        if (!this._raw) {
          this._binormals[0].normalize();
        }
        this._distances[0] = 0;
        var prev;
        var cur;
        var curTang;
        var prevNor;
        var prevBinor;
        for (var i = 1; i < l; i++) {
          prev = this._getLastNonNullVector(i);
          if (i < l - 1) {
            cur = this._getFirstNonNullVector(i);
            this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);
            this._tangents[i].normalize();
          }
          this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();
          curTang = this._tangents[i];
          prevBinor = this._binormals[i - 1];
          this._normals[i] = Vector3.Cross(prevBinor, curTang);
          if (!this._raw) {
            if (this._normals[i].length() === 0) {
              prevNor = this._normals[i - 1];
              this._normals[i] = prevNor.clone();
            } else {
              this._normals[i].normalize();
            }
          }
          this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);
          if (!this._raw) {
            this._binormals[i].normalize();
          }
        }
        this._pointAtData.id = NaN;
      };
      Path3D2.prototype._getFirstNonNullVector = function(index) {
        var i = 1;
        var nNVector = this._curve[index + i].subtract(this._curve[index]);
        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {
          i++;
          nNVector = this._curve[index + i].subtract(this._curve[index]);
        }
        return nNVector;
      };
      Path3D2.prototype._getLastNonNullVector = function(index) {
        var i = 1;
        var nLVector = this._curve[index].subtract(this._curve[index - i]);
        while (nLVector.length() === 0 && index > i + 1) {
          i++;
          nLVector = this._curve[index].subtract(this._curve[index - i]);
        }
        return nLVector;
      };
      Path3D2.prototype._normalVector = function(vt, va) {
        var normal0;
        var tgl = vt.length();
        if (tgl === 0) {
          tgl = 1;
        }
        if (va === void 0 || va === null) {
          var point = void 0;
          if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1, Epsilon)) {
            point = new Vector3(0, -1, 0);
          } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1, Epsilon)) {
            point = new Vector3(1, 0, 0);
          } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1, Epsilon)) {
            point = new Vector3(0, 0, 1);
          } else {
            point = Vector3.Zero();
          }
          normal0 = Vector3.Cross(vt, point);
        } else {
          normal0 = Vector3.Cross(vt, va);
          Vector3.CrossToRef(normal0, vt, normal0);
        }
        normal0.normalize();
        return normal0;
      };
      Path3D2.prototype._updatePointAtData = function(position, interpolateTNB) {
        if (interpolateTNB === void 0) {
          interpolateTNB = false;
        }
        if (this._pointAtData.id === position) {
          if (!this._pointAtData.interpolateReady) {
            this._updateInterpolationMatrix();
          }
          return this._pointAtData;
        } else {
          this._pointAtData.id = position;
        }
        var curvePoints = this.getPoints();
        if (position <= 0) {
          return this._setPointAtData(0, 0, curvePoints[0], 0, interpolateTNB);
        } else if (position >= 1) {
          return this._setPointAtData(1, 1, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);
        }
        var previousPoint = curvePoints[0];
        var currentPoint;
        var currentLength = 0;
        var targetLength = position * this.length();
        for (var i = 1; i < curvePoints.length; i++) {
          currentPoint = curvePoints[i];
          var distance = Vector3.Distance(previousPoint, currentPoint);
          currentLength += distance;
          if (currentLength === targetLength) {
            return this._setPointAtData(position, 1, currentPoint, i, interpolateTNB);
          } else if (currentLength > targetLength) {
            var toLength = currentLength - targetLength;
            var diff = toLength / distance;
            var dir = previousPoint.subtract(currentPoint);
            var point = currentPoint.add(dir.scaleInPlace(diff));
            return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);
          }
          previousPoint = currentPoint;
        }
        return this._pointAtData;
      };
      Path3D2.prototype._setPointAtData = function(position, subPosition, point, parentIndex, interpolateTNB) {
        this._pointAtData.point = point;
        this._pointAtData.position = position;
        this._pointAtData.subPosition = subPosition;
        this._pointAtData.previousPointArrayIndex = parentIndex;
        this._pointAtData.interpolateReady = interpolateTNB;
        if (interpolateTNB) {
          this._updateInterpolationMatrix();
        }
        return this._pointAtData;
      };
      Path3D2.prototype._updateInterpolationMatrix = function() {
        this._pointAtData.interpolationMatrix = Matrix.Identity();
        var parentIndex = this._pointAtData.previousPointArrayIndex;
        if (parentIndex !== this._tangents.length - 1) {
          var index = parentIndex + 1;
          var tangentFrom = this._tangents[parentIndex].clone();
          var normalFrom = this._normals[parentIndex].clone();
          var binormalFrom = this._binormals[parentIndex].clone();
          var tangentTo = this._tangents[index].clone();
          var normalTo = this._normals[index].clone();
          var binormalTo = this._binormals[index].clone();
          var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);
          var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);
          var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);
          quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);
        }
      };
      return Path3D2;
    }();
    Curve3 = function() {
      function Curve32(points) {
        this._length = 0;
        this._points = points;
        this._length = this._computeLength(points);
      }
      Curve32.CreateQuadraticBezier = function(v0, v1, v2, nbPoints) {
        nbPoints = nbPoints > 2 ? nbPoints : 3;
        var bez = new Array();
        var equation = function(t, val0, val1, val2) {
          var res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
          return res;
        };
        for (var i = 0; i <= nbPoints; i++) {
          bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
        }
        return new Curve32(bez);
      };
      Curve32.CreateCubicBezier = function(v0, v1, v2, v3, nbPoints) {
        nbPoints = nbPoints > 3 ? nbPoints : 4;
        var bez = new Array();
        var equation = function(t, val0, val1, val2, val3) {
          var res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
          return res;
        };
        for (var i = 0; i <= nbPoints; i++) {
          bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
        }
        return new Curve32(bez);
      };
      Curve32.CreateHermiteSpline = function(p1, t1, p2, t2, nbPoints) {
        var hermite = new Array();
        var step = 1 / nbPoints;
        for (var i = 0; i <= nbPoints; i++) {
          hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));
        }
        return new Curve32(hermite);
      };
      Curve32.CreateCatmullRomSpline = function(points, nbPoints, closed) {
        var catmullRom = new Array();
        var step = 1 / nbPoints;
        var amount = 0;
        if (closed) {
          var pointsCount = points.length;
          for (var i = 0; i < pointsCount; i++) {
            amount = 0;
            for (var c = 0; c < nbPoints; c++) {
              catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
              amount += step;
            }
          }
          catmullRom.push(catmullRom[0]);
        } else {
          var totalPoints = new Array();
          totalPoints.push(points[0].clone());
          Array.prototype.push.apply(totalPoints, points);
          totalPoints.push(points[points.length - 1].clone());
          var i = 0;
          for (; i < totalPoints.length - 3; i++) {
            amount = 0;
            for (var c = 0; c < nbPoints; c++) {
              catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
              amount += step;
            }
          }
          i--;
          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
        }
        return new Curve32(catmullRom);
      };
      Curve32.ArcThru3Points = function(first, second, third, steps, closed, fullCircle) {
        if (steps === void 0) {
          steps = 32;
        }
        if (closed === void 0) {
          closed = false;
        }
        if (fullCircle === void 0) {
          fullCircle = false;
        }
        var arc = new Array();
        var vec1 = second.subtract(first);
        var vec2 = third.subtract(second);
        var vec3 = first.subtract(third);
        var zAxis = Vector3.Cross(vec1, vec2);
        var len4 = zAxis.length();
        if (len4 < Math.pow(10, -8)) {
          return new Curve32(arc);
        }
        var len1_sq = vec1.lengthSquared();
        var len2_sq = vec2.lengthSquared();
        var len3_sq = vec3.lengthSquared();
        var len4_sq = zAxis.lengthSquared();
        var len1 = vec1.length();
        var len2 = vec2.length();
        var len3 = vec3.length();
        var radius = 0.5 * len1 * len2 * len3 / len4;
        var dot1 = Vector3.Dot(vec1, vec3);
        var dot2 = Vector3.Dot(vec1, vec2);
        var dot3 = Vector3.Dot(vec2, vec3);
        var a = -0.5 * len2_sq * dot1 / len4_sq;
        var b = -0.5 * len3_sq * dot2 / len4_sq;
        var c = -0.5 * len1_sq * dot3 / len4_sq;
        var center = first.scale(a).add(second.scale(b)).add(third.scale(c));
        var radiusVec = first.subtract(center);
        var xAxis = radiusVec.normalize();
        var yAxis = Vector3.Cross(zAxis, xAxis).normalize();
        if (fullCircle) {
          var dStep = 2 * Math.PI / steps;
          for (var theta = 0; theta <= 2 * Math.PI; theta += dStep) {
            arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));
          }
          arc.push(first);
        } else {
          var dStep = 1 / steps;
          var theta = 0;
          var point = Vector3.Zero();
          do {
            point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));
            arc.push(point);
            theta += dStep;
          } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));
          arc.push(third);
          if (closed) {
            arc.push(first);
          }
        }
        return new Curve32(arc);
      };
      Curve32.prototype.getPoints = function() {
        return this._points;
      };
      Curve32.prototype.length = function() {
        return this._length;
      };
      Curve32.prototype.continue = function(curve) {
        var lastPoint = this._points[this._points.length - 1];
        var continuedPoints = this._points.slice();
        var curvePoints = curve.getPoints();
        for (var i = 1; i < curvePoints.length; i++) {
          continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
        }
        var continuedCurve = new Curve32(continuedPoints);
        return continuedCurve;
      };
      Curve32.prototype._computeLength = function(path) {
        var l = 0;
        for (var i = 1; i < path.length; i++) {
          l += path[i].subtract(path[i - 1]).length();
        }
        return l;
      };
      return Curve32;
    }();
  }
});

// node_modules/@babylonjs/core/Animations/animationEvent.js
var AnimationEvent;
var init_animationEvent = __esm({
  "node_modules/@babylonjs/core/Animations/animationEvent.js"() {
    AnimationEvent = function() {
      function AnimationEvent2(frame, action, onlyOnce) {
        this.frame = frame;
        this.action = action;
        this.onlyOnce = onlyOnce;
        this.isDone = false;
      }
      AnimationEvent2.prototype._clone = function() {
        return new AnimationEvent2(this.frame, this.action, this.onlyOnce);
      };
      return AnimationEvent2;
    }();
  }
});

// node_modules/@babylonjs/core/Animations/animationGroup.js
var TargetedAnimation, AnimationGroup;
var init_animationGroup = __esm({
  "node_modules/@babylonjs/core/Animations/animationGroup.js"() {
    init_animation();
    init_observable();
    init_engineStore();
    init_tags();
    TargetedAnimation = function() {
      function TargetedAnimation2() {
      }
      TargetedAnimation2.prototype.getClassName = function() {
        return "TargetedAnimation";
      };
      TargetedAnimation2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.animation = this.animation.serialize();
        serializationObject.targetId = this.target.id;
        return serializationObject;
      };
      return TargetedAnimation2;
    }();
    AnimationGroup = function() {
      function AnimationGroup2(name105, scene) {
        if (scene === void 0) {
          scene = null;
        }
        this.name = name105;
        this._targetedAnimations = new Array();
        this._animatables = new Array();
        this._from = Number.MAX_VALUE;
        this._to = -Number.MAX_VALUE;
        this._speedRatio = 1;
        this._loopAnimation = false;
        this._isAdditive = false;
        this._parentContainer = null;
        this.onAnimationEndObservable = new Observable();
        this.onAnimationLoopObservable = new Observable();
        this.onAnimationGroupLoopObservable = new Observable();
        this.onAnimationGroupEndObservable = new Observable();
        this.onAnimationGroupPauseObservable = new Observable();
        this.onAnimationGroupPlayObservable = new Observable();
        this.metadata = null;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.uniqueId = this._scene.getUniqueId();
        this._scene.addAnimationGroup(this);
      }
      Object.defineProperty(AnimationGroup2.prototype, "from", {
        get: function() {
          return this._from;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "to", {
        get: function() {
          return this._to;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "isStarted", {
        get: function() {
          return this._isStarted;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "isPlaying", {
        get: function() {
          return this._isStarted && !this._isPaused;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "speedRatio", {
        get: function() {
          return this._speedRatio;
        },
        set: function(value) {
          if (this._speedRatio === value) {
            return;
          }
          this._speedRatio = value;
          for (var index = 0; index < this._animatables.length; index++) {
            var animatable = this._animatables[index];
            animatable.speedRatio = this._speedRatio;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "loopAnimation", {
        get: function() {
          return this._loopAnimation;
        },
        set: function(value) {
          if (this._loopAnimation === value) {
            return;
          }
          this._loopAnimation = value;
          for (var index = 0; index < this._animatables.length; index++) {
            var animatable = this._animatables[index];
            animatable.loopAnimation = this._loopAnimation;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "isAdditive", {
        get: function() {
          return this._isAdditive;
        },
        set: function(value) {
          if (this._isAdditive === value) {
            return;
          }
          this._isAdditive = value;
          for (var index = 0; index < this._animatables.length; index++) {
            var animatable = this._animatables[index];
            animatable.isAdditive = this._isAdditive;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "targetedAnimations", {
        get: function() {
          return this._targetedAnimations;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "animatables", {
        get: function() {
          return this._animatables;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimationGroup2.prototype, "children", {
        get: function() {
          return this._targetedAnimations;
        },
        enumerable: false,
        configurable: true
      });
      AnimationGroup2.prototype.addTargetedAnimation = function(animation, target) {
        var targetedAnimation = new TargetedAnimation();
        targetedAnimation.animation = animation;
        targetedAnimation.target = target;
        var keys = animation.getKeys();
        if (this._from > keys[0].frame) {
          this._from = keys[0].frame;
        }
        if (this._to < keys[keys.length - 1].frame) {
          this._to = keys[keys.length - 1].frame;
        }
        this._targetedAnimations.push(targetedAnimation);
        return targetedAnimation;
      };
      AnimationGroup2.prototype.normalize = function(beginFrame, endFrame) {
        if (beginFrame === void 0) {
          beginFrame = null;
        }
        if (endFrame === void 0) {
          endFrame = null;
        }
        if (beginFrame == null) {
          beginFrame = this._from;
        }
        if (endFrame == null) {
          endFrame = this._to;
        }
        for (var index = 0; index < this._targetedAnimations.length; index++) {
          var targetedAnimation = this._targetedAnimations[index];
          var keys = targetedAnimation.animation.getKeys();
          var startKey = keys[0];
          var endKey = keys[keys.length - 1];
          if (startKey.frame > beginFrame) {
            var newKey = {
              frame: beginFrame,
              value: startKey.value,
              inTangent: startKey.inTangent,
              outTangent: startKey.outTangent,
              interpolation: startKey.interpolation
            };
            keys.splice(0, 0, newKey);
          }
          if (endKey.frame < endFrame) {
            var newKey = {
              frame: endFrame,
              value: endKey.value,
              inTangent: endKey.inTangent,
              outTangent: endKey.outTangent,
              interpolation: endKey.interpolation
            };
            keys.push(newKey);
          }
        }
        this._from = beginFrame;
        this._to = endFrame;
        return this;
      };
      AnimationGroup2.prototype._processLoop = function(animatable, targetedAnimation, index) {
        var _this = this;
        animatable.onAnimationLoop = function() {
          _this.onAnimationLoopObservable.notifyObservers(targetedAnimation);
          if (_this._animationLoopFlags[index]) {
            return;
          }
          _this._animationLoopFlags[index] = true;
          _this._animationLoopCount++;
          if (_this._animationLoopCount === _this._targetedAnimations.length) {
            _this.onAnimationGroupLoopObservable.notifyObservers(_this);
            _this._animationLoopCount = 0;
            _this._animationLoopFlags = [];
          }
        };
      };
      AnimationGroup2.prototype.start = function(loop, speedRatio, from, to, isAdditive) {
        var _this = this;
        if (loop === void 0) {
          loop = false;
        }
        if (speedRatio === void 0) {
          speedRatio = 1;
        }
        if (this._isStarted || this._targetedAnimations.length === 0) {
          return this;
        }
        this._loopAnimation = loop;
        this._animationLoopCount = 0;
        this._animationLoopFlags = [];
        var _loop_1 = function(index2) {
          var targetedAnimation = this_1._targetedAnimations[index2];
          var animatable = this_1._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== void 0 ? from : this_1._from, to !== void 0 ? to : this_1._to, loop, speedRatio, void 0, void 0, isAdditive !== void 0 ? isAdditive : this_1._isAdditive);
          animatable.onAnimationEnd = function() {
            _this.onAnimationEndObservable.notifyObservers(targetedAnimation);
            _this._checkAnimationGroupEnded(animatable);
          };
          this_1._processLoop(animatable, targetedAnimation, index2);
          this_1._animatables.push(animatable);
        };
        var this_1 = this;
        for (var index = 0; index < this._targetedAnimations.length; index++) {
          _loop_1(index);
        }
        this._speedRatio = speedRatio;
        this._isStarted = true;
        this._isPaused = false;
        this.onAnimationGroupPlayObservable.notifyObservers(this);
        return this;
      };
      AnimationGroup2.prototype.pause = function() {
        if (!this._isStarted) {
          return this;
        }
        this._isPaused = true;
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.pause();
        }
        this.onAnimationGroupPauseObservable.notifyObservers(this);
        return this;
      };
      AnimationGroup2.prototype.play = function(loop) {
        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {
          if (loop !== void 0) {
            this.loopAnimation = loop;
          }
          this.restart();
        } else {
          this.stop();
          this.start(loop, this._speedRatio);
        }
        this._isPaused = false;
        return this;
      };
      AnimationGroup2.prototype.reset = function() {
        if (!this._isStarted) {
          this.play();
          this.goToFrame(0);
          this.stop();
          return this;
        }
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.reset();
        }
        return this;
      };
      AnimationGroup2.prototype.restart = function() {
        if (!this._isStarted) {
          return this;
        }
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.restart();
        }
        this.onAnimationGroupPlayObservable.notifyObservers(this);
        return this;
      };
      AnimationGroup2.prototype.stop = function() {
        if (!this._isStarted) {
          return this;
        }
        var list = this._animatables.slice();
        for (var index = 0; index < list.length; index++) {
          list[index].stop();
        }
        this._isStarted = false;
        return this;
      };
      AnimationGroup2.prototype.setWeightForAllAnimatables = function(weight) {
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.weight = weight;
        }
        return this;
      };
      AnimationGroup2.prototype.syncAllAnimationsWith = function(root) {
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.syncWith(root);
        }
        return this;
      };
      AnimationGroup2.prototype.goToFrame = function(frame) {
        if (!this._isStarted) {
          return this;
        }
        for (var index = 0; index < this._animatables.length; index++) {
          var animatable = this._animatables[index];
          animatable.goToFrame(frame);
        }
        return this;
      };
      AnimationGroup2.prototype.dispose = function() {
        this._targetedAnimations = [];
        this._animatables = [];
        var index = this._scene.animationGroups.indexOf(this);
        if (index > -1) {
          this._scene.animationGroups.splice(index, 1);
        }
        if (this._parentContainer) {
          var index_1 = this._parentContainer.animationGroups.indexOf(this);
          if (index_1 > -1) {
            this._parentContainer.animationGroups.splice(index_1, 1);
          }
          this._parentContainer = null;
        }
        this.onAnimationEndObservable.clear();
        this.onAnimationGroupEndObservable.clear();
        this.onAnimationGroupPauseObservable.clear();
        this.onAnimationGroupPlayObservable.clear();
        this.onAnimationLoopObservable.clear();
        this.onAnimationGroupLoopObservable.clear();
      };
      AnimationGroup2.prototype._checkAnimationGroupEnded = function(animatable) {
        var idx = this._animatables.indexOf(animatable);
        if (idx > -1) {
          this._animatables.splice(idx, 1);
        }
        if (this._animatables.length === 0) {
          this._isStarted = false;
          this.onAnimationGroupEndObservable.notifyObservers(this);
        }
      };
      AnimationGroup2.prototype.clone = function(newName, targetConverter, cloneAnimations) {
        if (cloneAnimations === void 0) {
          cloneAnimations = false;
        }
        var newGroup = new AnimationGroup2(newName || this.name, this._scene);
        for (var _i = 0, _a = this._targetedAnimations; _i < _a.length; _i++) {
          var targetAnimation = _a[_i];
          newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);
        }
        return newGroup;
      };
      AnimationGroup2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.from = this.from;
        serializationObject.to = this.to;
        serializationObject.targetedAnimations = [];
        for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {
          var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];
          serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();
        }
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        return serializationObject;
      };
      AnimationGroup2.Parse = function(parsedAnimationGroup, scene) {
        var animationGroup = new AnimationGroup2(parsedAnimationGroup.name, scene);
        for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {
          var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];
          var animation = Animation.Parse(targetedAnimation.animation);
          var id = targetedAnimation.targetId;
          if (targetedAnimation.animation.property === "influence") {
            var morphTarget = scene.getMorphTargetById(id);
            if (morphTarget) {
              animationGroup.addTargetedAnimation(animation, morphTarget);
            }
          } else {
            var targetNode = scene.getNodeById(id);
            if (targetNode != null) {
              animationGroup.addTargetedAnimation(animation, targetNode);
            }
          }
        }
        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {
          animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);
        }
        if (Tags) {
          Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);
        }
        if (parsedAnimationGroup.metadata !== void 0) {
          animationGroup.metadata = parsedAnimationGroup.metadata;
        }
        return animationGroup;
      };
      AnimationGroup2.MakeAnimationAdditive = function(sourceAnimationGroup, referenceFrame, range, cloneOriginal, clonedName) {
        if (referenceFrame === void 0) {
          referenceFrame = 0;
        }
        if (cloneOriginal === void 0) {
          cloneOriginal = false;
        }
        var animationGroup = sourceAnimationGroup;
        if (cloneOriginal) {
          animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);
        }
        var targetedAnimations = animationGroup.targetedAnimations;
        for (var index = 0; index < targetedAnimations.length; index++) {
          var targetedAnimation = targetedAnimations[index];
          Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);
        }
        animationGroup.isAdditive = true;
        return animationGroup;
      };
      AnimationGroup2.prototype.getClassName = function() {
        return "AnimationGroup";
      };
      AnimationGroup2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name;
        ret += ", type: " + this.getClassName();
        if (fullDetails) {
          ret += ", from: " + this._from;
          ret += ", to: " + this._to;
          ret += ", isStarted: " + this._isStarted;
          ret += ", speedRatio: " + this._speedRatio;
          ret += ", targetedAnimations length: " + this._targetedAnimations.length;
          ret += ", animatables length: " + this._animatables;
        }
        return ret;
      };
      return AnimationGroup2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/coroutine.js
function inlineScheduler(coroutine, onStep, onError) {
  try {
    var step_1 = coroutine.next();
    if (step_1.done) {
      onStep(step_1);
    } else if (!step_1.value) {
      onStep(step_1);
    } else {
      step_1.value.then(function() {
        step_1.value = void 0;
        onStep(step_1);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS) {
  if (yieldAfterMS === void 0) {
    yieldAfterMS = 25;
  }
  var startTime;
  return function(coroutine, onStep, onError) {
    var currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(function() {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  var resume = function() {
    var reschedule;
    var onStep = function(stepResult) {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  var result;
  runCoroutine(coroutine, inlineScheduler, function(r) {
    return result = r;
  }, function(e) {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise(function(resolve, reject) {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return runCoroutineSync(coroutineFactory.apply(void 0, params), abortSignal);
  };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
  return function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return runCoroutineAsync(coroutineFactory.apply(void 0, params), scheduler, abortSignal);
  };
}
var init_coroutine = __esm({
  "node_modules/@babylonjs/core/Misc/coroutine.js"() {
  }
});

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexData;
var init_mesh_vertexData = __esm({
  "node_modules/@babylonjs/core/Meshes/mesh.vertexData.js"() {
    init_tslib_es6();
    init_math_vector();
    init_buffer();
    init_devTools();
    init_math_color();
    init_logger();
    init_decorators();
    init_coroutine();
    init_error();
    VertexData = function() {
      function VertexData2() {
        this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
      }
      VertexData2.prototype.set = function(data, kind) {
        if (!data.length) {
          Logger.Warn("Setting vertex data kind '".concat(kind, "' with an empty array"));
        }
        switch (kind) {
          case VertexBuffer.PositionKind:
            this.positions = data;
            break;
          case VertexBuffer.NormalKind:
            this.normals = data;
            break;
          case VertexBuffer.TangentKind:
            this.tangents = data;
            break;
          case VertexBuffer.UVKind:
            this.uvs = data;
            break;
          case VertexBuffer.UV2Kind:
            this.uvs2 = data;
            break;
          case VertexBuffer.UV3Kind:
            this.uvs3 = data;
            break;
          case VertexBuffer.UV4Kind:
            this.uvs4 = data;
            break;
          case VertexBuffer.UV5Kind:
            this.uvs5 = data;
            break;
          case VertexBuffer.UV6Kind:
            this.uvs6 = data;
            break;
          case VertexBuffer.ColorKind:
            this.colors = data;
            break;
          case VertexBuffer.MatricesIndicesKind:
            this.matricesIndices = data;
            break;
          case VertexBuffer.MatricesWeightsKind:
            this.matricesWeights = data;
            break;
          case VertexBuffer.MatricesIndicesExtraKind:
            this.matricesIndicesExtra = data;
            break;
          case VertexBuffer.MatricesWeightsExtraKind:
            this.matricesWeightsExtra = data;
            break;
        }
      };
      VertexData2.prototype.applyToMesh = function(mesh, updatable) {
        this._applyTo(mesh, updatable, false);
        return this;
      };
      VertexData2.prototype.applyToGeometry = function(geometry, updatable) {
        this._applyTo(geometry, updatable, false);
        return this;
      };
      VertexData2.prototype.updateMesh = function(mesh) {
        this._update(mesh);
        return this;
      };
      VertexData2.prototype.updateGeometry = function(geometry) {
        this._update(geometry);
        return this;
      };
      VertexData2.prototype._applyToCoroutine = function(meshOrGeometry, updatable, isAsync) {
        if (updatable === void 0) {
          updatable = false;
        }
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!this.positions)
                return [3, 2];
              meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
              if (!isAsync)
                return [3, 2];
              return [4];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              if (!this.normals)
                return [3, 4];
              meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
              if (!isAsync)
                return [3, 4];
              return [4];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              if (!this.tangents)
                return [3, 6];
              meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
              if (!isAsync)
                return [3, 6];
              return [4];
            case 5:
              _a.sent();
              _a.label = 6;
            case 6:
              if (!this.uvs)
                return [3, 8];
              meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
              if (!isAsync)
                return [3, 8];
              return [4];
            case 7:
              _a.sent();
              _a.label = 8;
            case 8:
              if (!this.uvs2)
                return [3, 10];
              meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
              if (!isAsync)
                return [3, 10];
              return [4];
            case 9:
              _a.sent();
              _a.label = 10;
            case 10:
              if (!this.uvs3)
                return [3, 12];
              meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
              if (!isAsync)
                return [3, 12];
              return [4];
            case 11:
              _a.sent();
              _a.label = 12;
            case 12:
              if (!this.uvs4)
                return [3, 14];
              meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
              if (!isAsync)
                return [3, 14];
              return [4];
            case 13:
              _a.sent();
              _a.label = 14;
            case 14:
              if (!this.uvs5)
                return [3, 16];
              meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
              if (!isAsync)
                return [3, 16];
              return [4];
            case 15:
              _a.sent();
              _a.label = 16;
            case 16:
              if (!this.uvs6)
                return [3, 18];
              meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
              if (!isAsync)
                return [3, 18];
              return [4];
            case 17:
              _a.sent();
              _a.label = 18;
            case 18:
              if (!this.colors)
                return [3, 20];
              meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
              if (!isAsync)
                return [3, 20];
              return [4];
            case 19:
              _a.sent();
              _a.label = 20;
            case 20:
              if (!this.matricesIndices)
                return [3, 22];
              meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
              if (!isAsync)
                return [3, 22];
              return [4];
            case 21:
              _a.sent();
              _a.label = 22;
            case 22:
              if (!this.matricesWeights)
                return [3, 24];
              meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
              if (!isAsync)
                return [3, 24];
              return [4];
            case 23:
              _a.sent();
              _a.label = 24;
            case 24:
              if (!this.matricesIndicesExtra)
                return [3, 26];
              meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
              if (!isAsync)
                return [3, 26];
              return [4];
            case 25:
              _a.sent();
              _a.label = 26;
            case 26:
              if (!this.matricesWeightsExtra)
                return [3, 28];
              meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
              if (!isAsync)
                return [3, 28];
              return [4];
            case 27:
              _a.sent();
              _a.label = 28;
            case 28:
              if (!this.indices)
                return [3, 31];
              meshOrGeometry.setIndices(this.indices, null, updatable);
              if (!isAsync)
                return [3, 30];
              return [4];
            case 29:
              _a.sent();
              _a.label = 30;
            case 30:
              return [3, 32];
            case 31:
              meshOrGeometry.setIndices([], null);
              _a.label = 32;
            case 32:
              return [2, this];
          }
        });
      };
      VertexData2.prototype._update = function(meshOrGeometry, updateExtends, makeItUnique) {
        if (this.positions) {
          meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
        }
        if (this.normals) {
          meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
        }
        if (this.tangents) {
          meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
        }
        if (this.uvs) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
        }
        if (this.uvs2) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
        }
        if (this.uvs3) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
        }
        if (this.uvs4) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
        }
        if (this.uvs5) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
        }
        if (this.uvs6) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
        }
        if (this.colors) {
          meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
        }
        if (this.matricesIndices) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
        }
        if (this.matricesWeights) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
        }
        if (this.matricesIndicesExtra) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
        }
        if (this.matricesWeightsExtra) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
        }
        if (this.indices) {
          meshOrGeometry.setIndices(this.indices, null);
        }
        return this;
      };
      VertexData2._TransformVector3Coordinates = function(coordinates, transformation, offset, length) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = coordinates.length;
        }
        var coordinate = TmpVectors.Vector3[0];
        var transformedCoordinate = TmpVectors.Vector3[1];
        for (var index = offset; index < offset + length; index += 3) {
          Vector3.FromArrayToRef(coordinates, index, coordinate);
          Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
          coordinates[index] = transformedCoordinate.x;
          coordinates[index + 1] = transformedCoordinate.y;
          coordinates[index + 2] = transformedCoordinate.z;
        }
      };
      VertexData2._TransformVector3Normals = function(normals, transformation, offset, length) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = normals.length;
        }
        var normal = TmpVectors.Vector3[0];
        var transformedNormal = TmpVectors.Vector3[1];
        for (var index = offset; index < offset + length; index += 3) {
          Vector3.FromArrayToRef(normals, index, normal);
          Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
          normals[index] = transformedNormal.x;
          normals[index + 1] = transformedNormal.y;
          normals[index + 2] = transformedNormal.z;
        }
      };
      VertexData2._TransformVector4Normals = function(normals, transformation, offset, length) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = normals.length;
        }
        var normal = TmpVectors.Vector4[0];
        var transformedNormal = TmpVectors.Vector4[1];
        for (var index = offset; index < offset + length; index += 4) {
          Vector4.FromArrayToRef(normals, index, normal);
          Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
          normals[index] = transformedNormal.x;
          normals[index + 1] = transformedNormal.y;
          normals[index + 2] = transformedNormal.z;
          normals[index + 3] = transformedNormal.w;
        }
      };
      VertexData2._FlipFaces = function(indices, offset, length) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = indices.length;
        }
        for (var index = offset; index < offset + length; index += 3) {
          var tmp = indices[index + 1];
          indices[index + 1] = indices[index + 2];
          indices[index + 2] = tmp;
        }
      };
      VertexData2.prototype.transform = function(matrix) {
        var flip = matrix.determinant() < 0;
        if (this.positions) {
          VertexData2._TransformVector3Coordinates(this.positions, matrix);
        }
        if (this.normals) {
          VertexData2._TransformVector3Normals(this.normals, matrix);
        }
        if (this.tangents) {
          VertexData2._TransformVector4Normals(this.tangents, matrix);
        }
        if (flip && this.indices) {
          VertexData2._FlipFaces(this.indices);
        }
        return this;
      };
      VertexData2.prototype.merge = function(others, use32BitsIndices, forceCloneIndices) {
        if (use32BitsIndices === void 0) {
          use32BitsIndices = false;
        }
        if (forceCloneIndices === void 0) {
          forceCloneIndices = false;
        }
        var vertexDatas = Array.isArray(others) ? others.map(function(other) {
          return [other, void 0];
        }) : [[others, void 0]];
        return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices));
      };
      VertexData2.prototype._mergeCoroutine = function(transform, vertexDatas, use32BitsIndices, isAsync, forceCloneIndices) {
        var others, _i, others_1, other, totalIndices, sliceIndices, indices, indicesOffset, temp, positionsOffset, _a, vertexDatas_1, _b, other, transform_1, index;
        var _this = this;
        var _c, _d, _e, _f;
        if (use32BitsIndices === void 0) {
          use32BitsIndices = false;
        }
        return __generator(this, function(_g) {
          switch (_g.label) {
            case 0:
              this._validate();
              others = vertexDatas.map(function(vertexData) {
                return vertexData[0];
              });
              for (_i = 0, others_1 = others; _i < others_1.length; _i++) {
                other = others_1[_i];
                other._validate();
                if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
                  throw new Error("Cannot merge vertex data that do not have the same set of attributes");
                }
              }
              totalIndices = others.reduce(function(indexSum, vertexData) {
                var _a2, _b2;
                return indexSum + ((_b2 = (_a2 = vertexData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0);
              }, (_d = (_c = this.indices) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0);
              sliceIndices = forceCloneIndices || others.some(function(vertexData) {
                return vertexData.indices === _this.indices;
              });
              indices = sliceIndices ? (_e = this.indices) === null || _e === void 0 ? void 0 : _e.slice() : this.indices;
              if (!(totalIndices > 0))
                return [3, 4];
              indicesOffset = (_f = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _f !== void 0 ? _f : 0;
              if (!indices) {
                indices = new Array(totalIndices);
              }
              if (indices.length !== totalIndices) {
                if (Array.isArray(indices)) {
                  indices.length = totalIndices;
                } else {
                  temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
                  temp.set(indices);
                  indices = temp;
                }
                if (transform && transform.determinant() < 0) {
                  VertexData2._FlipFaces(indices, 0, indicesOffset);
                }
              }
              positionsOffset = this.positions ? this.positions.length / 3 : 0;
              _a = 0, vertexDatas_1 = vertexDatas;
              _g.label = 1;
            case 1:
              if (!(_a < vertexDatas_1.length))
                return [3, 4];
              _b = vertexDatas_1[_a], other = _b[0], transform_1 = _b[1];
              if (!other.indices)
                return [3, 3];
              for (index = 0; index < other.indices.length; index++) {
                indices[indicesOffset + index] = other.indices[index] + positionsOffset;
              }
              if (transform_1 && transform_1.determinant() < 0) {
                VertexData2._FlipFaces(indices, indicesOffset, other.indices.length);
              }
              positionsOffset += other.positions.length / 3;
              indicesOffset += other.indices.length;
              if (!isAsync)
                return [3, 3];
              return [4];
            case 2:
              _g.sent();
              _g.label = 3;
            case 3:
              _a++;
              return [3, 1];
            case 4:
              this.indices = indices;
              this.positions = VertexData2._MergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map(function(other2) {
                return [other2[0].positions, other2[1]];
              }));
              if (!isAsync)
                return [3, 6];
              return [4];
            case 5:
              _g.sent();
              _g.label = 6;
            case 6:
              this.normals = VertexData2._MergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map(function(other2) {
                return [other2[0].normals, other2[1]];
              }));
              if (!isAsync)
                return [3, 8];
              return [4];
            case 7:
              _g.sent();
              _g.label = 8;
            case 8:
              this.tangents = VertexData2._MergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map(function(other2) {
                return [other2[0].tangents, other2[1]];
              }));
              if (!isAsync)
                return [3, 10];
              return [4];
            case 9:
              _g.sent();
              _g.label = 10;
            case 10:
              this.uvs = VertexData2._MergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs, other2[1]];
              }));
              if (!isAsync)
                return [3, 12];
              return [4];
            case 11:
              _g.sent();
              _g.label = 12;
            case 12:
              this.uvs2 = VertexData2._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs2, other2[1]];
              }));
              if (!isAsync)
                return [3, 14];
              return [4];
            case 13:
              _g.sent();
              _g.label = 14;
            case 14:
              this.uvs3 = VertexData2._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs3, other2[1]];
              }));
              if (!isAsync)
                return [3, 16];
              return [4];
            case 15:
              _g.sent();
              _g.label = 16;
            case 16:
              this.uvs4 = VertexData2._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs4, other2[1]];
              }));
              if (!isAsync)
                return [3, 18];
              return [4];
            case 17:
              _g.sent();
              _g.label = 18;
            case 18:
              this.uvs5 = VertexData2._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs5, other2[1]];
              }));
              if (!isAsync)
                return [3, 20];
              return [4];
            case 19:
              _g.sent();
              _g.label = 20;
            case 20:
              this.uvs6 = VertexData2._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map(function(other2) {
                return [other2[0].uvs6, other2[1]];
              }));
              if (!isAsync)
                return [3, 22];
              return [4];
            case 21:
              _g.sent();
              _g.label = 22;
            case 22:
              this.colors = VertexData2._MergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map(function(other2) {
                return [other2[0].colors, other2[1]];
              }));
              if (!isAsync)
                return [3, 24];
              return [4];
            case 23:
              _g.sent();
              _g.label = 24;
            case 24:
              this.matricesIndices = VertexData2._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map(function(other2) {
                return [other2[0].matricesIndices, other2[1]];
              }));
              if (!isAsync)
                return [3, 26];
              return [4];
            case 25:
              _g.sent();
              _g.label = 26;
            case 26:
              this.matricesWeights = VertexData2._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map(function(other2) {
                return [other2[0].matricesWeights, other2[1]];
              }));
              if (!isAsync)
                return [3, 28];
              return [4];
            case 27:
              _g.sent();
              _g.label = 28;
            case 28:
              this.matricesIndicesExtra = VertexData2._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map(function(other2) {
                return [other2[0].matricesIndicesExtra, other2[1]];
              }));
              if (!isAsync)
                return [3, 30];
              return [4];
            case 29:
              _g.sent();
              _g.label = 30;
            case 30:
              this.matricesWeightsExtra = VertexData2._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map(function(other2) {
                return [other2[0].matricesWeightsExtra, other2[1]];
              }));
              return [2, this];
          }
        });
      };
      VertexData2._MergeElement = function(kind, source, transform, others) {
        var nonNullOthers = others.filter(function(other) {
          return other[0] !== null && other[0] !== void 0;
        });
        if (!source && nonNullOthers.length == 0) {
          return source;
        }
        if (!source) {
          return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
        }
        var len = nonNullOthers.reduce(function(sumLen, elements) {
          return sumLen + elements[0].length;
        }, source.length);
        var transformRange = kind === VertexBuffer.PositionKind ? VertexData2._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData2._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData2._TransformVector4Normals : function() {
        };
        if (source instanceof Float32Array) {
          var ret32 = new Float32Array(len);
          ret32.set(source);
          transform && transformRange(ret32, transform, 0, source.length);
          var offset = source.length;
          for (var _i = 0, nonNullOthers_1 = nonNullOthers; _i < nonNullOthers_1.length; _i++) {
            var _a = nonNullOthers_1[_i], vertexData = _a[0], transform_2 = _a[1];
            ret32.set(vertexData, offset);
            transform_2 && transformRange(ret32, transform_2, offset, vertexData.length);
            offset += vertexData.length;
          }
          return ret32;
        } else {
          var ret = new Array(len);
          for (var i = 0; i < source.length; i++) {
            ret[i] = source[i];
          }
          transform && transformRange(ret, transform, 0, source.length);
          var offset = source.length;
          for (var _b = 0, nonNullOthers_2 = nonNullOthers; _b < nonNullOthers_2.length; _b++) {
            var _c = nonNullOthers_2[_b], vertexData = _c[0], transform_3 = _c[1];
            for (var i = 0; i < vertexData.length; i++) {
              ret[offset + i] = vertexData[i];
            }
            transform_3 && transformRange(ret, transform_3, offset, vertexData.length);
            offset += vertexData.length;
          }
          return ret;
        }
      };
      VertexData2.prototype._validate = function() {
        if (!this.positions) {
          throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
        }
        var getElementCount = function(kind, values) {
          var stride = VertexBuffer.DeduceStride(kind);
          if (values.length % stride !== 0) {
            throw new Error("The " + kind + "s array count must be a multiple of " + stride);
          }
          return values.length / stride;
        };
        var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
        var validateElementCount = function(kind, values) {
          var elementCount = getElementCount(kind, values);
          if (elementCount !== positionsElementCount) {
            throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
          }
        };
        if (this.normals) {
          validateElementCount(VertexBuffer.NormalKind, this.normals);
        }
        if (this.tangents) {
          validateElementCount(VertexBuffer.TangentKind, this.tangents);
        }
        if (this.uvs) {
          validateElementCount(VertexBuffer.UVKind, this.uvs);
        }
        if (this.uvs2) {
          validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
        }
        if (this.uvs3) {
          validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
        }
        if (this.uvs4) {
          validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
        }
        if (this.uvs5) {
          validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
        }
        if (this.uvs6) {
          validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
        }
        if (this.colors) {
          validateElementCount(VertexBuffer.ColorKind, this.colors);
        }
        if (this.matricesIndices) {
          validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
        }
        if (this.matricesWeights) {
          validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
        }
        if (this.matricesIndicesExtra) {
          validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
        }
        if (this.matricesWeightsExtra) {
          validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
        }
      };
      VertexData2.prototype.serialize = function() {
        var serializationObject = {};
        if (this.positions) {
          serializationObject.positions = this.positions;
        }
        if (this.normals) {
          serializationObject.normals = this.normals;
        }
        if (this.tangents) {
          serializationObject.tangents = this.tangents;
        }
        if (this.uvs) {
          serializationObject.uvs = this.uvs;
        }
        if (this.uvs2) {
          serializationObject.uvs2 = this.uvs2;
        }
        if (this.uvs3) {
          serializationObject.uvs3 = this.uvs3;
        }
        if (this.uvs4) {
          serializationObject.uvs4 = this.uvs4;
        }
        if (this.uvs5) {
          serializationObject.uvs5 = this.uvs5;
        }
        if (this.uvs6) {
          serializationObject.uvs6 = this.uvs6;
        }
        if (this.colors) {
          serializationObject.colors = this.colors;
        }
        if (this.matricesIndices) {
          serializationObject.matricesIndices = this.matricesIndices;
          serializationObject.matricesIndices._isExpanded = true;
        }
        if (this.matricesWeights) {
          serializationObject.matricesWeights = this.matricesWeights;
        }
        if (this.matricesIndicesExtra) {
          serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;
          serializationObject.matricesIndicesExtra._isExpanded = true;
        }
        if (this.matricesWeightsExtra) {
          serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;
        }
        serializationObject.indices = this.indices;
        return serializationObject;
      };
      VertexData2.ExtractFromMesh = function(mesh, copyWhenShared, forceCopy) {
        return VertexData2._ExtractFrom(mesh, copyWhenShared, forceCopy);
      };
      VertexData2.ExtractFromGeometry = function(geometry, copyWhenShared, forceCopy) {
        return VertexData2._ExtractFrom(geometry, copyWhenShared, forceCopy);
      };
      VertexData2._ExtractFrom = function(meshOrGeometry, copyWhenShared, forceCopy) {
        var result = new VertexData2();
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
          result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
          result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
          result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
          result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
          result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
          result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
        }
        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
        return result;
      };
      VertexData2.CreateRibbon = function(options) {
        throw _WarnImport("ribbonBuilder");
      };
      VertexData2.CreateBox = function(options) {
        throw _WarnImport("boxBuilder");
      };
      VertexData2.CreateTiledBox = function(options) {
        throw _WarnImport("tiledBoxBuilder");
      };
      VertexData2.CreateTiledPlane = function(options) {
        throw _WarnImport("tiledPlaneBuilder");
      };
      VertexData2.CreateSphere = function(options) {
        throw _WarnImport("sphereBuilder");
      };
      VertexData2.CreateCylinder = function(options) {
        throw _WarnImport("cylinderBuilder");
      };
      VertexData2.CreateTorus = function(options) {
        throw _WarnImport("torusBuilder");
      };
      VertexData2.CreateLineSystem = function(options) {
        throw _WarnImport("linesBuilder");
      };
      VertexData2.CreateDashedLines = function(options) {
        throw _WarnImport("linesBuilder");
      };
      VertexData2.CreateGround = function(options) {
        throw _WarnImport("groundBuilder");
      };
      VertexData2.CreateTiledGround = function(options) {
        throw _WarnImport("groundBuilder");
      };
      VertexData2.CreateGroundFromHeightMap = function(options) {
        throw _WarnImport("groundBuilder");
      };
      VertexData2.CreatePlane = function(options) {
        throw _WarnImport("planeBuilder");
      };
      VertexData2.CreateDisc = function(options) {
        throw _WarnImport("discBuilder");
      };
      VertexData2.CreatePolygon = function(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
        throw _WarnImport("polygonBuilder");
      };
      VertexData2.CreateIcoSphere = function(options) {
        throw _WarnImport("icoSphereBuilder");
      };
      VertexData2.CreatePolyhedron = function(options) {
        throw _WarnImport("polyhedronBuilder");
      };
      VertexData2.CreateCapsule = function(options) {
        if (options === void 0) {
          options = {
            orientation: Vector3.Up(),
            subdivisions: 2,
            tessellation: 16,
            height: 1,
            radius: 0.25,
            capSubdivisions: 6
          };
        }
        throw _WarnImport("capsuleBuilder");
      };
      VertexData2.CreateTorusKnot = function(options) {
        throw _WarnImport("torusKnotBuilder");
      };
      VertexData2.ComputeNormals = function(positions, indices, normals, options) {
        var index = 0;
        var p1p2x = 0;
        var p1p2y = 0;
        var p1p2z = 0;
        var p3p2x = 0;
        var p3p2y = 0;
        var p3p2z = 0;
        var faceNormalx = 0;
        var faceNormaly = 0;
        var faceNormalz = 0;
        var length = 0;
        var v1x = 0;
        var v1y = 0;
        var v1z = 0;
        var v2x = 0;
        var v2y = 0;
        var v2z = 0;
        var v3x = 0;
        var v3y = 0;
        var v3z = 0;
        var computeFacetNormals = false;
        var computeFacetPositions = false;
        var computeFacetPartitioning = false;
        var computeDepthSort = false;
        var faceNormalSign = 1;
        var ratio = 0;
        var distanceTo = null;
        if (options) {
          computeFacetNormals = options.facetNormals ? true : false;
          computeFacetPositions = options.facetPositions ? true : false;
          computeFacetPartitioning = options.facetPartitioning ? true : false;
          faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
          ratio = options.ratio || 0;
          computeDepthSort = options.depthSort ? true : false;
          distanceTo = options.distanceTo;
          if (computeDepthSort) {
            if (distanceTo === void 0) {
              distanceTo = Vector3.Zero();
            }
          }
        }
        var xSubRatio = 0;
        var ySubRatio = 0;
        var zSubRatio = 0;
        var subSq = 0;
        if (computeFacetPartitioning && options && options.bbSize) {
          xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
          ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
          zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
          subSq = options.subDiv.max * options.subDiv.max;
          options.facetPartitioning.length = 0;
        }
        for (index = 0; index < positions.length; index++) {
          normals[index] = 0;
        }
        var nbFaces = indices.length / 3 | 0;
        for (index = 0; index < nbFaces; index++) {
          v1x = indices[index * 3] * 3;
          v1y = v1x + 1;
          v1z = v1x + 2;
          v2x = indices[index * 3 + 1] * 3;
          v2y = v2x + 1;
          v2z = v2x + 2;
          v3x = indices[index * 3 + 2] * 3;
          v3y = v3x + 1;
          v3z = v3x + 2;
          p1p2x = positions[v1x] - positions[v2x];
          p1p2y = positions[v1y] - positions[v2y];
          p1p2z = positions[v1z] - positions[v2z];
          p3p2x = positions[v3x] - positions[v2x];
          p3p2y = positions[v3y] - positions[v2y];
          p3p2z = positions[v3z] - positions[v2z];
          faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
          faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
          faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
          length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
          length = length === 0 ? 1 : length;
          faceNormalx /= length;
          faceNormaly /= length;
          faceNormalz /= length;
          if (computeFacetNormals && options) {
            options.facetNormals[index].x = faceNormalx;
            options.facetNormals[index].y = faceNormaly;
            options.facetNormals[index].z = faceNormalz;
          }
          if (computeFacetPositions && options) {
            options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
            options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
            options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
          }
          if (computeFacetPartitioning && options) {
            var ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
            var oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
            var oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
            var b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            var b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            var b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            var b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            var b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            var b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            var b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            var b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            var b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            var block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
            var block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
            var block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
            var block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
            options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
            options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
            options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
            options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
            options.facetPartitioning[block_idx_v1].push(index);
            if (block_idx_v2 != block_idx_v1) {
              options.facetPartitioning[block_idx_v2].push(index);
            }
            if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
              options.facetPartitioning[block_idx_v3].push(index);
            }
            if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
              options.facetPartitioning[block_idx_o].push(index);
            }
          }
          if (computeDepthSort && options && options.facetPositions) {
            var dsf = options.depthSortedFacets[index];
            dsf.ind = index * 3;
            dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
          }
          normals[v1x] += faceNormalx;
          normals[v1y] += faceNormaly;
          normals[v1z] += faceNormalz;
          normals[v2x] += faceNormalx;
          normals[v2y] += faceNormaly;
          normals[v2z] += faceNormalz;
          normals[v3x] += faceNormalx;
          normals[v3y] += faceNormaly;
          normals[v3z] += faceNormalz;
        }
        for (index = 0; index < normals.length / 3; index++) {
          faceNormalx = normals[index * 3];
          faceNormaly = normals[index * 3 + 1];
          faceNormalz = normals[index * 3 + 2];
          length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
          length = length === 0 ? 1 : length;
          faceNormalx /= length;
          faceNormaly /= length;
          faceNormalz /= length;
          normals[index * 3] = faceNormalx;
          normals[index * 3 + 1] = faceNormaly;
          normals[index * 3 + 2] = faceNormalz;
        }
      };
      VertexData2._ComputeSides = function(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
        var li = indices.length;
        var ln = normals.length;
        var i;
        var n;
        sideOrientation = sideOrientation || VertexData2.DEFAULTSIDE;
        switch (sideOrientation) {
          case VertexData2.FRONTSIDE:
            break;
          case VertexData2.BACKSIDE:
            for (i = 0; i < li; i += 3) {
              var tmp = indices[i];
              indices[i] = indices[i + 2];
              indices[i + 2] = tmp;
            }
            for (n = 0; n < ln; n++) {
              normals[n] = -normals[n];
            }
            break;
          case VertexData2.DOUBLESIDE: {
            var lp = positions.length;
            var l = lp / 3;
            for (var p = 0; p < lp; p++) {
              positions[lp + p] = positions[p];
            }
            for (i = 0; i < li; i += 3) {
              indices[i + li] = indices[i + 2] + l;
              indices[i + 1 + li] = indices[i + 1] + l;
              indices[i + 2 + li] = indices[i] + l;
            }
            for (n = 0; n < ln; n++) {
              normals[ln + n] = -normals[n];
            }
            var lu = uvs.length;
            var u = 0;
            for (u = 0; u < lu; u++) {
              uvs[u + lu] = uvs[u];
            }
            frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
            backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
            u = 0;
            for (i = 0; i < lu / 2; i++) {
              uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
              uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
              uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
              uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
              u += 2;
            }
            break;
          }
        }
      };
      VertexData2.ImportVertexData = function(parsedVertexData, geometry) {
        var vertexData = new VertexData2();
        var positions = parsedVertexData.positions;
        if (positions) {
          vertexData.set(positions, VertexBuffer.PositionKind);
        }
        var normals = parsedVertexData.normals;
        if (normals) {
          vertexData.set(normals, VertexBuffer.NormalKind);
        }
        var tangents = parsedVertexData.tangents;
        if (tangents) {
          vertexData.set(tangents, VertexBuffer.TangentKind);
        }
        var uvs = parsedVertexData.uvs;
        if (uvs) {
          vertexData.set(uvs, VertexBuffer.UVKind);
        }
        var uv2s = parsedVertexData.uv2s;
        if (uv2s) {
          vertexData.set(uv2s, VertexBuffer.UV2Kind);
        }
        var uv3s = parsedVertexData.uv3s;
        if (uv3s) {
          vertexData.set(uv3s, VertexBuffer.UV3Kind);
        }
        var uv4s = parsedVertexData.uv4s;
        if (uv4s) {
          vertexData.set(uv4s, VertexBuffer.UV4Kind);
        }
        var uv5s = parsedVertexData.uv5s;
        if (uv5s) {
          vertexData.set(uv5s, VertexBuffer.UV5Kind);
        }
        var uv6s = parsedVertexData.uv6s;
        if (uv6s) {
          vertexData.set(uv6s, VertexBuffer.UV6Kind);
        }
        var colors = parsedVertexData.colors;
        if (colors) {
          vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
        }
        var matricesIndices = parsedVertexData.matricesIndices;
        if (matricesIndices) {
          vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
        }
        var matricesWeights = parsedVertexData.matricesWeights;
        if (matricesWeights) {
          vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
        }
        var indices = parsedVertexData.indices;
        if (indices) {
          vertexData.indices = indices;
        }
        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
      };
      VertexData2.FRONTSIDE = 0;
      VertexData2.BACKSIDE = 1;
      VertexData2.DOUBLESIDE = 2;
      VertexData2.DEFAULTSIDE = 0;
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var coordinates = _a[0];
          return !Array.isArray(coordinates);
        })
      ], VertexData2, "_TransformVector3Coordinates", null);
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var normals = _a[0];
          return !Array.isArray(normals);
        })
      ], VertexData2, "_TransformVector3Normals", null);
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var normals = _a[0];
          return !Array.isArray(normals);
        })
      ], VertexData2, "_TransformVector4Normals", null);
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var indices = _a[0];
          return !Array.isArray(indices);
        })
      ], VertexData2, "_FlipFaces", null);
      return VertexData2;
    }();
  }
});

// node_modules/@babylonjs/core/Collisions/intersectionInfo.js
var IntersectionInfo;
var init_intersectionInfo = __esm({
  "node_modules/@babylonjs/core/Collisions/intersectionInfo.js"() {
    IntersectionInfo = function() {
      function IntersectionInfo2(bu, bv, distance) {
        this.bu = bu;
        this.bv = bv;
        this.distance = distance;
        this.faceId = 0;
        this.subMeshId = 0;
      }
      return IntersectionInfo2;
    }();
  }
});

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox;
var init_boundingBox = __esm({
  "node_modules/@babylonjs/core/Culling/boundingBox.js"() {
    init_arrayTools();
    init_math_vector();
    init_math_constants();
    BoundingBox = function() {
      function BoundingBox2(min, max, worldMatrix) {
        this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
        this.center = Vector3.Zero();
        this.centerWorld = Vector3.Zero();
        this.extendSize = Vector3.Zero();
        this.extendSizeWorld = Vector3.Zero();
        this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
        this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
        this.minimumWorld = Vector3.Zero();
        this.maximumWorld = Vector3.Zero();
        this.minimum = Vector3.Zero();
        this.maximum = Vector3.Zero();
        this._drawWrapperFront = null;
        this._drawWrapperBack = null;
        this.reConstruct(min, max, worldMatrix);
      }
      BoundingBox2.prototype.reConstruct = function(min, max, worldMatrix) {
        var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        var vectors = this.vectors;
        this.minimum.copyFromFloats(minX, minY, minZ);
        this.maximum.copyFromFloats(maxX, maxY, maxZ);
        vectors[0].copyFromFloats(minX, minY, minZ);
        vectors[1].copyFromFloats(maxX, maxY, maxZ);
        vectors[2].copyFromFloats(maxX, minY, minZ);
        vectors[3].copyFromFloats(minX, maxY, minZ);
        vectors[4].copyFromFloats(minX, minY, maxZ);
        vectors[5].copyFromFloats(maxX, maxY, minZ);
        vectors[6].copyFromFloats(minX, maxY, maxZ);
        vectors[7].copyFromFloats(maxX, minY, maxZ);
        max.addToRef(min, this.center).scaleInPlace(0.5);
        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
        this._update(this._worldMatrix);
      };
      BoundingBox2.prototype.scale = function(factor) {
        var tmpVectors = BoundingBox2._TmpVector3;
        var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
        var len = diff.length();
        diff.normalizeFromLength(len);
        var distance = len * factor;
        var newRadius = diff.scaleInPlace(distance * 0.5);
        var min = this.center.subtractToRef(newRadius, tmpVectors[1]);
        var max = this.center.addToRef(newRadius, tmpVectors[2]);
        this.reConstruct(min, max, this._worldMatrix);
        return this;
      };
      BoundingBox2.prototype.getWorldMatrix = function() {
        return this._worldMatrix;
      };
      BoundingBox2.prototype._update = function(world) {
        var minWorld = this.minimumWorld;
        var maxWorld = this.maximumWorld;
        var directions = this.directions;
        var vectorsWorld = this.vectorsWorld;
        var vectors = this.vectors;
        if (!world.isIdentity()) {
          minWorld.setAll(Number.MAX_VALUE);
          maxWorld.setAll(-Number.MAX_VALUE);
          for (var index = 0; index < 8; ++index) {
            var v = vectorsWorld[index];
            Vector3.TransformCoordinatesToRef(vectors[index], world, v);
            minWorld.minimizeInPlace(v);
            maxWorld.maximizeInPlace(v);
          }
          maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
          maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
        } else {
          minWorld.copyFrom(this.minimum);
          maxWorld.copyFrom(this.maximum);
          for (var index = 0; index < 8; ++index) {
            vectorsWorld[index].copyFrom(vectors[index]);
          }
          this.extendSizeWorld.copyFrom(this.extendSize);
          this.centerWorld.copyFrom(this.center);
        }
        Vector3.FromArrayToRef(world.m, 0, directions[0]);
        Vector3.FromArrayToRef(world.m, 4, directions[1]);
        Vector3.FromArrayToRef(world.m, 8, directions[2]);
        this._worldMatrix = world;
      };
      BoundingBox2.prototype.isInFrustum = function(frustumPlanes) {
        return BoundingBox2.IsInFrustum(this.vectorsWorld, frustumPlanes);
      };
      BoundingBox2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
        return BoundingBox2.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
      };
      BoundingBox2.prototype.intersectsPoint = function(point) {
        var min = this.minimumWorld;
        var max = this.maximumWorld;
        var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        var pointX = point.x, pointY = point.y, pointZ = point.z;
        var delta = -Epsilon;
        if (maxX - pointX < delta || delta > pointX - minX) {
          return false;
        }
        if (maxY - pointY < delta || delta > pointY - minY) {
          return false;
        }
        if (maxZ - pointZ < delta || delta > pointZ - minZ) {
          return false;
        }
        return true;
      };
      BoundingBox2.prototype.intersectsSphere = function(sphere) {
        return BoundingBox2.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
      };
      BoundingBox2.prototype.intersectsMinMax = function(min, max) {
        var myMin = this.minimumWorld;
        var myMax = this.maximumWorld;
        var myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
        var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        if (myMaxX < minX || myMinX > maxX) {
          return false;
        }
        if (myMaxY < minY || myMinY > maxY) {
          return false;
        }
        if (myMaxZ < minZ || myMinZ > maxZ) {
          return false;
        }
        return true;
      };
      BoundingBox2.prototype.dispose = function() {
        var _a, _b;
        (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();
      };
      BoundingBox2.Intersects = function(box0, box1) {
        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
      };
      BoundingBox2.IntersectsSphere = function(minPoint, maxPoint, sphereCenter, sphereRadius) {
        var vector = BoundingBox2._TmpVector3[0];
        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
        var num = Vector3.DistanceSquared(sphereCenter, vector);
        return num <= sphereRadius * sphereRadius;
      };
      BoundingBox2.IsCompletelyInFrustum = function(boundingVectors, frustumPlanes) {
        for (var p = 0; p < 6; ++p) {
          var frustumPlane = frustumPlanes[p];
          for (var i = 0; i < 8; ++i) {
            if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
              return false;
            }
          }
        }
        return true;
      };
      BoundingBox2.IsInFrustum = function(boundingVectors, frustumPlanes) {
        for (var p = 0; p < 6; ++p) {
          var canReturnFalse = true;
          var frustumPlane = frustumPlanes[p];
          for (var i = 0; i < 8; ++i) {
            if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
              canReturnFalse = false;
              break;
            }
          }
          if (canReturnFalse) {
            return false;
          }
        }
        return true;
      };
      BoundingBox2._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
      return BoundingBox2;
    }();
  }
});

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere;
var init_boundingSphere = __esm({
  "node_modules/@babylonjs/core/Culling/boundingSphere.js"() {
    init_arrayTools();
    init_math_vector();
    BoundingSphere = function() {
      function BoundingSphere2(min, max, worldMatrix) {
        this.center = Vector3.Zero();
        this.centerWorld = Vector3.Zero();
        this.minimum = Vector3.Zero();
        this.maximum = Vector3.Zero();
        this.reConstruct(min, max, worldMatrix);
      }
      BoundingSphere2.prototype.reConstruct = function(min, max, worldMatrix) {
        this.minimum.copyFrom(min);
        this.maximum.copyFrom(max);
        var distance = Vector3.Distance(min, max);
        max.addToRef(min, this.center).scaleInPlace(0.5);
        this.radius = distance * 0.5;
        this._update(worldMatrix || Matrix.IdentityReadOnly);
      };
      BoundingSphere2.prototype.scale = function(factor) {
        var newRadius = this.radius * factor;
        var tmpVectors = BoundingSphere2._TmpVector3;
        var tempRadiusVector = tmpVectors[0].setAll(newRadius);
        var min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
        var max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
        this.reConstruct(min, max, this._worldMatrix);
        return this;
      };
      BoundingSphere2.prototype.getWorldMatrix = function() {
        return this._worldMatrix;
      };
      BoundingSphere2.prototype._update = function(worldMatrix) {
        if (!worldMatrix.isIdentity()) {
          Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
          var tempVector = BoundingSphere2._TmpVector3[0];
          Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
          this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
        } else {
          this.centerWorld.copyFrom(this.center);
          this.radiusWorld = this.radius;
        }
      };
      BoundingSphere2.prototype.isInFrustum = function(frustumPlanes) {
        var center = this.centerWorld;
        var radius = this.radiusWorld;
        for (var i = 0; i < 6; i++) {
          if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
            return false;
          }
        }
        return true;
      };
      BoundingSphere2.prototype.isCenterInFrustum = function(frustumPlanes) {
        var center = this.centerWorld;
        for (var i = 0; i < 6; i++) {
          if (frustumPlanes[i].dotCoordinate(center) < 0) {
            return false;
          }
        }
        return true;
      };
      BoundingSphere2.prototype.intersectsPoint = function(point) {
        var squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
        if (this.radiusWorld * this.radiusWorld < squareDistance) {
          return false;
        }
        return true;
      };
      BoundingSphere2.Intersects = function(sphere0, sphere1) {
        var squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
        var radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
        if (radiusSum * radiusSum < squareDistance) {
          return false;
        }
        return true;
      };
      BoundingSphere2.CreateFromCenterAndRadius = function(center, radius, matrix) {
        this._TmpVector3[0].copyFrom(center);
        this._TmpVector3[1].copyFromFloats(0, 0, radius);
        this._TmpVector3[2].copyFrom(center);
        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
        var sphere = new BoundingSphere2(this._TmpVector3[0], this._TmpVector3[2]);
        if (matrix) {
          sphere._worldMatrix = matrix;
        } else {
          sphere._worldMatrix = Matrix.Identity();
        }
        return sphere;
      };
      BoundingSphere2._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
      return BoundingSphere2;
    }();
  }
});

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _result0, _result1, computeBoxExtents, axisOverlap, BoundingInfo;
var init_boundingInfo = __esm({
  "node_modules/@babylonjs/core/Culling/boundingInfo.js"() {
    init_arrayTools();
    init_math_vector();
    init_boundingBox();
    init_boundingSphere();
    _result0 = { min: 0, max: 0 };
    _result1 = { min: 0, max: 0 };
    computeBoxExtents = function(axis, box, result) {
      var p = Vector3.Dot(box.centerWorld, axis);
      var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
      var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
      var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
      var r = r0 + r1 + r2;
      result.min = p - r;
      result.max = p + r;
    };
    axisOverlap = function(axis, box0, box1) {
      computeBoxExtents(axis, box0, _result0);
      computeBoxExtents(axis, box1, _result1);
      return !(_result0.min > _result1.max || _result1.min > _result0.max);
    };
    BoundingInfo = function() {
      function BoundingInfo2(minimum, maximum, worldMatrix) {
        this._isLocked = false;
        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
      }
      BoundingInfo2.prototype.reConstruct = function(min, max, worldMatrix) {
        this.boundingBox.reConstruct(min, max, worldMatrix);
        this.boundingSphere.reConstruct(min, max, worldMatrix);
      };
      Object.defineProperty(BoundingInfo2.prototype, "minimum", {
        get: function() {
          return this.boundingBox.minimum;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BoundingInfo2.prototype, "maximum", {
        get: function() {
          return this.boundingBox.maximum;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BoundingInfo2.prototype, "isLocked", {
        get: function() {
          return this._isLocked;
        },
        set: function(value) {
          this._isLocked = value;
        },
        enumerable: false,
        configurable: true
      });
      BoundingInfo2.prototype.update = function(world) {
        if (this._isLocked) {
          return;
        }
        this.boundingBox._update(world);
        this.boundingSphere._update(world);
      };
      BoundingInfo2.prototype.centerOn = function(center, extend) {
        var minimum = BoundingInfo2._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
        var maximum = BoundingInfo2._TmpVector3[1].copyFrom(center).addInPlace(extend);
        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        return this;
      };
      BoundingInfo2.prototype.encapsulate = function(point) {
        var minimum = Vector3.Minimize(this.minimum, point);
        var maximum = Vector3.Maximize(this.maximum, point);
        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        return this;
      };
      BoundingInfo2.prototype.encapsulateBoundingInfo = function(toEncapsulate) {
        this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));
        this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));
        return this;
      };
      BoundingInfo2.prototype.scale = function(factor) {
        this.boundingBox.scale(factor);
        this.boundingSphere.scale(factor);
        return this;
      };
      BoundingInfo2.prototype.isInFrustum = function(frustumPlanes, strategy) {
        if (strategy === void 0) {
          strategy = 0;
        }
        var inclusionTest = strategy === 2 || strategy === 3;
        if (inclusionTest) {
          if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
            return true;
          }
        }
        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
          return false;
        }
        var bSphereOnlyTest = strategy === 1 || strategy === 3;
        if (bSphereOnlyTest) {
          return true;
        }
        return this.boundingBox.isInFrustum(frustumPlanes);
      };
      Object.defineProperty(BoundingInfo2.prototype, "diagonalLength", {
        get: function() {
          var boundingBox = this.boundingBox;
          var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo2._TmpVector3[0]);
          return diag.length();
        },
        enumerable: false,
        configurable: true
      });
      BoundingInfo2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
      };
      BoundingInfo2.prototype._checkCollision = function(collider) {
        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
      };
      BoundingInfo2.prototype.intersectsPoint = function(point) {
        if (!this.boundingSphere.centerWorld) {
          return false;
        }
        if (!this.boundingSphere.intersectsPoint(point)) {
          return false;
        }
        if (!this.boundingBox.intersectsPoint(point)) {
          return false;
        }
        return true;
      };
      BoundingInfo2.prototype.intersects = function(boundingInfo, precise) {
        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
          return false;
        }
        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
          return false;
        }
        if (!precise) {
          return true;
        }
        var box0 = this.boundingBox;
        var box1 = boundingInfo.boundingBox;
        if (!axisOverlap(box0.directions[0], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box0.directions[1], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box0.directions[2], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[0], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[1], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[2], box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
          return false;
        }
        return true;
      };
      BoundingInfo2._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);
      return BoundingInfo2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.functions.js
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias, stride) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
var MathHelpers;
var init_math_functions = __esm({
  "node_modules/@babylonjs/core/Maths/math.functions.js"() {
    init_tslib_es6();
    init_math_vector();
    init_decorators();
    MathHelpers = function() {
      function MathHelpers2() {
      }
      MathHelpers2.extractMinAndMaxIndexed = function(positions, indices, indexStart, indexCount, minimum, maximum) {
        for (var index = indexStart; index < indexStart + indexCount; index++) {
          var offset = indices[index] * 3;
          var x = positions[offset];
          var y = positions[offset + 1];
          var z = positions[offset + 2];
          minimum.minimizeInPlaceFromFloats(x, y, z);
          maximum.maximizeInPlaceFromFloats(x, y, z);
        }
      };
      MathHelpers2.extractMinAndMax = function(positions, start, count, stride, minimum, maximum) {
        for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {
          var x = positions[offset];
          var y = positions[offset + 1];
          var z = positions[offset + 2];
          minimum.minimizeInPlaceFromFloats(x, y, z);
          maximum.maximizeInPlaceFromFloats(x, y, z);
        }
      };
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var positions = _a[0], indices = _a[1];
          return !Array.isArray(positions) && !Array.isArray(indices);
        })
      ], MathHelpers2, "extractMinAndMaxIndexed", null);
      __decorate([
        nativeOverride.filter(function() {
          var _a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            _a[_i] = arguments[_i];
          }
          var positions = _a[0];
          return !Array.isArray(positions);
        })
      ], MathHelpers2, "extractMinAndMax", null);
      return MathHelpers2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/subMesh.js
var SubMesh;
var init_subMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/subMesh.js"() {
    init_buffer();
    init_intersectionInfo();
    init_boundingInfo();
    init_math_functions();
    init_drawWrapper();
    SubMesh = function() {
      function SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {
        if (createBoundingBox === void 0) {
          createBoundingBox = true;
        }
        if (addToMesh === void 0) {
          addToMesh = true;
        }
        this.materialIndex = materialIndex;
        this.verticesStart = verticesStart;
        this.verticesCount = verticesCount;
        this.indexStart = indexStart;
        this.indexCount = indexCount;
        this._mainDrawWrapperOverride = null;
        this._linesIndexCount = 0;
        this._linesIndexBuffer = null;
        this._lastColliderWorldVertices = null;
        this._lastColliderTransformMatrix = null;
        this._renderId = 0;
        this._alphaIndex = 0;
        this._distanceToCamera = 0;
        this._currentMaterial = null;
        this._mesh = mesh;
        this._renderingMesh = renderingMesh || mesh;
        if (addToMesh) {
          mesh.subMeshes.push(this);
        }
        this._engine = this._mesh.getScene().getEngine();
        this.resetDrawCache();
        this._trianglePlanes = [];
        this._id = mesh.subMeshes.length - 1;
        if (createBoundingBox) {
          this.refreshBoundingInfo();
          mesh.computeWorldMatrix(true);
        }
      }
      Object.defineProperty(SubMesh2.prototype, "materialDefines", {
        get: function() {
          var _a;
          return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;
        },
        set: function(defines) {
          var _a;
          var drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
          drawWrapper.defines = defines;
        },
        enumerable: false,
        configurable: true
      });
      SubMesh2.prototype._getDrawWrapper = function(passId, createIfNotExisting) {
        if (createIfNotExisting === void 0) {
          createIfNotExisting = false;
        }
        passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;
        var drawWrapper = this._drawWrappers[passId];
        if (!drawWrapper && createIfNotExisting) {
          this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
        }
        return drawWrapper;
      };
      SubMesh2.prototype._removeDrawWrapper = function(passId, disposeWrapper) {
        var _a;
        if (disposeWrapper === void 0) {
          disposeWrapper = true;
        }
        if (disposeWrapper) {
          (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();
        }
        this._drawWrappers[passId] = void 0;
      };
      Object.defineProperty(SubMesh2.prototype, "effect", {
        get: function() {
          var _a, _b;
          return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SubMesh2.prototype, "_drawWrapper", {
        get: function() {
          var _a;
          return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SubMesh2.prototype, "_drawWrapperOverride", {
        get: function() {
          return this._mainDrawWrapperOverride;
        },
        enumerable: false,
        configurable: true
      });
      SubMesh2.prototype._setMainDrawWrapperOverride = function(wrapper) {
        this._mainDrawWrapperOverride = wrapper;
      };
      SubMesh2.prototype.setEffect = function(effect, defines, materialContext, resetContext) {
        if (defines === void 0) {
          defines = null;
        }
        if (resetContext === void 0) {
          resetContext = true;
        }
        var drawWrapper = this._drawWrapper;
        drawWrapper.setEffect(effect, defines, resetContext);
        if (materialContext !== void 0) {
          drawWrapper.materialContext = materialContext;
        }
        if (!effect) {
          drawWrapper.defines = null;
          drawWrapper.materialContext = void 0;
        }
      };
      SubMesh2.prototype.resetDrawCache = function(passId) {
        if (this._drawWrappers) {
          if (passId !== void 0) {
            this._removeDrawWrapper(passId);
            return;
          } else {
            for (var _i = 0, _a = this._drawWrappers; _i < _a.length; _i++) {
              var drawWrapper = _a[_i];
              drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
            }
          }
        }
        this._drawWrappers = [];
      };
      SubMesh2.AddToMesh = function(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {
        if (createBoundingBox === void 0) {
          createBoundingBox = true;
        }
        return new SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
      };
      Object.defineProperty(SubMesh2.prototype, "IsGlobal", {
        get: function() {
          return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();
        },
        enumerable: false,
        configurable: true
      });
      SubMesh2.prototype.getBoundingInfo = function() {
        if (this.IsGlobal) {
          return this._mesh.getBoundingInfo();
        }
        return this._boundingInfo;
      };
      SubMesh2.prototype.setBoundingInfo = function(boundingInfo) {
        this._boundingInfo = boundingInfo;
        return this;
      };
      SubMesh2.prototype.getMesh = function() {
        return this._mesh;
      };
      SubMesh2.prototype.getRenderingMesh = function() {
        return this._renderingMesh;
      };
      SubMesh2.prototype.getReplacementMesh = function() {
        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
      };
      SubMesh2.prototype.getEffectiveMesh = function() {
        var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
        return replacementMesh ? replacementMesh : this._renderingMesh;
      };
      SubMesh2.prototype.getMaterial = function() {
        var _a;
        var rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;
        if (!rootMaterial) {
          return this._mesh.getScene().defaultMaterial;
        } else if (this._isMultiMaterial(rootMaterial)) {
          var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
          if (this._currentMaterial !== effectiveMaterial) {
            this._currentMaterial = effectiveMaterial;
            this.resetDrawCache();
          }
          return effectiveMaterial;
        }
        return rootMaterial;
      };
      SubMesh2.prototype._isMultiMaterial = function(material) {
        return material.getSubMaterial !== void 0;
      };
      SubMesh2.prototype.refreshBoundingInfo = function(data) {
        if (data === void 0) {
          data = null;
        }
        this._lastColliderWorldVertices = null;
        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
          return this;
        }
        if (!data) {
          data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
        }
        if (!data) {
          this._boundingInfo = this._mesh.getBoundingInfo();
          return this;
        }
        var indices = this._renderingMesh.getIndices();
        var extend;
        if (this.indexStart === 0 && this.indexCount === indices.length) {
          var boundingInfo = this._renderingMesh.getBoundingInfo();
          extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
        } else {
          extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
        }
        if (this._boundingInfo) {
          this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
        } else {
          this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
        }
        return this;
      };
      SubMesh2.prototype._checkCollision = function(collider) {
        var boundingInfo = this.getBoundingInfo();
        return boundingInfo._checkCollision(collider);
      };
      SubMesh2.prototype.updateBoundingInfo = function(world) {
        var boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          this.refreshBoundingInfo();
          boundingInfo = this.getBoundingInfo();
        }
        if (boundingInfo) {
          boundingInfo.update(world);
        }
        return this;
      };
      SubMesh2.prototype.isInFrustum = function(frustumPlanes) {
        var boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
      };
      SubMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
        var boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return boundingInfo.isCompletelyInFrustum(frustumPlanes);
      };
      SubMesh2.prototype.render = function(enableAlphaMode) {
        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
        return this;
      };
      SubMesh2.prototype._getLinesIndexBuffer = function(indices, engine) {
        if (!this._linesIndexBuffer) {
          var linesIndices = [];
          for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
            linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
          }
          this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
          this._linesIndexCount = linesIndices.length;
        }
        return this._linesIndexBuffer;
      };
      SubMesh2.prototype.canIntersects = function(ray) {
        var boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return ray.intersectsBox(boundingInfo.boundingBox);
      };
      SubMesh2.prototype.intersects = function(ray, positions, indices, fastCheck, trianglePredicate) {
        var material = this.getMaterial();
        if (!material) {
          return null;
        }
        var step = 3;
        var checkStopper = false;
        switch (material.fillMode) {
          case 3:
          case 5:
          case 6:
          case 8:
            return null;
          case 7:
            step = 1;
            checkStopper = true;
            break;
          default:
            break;
        }
        if (material.fillMode === 4) {
          if (!indices.length) {
            return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
          }
          return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
        } else {
          if (!indices.length && this._mesh._unIndexed) {
            return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
          }
          return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
        }
      };
      SubMesh2.prototype._intersectLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
        var intersectInfo = null;
        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
          var p0 = positions[indices[index]];
          var p1 = positions[indices[index + 1]];
          var length_1 = ray.intersectionSegment(p0, p1, intersectionThreshold);
          if (length_1 < 0) {
            continue;
          }
          if (fastCheck || !intersectInfo || length_1 < intersectInfo.distance) {
            intersectInfo = new IntersectionInfo(null, null, length_1);
            intersectInfo.faceId = index / 2;
            if (fastCheck) {
              break;
            }
          }
        }
        return intersectInfo;
      };
      SubMesh2.prototype._intersectUnIndexedLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
        var intersectInfo = null;
        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
          var p0 = positions[index];
          var p1 = positions[index + 1];
          var length_2 = ray.intersectionSegment(p0, p1, intersectionThreshold);
          if (length_2 < 0) {
            continue;
          }
          if (fastCheck || !intersectInfo || length_2 < intersectInfo.distance) {
            intersectInfo = new IntersectionInfo(null, null, length_2);
            intersectInfo.faceId = index / 2;
            if (fastCheck) {
              break;
            }
          }
        }
        return intersectInfo;
      };
      SubMesh2.prototype._intersectTriangles = function(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
        var intersectInfo = null;
        var faceId = -1;
        for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
          faceId++;
          var indexA = indices[index];
          var indexB = indices[index + 1];
          var indexC = indices[index + 2];
          if (checkStopper && indexC === 4294967295) {
            index += 2;
            continue;
          }
          var p0 = positions[indexA];
          var p1 = positions[indexB];
          var p2 = positions[indexC];
          if (!p0 || !p1 || !p2) {
            continue;
          }
          if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
            continue;
          }
          var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
          if (currentIntersectInfo) {
            if (currentIntersectInfo.distance < 0) {
              continue;
            }
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.faceId = faceId;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        return intersectInfo;
      };
      SubMesh2.prototype._intersectUnIndexedTriangles = function(ray, positions, indices, fastCheck, trianglePredicate) {
        var intersectInfo = null;
        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
          var p0 = positions[index];
          var p1 = positions[index + 1];
          var p2 = positions[index + 2];
          if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
            continue;
          }
          var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
          if (currentIntersectInfo) {
            if (currentIntersectInfo.distance < 0) {
              continue;
            }
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.faceId = index / 3;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        return intersectInfo;
      };
      SubMesh2.prototype._rebuild = function() {
        if (this._linesIndexBuffer) {
          this._linesIndexBuffer = null;
        }
      };
      SubMesh2.prototype.clone = function(newMesh, newRenderingMesh) {
        var result = new SubMesh2(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
        if (!this.IsGlobal) {
          var boundingInfo = this.getBoundingInfo();
          if (!boundingInfo) {
            return result;
          }
          result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
        }
        return result;
      };
      SubMesh2.prototype.dispose = function() {
        if (this._linesIndexBuffer) {
          this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
          this._linesIndexBuffer = null;
        }
        var index = this._mesh.subMeshes.indexOf(this);
        this._mesh.subMeshes.splice(index, 1);
        this.resetDrawCache();
      };
      SubMesh2.prototype.getClassName = function() {
        return "SubMesh";
      };
      SubMesh2.CreateFromIndices = function(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox) {
        if (createBoundingBox === void 0) {
          createBoundingBox = true;
        }
        var minVertexIndex = Number.MAX_VALUE;
        var maxVertexIndex = -Number.MAX_VALUE;
        var whatWillRender = renderingMesh || mesh;
        var indices = whatWillRender.getIndices();
        for (var index = startIndex; index < startIndex + indexCount; index++) {
          var vertexIndex = indices[index];
          if (vertexIndex < minVertexIndex) {
            minVertexIndex = vertexIndex;
          }
          if (vertexIndex > maxVertexIndex) {
            maxVertexIndex = vertexIndex;
          }
        }
        return new SubMesh2(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
      };
      return SubMesh2;
    }();
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js
var SceneLoaderFlags;
var init_sceneLoaderFlags = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js"() {
    SceneLoaderFlags = function() {
      function SceneLoaderFlags2() {
      }
      Object.defineProperty(SceneLoaderFlags2, "ForceFullSceneLoadingForIncremental", {
        get: function() {
          return SceneLoaderFlags2._ForceFullSceneLoadingForIncremental;
        },
        set: function(value) {
          SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoaderFlags2, "ShowLoadingScreen", {
        get: function() {
          return SceneLoaderFlags2._ShowLoadingScreen;
        },
        set: function(value) {
          SceneLoaderFlags2._ShowLoadingScreen = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoaderFlags2, "loggingLevel", {
        get: function() {
          return SceneLoaderFlags2._LoggingLevel;
        },
        set: function(value) {
          SceneLoaderFlags2._LoggingLevel = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoaderFlags2, "CleanBoneMatrixWeights", {
        get: function() {
          return SceneLoaderFlags2._CleanBoneMatrixWeights;
        },
        set: function(value) {
          SceneLoaderFlags2._CleanBoneMatrixWeights = value;
        },
        enumerable: false,
        configurable: true
      });
      SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = false;
      SceneLoaderFlags2._ShowLoadingScreen = true;
      SceneLoaderFlags2._CleanBoneMatrixWeights = false;
      SceneLoaderFlags2._LoggingLevel = 0;
      return SceneLoaderFlags2;
    }();
  }
});

// node_modules/@babylonjs/core/Compat/compatibilityOptions.js
var CompatibilityOptions;
var init_compatibilityOptions = __esm({
  "node_modules/@babylonjs/core/Compat/compatibilityOptions.js"() {
    CompatibilityOptions = function() {
      function CompatibilityOptions2() {
      }
      CompatibilityOptions2.UseOpenGLOrientationForUV = false;
      return CompatibilityOptions2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/geometry.js
var Geometry;
var init_geometry = __esm({
  "node_modules/@babylonjs/core/Meshes/geometry.js"() {
    init_math_vector();
    init_math_color();
    init_mesh_vertexData();
    init_buffer();
    init_subMesh();
    init_sceneLoaderFlags();
    init_boundingInfo();
    init_tools();
    init_tags();
    init_math_functions();
    init_engineStore();
    init_compatibilityOptions();
    Geometry = function() {
      function Geometry2(id, scene, vertexData, updatable, mesh) {
        if (updatable === void 0) {
          updatable = false;
        }
        if (mesh === void 0) {
          mesh = null;
        }
        this.delayLoadState = 0;
        this._totalVertices = 0;
        this._isDisposed = false;
        this._indexBufferIsUpdatable = false;
        this._positionsCache = [];
        this._parentContainer = null;
        this.useBoundingInfoFromGeometry = false;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        this.id = id;
        this.uniqueId = this._scene.getUniqueId();
        this._engine = this._scene.getEngine();
        this._meshes = [];
        this._vertexBuffers = {};
        this._indices = [];
        this._updatable = updatable;
        if (vertexData) {
          this.setAllVerticesData(vertexData, updatable);
        } else {
          this._totalVertices = 0;
          this._indices = [];
        }
        if (this._engine.getCaps().vertexArrayObject) {
          this._vertexArrayObjects = {};
        }
        if (mesh) {
          this.applyToMesh(mesh);
          mesh.computeWorldMatrix(true);
        }
      }
      Object.defineProperty(Geometry2.prototype, "boundingBias", {
        get: function() {
          return this._boundingBias;
        },
        set: function(value) {
          if (this._boundingBias) {
            this._boundingBias.copyFrom(value);
          } else {
            this._boundingBias = value.clone();
          }
          this._updateBoundingInfo(true, null);
        },
        enumerable: false,
        configurable: true
      });
      Geometry2.CreateGeometryForMesh = function(mesh) {
        var geometry = new Geometry2(Geometry2.RandomId(), mesh.getScene());
        geometry.applyToMesh(mesh);
        return geometry;
      };
      Object.defineProperty(Geometry2.prototype, "meshes", {
        get: function() {
          return this._meshes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Geometry2.prototype, "extend", {
        get: function() {
          return this._extend;
        },
        enumerable: false,
        configurable: true
      });
      Geometry2.prototype.getScene = function() {
        return this._scene;
      };
      Geometry2.prototype.getEngine = function() {
        return this._engine;
      };
      Geometry2.prototype.isReady = function() {
        return this.delayLoadState === 1 || this.delayLoadState === 0;
      };
      Object.defineProperty(Geometry2.prototype, "doNotSerialize", {
        get: function() {
          for (var index = 0; index < this._meshes.length; index++) {
            if (!this._meshes[index].doNotSerialize) {
              return false;
            }
          }
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Geometry2.prototype._rebuild = function() {
        if (this._vertexArrayObjects) {
          this._vertexArrayObjects = {};
        }
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
        }
        for (var key in this._vertexBuffers) {
          var vertexBuffer = this._vertexBuffers[key];
          vertexBuffer._rebuild();
        }
      };
      Geometry2.prototype.setAllVerticesData = function(vertexData, updatable) {
        vertexData.applyToGeometry(this, updatable);
        this._notifyUpdate();
      };
      Geometry2.prototype.setVerticesData = function(kind, data, updatable, stride) {
        if (updatable === void 0) {
          updatable = false;
        }
        if (updatable && Array.isArray(data)) {
          data = new Float32Array(data);
        }
        var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
        this.setVerticesBuffer(buffer);
      };
      Geometry2.prototype.removeVerticesData = function(kind) {
        if (this._vertexBuffers[kind]) {
          this._vertexBuffers[kind].dispose();
          delete this._vertexBuffers[kind];
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
      };
      Geometry2.prototype.setVerticesBuffer = function(buffer, totalVertices, disposeExistingBuffer) {
        if (totalVertices === void 0) {
          totalVertices = null;
        }
        if (disposeExistingBuffer === void 0) {
          disposeExistingBuffer = true;
        }
        var kind = buffer.getKind();
        if (this._vertexBuffers[kind] && disposeExistingBuffer) {
          this._vertexBuffers[kind].dispose();
        }
        if (buffer._buffer) {
          buffer._buffer._increaseReferences();
        }
        this._vertexBuffers[kind] = buffer;
        var meshes = this._meshes;
        var numOfMeshes = meshes.length;
        if (kind === VertexBuffer.PositionKind) {
          var data = buffer.getData();
          if (totalVertices != null) {
            this._totalVertices = totalVertices;
          } else {
            if (data != null) {
              this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);
            }
          }
          this._updateExtend(data);
          this._resetPointsArrayCache();
          for (var index = 0; index < numOfMeshes; index++) {
            var mesh = meshes[index];
            mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            mesh._createGlobalSubMesh(false);
            mesh.computeWorldMatrix(true);
            mesh.synchronizeInstances();
          }
        }
        this._notifyUpdate(kind);
      };
      Geometry2.prototype.updateVerticesDataDirectly = function(kind, data, offset, useBytes) {
        if (useBytes === void 0) {
          useBytes = false;
        }
        var vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.updateDirectly(data, offset, useBytes);
        this._notifyUpdate(kind);
      };
      Geometry2.prototype.updateVerticesData = function(kind, data, updateExtends) {
        if (updateExtends === void 0) {
          updateExtends = false;
        }
        var vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.update(data);
        if (kind === VertexBuffer.PositionKind) {
          this._updateBoundingInfo(updateExtends, data);
        }
        this._notifyUpdate(kind);
      };
      Geometry2.prototype._updateBoundingInfo = function(updateExtends, data) {
        if (updateExtends) {
          this._updateExtend(data);
        }
        this._resetPointsArrayCache();
        if (updateExtends) {
          var meshes = this._meshes;
          for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
            var mesh = meshes_1[_i];
            if (mesh.hasBoundingInfo) {
              mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
            } else {
              mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            }
            var subMeshes = mesh.subMeshes;
            for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {
              var subMesh = subMeshes_1[_a];
              subMesh.refreshBoundingInfo();
            }
          }
        }
      };
      Geometry2.prototype._bind = function(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
        if (!effect) {
          return;
        }
        if (indexToBind === void 0) {
          indexToBind = this._indexBuffer;
        }
        var vbs = this.getVertexBuffers();
        if (!vbs) {
          return;
        }
        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
          this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
          return;
        }
        var vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
        if (!vaos[effect.key]) {
          vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
        }
        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
      };
      Geometry2.prototype.getTotalVertices = function() {
        if (!this.isReady()) {
          return 0;
        }
        return this._totalVertices;
      };
      Geometry2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
        var vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return null;
        }
        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
      };
      Geometry2.prototype.isVertexBufferUpdatable = function(kind) {
        var vb = this._vertexBuffers[kind];
        if (!vb) {
          return false;
        }
        return vb.isUpdatable();
      };
      Geometry2.prototype.getVertexBuffer = function(kind) {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers[kind];
      };
      Geometry2.prototype.getVertexBuffers = function() {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers;
      };
      Geometry2.prototype.isVerticesDataPresent = function(kind) {
        if (!this._vertexBuffers) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return this._vertexBuffers[kind] !== void 0;
      };
      Geometry2.prototype.getVerticesDataKinds = function() {
        var result = [];
        var kind;
        if (!this._vertexBuffers && this._delayInfo) {
          for (kind in this._delayInfo) {
            result.push(kind);
          }
        } else {
          for (kind in this._vertexBuffers) {
            result.push(kind);
          }
        }
        return result;
      };
      Geometry2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
        if (gpuMemoryOnly === void 0) {
          gpuMemoryOnly = false;
        }
        if (!this._indexBuffer) {
          return;
        }
        if (!this._indexBufferIsUpdatable) {
          this.setIndices(indices, null, true);
        } else {
          var needToUpdateSubMeshes = indices.length !== this._indices.length;
          if (!gpuMemoryOnly) {
            this._indices = indices.slice();
          }
          this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
          if (needToUpdateSubMeshes) {
            for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
              var mesh = _a[_i];
              mesh._createGlobalSubMesh(true);
            }
          }
        }
      };
      Geometry2.prototype.setIndices = function(indices, totalVertices, updatable) {
        if (totalVertices === void 0) {
          totalVertices = null;
        }
        if (updatable === void 0) {
          updatable = false;
        }
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indices = indices;
        this._indexBufferIsUpdatable = updatable;
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
        }
        if (totalVertices != void 0) {
          this._totalVertices = totalVertices;
        }
        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._createGlobalSubMesh(true);
          mesh.synchronizeInstances();
        }
        this._notifyUpdate();
      };
      Geometry2.prototype.getTotalIndices = function() {
        if (!this.isReady()) {
          return 0;
        }
        return this._indices.length;
      };
      Geometry2.prototype.getIndices = function(copyWhenShared, forceCopy) {
        if (!this.isReady()) {
          return null;
        }
        var orig = this._indices;
        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
          return orig;
        } else {
          return Tools.Slice(orig);
        }
      };
      Geometry2.prototype.getIndexBuffer = function() {
        if (!this.isReady()) {
          return null;
        }
        return this._indexBuffer;
      };
      Geometry2.prototype._releaseVertexArrayObject = function(effect) {
        if (effect === void 0) {
          effect = null;
        }
        if (!effect || !this._vertexArrayObjects) {
          return;
        }
        if (this._vertexArrayObjects[effect.key]) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
          delete this._vertexArrayObjects[effect.key];
        }
      };
      Geometry2.prototype.releaseForMesh = function(mesh, shouldDispose) {
        var meshes = this._meshes;
        var index = meshes.indexOf(mesh);
        if (index === -1) {
          return;
        }
        meshes.splice(index, 1);
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        mesh._geometry = null;
        if (meshes.length === 0 && shouldDispose) {
          this.dispose();
        }
      };
      Geometry2.prototype.applyToMesh = function(mesh) {
        if (mesh._geometry === this) {
          return;
        }
        var previousGeometry = mesh._geometry;
        if (previousGeometry) {
          previousGeometry.releaseForMesh(mesh);
        }
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        var meshes = this._meshes;
        mesh._geometry = this;
        mesh._internalAbstractMeshDataInfo._positions = null;
        this._scene.pushGeometry(this);
        meshes.push(mesh);
        if (this.isReady()) {
          this._applyToMesh(mesh);
        } else if (this._boundingInfo) {
          mesh.setBoundingInfo(this._boundingInfo);
        }
      };
      Geometry2.prototype._updateExtend = function(data) {
        if (data === void 0) {
          data = null;
        }
        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
          this._extend = {
            minimum: this._boundingInfo.minimum.clone(),
            maximum: this._boundingInfo.maximum.clone()
          };
        } else {
          if (!data) {
            data = this.getVerticesData(VertexBuffer.PositionKind);
            if (!data) {
              return;
            }
          }
          this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
        }
      };
      Geometry2.prototype._applyToMesh = function(mesh) {
        var numOfMeshes = this._meshes.length;
        for (var kind in this._vertexBuffers) {
          if (numOfMeshes === 1) {
            this._vertexBuffers[kind].create();
          }
          if (kind === VertexBuffer.PositionKind) {
            if (!this._extend) {
              this._updateExtend();
            }
            mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            mesh._createGlobalSubMesh(false);
            mesh._updateBoundingInfo();
          }
        }
        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
        }
        mesh._syncGeometryWithMorphTargetManager();
        mesh.synchronizeInstances();
      };
      Geometry2.prototype._notifyUpdate = function(kind) {
        if (this.onGeometryUpdated) {
          this.onGeometryUpdated(this, kind);
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._markSubMeshesAsAttributesDirty();
        }
      };
      Geometry2.prototype.load = function(scene, onLoaded) {
        if (this.delayLoadState === 2) {
          return;
        }
        if (this.isReady()) {
          if (onLoaded) {
            onLoaded();
          }
          return;
        }
        this.delayLoadState = 2;
        this._queueLoad(scene, onLoaded);
      };
      Geometry2.prototype._queueLoad = function(scene, onLoaded) {
        var _this = this;
        if (!this.delayLoadingFile) {
          return;
        }
        scene._addPendingData(this);
        scene._loadFile(this.delayLoadingFile, function(data) {
          if (!_this._delayLoadingFunction) {
            return;
          }
          _this._delayLoadingFunction(JSON.parse(data), _this);
          _this.delayLoadState = 1;
          _this._delayInfo = [];
          scene._removePendingData(_this);
          var meshes = _this._meshes;
          var numOfMeshes = meshes.length;
          for (var index = 0; index < numOfMeshes; index++) {
            _this._applyToMesh(meshes[index]);
          }
          if (onLoaded) {
            onLoaded();
          }
        }, void 0, true);
      };
      Geometry2.prototype.toLeftHanded = function() {
        var tIndices = this.getIndices(false);
        if (tIndices != null && tIndices.length > 0) {
          for (var i = 0; i < tIndices.length; i += 3) {
            var tTemp = tIndices[i + 0];
            tIndices[i + 0] = tIndices[i + 2];
            tIndices[i + 2] = tTemp;
          }
          this.setIndices(tIndices);
        }
        var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
        if (tPositions != null && tPositions.length > 0) {
          for (var i = 0; i < tPositions.length; i += 3) {
            tPositions[i + 2] = -tPositions[i + 2];
          }
          this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
        }
        var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
        if (tNormals != null && tNormals.length > 0) {
          for (var i = 0; i < tNormals.length; i += 3) {
            tNormals[i + 2] = -tNormals[i + 2];
          }
          this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
        }
      };
      Geometry2.prototype._resetPointsArrayCache = function() {
        this._positions = null;
      };
      Geometry2.prototype._generatePointsArray = function() {
        if (this._positions) {
          return true;
        }
        var data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data || data.length === 0) {
          return false;
        }
        for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
        }
        for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
        }
        this._positionsCache.length = data.length / 3;
        this._positions = this._positionsCache;
        return true;
      };
      Geometry2.prototype.isDisposed = function() {
        return this._isDisposed;
      };
      Geometry2.prototype._disposeVertexArrayObjects = function() {
        if (this._vertexArrayObjects) {
          for (var kind in this._vertexArrayObjects) {
            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
          }
          this._vertexArrayObjects = {};
          var meshes = this._meshes;
          var numOfMeshes = meshes.length;
          for (var index = 0; index < numOfMeshes; index++) {
            meshes[index]._invalidateInstanceVertexArrayObject();
          }
        }
      };
      Geometry2.prototype.dispose = function() {
        var meshes = this._meshes;
        var numOfMeshes = meshes.length;
        var index;
        for (index = 0; index < numOfMeshes; index++) {
          this.releaseForMesh(meshes[index]);
        }
        this._meshes = [];
        this._disposeVertexArrayObjects();
        for (var kind in this._vertexBuffers) {
          this._vertexBuffers[kind].dispose();
        }
        this._vertexBuffers = {};
        this._totalVertices = 0;
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indexBuffer = null;
        this._indices = [];
        this.delayLoadState = 0;
        this.delayLoadingFile = null;
        this._delayLoadingFunction = null;
        this._delayInfo = [];
        this._boundingInfo = null;
        this._scene.removeGeometry(this);
        if (this._parentContainer) {
          var index_1 = this._parentContainer.geometries.indexOf(this);
          if (index_1 > -1) {
            this._parentContainer.geometries.splice(index_1, 1);
          }
          this._parentContainer = null;
        }
        this._isDisposed = true;
      };
      Geometry2.prototype.copy = function(id) {
        var vertexData = new VertexData();
        vertexData.indices = [];
        var indices = this.getIndices();
        if (indices) {
          for (var index = 0; index < indices.length; index++) {
            vertexData.indices.push(indices[index]);
          }
        }
        var updatable = false;
        var stopChecking = false;
        var kind;
        for (kind in this._vertexBuffers) {
          var data = this.getVerticesData(kind);
          if (data) {
            if (data instanceof Float32Array) {
              vertexData.set(new Float32Array(data), kind);
            } else {
              vertexData.set(data.slice(0), kind);
            }
            if (!stopChecking) {
              var vb = this.getVertexBuffer(kind);
              if (vb) {
                updatable = vb.isUpdatable();
                stopChecking = !updatable;
              }
            }
          }
        }
        var geometry = new Geometry2(id, this._scene, vertexData, updatable);
        geometry.delayLoadState = this.delayLoadState;
        geometry.delayLoadingFile = this.delayLoadingFile;
        geometry._delayLoadingFunction = this._delayLoadingFunction;
        for (kind in this._delayInfo) {
          geometry._delayInfo = geometry._delayInfo || [];
          geometry._delayInfo.push(kind);
        }
        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        return geometry;
      };
      Geometry2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.updatable = this._updatable;
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        return serializationObject;
      };
      Geometry2.prototype._toNumberArray = function(origin) {
        if (Array.isArray(origin)) {
          return origin;
        } else {
          return Array.prototype.slice.call(origin);
        }
      };
      Geometry2.prototype.clearCachedData = function() {
        this._indices = [];
        this._resetPointsArrayCache();
        for (var vbName in this._vertexBuffers) {
          if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
            continue;
          }
          this._vertexBuffers[vbName]._buffer._data = null;
        }
      };
      Geometry2.prototype.serializeVerticeData = function() {
        var serializationObject = this.serialize();
        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            serializationObject.positions._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            serializationObject.normals._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
            serializationObject.tangents._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
            serializationObject.uvs._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
            serializationObject.uv2s._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
          serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
            serializationObject.uv3s._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
          serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
            serializationObject.uv4s._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
          serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
            serializationObject.uv5s._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
          serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
            serializationObject.uv6s._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
            serializationObject.colors._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
          serializationObject.matricesIndices._isExpanded = true;
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
            serializationObject.matricesIndices._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
            serializationObject.matricesWeights._updatable = true;
          }
        }
        serializationObject.indices = this._toNumberArray(this.getIndices());
        return serializationObject;
      };
      Geometry2.ExtractFromMesh = function(mesh, id) {
        var geometry = mesh._geometry;
        if (!geometry) {
          return null;
        }
        return geometry.copy(id);
      };
      Geometry2.RandomId = function() {
        return Tools.RandomId();
      };
      Geometry2._GetGeometryByLoadedUniqueId = function(uniqueId, scene) {
        for (var index = 0; index < scene.geometries.length; index++) {
          if (scene.geometries[index]._loadedUniqueId === uniqueId) {
            return scene.geometries[index];
          }
        }
        return null;
      };
      Geometry2._ImportGeometry = function(parsedGeometry, mesh) {
        var scene = mesh.getScene();
        var geometryUniqueId = parsedGeometry.geometryUniqueId;
        var geometryId = parsedGeometry.geometryId;
        if (geometryUniqueId || geometryId) {
          var geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
          if (geometry) {
            geometry.applyToMesh(mesh);
          }
        } else if (parsedGeometry instanceof ArrayBuffer) {
          var binaryInfo = mesh._binaryInfo;
          if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
            var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
          }
          if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
            var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
          }
          if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
            var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
          }
          if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
            var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvsData.length; index += 2) {
                uvsData[index] = 1 - uvsData[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
          }
          if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
            var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvs2Data.length; index += 2) {
                uvs2Data[index] = 1 - uvs2Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
          }
          if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
            var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvs3Data.length; index += 2) {
                uvs3Data[index] = 1 - uvs3Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
          }
          if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
            var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvs4Data.length; index += 2) {
                uvs4Data[index] = 1 - uvs4Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
          }
          if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
            var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvs5Data.length; index += 2) {
                uvs5Data[index] = 1 - uvs5Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
          }
          if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
            var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (var index = 1; index < uvs6Data.length; index += 2) {
                uvs6Data[index] = 1 - uvs6Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
          }
          if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
            var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
          }
          if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
            var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
            var floatIndices = [];
            for (var i = 0; i < matricesIndicesData.length; i++) {
              var index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
          }
          if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
            var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
            var floatIndices = [];
            for (var i = 0; i < matricesIndicesData.length; i++) {
              var index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
          }
          if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
            var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
          }
          if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
            var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
            mesh.setIndices(indicesData, null);
          }
          if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
            var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
            mesh.subMeshes = [];
            for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
              var materialIndex = subMeshesData[i * 5 + 0];
              var verticesStart = subMeshesData[i * 5 + 1];
              var verticesCount = subMeshesData[i * 5 + 2];
              var indexStart = subMeshesData[i * 5 + 3];
              var indexCount = subMeshesData[i * 5 + 4];
              SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
            }
          }
        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
          mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
          mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
          if (parsedGeometry.tangents) {
            mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
          }
          if (parsedGeometry.uvs) {
            mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
          }
          if (parsedGeometry.uvs2) {
            mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
          }
          if (parsedGeometry.uvs3) {
            mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
          }
          if (parsedGeometry.uvs4) {
            mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
          }
          if (parsedGeometry.uvs5) {
            mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
          }
          if (parsedGeometry.uvs6) {
            mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
          }
          if (parsedGeometry.colors) {
            mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
          }
          if (parsedGeometry.matricesIndices) {
            if (!parsedGeometry.matricesIndices._isExpanded) {
              var floatIndices = [];
              for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {
                var matricesIndex = parsedGeometry.matricesIndices[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
            }
          }
          if (parsedGeometry.matricesIndicesExtra) {
            if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
              var floatIndices = [];
              for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
                var matricesIndex = parsedGeometry.matricesIndicesExtra[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
            }
          }
          if (parsedGeometry.matricesWeights) {
            Geometry2._CleanMatricesWeights(parsedGeometry, mesh);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
          }
          if (parsedGeometry.matricesWeightsExtra) {
            mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
          }
          mesh.setIndices(parsedGeometry.indices, null);
        }
        if (parsedGeometry.subMeshes) {
          mesh.subMeshes = [];
          for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
            var parsedSubMesh = parsedGeometry.subMeshes[subIndex];
            SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
          }
        }
        if (mesh._shouldGenerateFlatShading) {
          mesh.convertToFlatShadedMesh();
          mesh._shouldGenerateFlatShading = false;
        }
        mesh.computeWorldMatrix(true);
        scene.onMeshImportedObservable.notifyObservers(mesh);
      };
      Geometry2._CleanMatricesWeights = function(parsedGeometry, mesh) {
        var epsilon = 1e-3;
        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
          return;
        }
        var noInfluenceBoneIndex = 0;
        if (parsedGeometry.skeletonId > -1) {
          var skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
          if (!skeleton) {
            return;
          }
          noInfluenceBoneIndex = skeleton.bones.length;
        } else {
          return;
        }
        var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
        var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        var matricesWeights = parsedGeometry.matricesWeights;
        var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
        var influencers = parsedGeometry.numBoneInfluencer;
        var size = matricesWeights.length;
        for (var i = 0; i < size; i += 4) {
          var weight = 0;
          var firstZeroWeight = -1;
          for (var j = 0; j < 4; j++) {
            var w = matricesWeights[i + j];
            weight += w;
            if (w < epsilon && firstZeroWeight < 0) {
              firstZeroWeight = j;
            }
          }
          if (matricesWeightsExtra) {
            for (var j = 0; j < 4; j++) {
              var w = matricesWeightsExtra[i + j];
              weight += w;
              if (w < epsilon && firstZeroWeight < 0) {
                firstZeroWeight = j + 4;
              }
            }
          }
          if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
            firstZeroWeight = influencers - 1;
          }
          if (weight > epsilon) {
            var mweight = 1 / weight;
            for (var j = 0; j < 4; j++) {
              matricesWeights[i + j] *= mweight;
            }
            if (matricesWeightsExtra) {
              for (var j = 0; j < 4; j++) {
                matricesWeightsExtra[i + j] *= mweight;
              }
            }
          } else {
            if (firstZeroWeight >= 4) {
              matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
              matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
            } else {
              matricesWeights[i + firstZeroWeight] = 1 - weight;
              matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
            }
          }
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
        if (parsedGeometry.matricesWeightsExtra) {
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
        }
      };
      Geometry2.Parse = function(parsedVertexData, scene, rootUrl) {
        var geometry = new Geometry2(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
        geometry._loadedUniqueId = parsedVertexData.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(geometry, parsedVertexData.tags);
        }
        if (parsedVertexData.delayLoadingFile) {
          geometry.delayLoadState = 4;
          geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
          geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
          geometry._delayInfo = [];
          if (parsedVertexData.hasUVs) {
            geometry._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedVertexData.hasUVs2) {
            geometry._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedVertexData.hasUVs3) {
            geometry._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedVertexData.hasUVs4) {
            geometry._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedVertexData.hasUVs5) {
            geometry._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedVertexData.hasUVs6) {
            geometry._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedVertexData.hasColors) {
            geometry._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedVertexData.hasMatricesIndices) {
            geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedVertexData.hasMatricesWeights) {
            geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          geometry._delayLoadingFunction = VertexData.ImportVertexData;
        } else {
          VertexData.ImportVertexData(parsedVertexData, geometry);
        }
        scene.pushGeometry(geometry, true);
        return geometry;
      };
      return Geometry2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/transformNode.js
var TransformNode;
var init_transformNode = __esm({
  "node_modules/@babylonjs/core/Meshes/transformNode.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_node();
    init_math_axis();
    TransformNode = function(_super) {
      __extends(TransformNode2, _super);
      function TransformNode2(name105, scene, isPure) {
        if (scene === void 0) {
          scene = null;
        }
        if (isPure === void 0) {
          isPure = true;
        }
        var _this = _super.call(this, name105, scene) || this;
        _this._forward = new Vector3(0, 0, 1);
        _this._up = new Vector3(0, 1, 0);
        _this._right = new Vector3(1, 0, 0);
        _this._position = Vector3.Zero();
        _this._rotation = Vector3.Zero();
        _this._rotationQuaternion = null;
        _this._scaling = Vector3.One();
        _this._transformToBoneReferal = null;
        _this._isAbsoluteSynced = false;
        _this._billboardMode = TransformNode2.BILLBOARDMODE_NONE;
        _this._preserveParentRotationForBillboard = false;
        _this.scalingDeterminant = 1;
        _this._infiniteDistance = false;
        _this.ignoreNonUniformScaling = false;
        _this.reIntegrateRotationIntoRotationQuaternion = false;
        _this._poseMatrix = null;
        _this._localMatrix = Matrix.Zero();
        _this._usePivotMatrix = false;
        _this._absolutePosition = Vector3.Zero();
        _this._absoluteScaling = Vector3.Zero();
        _this._absoluteRotationQuaternion = Quaternion.Identity();
        _this._pivotMatrix = Matrix.Identity();
        _this._postMultiplyPivotMatrix = false;
        _this._isWorldMatrixFrozen = false;
        _this._indexInSceneTransformNodesArray = -1;
        _this.onAfterWorldMatrixUpdateObservable = new Observable();
        _this._nonUniformScaling = false;
        if (isPure) {
          _this.getScene().addTransformNode(_this);
        }
        return _this;
      }
      Object.defineProperty(TransformNode2.prototype, "billboardMode", {
        get: function() {
          return this._billboardMode;
        },
        set: function(value) {
          if (this._billboardMode === value) {
            return;
          }
          this._billboardMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "preserveParentRotationForBillboard", {
        get: function() {
          return this._preserveParentRotationForBillboard;
        },
        set: function(value) {
          if (value === this._preserveParentRotationForBillboard) {
            return;
          }
          this._preserveParentRotationForBillboard = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "infiniteDistance", {
        get: function() {
          return this._infiniteDistance;
        },
        set: function(value) {
          if (this._infiniteDistance === value) {
            return;
          }
          this._infiniteDistance = value;
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype.getClassName = function() {
        return "TransformNode";
      };
      Object.defineProperty(TransformNode2.prototype, "position", {
        get: function() {
          return this._position;
        },
        set: function(newPosition) {
          this._position = newPosition;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype.isUsingPivotMatrix = function() {
        return this._usePivotMatrix;
      };
      Object.defineProperty(TransformNode2.prototype, "rotation", {
        get: function() {
          return this._rotation;
        },
        set: function(newRotation) {
          this._rotation = newRotation;
          this._rotationQuaternion = null;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "scaling", {
        get: function() {
          return this._scaling;
        },
        set: function(newScaling) {
          this._scaling = newScaling;
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "rotationQuaternion", {
        get: function() {
          return this._rotationQuaternion;
        },
        set: function(quaternion) {
          this._rotationQuaternion = quaternion;
          if (quaternion) {
            this._rotation.setAll(0);
          }
          this._isDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "forward", {
        get: function() {
          Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
          return this._forward.normalize();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "up", {
        get: function() {
          Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
          return this._up.normalize();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "right", {
        get: function() {
          Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
          return this._right.normalize();
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype.updatePoseMatrix = function(matrix) {
        if (!this._poseMatrix) {
          this._poseMatrix = matrix.clone();
          return this;
        }
        this._poseMatrix.copyFrom(matrix);
        return this;
      };
      TransformNode2.prototype.getPoseMatrix = function() {
        if (!this._poseMatrix) {
          this._poseMatrix = Matrix.Identity();
        }
        return this._poseMatrix;
      };
      TransformNode2.prototype._isSynchronized = function() {
        var cache = this._cache;
        if (this.billboardMode !== cache.billboardMode || this.billboardMode !== TransformNode2.BILLBOARDMODE_NONE) {
          return false;
        }
        if (cache.pivotMatrixUpdated) {
          return false;
        }
        if (this.infiniteDistance) {
          return false;
        }
        if (this.position._isDirty) {
          return false;
        }
        if (this.scaling._isDirty) {
          return false;
        }
        if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this.rotation._isDirty) {
          return false;
        }
        return true;
      };
      TransformNode2.prototype._initCache = function() {
        _super.prototype._initCache.call(this);
        var cache = this._cache;
        cache.localMatrixUpdated = false;
        cache.billboardMode = -1;
        cache.infiniteDistance = false;
      };
      Object.defineProperty(TransformNode2.prototype, "absolutePosition", {
        get: function() {
          return this.getAbsolutePosition();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "absoluteScaling", {
        get: function() {
          this._syncAbsoluteScalingAndRotation();
          return this._absoluteScaling;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformNode2.prototype, "absoluteRotationQuaternion", {
        get: function() {
          this._syncAbsoluteScalingAndRotation();
          return this._absoluteRotationQuaternion;
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype.setPreTransformMatrix = function(matrix) {
        return this.setPivotMatrix(matrix, false);
      };
      TransformNode2.prototype.setPivotMatrix = function(matrix, postMultiplyPivotMatrix) {
        if (postMultiplyPivotMatrix === void 0) {
          postMultiplyPivotMatrix = true;
        }
        this._pivotMatrix.copyFrom(matrix);
        this._usePivotMatrix = !this._pivotMatrix.isIdentity();
        this._cache.pivotMatrixUpdated = true;
        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
        if (this._postMultiplyPivotMatrix) {
          if (!this._pivotMatrixInverse) {
            this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
          } else {
            this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
          }
        }
        return this;
      };
      TransformNode2.prototype.getPivotMatrix = function() {
        return this._pivotMatrix;
      };
      TransformNode2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
        if (newParent === void 0) {
          newParent = null;
        }
        var clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
        if (clone) {
          if (onNewNodeCreated) {
            onNewNodeCreated(this, clone);
          }
        }
        for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
          var child = _a[_i];
          child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
      };
      TransformNode2.prototype.freezeWorldMatrix = function(newWorldMatrix, decompose) {
        if (newWorldMatrix === void 0) {
          newWorldMatrix = null;
        }
        if (decompose === void 0) {
          decompose = false;
        }
        if (newWorldMatrix) {
          if (decompose) {
            this._rotation.setAll(0);
            this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
            newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
            this.computeWorldMatrix(true);
          } else {
            this._worldMatrix = newWorldMatrix;
            this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
            this._afterComputeWorldMatrix();
          }
        } else {
          this._isWorldMatrixFrozen = false;
          this.computeWorldMatrix(true);
        }
        this._isDirty = false;
        this._isWorldMatrixFrozen = true;
        return this;
      };
      TransformNode2.prototype.unfreezeWorldMatrix = function() {
        this._isWorldMatrixFrozen = false;
        this.computeWorldMatrix(true);
        return this;
      };
      Object.defineProperty(TransformNode2.prototype, "isWorldMatrixFrozen", {
        get: function() {
          return this._isWorldMatrixFrozen;
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype.getAbsolutePosition = function() {
        this.computeWorldMatrix();
        return this._absolutePosition;
      };
      TransformNode2.prototype.setAbsolutePosition = function(absolutePosition) {
        if (!absolutePosition) {
          return this;
        }
        var absolutePositionX;
        var absolutePositionY;
        var absolutePositionZ;
        if (absolutePosition.x === void 0) {
          if (arguments.length < 3) {
            return this;
          }
          absolutePositionX = arguments[0];
          absolutePositionY = arguments[1];
          absolutePositionZ = arguments[2];
        } else {
          absolutePositionX = absolutePosition.x;
          absolutePositionY = absolutePosition.y;
          absolutePositionZ = absolutePosition.z;
        }
        if (this.parent) {
          var invertParentWorldMatrix = TmpVectors.Matrix[0];
          this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
          Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
        } else {
          this.position.x = absolutePositionX;
          this.position.y = absolutePositionY;
          this.position.z = absolutePositionZ;
        }
        this._absolutePosition.copyFrom(absolutePosition);
        return this;
      };
      TransformNode2.prototype.setPositionWithLocalVector = function(vector3) {
        this.computeWorldMatrix();
        this.position = Vector3.TransformNormal(vector3, this._localMatrix);
        return this;
      };
      TransformNode2.prototype.getPositionExpressedInLocalSpace = function() {
        this.computeWorldMatrix();
        var invLocalWorldMatrix = TmpVectors.Matrix[0];
        this._localMatrix.invertToRef(invLocalWorldMatrix);
        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
      };
      TransformNode2.prototype.locallyTranslate = function(vector3) {
        this.computeWorldMatrix(true);
        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
        return this;
      };
      TransformNode2.prototype.lookAt = function(targetPoint, yawCor, pitchCor, rollCor, space) {
        if (yawCor === void 0) {
          yawCor = 0;
        }
        if (pitchCor === void 0) {
          pitchCor = 0;
        }
        if (rollCor === void 0) {
          rollCor = 0;
        }
        if (space === void 0) {
          space = Space.LOCAL;
        }
        var dv = TransformNode2._LookAtVectorCache;
        var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
        targetPoint.subtractToRef(pos, dv);
        this.setDirection(dv, yawCor, pitchCor, rollCor);
        if (space === Space.WORLD && this.parent) {
          if (this.rotationQuaternion) {
            var rotationMatrix = TmpVectors.Matrix[0];
            this.rotationQuaternion.toRotationMatrix(rotationMatrix);
            var parentRotationMatrix = TmpVectors.Matrix[1];
            this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
            parentRotationMatrix.invert();
            rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
            this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
          } else {
            var quaternionRotation = TmpVectors.Quaternion[0];
            Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
            var rotationMatrix = TmpVectors.Matrix[0];
            quaternionRotation.toRotationMatrix(rotationMatrix);
            var parentRotationMatrix = TmpVectors.Matrix[1];
            this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
            parentRotationMatrix.invert();
            rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
            quaternionRotation.fromRotationMatrix(rotationMatrix);
            quaternionRotation.toEulerAnglesToRef(this.rotation);
          }
        }
        return this;
      };
      TransformNode2.prototype.getDirection = function(localAxis) {
        var result = Vector3.Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
      };
      TransformNode2.prototype.getDirectionToRef = function(localAxis, result) {
        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
        return this;
      };
      TransformNode2.prototype.setDirection = function(localAxis, yawCor, pitchCor, rollCor) {
        if (yawCor === void 0) {
          yawCor = 0;
        }
        if (pitchCor === void 0) {
          pitchCor = 0;
        }
        if (rollCor === void 0) {
          rollCor = 0;
        }
        var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
        var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
        var pitch = -Math.atan2(localAxis.y, len);
        if (this.rotationQuaternion) {
          Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
        } else {
          this.rotation.x = pitch + pitchCor;
          this.rotation.y = yaw + yawCor;
          this.rotation.z = rollCor;
        }
        return this;
      };
      TransformNode2.prototype.setPivotPoint = function(point, space) {
        if (space === void 0) {
          space = Space.LOCAL;
        }
        if (this.getScene().getRenderId() == 0) {
          this.computeWorldMatrix(true);
        }
        var wm = this.getWorldMatrix();
        if (space == Space.WORLD) {
          var tmat = TmpVectors.Matrix[0];
          wm.invertToRef(tmat);
          point = Vector3.TransformCoordinates(point, tmat);
        }
        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
      };
      TransformNode2.prototype.getPivotPoint = function() {
        var point = Vector3.Zero();
        this.getPivotPointToRef(point);
        return point;
      };
      TransformNode2.prototype.getPivotPointToRef = function(result) {
        result.x = -this._pivotMatrix.m[12];
        result.y = -this._pivotMatrix.m[13];
        result.z = -this._pivotMatrix.m[14];
        return this;
      };
      TransformNode2.prototype.getAbsolutePivotPoint = function() {
        var point = Vector3.Zero();
        this.getAbsolutePivotPointToRef(point);
        return point;
      };
      TransformNode2.prototype.getAbsolutePivotPointToRef = function(result) {
        this.getPivotPointToRef(result);
        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
        return this;
      };
      TransformNode2.prototype.markAsDirty = function(property) {
        if (this._children) {
          for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.markAsDirty(property);
          }
        }
        return _super.prototype.markAsDirty.call(this, property);
      };
      TransformNode2.prototype.setParent = function(node, preserveScalingSign) {
        if (preserveScalingSign === void 0) {
          preserveScalingSign = false;
        }
        if (!node && !this.parent) {
          return this;
        }
        var quatRotation = TmpVectors.Quaternion[0];
        var position = TmpVectors.Vector3[0];
        var scale = TmpVectors.Vector3[1];
        var invParentMatrix = TmpVectors.Matrix[1];
        Matrix.IdentityToRef(invParentMatrix);
        var composedMatrix = TmpVectors.Matrix[0];
        this.computeWorldMatrix(true);
        var currentRotation = this.rotationQuaternion;
        if (!currentRotation) {
          currentRotation = TransformNode2._TmpRotation;
          Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
        }
        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
        if (this.parent) {
          composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
        }
        if (node) {
          node.computeWorldMatrix(true).invertToRef(invParentMatrix);
          composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
        }
        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
        if (this.rotationQuaternion) {
          this.rotationQuaternion.copyFrom(quatRotation);
        } else {
          quatRotation.toEulerAnglesToRef(this.rotation);
        }
        this.scaling.copyFrom(scale);
        this.position.copyFrom(position);
        this.parent = node;
        return this;
      };
      Object.defineProperty(TransformNode2.prototype, "nonUniformScaling", {
        get: function() {
          return this._nonUniformScaling;
        },
        enumerable: false,
        configurable: true
      });
      TransformNode2.prototype._updateNonUniformScalingState = function(value) {
        if (this._nonUniformScaling === value) {
          return false;
        }
        this._nonUniformScaling = value;
        return true;
      };
      TransformNode2.prototype.attachToBone = function(bone, affectedTransformNode) {
        this._currentParentWhenAttachingToBone = this.parent;
        this._transformToBoneReferal = affectedTransformNode;
        this.parent = bone;
        bone.getSkeleton().prepare();
        if (bone.getWorldMatrix().determinant() < 0) {
          this.scalingDeterminant *= -1;
        }
        return this;
      };
      TransformNode2.prototype.detachFromBone = function(resetToPreviousParent) {
        if (resetToPreviousParent === void 0) {
          resetToPreviousParent = false;
        }
        if (!this.parent) {
          if (resetToPreviousParent) {
            this.parent = this._currentParentWhenAttachingToBone;
          }
          return this;
        }
        if (this.parent.getWorldMatrix().determinant() < 0) {
          this.scalingDeterminant *= -1;
        }
        this._transformToBoneReferal = null;
        if (resetToPreviousParent) {
          this.parent = this._currentParentWhenAttachingToBone;
        } else {
          this.parent = null;
        }
        return this;
      };
      TransformNode2.prototype.rotate = function(axis, amount, space) {
        axis.normalize();
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = this.rotation.toQuaternion();
          this.rotation.setAll(0);
        }
        var rotationQuaternion;
        if (!space || space === Space.LOCAL) {
          rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._RotationAxisCache);
          this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
        } else {
          if (this.parent) {
            var invertParentWorldMatrix = TmpVectors.Matrix[0];
            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
            axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
          }
          rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._RotationAxisCache);
          rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        }
        return this;
      };
      TransformNode2.prototype.rotateAround = function(point, axis, amount) {
        axis.normalize();
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
          this.rotation.setAll(0);
        }
        var tmpVector = TmpVectors.Vector3[0];
        var finalScale = TmpVectors.Vector3[1];
        var finalTranslation = TmpVectors.Vector3[2];
        var finalRotation = TmpVectors.Quaternion[0];
        var translationMatrix = TmpVectors.Matrix[0];
        var translationMatrixInv = TmpVectors.Matrix[1];
        var rotationMatrix = TmpVectors.Matrix[2];
        var finalMatrix = TmpVectors.Matrix[3];
        point.subtractToRef(this.position, tmpVector);
        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
        Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
        finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
        this.position.addInPlace(finalTranslation);
        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        return this;
      };
      TransformNode2.prototype.translate = function(axis, distance, space) {
        var displacementVector = axis.scale(distance);
        if (!space || space === Space.LOCAL) {
          var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
          this.setPositionWithLocalVector(tempV3);
        } else {
          this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
        }
        return this;
      };
      TransformNode2.prototype.addRotation = function(x, y, z) {
        var rotationQuaternion;
        if (this.rotationQuaternion) {
          rotationQuaternion = this.rotationQuaternion;
        } else {
          rotationQuaternion = TmpVectors.Quaternion[1];
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
        }
        var accumulation = TmpVectors.Quaternion[0];
        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
        rotationQuaternion.multiplyInPlace(accumulation);
        if (!this.rotationQuaternion) {
          rotationQuaternion.toEulerAnglesToRef(this.rotation);
        }
        return this;
      };
      TransformNode2.prototype._getEffectiveParent = function() {
        return this.parent;
      };
      TransformNode2.prototype.computeWorldMatrix = function(force) {
        if (this._isWorldMatrixFrozen && !this._isDirty) {
          return this._worldMatrix;
        }
        var currentRenderId = this.getScene().getRenderId();
        if (!this._isDirty && !force && this.isSynchronized()) {
          this._currentRenderId = currentRenderId;
          return this._worldMatrix;
        }
        var camera = this.getScene().activeCamera;
        var useBillboardPosition = (this._billboardMode & TransformNode2.BILLBOARDMODE_USE_POSITION) !== 0;
        var useBillboardPath = this._billboardMode !== TransformNode2.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
        this._updateCache();
        var cache = this._cache;
        cache.pivotMatrixUpdated = false;
        cache.billboardMode = this.billboardMode;
        cache.infiniteDistance = this.infiniteDistance;
        cache.parent = this._parentNode;
        this._currentRenderId = currentRenderId;
        this._childUpdateId += 1;
        this._isDirty = false;
        this._position._isDirty = false;
        this._rotation._isDirty = false;
        this._scaling._isDirty = false;
        var parent = this._getEffectiveParent();
        var scaling = TransformNode2._TmpScaling;
        var translation = this._position;
        if (this._infiniteDistance) {
          if (!this.parent && camera) {
            var cameraWorldMatrix = camera.getWorldMatrix();
            var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
            translation = TransformNode2._TmpTranslation;
            translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
          }
        }
        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
        var rotation;
        if (this._rotationQuaternion) {
          this._rotationQuaternion._isDirty = false;
          rotation = this._rotationQuaternion;
          if (this.reIntegrateRotationIntoRotationQuaternion) {
            var len = this.rotation.lengthSquared();
            if (len) {
              this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
              this._rotation.copyFromFloats(0, 0, 0);
            }
          }
        } else {
          rotation = TransformNode2._TmpRotation;
          Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
        }
        if (this._usePivotMatrix) {
          var scaleMatrix = TmpVectors.Matrix[1];
          Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
          var rotationMatrix = TmpVectors.Matrix[0];
          rotation.toRotationMatrix(rotationMatrix);
          this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
          if (this._postMultiplyPivotMatrix) {
            this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
          }
          this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
        } else {
          Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
        }
        if (parent && parent.getWorldMatrix) {
          if (force) {
            parent.computeWorldMatrix(force);
          }
          if (useBillboardPath) {
            if (this._transformToBoneReferal) {
              parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
            } else {
              TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
            }
            var translation_1 = TmpVectors.Vector3[5];
            var scale = TmpVectors.Vector3[6];
            TmpVectors.Matrix[7].decompose(scale, void 0, translation_1);
            Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
            TmpVectors.Matrix[7].setTranslation(translation_1);
            this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
          } else {
            if (this._transformToBoneReferal) {
              this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);
              TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
            } else {
              this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
            }
          }
          this._markSyncedWithParent();
        } else {
          this._worldMatrix.copyFrom(this._localMatrix);
        }
        if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {
          var storedTranslation = TmpVectors.Vector3[0];
          this._worldMatrix.getTranslationToRef(storedTranslation);
          TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
          TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
          TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
          if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
            TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
            var eulerAngles = TmpVectors.Vector3[1];
            TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
              eulerAngles.x = 0;
            }
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
              eulerAngles.y = 0;
            }
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
              eulerAngles.z = 0;
            }
            Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
          }
          this._worldMatrix.setTranslationFromFloats(0, 0, 0);
          this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
          this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
        } else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {
          var storedTranslation = TmpVectors.Vector3[0];
          this._worldMatrix.getTranslationToRef(storedTranslation);
          var cameraPosition = camera.globalPosition;
          this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
          var camInObjSpace = TmpVectors.Vector3[1];
          Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
          camInObjSpace.normalize();
          var yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
          var len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
          var pitch = -Math.atan2(camInObjSpace.y, len);
          Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
          if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
            var eulerAngles = TmpVectors.Vector3[1];
            TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
              eulerAngles.x = 0;
            }
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
              eulerAngles.y = 0;
            }
            if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
              eulerAngles.z = 0;
            }
            Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
          } else {
            Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
          }
          this._worldMatrix.setTranslationFromFloats(0, 0, 0);
          this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
          this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
        }
        if (!this.ignoreNonUniformScaling) {
          if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
            this._updateNonUniformScalingState(true);
          } else if (parent && parent._nonUniformScaling) {
            this._updateNonUniformScalingState(parent._nonUniformScaling);
          } else {
            this._updateNonUniformScalingState(false);
          }
        } else {
          this._updateNonUniformScalingState(false);
        }
        this._afterComputeWorldMatrix();
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._isAbsoluteSynced = false;
        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
        if (!this._poseMatrix) {
          this._poseMatrix = Matrix.Invert(this._worldMatrix);
        }
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
      };
      TransformNode2.prototype.resetLocalMatrix = function(independentOfChildren) {
        if (independentOfChildren === void 0) {
          independentOfChildren = true;
        }
        this.computeWorldMatrix();
        if (independentOfChildren) {
          var children = this.getChildren();
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child) {
              child.computeWorldMatrix();
              var bakedMatrix = TmpVectors.Matrix[0];
              child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
              var tmpRotationQuaternion = TmpVectors.Quaternion[0];
              bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
              if (child.rotationQuaternion) {
                child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
              } else {
                tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
              }
            }
          }
        }
        this.scaling.copyFromFloats(1, 1, 1);
        this.position.copyFromFloats(0, 0, 0);
        this.rotation.copyFromFloats(0, 0, 0);
        if (this.rotationQuaternion) {
          this.rotationQuaternion = Quaternion.Identity();
        }
        this._worldMatrix = Matrix.Identity();
      };
      TransformNode2.prototype._afterComputeWorldMatrix = function() {
      };
      TransformNode2.prototype.registerAfterWorldMatrixUpdate = function(func) {
        this.onAfterWorldMatrixUpdateObservable.add(func);
        return this;
      };
      TransformNode2.prototype.unregisterAfterWorldMatrixUpdate = function(func) {
        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
        return this;
      };
      TransformNode2.prototype.getPositionInCameraSpace = function(camera) {
        if (camera === void 0) {
          camera = null;
        }
        if (!camera) {
          camera = this.getScene().activeCamera;
        }
        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
      };
      TransformNode2.prototype.getDistanceToCamera = function(camera) {
        if (camera === void 0) {
          camera = null;
        }
        if (!camera) {
          camera = this.getScene().activeCamera;
        }
        return this.getAbsolutePosition().subtract(camera.globalPosition).length();
      };
      TransformNode2.prototype.clone = function(name105, newParent, doNotCloneChildren) {
        var _this = this;
        var result = SerializationHelper.Clone(function() {
          return new TransformNode2(name105, _this.getScene());
        }, this);
        result.name = name105;
        result.id = name105;
        if (newParent) {
          result.parent = newParent;
        }
        if (!doNotCloneChildren) {
          var directDescendants = this.getDescendants(true);
          for (var index = 0; index < directDescendants.length; index++) {
            var child = directDescendants[index];
            if (child.clone) {
              child.clone(name105 + "." + child.name, result);
            }
          }
        }
        return result;
      };
      TransformNode2.prototype.serialize = function(currentSerializationObject) {
        var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.uniqueId = this.uniqueId;
        if (this.parent) {
          serializationObject.parentId = this.parent.uniqueId;
        }
        serializationObject.localMatrix = this.getPivotMatrix().asArray();
        serializationObject.isEnabled = this.isEnabled();
        if (this.parent) {
          serializationObject.parentId = this.parent.uniqueId;
        }
        return serializationObject;
      };
      TransformNode2.Parse = function(parsedTransformNode, scene, rootUrl) {
        var transformNode = SerializationHelper.Parse(function() {
          return new TransformNode2(parsedTransformNode.name, scene);
        }, parsedTransformNode, scene, rootUrl);
        if (parsedTransformNode.localMatrix) {
          transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
        } else if (parsedTransformNode.pivotMatrix) {
          transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
        }
        transformNode.setEnabled(parsedTransformNode.isEnabled);
        if (parsedTransformNode.parentId !== void 0) {
          transformNode._waitingParentId = parsedTransformNode.parentId;
        }
        return transformNode;
      };
      TransformNode2.prototype.getChildTransformNodes = function(directDescendantsOnly, predicate) {
        var results = [];
        this._getDescendants(results, directDescendantsOnly, function(node) {
          return (!predicate || predicate(node)) && node instanceof TransformNode2;
        });
        return results;
      };
      TransformNode2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        this.getScene().stopAnimation(this);
        this.getScene().removeTransformNode(this);
        if (this._parentContainer) {
          var index = this._parentContainer.transformNodes.indexOf(this);
          if (index > -1) {
            this._parentContainer.transformNodes.splice(index, 1);
          }
          this._parentContainer = null;
        }
        this.onAfterWorldMatrixUpdateObservable.clear();
        if (doNotRecurse) {
          var transformNodes = this.getChildTransformNodes(true);
          for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {
            var transformNode = transformNodes_1[_i];
            transformNode.parent = null;
            transformNode.computeWorldMatrix(true);
          }
        }
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
      };
      TransformNode2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
        if (includeDescendants === void 0) {
          includeDescendants = true;
        }
        if (ignoreRotation === void 0) {
          ignoreRotation = false;
        }
        var storedRotation = null;
        var storedRotationQuaternion = null;
        if (ignoreRotation) {
          if (this.rotationQuaternion) {
            storedRotationQuaternion = this.rotationQuaternion.clone();
            this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
          } else if (this.rotation) {
            storedRotation = this.rotation.clone();
            this.rotation.copyFromFloats(0, 0, 0);
          }
        }
        var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
        var sizeVec = boundingVectors.max.subtract(boundingVectors.min);
        var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        if (maxDimension === 0) {
          return this;
        }
        var scale = 1 / maxDimension;
        this.scaling.scaleInPlace(scale);
        if (ignoreRotation) {
          if (this.rotationQuaternion && storedRotationQuaternion) {
            this.rotationQuaternion.copyFrom(storedRotationQuaternion);
          } else if (this.rotation && storedRotation) {
            this.rotation.copyFrom(storedRotation);
          }
        }
        return this;
      };
      TransformNode2.prototype._syncAbsoluteScalingAndRotation = function() {
        if (!this._isAbsoluteSynced) {
          this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
          this._isAbsoluteSynced = true;
        }
      };
      TransformNode2.BILLBOARDMODE_NONE = 0;
      TransformNode2.BILLBOARDMODE_X = 1;
      TransformNode2.BILLBOARDMODE_Y = 2;
      TransformNode2.BILLBOARDMODE_Z = 4;
      TransformNode2.BILLBOARDMODE_ALL = 7;
      TransformNode2.BILLBOARDMODE_USE_POSITION = 128;
      TransformNode2._TmpRotation = Quaternion.Zero();
      TransformNode2._TmpScaling = Vector3.Zero();
      TransformNode2._TmpTranslation = Vector3.Zero();
      TransformNode2._LookAtVectorCache = new Vector3(0, 0, 0);
      TransformNode2._RotationAxisCache = new Quaternion();
      __decorate([
        serializeAsVector3("position")
      ], TransformNode2.prototype, "_position", void 0);
      __decorate([
        serializeAsVector3("rotation")
      ], TransformNode2.prototype, "_rotation", void 0);
      __decorate([
        serializeAsQuaternion("rotationQuaternion")
      ], TransformNode2.prototype, "_rotationQuaternion", void 0);
      __decorate([
        serializeAsVector3("scaling")
      ], TransformNode2.prototype, "_scaling", void 0);
      __decorate([
        serialize("billboardMode")
      ], TransformNode2.prototype, "_billboardMode", void 0);
      __decorate([
        serialize()
      ], TransformNode2.prototype, "scalingDeterminant", void 0);
      __decorate([
        serialize("infiniteDistance")
      ], TransformNode2.prototype, "_infiniteDistance", void 0);
      __decorate([
        serialize()
      ], TransformNode2.prototype, "ignoreNonUniformScaling", void 0);
      __decorate([
        serialize()
      ], TransformNode2.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
      return TransformNode2;
    }(Node);
  }
});

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData;
var init_meshCollisionData = __esm({
  "node_modules/@babylonjs/core/Collisions/meshCollisionData.js"() {
    init_math_vector();
    _MeshCollisionData = function() {
      function _MeshCollisionData2() {
        this._checkCollisions = false;
        this._collisionMask = -1;
        this._collisionGroup = -1;
        this._surroundingMeshes = null;
        this._collider = null;
        this._oldPositionForCollisions = new Vector3(0, 0, 0);
        this._diffPositionForCollisions = new Vector3(0, 0, 0);
        this._collisionResponse = true;
      }
      return _MeshCollisionData2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
var _FacetDataStorage, _InternalAbstractMeshDataInfo, AbstractMesh;
var init_abstractMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/abstractMesh.js"() {
    init_tslib_es6();
    init_tools();
    init_observable();
    init_math_vector();
    init_engine();
    init_buffer();
    init_mesh_vertexData();
    init_transformNode();
    init_pickingInfo();
    init_boundingInfo();
    init_uniformBuffer();
    init_meshCollisionData();
    init_devTools();
    init_math_functions();
    init_math_color();
    init_math_constants();
    init_math_axis();
    init_typeStore();
    _FacetDataStorage = function() {
      function _FacetDataStorage2() {
        this.facetNb = 0;
        this.partitioningSubdivisions = 10;
        this.partitioningBBoxRatio = 1.01;
        this.facetDataEnabled = false;
        this.facetParameters = {};
        this.bbSize = Vector3.Zero();
        this.subDiv = {
          max: 1,
          X: 1,
          Y: 1,
          Z: 1
        };
        this.facetDepthSort = false;
        this.facetDepthSortEnabled = false;
      }
      return _FacetDataStorage2;
    }();
    _InternalAbstractMeshDataInfo = function() {
      function _InternalAbstractMeshDataInfo2() {
        this._hasVertexAlpha = false;
        this._useVertexColors = true;
        this._numBoneInfluencers = 4;
        this._applyFog = true;
        this._receiveShadows = false;
        this._facetData = new _FacetDataStorage();
        this._visibility = 1;
        this._skeleton = null;
        this._layerMask = 268435455;
        this._computeBonesUsingShaders = true;
        this._isActive = false;
        this._onlyForInstances = false;
        this._isActiveIntermediate = false;
        this._onlyForInstancesIntermediate = false;
        this._actAsRegularMesh = false;
        this._currentLOD = null;
        this._currentLODIsUpToDate = false;
        this._collisionRetryCount = 3;
        this._morphTargetManager = null;
        this._renderingGroupId = 0;
        this._bakedVertexAnimationManager = null;
        this._material = null;
        this._positions = null;
        this._meshCollisionData = new _MeshCollisionData();
        this._enableDistantPicking = false;
      }
      return _InternalAbstractMeshDataInfo2;
    }();
    AbstractMesh = function(_super) {
      __extends(AbstractMesh2, _super);
      function AbstractMesh2(name105, scene) {
        if (scene === void 0) {
          scene = null;
        }
        var _this = _super.call(this, name105, scene, false) || this;
        _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
        _this._waitingMaterialId = null;
        _this.cullingStrategy = AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
        _this.onCollideObservable = new Observable();
        _this.onCollisionPositionChangeObservable = new Observable();
        _this.onMaterialChangedObservable = new Observable();
        _this.definedFacingForward = true;
        _this._occlusionQuery = null;
        _this._renderingGroup = null;
        _this.alphaIndex = Number.MAX_VALUE;
        _this.isVisible = true;
        _this.isPickable = true;
        _this.isNearPickable = false;
        _this.isNearGrabbable = false;
        _this.showSubMeshesBoundingBox = false;
        _this.isBlocker = false;
        _this.enablePointerMoveEvents = false;
        _this.outlineColor = Color3.Red();
        _this.outlineWidth = 0.02;
        _this.overlayColor = Color3.Red();
        _this.overlayAlpha = 0.5;
        _this.useOctreeForRenderingSelection = true;
        _this.useOctreeForPicking = true;
        _this.useOctreeForCollisions = true;
        _this.alwaysSelectAsActiveMesh = false;
        _this.doNotSyncBoundingInfo = false;
        _this.actionManager = null;
        _this.ellipsoid = new Vector3(0.5, 1, 0.5);
        _this.ellipsoidOffset = new Vector3(0, 0, 0);
        _this.edgesWidth = 1;
        _this.edgesColor = new Color4(1, 0, 0, 1);
        _this._edgesRenderer = null;
        _this._masterMesh = null;
        _this._boundingInfo = null;
        _this._boundingInfoIsDirty = true;
        _this._renderId = 0;
        _this._intersectionsInProgress = new Array();
        _this._unIndexed = false;
        _this._lightSources = new Array();
        _this._waitingData = {
          lods: null,
          actions: null,
          freezeWorldMatrix: null
        };
        _this._bonesTransformMatrices = null;
        _this._transformMatrixTexture = null;
        _this.onRebuildObservable = new Observable();
        _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
          if (collidedMesh === void 0) {
            collidedMesh = null;
          }
          newPosition.subtractToRef(_this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, _this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
          if (_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
            _this.position.addInPlace(_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
          }
          if (collidedMesh) {
            _this.onCollideObservable.notifyObservers(collidedMesh);
          }
          _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);
        };
        _this.getScene().addMesh(_this);
        _this._resyncLightSources();
        _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name105, !_this.getScene().getEngine().isWebGPU);
        _this._buildUniformLayout();
        return _this;
      }
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_NONE", {
        get: function() {
          return TransformNode.BILLBOARDMODE_NONE;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_X", {
        get: function() {
          return TransformNode.BILLBOARDMODE_X;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Y", {
        get: function() {
          return TransformNode.BILLBOARDMODE_Y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Z", {
        get: function() {
          return TransformNode.BILLBOARDMODE_Z;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_ALL", {
        get: function() {
          return TransformNode.BILLBOARDMODE_ALL;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_USE_POSITION", {
        get: function() {
          return TransformNode.BILLBOARDMODE_USE_POSITION;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "facetNb", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.facetNb;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "partitioningSubdivisions", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
        },
        set: function(nb) {
          this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "partitioningBBoxRatio", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
        },
        set: function(ratio) {
          this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "mustDepthSortFacets", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
        },
        set: function(sort) {
          this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "facetDepthSortFrom", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
        },
        set: function(location) {
          this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "collisionRetryCount", {
        get: function() {
          return this._internalAbstractMeshDataInfo._collisionRetryCount;
        },
        set: function(retryCount) {
          this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "isFacetDataEnabled", {
        get: function() {
          return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "morphTargetManager", {
        get: function() {
          return this._internalAbstractMeshDataInfo._morphTargetManager;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._morphTargetManager = value;
          this._syncGeometryWithMorphTargetManager();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "bakedVertexAnimationManager", {
        get: function() {
          return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype._syncGeometryWithMorphTargetManager = function() {
      };
      AbstractMesh2.prototype._updateNonUniformScalingState = function(value) {
        if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {
          return false;
        }
        this._markSubMeshesAsMiscDirty();
        return true;
      };
      Object.defineProperty(AbstractMesh2.prototype, "onCollide", {
        set: function(callback) {
          if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
            this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
          }
          this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "onCollisionPositionChange", {
        set: function(callback) {
          if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
            this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
          }
          this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "visibility", {
        get: function() {
          return this._internalAbstractMeshDataInfo._visibility;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._visibility === value) {
            return;
          }
          var oldValue = this._internalAbstractMeshDataInfo._visibility;
          this._internalAbstractMeshDataInfo._visibility = value;
          if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
            this._markSubMeshesAsMiscDirty();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "renderingGroupId", {
        get: function() {
          return this._internalAbstractMeshDataInfo._renderingGroupId;
        },
        set: function(value) {
          this._internalAbstractMeshDataInfo._renderingGroupId = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "material", {
        get: function() {
          return this._internalAbstractMeshDataInfo._material;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._material === value) {
            return;
          }
          if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
          }
          this._internalAbstractMeshDataInfo._material = value;
          if (value && value.meshMap) {
            value.meshMap[this.uniqueId] = this;
          }
          if (this.onMaterialChangedObservable.hasObservers()) {
            this.onMaterialChangedObservable.notifyObservers(this);
          }
          if (!this.subMeshes) {
            return;
          }
          this.resetDrawCache();
          this._unBindEffect();
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype.getMaterialForRenderPass = function(renderPassId) {
        var _a;
        return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];
      };
      AbstractMesh2.prototype.setMaterialForRenderPass = function(renderPassId, material) {
        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
          this._internalAbstractMeshDataInfo._materialForRenderPass = [];
        }
        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
      };
      Object.defineProperty(AbstractMesh2.prototype, "receiveShadows", {
        get: function() {
          return this._internalAbstractMeshDataInfo._receiveShadows;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._receiveShadows = value;
          this._markSubMeshesAsLightDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "hasVertexAlpha", {
        get: function() {
          return this._internalAbstractMeshDataInfo._hasVertexAlpha;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
          this._markSubMeshesAsAttributesDirty();
          this._markSubMeshesAsMiscDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "useVertexColors", {
        get: function() {
          return this._internalAbstractMeshDataInfo._useVertexColors;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._useVertexColors = value;
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "computeBonesUsingShaders", {
        get: function() {
          return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "numBoneInfluencers", {
        get: function() {
          return this._internalAbstractMeshDataInfo._numBoneInfluencers;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "applyFog", {
        get: function() {
          return this._internalAbstractMeshDataInfo._applyFog;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._applyFog === value) {
            return;
          }
          this._internalAbstractMeshDataInfo._applyFog = value;
          this._markSubMeshesAsMiscDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "enableDistantPicking", {
        get: function() {
          return this._internalAbstractMeshDataInfo._enableDistantPicking;
        },
        set: function(value) {
          this._internalAbstractMeshDataInfo._enableDistantPicking = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "layerMask", {
        get: function() {
          return this._internalAbstractMeshDataInfo._layerMask;
        },
        set: function(value) {
          if (value === this._internalAbstractMeshDataInfo._layerMask) {
            return;
          }
          this._internalAbstractMeshDataInfo._layerMask = value;
          this._resyncLightSources();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "collisionMask", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
        },
        set: function(mask) {
          this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "collisionResponse", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
        },
        set: function(response) {
          this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "collisionGroup", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
        },
        set: function(mask) {
          this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "surroundingMeshes", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
        },
        set: function(meshes) {
          this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "lightSources", {
        get: function() {
          return this._lightSources;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "_positions", {
        get: function() {
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "skeleton", {
        get: function() {
          return this._internalAbstractMeshDataInfo._skeleton;
        },
        set: function(value) {
          var skeleton = this._internalAbstractMeshDataInfo._skeleton;
          if (skeleton && skeleton.needInitialSkinMatrix) {
            skeleton._unregisterMeshWithPoseMatrix(this);
          }
          if (value && value.needInitialSkinMatrix) {
            value._registerMeshWithPoseMatrix(this);
          }
          this._internalAbstractMeshDataInfo._skeleton = value;
          if (!this._internalAbstractMeshDataInfo._skeleton) {
            this._bonesTransformMatrices = null;
          }
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype._buildUniformLayout = function() {
        this._uniformBuffer.addUniform("world", 16);
        this._uniformBuffer.addUniform("visibility", 1);
        this._uniformBuffer.create();
      };
      AbstractMesh2.prototype.transferToEffect = function(world) {
        var ubo = this._uniformBuffer;
        ubo.updateMatrix("world", world);
        ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
        ubo.update();
      };
      AbstractMesh2.prototype.getMeshUniformBuffer = function() {
        return this._uniformBuffer;
      };
      AbstractMesh2.prototype.getClassName = function() {
        return "AbstractMesh";
      };
      AbstractMesh2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
        ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
        var skeleton = this._internalAbstractMeshDataInfo._skeleton;
        if (skeleton) {
          ret += ", skeleton: " + skeleton.name;
        }
        if (fullDetails) {
          ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
          ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
        }
        return ret;
      };
      AbstractMesh2.prototype._getEffectiveParent = function() {
        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
          return this._masterMesh;
        }
        return _super.prototype._getEffectiveParent.call(this);
      };
      AbstractMesh2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
        if (initialCall === void 0) {
          initialCall = true;
        }
        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
          if (trigger) {
            if (this.actionManager.hasSpecificTrigger(trigger)) {
              return this.actionManager;
            }
          } else {
            return this.actionManager;
          }
        }
        if (!this.parent) {
          return null;
        }
        return this.parent._getActionManagerForTrigger(trigger, false);
      };
      AbstractMesh2.prototype._rebuild = function(dispose) {
        if (dispose === void 0) {
          dispose = false;
        }
        this.onRebuildObservable.notifyObservers(this);
        if (this._occlusionQuery !== null) {
          this._occlusionQuery = null;
        }
        if (!this.subMeshes) {
          return;
        }
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          subMesh._rebuild();
        }
      };
      AbstractMesh2.prototype._resyncLightSources = function() {
        this._lightSources.length = 0;
        for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {
          var light = _a[_i];
          if (!light.isEnabled()) {
            continue;
          }
          if (light.canAffectMesh(this)) {
            this._lightSources.push(light);
          }
        }
        this._markSubMeshesAsLightDirty();
      };
      AbstractMesh2.prototype._resyncLightSource = function(light) {
        var isIn = light.isEnabled() && light.canAffectMesh(this);
        var index = this._lightSources.indexOf(light);
        var removed = false;
        if (index === -1) {
          if (!isIn) {
            return;
          }
          this._lightSources.push(light);
        } else {
          if (isIn) {
            return;
          }
          removed = true;
          this._lightSources.splice(index, 1);
        }
        this._markSubMeshesAsLightDirty(removed);
      };
      AbstractMesh2.prototype._unBindEffect = function() {
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          subMesh.setEffect(null);
        }
      };
      AbstractMesh2.prototype._removeLightSource = function(light, dispose) {
        var index = this._lightSources.indexOf(light);
        if (index === -1) {
          return;
        }
        this._lightSources.splice(index, 1);
        this._markSubMeshesAsLightDirty(dispose);
      };
      AbstractMesh2.prototype._markSubMeshesAsDirty = function(func) {
        if (!this.subMeshes) {
          return;
        }
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          for (var i = 0; i < subMesh._drawWrappers.length; ++i) {
            var drawWrapper = subMesh._drawWrappers[i];
            if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
              continue;
            }
            func(drawWrapper.defines);
          }
        }
      };
      AbstractMesh2.prototype._markSubMeshesAsLightDirty = function(dispose) {
        if (dispose === void 0) {
          dispose = false;
        }
        this._markSubMeshesAsDirty(function(defines) {
          return defines.markAsLightDirty(dispose);
        });
      };
      AbstractMesh2.prototype._markSubMeshesAsAttributesDirty = function() {
        this._markSubMeshesAsDirty(function(defines) {
          return defines.markAsAttributesDirty();
        });
      };
      AbstractMesh2.prototype._markSubMeshesAsMiscDirty = function() {
        this._markSubMeshesAsDirty(function(defines) {
          return defines.markAsMiscDirty();
        });
      };
      AbstractMesh2.prototype.markAsDirty = function(property) {
        this._currentRenderId = Number.MAX_VALUE;
        this._isDirty = true;
        return this;
      };
      AbstractMesh2.prototype.resetDrawCache = function(passId) {
        if (!this.subMeshes) {
          return;
        }
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          subMesh.resetDrawCache(passId);
        }
      };
      Object.defineProperty(AbstractMesh2.prototype, "scaling", {
        get: function() {
          return this._scaling;
        },
        set: function(newScaling) {
          this._scaling = newScaling;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "isBlocked", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype.getLOD = function(camera) {
        return this;
      };
      AbstractMesh2.prototype.getTotalVertices = function() {
        return 0;
      };
      AbstractMesh2.prototype.getTotalIndices = function() {
        return 0;
      };
      AbstractMesh2.prototype.getIndices = function() {
        return null;
      };
      AbstractMesh2.prototype.getVerticesData = function(kind) {
        return null;
      };
      AbstractMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
        return this;
      };
      AbstractMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
        return this;
      };
      AbstractMesh2.prototype.setIndices = function(indices, totalVertices) {
        return this;
      };
      AbstractMesh2.prototype.isVerticesDataPresent = function(kind) {
        return false;
      };
      AbstractMesh2.prototype.getBoundingInfo = function() {
        if (this._masterMesh) {
          return this._masterMesh.getBoundingInfo();
        }
        if (this._boundingInfoIsDirty) {
          this._boundingInfoIsDirty = false;
          this._updateBoundingInfo();
        }
        return this._boundingInfo;
      };
      AbstractMesh2.prototype.setBoundingInfo = function(boundingInfo) {
        this._boundingInfo = boundingInfo;
        return this;
      };
      Object.defineProperty(AbstractMesh2.prototype, "hasBoundingInfo", {
        get: function() {
          return this._boundingInfo !== null;
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype.buildBoundingInfo = function(minimum, maximum, worldMatrix) {
        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
        return this._boundingInfo;
      };
      AbstractMesh2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
        if (includeDescendants === void 0) {
          includeDescendants = true;
        }
        if (ignoreRotation === void 0) {
          ignoreRotation = false;
        }
        return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);
      };
      Object.defineProperty(AbstractMesh2.prototype, "useBones", {
        get: function() {
          return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype._preActivate = function() {
      };
      AbstractMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
      };
      AbstractMesh2.prototype._activate = function(renderId, intermediateRendering) {
        this._renderId = renderId;
        return true;
      };
      AbstractMesh2.prototype._postActivate = function() {
      };
      AbstractMesh2.prototype._freeze = function() {
      };
      AbstractMesh2.prototype._unFreeze = function() {
      };
      AbstractMesh2.prototype.getWorldMatrix = function() {
        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
          return this._masterMesh.getWorldMatrix();
        }
        return _super.prototype.getWorldMatrix.call(this);
      };
      AbstractMesh2.prototype._getWorldMatrixDeterminant = function() {
        if (this._masterMesh) {
          return this._masterMesh._getWorldMatrixDeterminant();
        }
        return _super.prototype._getWorldMatrixDeterminant.call(this);
      };
      Object.defineProperty(AbstractMesh2.prototype, "isAnInstance", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "hasInstances", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "hasThinInstances", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype.movePOV = function(amountRight, amountUp, amountForward) {
        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
        return this;
      };
      AbstractMesh2.prototype.calcMovePOV = function(amountRight, amountUp, amountForward) {
        var rotMatrix = new Matrix();
        var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
        rotQuaternion.toRotationMatrix(rotMatrix);
        var translationDelta = Vector3.Zero();
        var defForwardMult = this.definedFacingForward ? -1 : 1;
        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
        return translationDelta;
      };
      AbstractMesh2.prototype.rotatePOV = function(flipBack, twirlClockwise, tiltRight) {
        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
        return this;
      };
      AbstractMesh2.prototype.calcRotatePOV = function(flipBack, twirlClockwise, tiltRight) {
        var defForwardMult = this.definedFacingForward ? 1 : -1;
        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
      };
      AbstractMesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
        if (applySkeleton === void 0) {
          applySkeleton = false;
        }
        if (applyMorph === void 0) {
          applyMorph = false;
        }
        if (this._boundingInfo && this._boundingInfo.isLocked) {
          return this;
        }
        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);
        return this;
      };
      AbstractMesh2.prototype._refreshBoundingInfo = function(data, bias) {
        if (data) {
          var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
          if (this._boundingInfo) {
            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
          } else {
            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
          }
        }
        if (this.subMeshes) {
          for (var index = 0; index < this.subMeshes.length; index++) {
            this.subMeshes[index].refreshBoundingInfo(data);
          }
        }
        this._updateBoundingInfo();
      };
      AbstractMesh2.prototype.getPositionData = function(applySkeleton, applyMorph, data) {
        if (applySkeleton === void 0) {
          applySkeleton = false;
        }
        if (applyMorph === void 0) {
          applyMorph = false;
        }
        data = data !== null && data !== void 0 ? data : Tools.Slice(this.getVerticesData(VertexBuffer.PositionKind));
        if (data && applyMorph && this.morphTargetManager) {
          var faceIndexCount = 0;
          var positionIndex = 0;
          for (var vertexCount = 0; vertexCount < data.length; vertexCount++) {
            for (var targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {
              var targetMorph = this.morphTargetManager.getTarget(targetCount);
              var influence = targetMorph.influence;
              if (influence > 0) {
                var morphTargetPositions = targetMorph.getPositions();
                if (morphTargetPositions) {
                  data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;
                }
              }
            }
            faceIndexCount++;
            if (this._positions && faceIndexCount === 3) {
              faceIndexCount = 0;
              var index = positionIndex * 3;
              this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);
            }
          }
        }
        if (data && applySkeleton && this.skeleton) {
          var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
          var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
          if (matricesWeightsData && matricesIndicesData) {
            var needExtras = this.numBoneInfluencers > 4;
            var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
            var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
            var skeletonMatrices = this.skeleton.getTransformMatrices(this);
            var tempVector = TmpVectors.Vector3[0];
            var finalMatrix = TmpVectors.Matrix[0];
            var tempMatrix = TmpVectors.Matrix[1];
            var matWeightIdx = 0;
            for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {
              finalMatrix.reset();
              var inf = void 0;
              var weight = void 0;
              for (inf = 0; inf < 4; inf++) {
                weight = matricesWeightsData[matWeightIdx + inf];
                if (weight > 0) {
                  Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
                  finalMatrix.addToSelf(tempMatrix);
                }
              }
              if (needExtras) {
                for (inf = 0; inf < 4; inf++) {
                  weight = matricesWeightsExtraData[matWeightIdx + inf];
                  if (weight > 0) {
                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                    finalMatrix.addToSelf(tempMatrix);
                  }
                }
              }
              Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
              tempVector.toArray(data, index);
              if (this._positions) {
                this._positions[index / 3].copyFrom(tempVector);
              }
            }
          }
        }
        return data;
      };
      AbstractMesh2.prototype._getPositionData = function(applySkeleton, applyMorph) {
        var _a;
        var data = this.getVerticesData(VertexBuffer.PositionKind);
        if (this._internalAbstractMeshDataInfo._positions) {
          this._internalAbstractMeshDataInfo._positions = null;
        }
        if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {
          data = Tools.Slice(data);
          this._generatePointsArray();
          if (this._positions) {
            var pos = this._positions;
            this._internalAbstractMeshDataInfo._positions = new Array(pos.length);
            for (var i = 0; i < pos.length; i++) {
              this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();
            }
          }
          return this.getPositionData(applySkeleton, applyMorph, data);
        }
        return data;
      };
      AbstractMesh2.prototype._updateBoundingInfo = function() {
        if (this._boundingInfo) {
          this._boundingInfo.update(this.worldMatrixFromCache);
        } else {
          this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
        }
        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        return this;
      };
      AbstractMesh2.prototype._updateSubMeshesBoundingInfo = function(matrix) {
        if (!this.subMeshes) {
          return this;
        }
        var count = this.subMeshes.length;
        for (var subIndex = 0; subIndex < count; subIndex++) {
          var subMesh = this.subMeshes[subIndex];
          if (count > 1 || !subMesh.IsGlobal) {
            subMesh.updateBoundingInfo(matrix);
          }
        }
        return this;
      };
      AbstractMesh2.prototype._afterComputeWorldMatrix = function() {
        if (this.doNotSyncBoundingInfo) {
          return;
        }
        this._boundingInfoIsDirty = true;
      };
      AbstractMesh2.prototype.isInFrustum = function(frustumPlanes) {
        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
      };
      AbstractMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
      };
      AbstractMesh2.prototype.intersectsMesh = function(mesh, precise, includeDescendants) {
        if (precise === void 0) {
          precise = false;
        }
        var boundingInfo = this.getBoundingInfo();
        var otherBoundingInfo = mesh.getBoundingInfo();
        if (boundingInfo.intersects(otherBoundingInfo, precise)) {
          return true;
        }
        if (includeDescendants) {
          for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {
            var child = _a[_i];
            if (child.intersectsMesh(mesh, precise, true)) {
              return true;
            }
          }
        }
        return false;
      };
      AbstractMesh2.prototype.intersectsPoint = function(point) {
        return this.getBoundingInfo().intersectsPoint(point);
      };
      Object.defineProperty(AbstractMesh2.prototype, "checkCollisions", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
        },
        set: function(collisionEnabled) {
          this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractMesh2.prototype, "collider", {
        get: function() {
          return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
        },
        enumerable: false,
        configurable: true
      });
      AbstractMesh2.prototype.moveWithCollisions = function(displacement) {
        var globalPosition = this.getAbsolutePosition();
        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
        var coordinator = this.getScene().collisionCoordinator;
        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
          this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
        }
        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
        coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
        return this;
      };
      AbstractMesh2.prototype._collideForSubMesh = function(subMesh, transformMatrix, collider) {
        var _a;
        this._generatePointsArray();
        if (!this._positions) {
          return this;
        }
        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
          subMesh._lastColliderTransformMatrix = transformMatrix.clone();
          subMesh._lastColliderWorldVertices = [];
          subMesh._trianglePlanes = [];
          var start = subMesh.verticesStart;
          var end = subMesh.verticesStart + subMesh.verticesCount;
          for (var i = start; i < end; i++) {
            subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
          }
        }
        collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);
        return this;
      };
      AbstractMesh2.prototype._processCollisionsForSubMeshes = function(collider, transformMatrix) {
        var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
        var len = subMeshes.length;
        for (var index = 0; index < len; index++) {
          var subMesh = subMeshes.data[index];
          if (len > 1 && !subMesh._checkCollision(collider)) {
            continue;
          }
          this._collideForSubMesh(subMesh, transformMatrix, collider);
        }
        return this;
      };
      AbstractMesh2.prototype._shouldConvertRHS = function() {
        return false;
      };
      AbstractMesh2.prototype._checkCollision = function(collider) {
        if (!this.getBoundingInfo()._checkCollision(collider)) {
          return this;
        }
        var collisionsScalingMatrix = TmpVectors.Matrix[0];
        var collisionsTransformMatrix = TmpVectors.Matrix[1];
        Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
        return this;
      };
      AbstractMesh2.prototype._generatePointsArray = function() {
        return false;
      };
      AbstractMesh2.prototype.intersects = function(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {
        if (onlyBoundingInfo === void 0) {
          onlyBoundingInfo = false;
        }
        if (skipBoundingInfo === void 0) {
          skipBoundingInfo = false;
        }
        var pickingInfo = new PickingInfo();
        var intersectionThreshold = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0;
        var boundingInfo = this.getBoundingInfo();
        if (!this.subMeshes) {
          return pickingInfo;
        }
        if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
          return pickingInfo;
        }
        if (onlyBoundingInfo) {
          pickingInfo.hit = skipBoundingInfo ? false : true;
          pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
          pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
          pickingInfo.subMeshId = 0;
          return pickingInfo;
        }
        if (!this._generatePointsArray()) {
          return pickingInfo;
        }
        var intersectInfo = null;
        var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
        var len = subMeshes.length;
        var anySubmeshSupportIntersect = false;
        for (var index = 0; index < len; index++) {
          var subMesh = subMeshes.data[index];
          var material = subMesh.getMaterial();
          if (!material) {
            continue;
          }
          if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
            anySubmeshSupportIntersect = true;
            break;
          }
        }
        if (!anySubmeshSupportIntersect) {
          pickingInfo.hit = true;
          pickingInfo.pickedMesh = this;
          pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
          pickingInfo.subMeshId = -1;
          return pickingInfo;
        }
        for (var index = 0; index < len; index++) {
          var subMesh = subMeshes.data[index];
          if (len > 1 && !subMesh.canIntersects(ray)) {
            continue;
          }
          var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
          if (currentIntersectInfo) {
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.subMeshId = index;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        if (intersectInfo) {
          var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();
          var worldOrigin = TmpVectors.Vector3[0];
          var direction = TmpVectors.Vector3[1];
          Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
          ray.direction.scaleToRef(intersectInfo.distance, direction);
          var worldDirection = Vector3.TransformNormal(direction, world);
          var pickedPoint = worldDirection.addInPlace(worldOrigin);
          pickingInfo.hit = true;
          pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
          pickingInfo.pickedPoint = pickedPoint;
          pickingInfo.pickedMesh = this;
          pickingInfo.bu = intersectInfo.bu || 0;
          pickingInfo.bv = intersectInfo.bv || 0;
          pickingInfo.subMeshFaceId = intersectInfo.faceId;
          pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
          pickingInfo.subMeshId = intersectInfo.subMeshId;
          return pickingInfo;
        }
        return pickingInfo;
      };
      AbstractMesh2.prototype.clone = function(name105, newParent, doNotCloneChildren) {
        return null;
      };
      AbstractMesh2.prototype.releaseSubMeshes = function() {
        if (this.subMeshes) {
          while (this.subMeshes.length) {
            this.subMeshes[0].dispose();
          }
        } else {
          this.subMeshes = new Array();
        }
        return this;
      };
      AbstractMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        var _this = this;
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        var index;
        if (this._scene.useMaterialMeshMap) {
          if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
          }
        }
        this.getScene().freeActiveMeshes();
        this.getScene().freeRenderingGroups();
        if (this.actionManager !== void 0 && this.actionManager !== null) {
          this.actionManager.dispose();
          this.actionManager = null;
        }
        this._internalAbstractMeshDataInfo._skeleton = null;
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
        for (index = 0; index < this._intersectionsInProgress.length; index++) {
          var other = this._intersectionsInProgress[index];
          var pos = other._intersectionsInProgress.indexOf(this);
          other._intersectionsInProgress.splice(pos, 1);
        }
        this._intersectionsInProgress = [];
        var lights = this.getScene().lights;
        lights.forEach(function(light) {
          var meshIndex = light.includedOnlyMeshes.indexOf(_this);
          if (meshIndex !== -1) {
            light.includedOnlyMeshes.splice(meshIndex, 1);
          }
          meshIndex = light.excludedMeshes.indexOf(_this);
          if (meshIndex !== -1) {
            light.excludedMeshes.splice(meshIndex, 1);
          }
          var generator = light.getShadowGenerator();
          if (generator) {
            var shadowMap = generator.getShadowMap();
            if (shadowMap && shadowMap.renderList) {
              meshIndex = shadowMap.renderList.indexOf(_this);
              if (meshIndex !== -1) {
                shadowMap.renderList.splice(meshIndex, 1);
              }
            }
          }
        });
        if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
          this.releaseSubMeshes();
        }
        var engine = this.getScene().getEngine();
        if (this._occlusionQuery !== null) {
          this.isOcclusionQueryInProgress = false;
          engine.deleteQuery(this._occlusionQuery);
          this._occlusionQuery = null;
        }
        engine.wipeCaches();
        this.getScene().removeMesh(this);
        if (this._parentContainer) {
          var index_1 = this._parentContainer.meshes.indexOf(this);
          if (index_1 > -1) {
            this._parentContainer.meshes.splice(index_1, 1);
          }
          this._parentContainer = null;
        }
        if (disposeMaterialAndTextures) {
          if (this.material) {
            if (this.material.getClassName() === "MultiMaterial") {
              this.material.dispose(false, true, true);
            } else {
              this.material.dispose(false, true);
            }
          }
        }
        if (!doNotRecurse) {
          for (index = 0; index < this.getScene().particleSystems.length; index++) {
            if (this.getScene().particleSystems[index].emitter === this) {
              this.getScene().particleSystems[index].dispose();
              index--;
            }
          }
        }
        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
          this.disableFacetData();
        }
        this._uniformBuffer.dispose();
        this.onAfterWorldMatrixUpdateObservable.clear();
        this.onCollideObservable.clear();
        this.onCollisionPositionChangeObservable.clear();
        this.onRebuildObservable.clear();
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
      };
      AbstractMesh2.prototype.addChild = function(mesh, preserveScalingSign) {
        if (preserveScalingSign === void 0) {
          preserveScalingSign = false;
        }
        mesh.setParent(this, preserveScalingSign);
        return this;
      };
      AbstractMesh2.prototype.removeChild = function(mesh, preserveScalingSign) {
        if (preserveScalingSign === void 0) {
          preserveScalingSign = false;
        }
        mesh.setParent(null, preserveScalingSign);
        return this;
      };
      AbstractMesh2.prototype._initFacetData = function() {
        var data = this._internalAbstractMeshDataInfo._facetData;
        if (!data.facetNormals) {
          data.facetNormals = new Array();
        }
        if (!data.facetPositions) {
          data.facetPositions = new Array();
        }
        if (!data.facetPartitioning) {
          data.facetPartitioning = new Array();
        }
        data.facetNb = this.getIndices().length / 3 | 0;
        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
        for (var f = 0; f < data.facetNb; f++) {
          data.facetNormals[f] = Vector3.Zero();
          data.facetPositions[f] = Vector3.Zero();
        }
        data.facetDataEnabled = true;
        return this;
      };
      AbstractMesh2.prototype.updateFacetData = function() {
        var data = this._internalAbstractMeshDataInfo._facetData;
        if (!data.facetDataEnabled) {
          this._initFacetData();
        }
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        var indices = this.getIndices();
        var normals = this.getVerticesData(VertexBuffer.NormalKind);
        var bInfo = this.getBoundingInfo();
        if (data.facetDepthSort && !data.facetDepthSortEnabled) {
          data.facetDepthSortEnabled = true;
          if (indices instanceof Uint16Array) {
            data.depthSortedIndices = new Uint16Array(indices);
          } else if (indices instanceof Uint32Array) {
            data.depthSortedIndices = new Uint32Array(indices);
          } else {
            var needs32bits = false;
            for (var i = 0; i < indices.length; i++) {
              if (indices[i] > 65535) {
                needs32bits = true;
                break;
              }
            }
            if (needs32bits) {
              data.depthSortedIndices = new Uint32Array(indices);
            } else {
              data.depthSortedIndices = new Uint16Array(indices);
            }
          }
          data.facetDepthSortFunction = function(f1, f2) {
            return f2.sqDistance - f1.sqDistance;
          };
          if (!data.facetDepthSortFrom) {
            var camera = this.getScene().activeCamera;
            data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
          }
          data.depthSortedFacets = [];
          for (var f = 0; f < data.facetNb; f++) {
            var depthSortedFacet = { ind: f * 3, sqDistance: 0 };
            data.depthSortedFacets.push(depthSortedFacet);
          }
          data.invertedMatrix = Matrix.Identity();
          data.facetDepthSortOrigin = Vector3.Zero();
        }
        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
        var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
        data.subDiv.max = data.partitioningSubdivisions;
        data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
        data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
        data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
        data.facetParameters.facetNormals = this.getFacetLocalNormals();
        data.facetParameters.facetPositions = this.getFacetLocalPositions();
        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
        data.facetParameters.bInfo = bInfo;
        data.facetParameters.bbSize = data.bbSize;
        data.facetParameters.subDiv = data.subDiv;
        data.facetParameters.ratio = this.partitioningBBoxRatio;
        data.facetParameters.depthSort = data.facetDepthSort;
        if (data.facetDepthSort && data.facetDepthSortEnabled) {
          this.computeWorldMatrix(true);
          this._worldMatrix.invertToRef(data.invertedMatrix);
          Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
          data.facetParameters.distanceTo = data.facetDepthSortOrigin;
        }
        data.facetParameters.depthSortedFacets = data.depthSortedFacets;
        if (normals) {
          VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
        }
        if (data.facetDepthSort && data.facetDepthSortEnabled) {
          data.depthSortedFacets.sort(data.facetDepthSortFunction);
          var l = data.depthSortedIndices.length / 3 | 0;
          for (var f = 0; f < l; f++) {
            var sind = data.depthSortedFacets[f].ind;
            data.depthSortedIndices[f * 3] = indices[sind];
            data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
            data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
          }
          this.updateIndices(data.depthSortedIndices, void 0, true);
        }
        return this;
      };
      AbstractMesh2.prototype.getFacetLocalNormals = function() {
        var facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetNormals) {
          this.updateFacetData();
        }
        return facetData.facetNormals;
      };
      AbstractMesh2.prototype.getFacetLocalPositions = function() {
        var facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetPositions) {
          this.updateFacetData();
        }
        return facetData.facetPositions;
      };
      AbstractMesh2.prototype.getFacetLocalPartitioning = function() {
        var facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetPartitioning) {
          this.updateFacetData();
        }
        return facetData.facetPartitioning;
      };
      AbstractMesh2.prototype.getFacetPosition = function(i) {
        var pos = Vector3.Zero();
        this.getFacetPositionToRef(i, pos);
        return pos;
      };
      AbstractMesh2.prototype.getFacetPositionToRef = function(i, ref) {
        var localPos = this.getFacetLocalPositions()[i];
        var world = this.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(localPos, world, ref);
        return this;
      };
      AbstractMesh2.prototype.getFacetNormal = function(i) {
        var norm = Vector3.Zero();
        this.getFacetNormalToRef(i, norm);
        return norm;
      };
      AbstractMesh2.prototype.getFacetNormalToRef = function(i, ref) {
        var localNorm = this.getFacetLocalNormals()[i];
        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
        return this;
      };
      AbstractMesh2.prototype.getFacetsAtLocalCoordinates = function(x, y, z) {
        var bInfo = this.getBoundingInfo();
        var data = this._internalAbstractMeshDataInfo._facetData;
        var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
        var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
        var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
          return null;
        }
        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
      };
      AbstractMesh2.prototype.getClosestFacetAtCoordinates = function(x, y, z, projected, checkFace, facing) {
        if (checkFace === void 0) {
          checkFace = false;
        }
        if (facing === void 0) {
          facing = true;
        }
        var world = this.getWorldMatrix();
        var invMat = TmpVectors.Matrix[5];
        world.invertToRef(invMat);
        var invVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
        var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
        if (projected) {
          Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
        }
        return closest;
      };
      AbstractMesh2.prototype.getClosestFacetAtLocalCoordinates = function(x, y, z, projected, checkFace, facing) {
        if (checkFace === void 0) {
          checkFace = false;
        }
        if (facing === void 0) {
          facing = true;
        }
        var closest = null;
        var tmpx = 0;
        var tmpy = 0;
        var tmpz = 0;
        var d = 0;
        var t0 = 0;
        var projx = 0;
        var projy = 0;
        var projz = 0;
        var facetPositions = this.getFacetLocalPositions();
        var facetNormals = this.getFacetLocalNormals();
        var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
        if (!facetsInBlock) {
          return null;
        }
        var shortest = Number.MAX_VALUE;
        var tmpDistance = shortest;
        var fib;
        var norm;
        var p0;
        for (var idx = 0; idx < facetsInBlock.length; idx++) {
          fib = facetsInBlock[idx];
          norm = facetNormals[fib];
          p0 = facetPositions[fib];
          d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
          if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
            d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
            t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
            projx = x + norm.x * t0;
            projy = y + norm.y * t0;
            projz = z + norm.z * t0;
            tmpx = projx - x;
            tmpy = projy - y;
            tmpz = projz - z;
            tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
            if (tmpDistance < shortest) {
              shortest = tmpDistance;
              closest = fib;
              if (projected) {
                projected.x = projx;
                projected.y = projy;
                projected.z = projz;
              }
            }
          }
        }
        return closest;
      };
      AbstractMesh2.prototype.getFacetDataParameters = function() {
        return this._internalAbstractMeshDataInfo._facetData.facetParameters;
      };
      AbstractMesh2.prototype.disableFacetData = function() {
        var facetData = this._internalAbstractMeshDataInfo._facetData;
        if (facetData.facetDataEnabled) {
          facetData.facetDataEnabled = false;
          facetData.facetPositions = new Array();
          facetData.facetNormals = new Array();
          facetData.facetPartitioning = new Array();
          facetData.facetParameters = null;
          facetData.depthSortedIndices = new Uint32Array(0);
        }
        return this;
      };
      AbstractMesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
        if (gpuMemoryOnly === void 0) {
          gpuMemoryOnly = false;
        }
        return this;
      };
      AbstractMesh2.prototype.createNormals = function(updatable) {
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        var indices = this.getIndices();
        var normals;
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          normals = this.getVerticesData(VertexBuffer.NormalKind);
        } else {
          normals = [];
        }
        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
        return this;
      };
      AbstractMesh2.prototype.alignWithNormal = function(normal, upDirection) {
        if (!upDirection) {
          upDirection = Axis.Y;
        }
        var axisX = TmpVectors.Vector3[0];
        var axisZ = TmpVectors.Vector3[1];
        Vector3.CrossToRef(upDirection, normal, axisZ);
        Vector3.CrossToRef(normal, axisZ, axisX);
        if (this.rotationQuaternion) {
          Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
        } else {
          Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
        }
        return this;
      };
      AbstractMesh2.prototype._checkOcclusionQuery = function() {
        return false;
      };
      AbstractMesh2.prototype.disableEdgesRendering = function() {
        throw _WarnImport("EdgesRenderer");
      };
      AbstractMesh2.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices, options) {
        throw _WarnImport("EdgesRenderer");
      };
      AbstractMesh2.prototype.getConnectedParticleSystems = function() {
        var _this = this;
        return this._scene.particleSystems.filter(function(particleSystem) {
          return particleSystem.emitter === _this;
        });
      };
      AbstractMesh2.OCCLUSION_TYPE_NONE = 0;
      AbstractMesh2.OCCLUSION_TYPE_OPTIMISTIC = 1;
      AbstractMesh2.OCCLUSION_TYPE_STRICT = 2;
      AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
      AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
      AbstractMesh2.CULLINGSTRATEGY_STANDARD = 0;
      AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
      AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
      AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
      return AbstractMesh2;
    }(TransformNode);
    RegisterClass("BABYLON.AbstractMesh", AbstractMesh);
  }
});

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport;
var init_math_viewport = __esm({
  "node_modules/@babylonjs/core/Maths/math.viewport.js"() {
    Viewport = function() {
      function Viewport2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      Viewport2.prototype.toGlobal = function(renderWidth, renderHeight) {
        return new Viewport2(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
      };
      Viewport2.prototype.toGlobalToRef = function(renderWidth, renderHeight, ref) {
        ref.x = this.x * renderWidth;
        ref.y = this.y * renderHeight;
        ref.width = this.width * renderWidth;
        ref.height = this.height * renderHeight;
        return this;
      };
      Viewport2.prototype.clone = function() {
        return new Viewport2(this.x, this.y, this.width, this.height);
      };
      return Viewport2;
    }();
  }
});

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera;
var init_camera = __esm({
  "node_modules/@babylonjs/core/Cameras/camera.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_tools();
    init_observable();
    init_math_vector();
    init_node();
    init_logger();
    init_typeStore();
    init_devTools();
    init_math_viewport();
    init_math_frustum();
    Camera = function(_super) {
      __extends(Camera2, _super);
      function Camera2(name105, position, scene, setActiveOnSceneIfNoneActive) {
        if (setActiveOnSceneIfNoneActive === void 0) {
          setActiveOnSceneIfNoneActive = true;
        }
        var _this = _super.call(this, name105, scene) || this;
        _this._position = Vector3.Zero();
        _this._upVector = Vector3.Up();
        _this.orthoLeft = null;
        _this.orthoRight = null;
        _this.orthoBottom = null;
        _this.orthoTop = null;
        _this.fov = 0.8;
        _this.projectionPlaneTilt = 0;
        _this.minZ = 1;
        _this.maxZ = 1e4;
        _this.inertia = 0.9;
        _this.mode = Camera2.PERSPECTIVE_CAMERA;
        _this.isIntermediate = false;
        _this.viewport = new Viewport(0, 0, 1, 1);
        _this.layerMask = 268435455;
        _this.fovMode = Camera2.FOVMODE_VERTICAL_FIXED;
        _this.cameraRigMode = Camera2.RIG_MODE_NONE;
        _this.customRenderTargets = new Array();
        _this.outputRenderTarget = null;
        _this.onViewMatrixChangedObservable = new Observable();
        _this.onProjectionMatrixChangedObservable = new Observable();
        _this.onAfterCheckInputsObservable = new Observable();
        _this.onRestoreStateObservable = new Observable();
        _this.isRigCamera = false;
        _this._rigCameras = new Array();
        _this._webvrViewMatrix = Matrix.Identity();
        _this._skipRendering = false;
        _this._projectionMatrix = new Matrix();
        _this._postProcesses = new Array();
        _this._activeMeshes = new SmartArray(256);
        _this._globalPosition = Vector3.Zero();
        _this._computedViewMatrix = Matrix.Identity();
        _this._doNotComputeProjectionMatrix = false;
        _this._transformMatrix = Matrix.Zero();
        _this._refreshFrustumPlanes = true;
        _this._absoluteRotation = Quaternion.Identity();
        _this._isCamera = true;
        _this._isLeftCamera = false;
        _this._isRightCamera = false;
        _this.getScene().addCamera(_this);
        if (setActiveOnSceneIfNoneActive && !_this.getScene().activeCamera) {
          _this.getScene().activeCamera = _this;
        }
        _this.position = position;
        _this.renderPassId = _this.getScene().getEngine().createRenderPassId("Camera ".concat(name105));
        return _this;
      }
      Object.defineProperty(Camera2.prototype, "position", {
        get: function() {
          return this._position;
        },
        set: function(newPosition) {
          this._position = newPosition;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "upVector", {
        get: function() {
          return this._upVector;
        },
        set: function(vec) {
          this._upVector = vec;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "screenArea", {
        get: function() {
          var _a, _b, _c, _d;
          var x = 0;
          var y = 0;
          if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
            if (this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED) {
              y = this.minZ * 2 * Math.tan(this.fov / 2);
              x = this.getEngine().getAspectRatio(this) * y;
            } else {
              x = this.minZ * 2 * Math.tan(this.fov / 2);
              y = x / this.getEngine().getAspectRatio(this);
            }
          } else {
            var halfWidth = this.getEngine().getRenderWidth() / 2;
            var halfHeight = this.getEngine().getRenderHeight() / 2;
            x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);
            y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);
          }
          return x * y;
        },
        enumerable: false,
        configurable: true
      });
      Camera2.prototype.storeState = function() {
        this._stateStored = true;
        this._storedFov = this.fov;
        return this;
      };
      Camera2.prototype._restoreStateValues = function() {
        if (!this._stateStored) {
          return false;
        }
        this.fov = this._storedFov;
        return true;
      };
      Camera2.prototype.restoreState = function() {
        if (this._restoreStateValues()) {
          this.onRestoreStateObservable.notifyObservers(this);
          return true;
        }
        return false;
      };
      Camera2.prototype.getClassName = function() {
        return "Camera";
      };
      Camera2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name;
        ret += ", type: " + this.getClassName();
        if (this.animations) {
          for (var i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      };
      Camera2.prototype.applyVerticalCorrection = function() {
        var rot = this.absoluteRotation.toEulerAngles();
        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
      };
      Object.defineProperty(Camera2.prototype, "globalPosition", {
        get: function() {
          return this._globalPosition;
        },
        enumerable: false,
        configurable: true
      });
      Camera2.prototype.getActiveMeshes = function() {
        return this._activeMeshes;
      };
      Camera2.prototype.isActiveMesh = function(mesh) {
        return this._activeMeshes.indexOf(mesh) !== -1;
      };
      Camera2.prototype.isReady = function(completeCheck) {
        if (completeCheck === void 0) {
          completeCheck = false;
        }
        if (completeCheck) {
          for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
            var pp = _a[_i];
            if (pp && !pp.isReady()) {
              return false;
            }
          }
        }
        return _super.prototype.isReady.call(this, completeCheck);
      };
      Camera2.prototype._initCache = function() {
        _super.prototype._initCache.call(this);
        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.mode = void 0;
        this._cache.minZ = void 0;
        this._cache.maxZ = void 0;
        this._cache.fov = void 0;
        this._cache.fovMode = void 0;
        this._cache.aspectRatio = void 0;
        this._cache.orthoLeft = void 0;
        this._cache.orthoRight = void 0;
        this._cache.orthoBottom = void 0;
        this._cache.orthoTop = void 0;
        this._cache.renderWidth = void 0;
        this._cache.renderHeight = void 0;
      };
      Camera2.prototype._updateCache = function(ignoreParentClass) {
        if (!ignoreParentClass) {
          _super.prototype._updateCache.call(this);
        }
        this._cache.position.copyFrom(this.position);
        this._cache.upVector.copyFrom(this.upVector);
      };
      Camera2.prototype._isSynchronized = function() {
        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
      };
      Camera2.prototype._isSynchronizedViewMatrix = function() {
        if (!_super.prototype._isSynchronized.call(this)) {
          return false;
        }
        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
      };
      Camera2.prototype._isSynchronizedProjectionMatrix = function() {
        var check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
        if (!check) {
          return false;
        }
        var engine = this.getEngine();
        if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
          check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
        } else {
          check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
        }
        return check;
      };
      Camera2.prototype.attachControl = function(_ignored, _noPreventDefault) {
      };
      Camera2.prototype.detachControl = function(_ignored) {
      };
      Camera2.prototype.update = function() {
        this._checkInputs();
        if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
          this._updateRigCameras();
        }
      };
      Camera2.prototype._checkInputs = function() {
        this.onAfterCheckInputsObservable.notifyObservers(this);
      };
      Object.defineProperty(Camera2.prototype, "rigCameras", {
        get: function() {
          return this._rigCameras;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "rigPostProcess", {
        get: function() {
          return this._rigPostProcess;
        },
        enumerable: false,
        configurable: true
      });
      Camera2.prototype._getFirstPostProcess = function() {
        for (var ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
          if (this._postProcesses[ppIndex] !== null) {
            return this._postProcesses[ppIndex];
          }
        }
        return null;
      };
      Camera2.prototype._cascadePostProcessesToRigCams = function() {
        var firstPostProcess = this._getFirstPostProcess();
        if (firstPostProcess) {
          firstPostProcess.markTextureDirty();
        }
        for (var i = 0, len = this._rigCameras.length; i < len; i++) {
          var cam = this._rigCameras[i];
          var rigPostProcess = cam._rigPostProcess;
          if (rigPostProcess) {
            var isPass = rigPostProcess.getEffectName() === "pass";
            if (isPass) {
              cam.isIntermediate = this._postProcesses.length === 0;
            }
            cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
            rigPostProcess.markTextureDirty();
          } else {
            cam._postProcesses = this._postProcesses.slice(0);
          }
        }
      };
      Camera2.prototype.attachPostProcess = function(postProcess, insertAt) {
        if (insertAt === void 0) {
          insertAt = null;
        }
        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
          Logger.Error("You're trying to reuse a post process not defined as reusable.");
          return 0;
        }
        if (insertAt == null || insertAt < 0) {
          this._postProcesses.push(postProcess);
        } else if (this._postProcesses[insertAt] === null) {
          this._postProcesses[insertAt] = postProcess;
        } else {
          this._postProcesses.splice(insertAt, 0, postProcess);
        }
        this._cascadePostProcessesToRigCams();
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        return this._postProcesses.indexOf(postProcess);
      };
      Camera2.prototype.detachPostProcess = function(postProcess) {
        var idx = this._postProcesses.indexOf(postProcess);
        if (idx !== -1) {
          this._postProcesses[idx] = null;
        }
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        this._cascadePostProcessesToRigCams();
      };
      Camera2.prototype.getWorldMatrix = function() {
        if (this._isSynchronizedViewMatrix()) {
          return this._worldMatrix;
        }
        this.getViewMatrix();
        return this._worldMatrix;
      };
      Camera2.prototype._getViewMatrix = function() {
        return Matrix.Identity();
      };
      Camera2.prototype.getViewMatrix = function(force) {
        if (!force && this._isSynchronizedViewMatrix()) {
          return this._computedViewMatrix;
        }
        this.updateCache();
        this._computedViewMatrix = this._getViewMatrix();
        this._currentRenderId = this.getScene().getRenderId();
        this._childUpdateId++;
        this._refreshFrustumPlanes = true;
        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
          this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
        }
        if (this.parent && this.parent.onViewMatrixChangedObservable) {
          this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
        }
        this.onViewMatrixChangedObservable.notifyObservers(this);
        this._computedViewMatrix.invertToRef(this._worldMatrix);
        return this._computedViewMatrix;
      };
      Camera2.prototype.freezeProjectionMatrix = function(projection) {
        this._doNotComputeProjectionMatrix = true;
        if (projection !== void 0) {
          this._projectionMatrix = projection;
        }
      };
      Camera2.prototype.unfreezeProjectionMatrix = function() {
        this._doNotComputeProjectionMatrix = false;
      };
      Camera2.prototype.getProjectionMatrix = function(force) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
          return this._projectionMatrix;
        }
        this._cache.mode = this.mode;
        this._cache.minZ = this.minZ;
        this._cache.maxZ = this.maxZ;
        this._refreshFrustumPlanes = true;
        var engine = this.getEngine();
        var scene = this.getScene();
        if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
          this._cache.fov = this.fov;
          this._cache.fovMode = this.fovMode;
          this._cache.aspectRatio = engine.getAspectRatio(this);
          this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
          if (this.minZ <= 0) {
            this.minZ = 0.1;
          }
          var reverseDepth = engine.useReverseDepthBuffer;
          var getProjectionMatrix = void 0;
          if (scene.useRightHandedSystem) {
            getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
          } else {
            getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
          }
          getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, engine.useReverseDepthBuffer);
        } else {
          var halfWidth = engine.getRenderWidth() / 2;
          var halfHeight = engine.getRenderHeight() / 2;
          if (scene.useRightHandedSystem) {
            Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
          } else {
            Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
          }
          this._cache.orthoLeft = this.orthoLeft;
          this._cache.orthoRight = this.orthoRight;
          this._cache.orthoBottom = this.orthoBottom;
          this._cache.orthoTop = this.orthoTop;
          this._cache.renderWidth = engine.getRenderWidth();
          this._cache.renderHeight = engine.getRenderHeight();
        }
        this.onProjectionMatrixChangedObservable.notifyObservers(this);
        return this._projectionMatrix;
      };
      Camera2.prototype.getTransformationMatrix = function() {
        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        return this._transformMatrix;
      };
      Camera2.prototype._updateFrustumPlanes = function() {
        if (!this._refreshFrustumPlanes) {
          return;
        }
        this.getTransformationMatrix();
        if (!this._frustumPlanes) {
          this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
        } else {
          Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
        }
        this._refreshFrustumPlanes = false;
      };
      Camera2.prototype.isInFrustum = function(target, checkRigCameras) {
        if (checkRigCameras === void 0) {
          checkRigCameras = false;
        }
        this._updateFrustumPlanes();
        if (checkRigCameras && this.rigCameras.length > 0) {
          var result_1 = false;
          this.rigCameras.forEach(function(cam) {
            cam._updateFrustumPlanes();
            result_1 = result_1 || target.isInFrustum(cam._frustumPlanes);
          });
          return result_1;
        } else {
          return target.isInFrustum(this._frustumPlanes);
        }
      };
      Camera2.prototype.isCompletelyInFrustum = function(target) {
        this._updateFrustumPlanes();
        return target.isCompletelyInFrustum(this._frustumPlanes);
      };
      Camera2.prototype.getForwardRay = function(length, transform, origin) {
        if (length === void 0) {
          length = 100;
        }
        throw _WarnImport("Ray");
      };
      Camera2.prototype.getForwardRayToRef = function(refRay, length, transform, origin) {
        if (length === void 0) {
          length = 100;
        }
        throw _WarnImport("Ray");
      };
      Camera2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        this.onViewMatrixChangedObservable.clear();
        this.onProjectionMatrixChangedObservable.clear();
        this.onAfterCheckInputsObservable.clear();
        this.onRestoreStateObservable.clear();
        if (this.inputs) {
          this.inputs.clear();
        }
        this.getScene().stopAnimation(this);
        this.getScene().removeCamera(this);
        while (this._rigCameras.length > 0) {
          var camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        if (this._parentContainer) {
          var index = this._parentContainer.cameras.indexOf(this);
          if (index > -1) {
            this._parentContainer.cameras.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._rigPostProcess) {
          this._rigPostProcess.dispose(this);
          this._rigPostProcess = null;
          this._postProcesses = [];
        } else if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
          this._rigPostProcess = null;
          this._postProcesses = [];
        } else {
          var i_1 = this._postProcesses.length;
          while (--i_1 >= 0) {
            var postProcess = this._postProcesses[i_1];
            if (postProcess) {
              postProcess.dispose(this);
            }
          }
        }
        var i = this.customRenderTargets.length;
        while (--i >= 0) {
          this.customRenderTargets[i].dispose();
        }
        this.customRenderTargets = [];
        this._activeMeshes.dispose();
        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
      };
      Object.defineProperty(Camera2.prototype, "isLeftCamera", {
        get: function() {
          return this._isLeftCamera;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "isRightCamera", {
        get: function() {
          return this._isRightCamera;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "leftCamera", {
        get: function() {
          if (this._rigCameras.length < 1) {
            return null;
          }
          return this._rigCameras[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Camera2.prototype, "rightCamera", {
        get: function() {
          if (this._rigCameras.length < 2) {
            return null;
          }
          return this._rigCameras[1];
        },
        enumerable: false,
        configurable: true
      });
      Camera2.prototype.getLeftTarget = function() {
        if (this._rigCameras.length < 1) {
          return null;
        }
        return this._rigCameras[0].getTarget();
      };
      Camera2.prototype.getRightTarget = function() {
        if (this._rigCameras.length < 2) {
          return null;
        }
        return this._rigCameras[1].getTarget();
      };
      Camera2.prototype.setCameraRigMode = function(mode, rigParams) {
        if (this.cameraRigMode === mode) {
          return;
        }
        while (this._rigCameras.length > 0) {
          var camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        this.cameraRigMode = mode;
        this._cameraRigParams = {};
        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
        if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
          var leftCamera = this.createRigCamera(this.name + "_L", 0);
          if (leftCamera) {
            leftCamera._isLeftCamera = true;
          }
          var rightCamera = this.createRigCamera(this.name + "_R", 1);
          if (rightCamera) {
            rightCamera._isRightCamera = true;
          }
          if (leftCamera && rightCamera) {
            this._rigCameras.push(leftCamera);
            this._rigCameras.push(rightCamera);
          }
        }
        this._setRigMode(rigParams);
        this._cascadePostProcessesToRigCams();
        this.update();
      };
      Camera2.prototype._setRigMode = function(rigParams) {
      };
      Camera2.prototype._getVRProjectionMatrix = function() {
        Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
        return this._projectionMatrix;
      };
      Camera2.prototype._updateCameraRotationMatrix = function() {
      };
      Camera2.prototype._updateWebVRCameraRotationMatrix = function() {
      };
      Camera2.prototype._getWebVRProjectionMatrix = function() {
        return Matrix.Identity();
      };
      Camera2.prototype._getWebVRViewMatrix = function() {
        return Matrix.Identity();
      };
      Camera2.prototype.setCameraRigParameter = function(name105, value) {
        if (!this._cameraRigParams) {
          this._cameraRigParams = {};
        }
        this._cameraRigParams[name105] = value;
        if (name105 === "interaxialDistance") {
          this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
        }
      };
      Camera2.prototype.createRigCamera = function(name105, cameraIndex) {
        return null;
      };
      Camera2.prototype._updateRigCameras = function() {
        for (var i = 0; i < this._rigCameras.length; i++) {
          this._rigCameras[i].minZ = this.minZ;
          this._rigCameras[i].maxZ = this.maxZ;
          this._rigCameras[i].fov = this.fov;
          this._rigCameras[i].upVector.copyFrom(this.upVector);
        }
        if (this.cameraRigMode === Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
          this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
        }
      };
      Camera2.prototype._setupInputs = function() {
      };
      Camera2.prototype.serialize = function() {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (this.parent) {
          serializationObject.parentId = this.parent.uniqueId;
        }
        if (this.inputs) {
          this.inputs.serialize(serializationObject);
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      };
      Camera2.prototype.clone = function(name105, newParent) {
        if (newParent === void 0) {
          newParent = null;
        }
        var camera = SerializationHelper.Clone(Camera2.GetConstructorFromName(this.getClassName(), name105, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
        camera.name = name105;
        camera.parent = newParent;
        this.onClonedObservable.notifyObservers(camera);
        return camera;
      };
      Camera2.prototype.getDirection = function(localAxis) {
        var result = Vector3.Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
      };
      Object.defineProperty(Camera2.prototype, "absoluteRotation", {
        get: function() {
          this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
          return this._absoluteRotation;
        },
        enumerable: false,
        configurable: true
      });
      Camera2.prototype.getDirectionToRef = function(localAxis, result) {
        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
      };
      Camera2.GetConstructorFromName = function(type, name105, scene, interaxial_distance, isStereoscopicSideBySide) {
        if (interaxial_distance === void 0) {
          interaxial_distance = 0;
        }
        if (isStereoscopicSideBySide === void 0) {
          isStereoscopicSideBySide = true;
        }
        var constructorFunc = Node.Construct(type, name105, scene, {
          interaxial_distance,
          isStereoscopicSideBySide
        });
        if (constructorFunc) {
          return constructorFunc;
        }
        return function() {
          return Camera2._CreateDefaultParsedCamera(name105, scene);
        };
      };
      Camera2.prototype.computeWorldMatrix = function() {
        return this.getWorldMatrix();
      };
      Camera2.Parse = function(parsedCamera, scene) {
        var type = parsedCamera.type;
        var construct = Camera2.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
        var camera = SerializationHelper.Parse(construct, parsedCamera, scene);
        if (parsedCamera.parentId !== void 0) {
          camera._waitingParentId = parsedCamera.parentId;
        }
        if (camera.inputs) {
          camera.inputs.parse(parsedCamera);
          camera._setupInputs();
        }
        if (parsedCamera.upVector) {
          camera.upVector = Vector3.FromArray(parsedCamera.upVector);
        }
        if (camera.setPosition) {
          camera.position.copyFromFloats(0, 0, 0);
          camera.setPosition(Vector3.FromArray(parsedCamera.position));
        }
        if (parsedCamera.target) {
          if (camera.setTarget) {
            camera.setTarget(Vector3.FromArray(parsedCamera.target));
          }
        }
        if (parsedCamera.cameraRigMode) {
          var rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
          camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
        }
        if (parsedCamera.animations) {
          for (var animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
            var parsedAnimation = parsedCamera.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              camera.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(camera, parsedCamera, scene);
        }
        if (parsedCamera.autoAnimate) {
          scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
        }
        if (parsedCamera.isEnabled !== void 0) {
          camera.setEnabled(parsedCamera.isEnabled);
        }
        return camera;
      };
      Camera2._CreateDefaultParsedCamera = function(name105, scene) {
        throw _WarnImport("UniversalCamera");
      };
      Camera2.PERSPECTIVE_CAMERA = 0;
      Camera2.ORTHOGRAPHIC_CAMERA = 1;
      Camera2.FOVMODE_VERTICAL_FIXED = 0;
      Camera2.FOVMODE_HORIZONTAL_FIXED = 1;
      Camera2.RIG_MODE_NONE = 0;
      Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
      Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
      Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
      Camera2.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
      Camera2.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
      Camera2.RIG_MODE_VR = 20;
      Camera2.RIG_MODE_WEBVR = 21;
      Camera2.RIG_MODE_CUSTOM = 22;
      Camera2.ForceAttachControlToAlwaysPreventDefault = false;
      __decorate([
        serializeAsVector3("position")
      ], Camera2.prototype, "_position", void 0);
      __decorate([
        serializeAsVector3("upVector")
      ], Camera2.prototype, "_upVector", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "orthoLeft", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "orthoRight", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "orthoBottom", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "orthoTop", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "fov", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "projectionPlaneTilt", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "minZ", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "maxZ", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "inertia", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "mode", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "layerMask", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "fovMode", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "cameraRigMode", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "interaxialDistance", void 0);
      __decorate([
        serialize()
      ], Camera2.prototype, "isStereoscopicSideBySide", void 0);
      return Camera2;
    }(Node);
  }
});

// node_modules/@babylonjs/core/Lights/light.js
var Light;
var init_light = __esm({
  "node_modules/@babylonjs/core/Lights/light.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_uniformBuffer();
    init_typeStore();
    init_lightConstants();
    Light = function(_super) {
      __extends(Light2, _super);
      function Light2(name105, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this.diffuse = new Color3(1, 1, 1);
        _this.specular = new Color3(1, 1, 1);
        _this.falloffType = Light2.FALLOFF_DEFAULT;
        _this.intensity = 1;
        _this._range = Number.MAX_VALUE;
        _this._inverseSquaredRange = 0;
        _this._photometricScale = 1;
        _this._intensityMode = Light2.INTENSITYMODE_AUTOMATIC;
        _this._radius = 1e-5;
        _this.renderPriority = 0;
        _this._shadowEnabled = true;
        _this._excludeWithLayerMask = 0;
        _this._includeOnlyWithLayerMask = 0;
        _this._lightmapMode = 0;
        _this._excludedMeshesIds = new Array();
        _this._includedOnlyMeshesIds = new Array();
        _this._isLight = true;
        _this.getScene().addLight(_this);
        _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name105);
        _this._buildUniformLayout();
        _this.includedOnlyMeshes = new Array();
        _this.excludedMeshes = new Array();
        _this._resyncMeshes();
        return _this;
      }
      Object.defineProperty(Light2.prototype, "range", {
        get: function() {
          return this._range;
        },
        set: function(value) {
          this._range = value;
          this._inverseSquaredRange = 1 / (this.range * this.range);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "intensityMode", {
        get: function() {
          return this._intensityMode;
        },
        set: function(value) {
          this._intensityMode = value;
          this._computePhotometricScale();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "radius", {
        get: function() {
          return this._radius;
        },
        set: function(value) {
          this._radius = value;
          this._computePhotometricScale();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "shadowEnabled", {
        get: function() {
          return this._shadowEnabled;
        },
        set: function(value) {
          if (this._shadowEnabled === value) {
            return;
          }
          this._shadowEnabled = value;
          this._markMeshesAsLightDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "includedOnlyMeshes", {
        get: function() {
          return this._includedOnlyMeshes;
        },
        set: function(value) {
          this._includedOnlyMeshes = value;
          this._hookArrayForIncludedOnly(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "excludedMeshes", {
        get: function() {
          return this._excludedMeshes;
        },
        set: function(value) {
          this._excludedMeshes = value;
          this._hookArrayForExcluded(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "excludeWithLayerMask", {
        get: function() {
          return this._excludeWithLayerMask;
        },
        set: function(value) {
          this._excludeWithLayerMask = value;
          this._resyncMeshes();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "includeOnlyWithLayerMask", {
        get: function() {
          return this._includeOnlyWithLayerMask;
        },
        set: function(value) {
          this._includeOnlyWithLayerMask = value;
          this._resyncMeshes();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Light2.prototype, "lightmapMode", {
        get: function() {
          return this._lightmapMode;
        },
        set: function(value) {
          if (this._lightmapMode === value) {
            return;
          }
          this._lightmapMode = value;
          this._markMeshesAsLightDirty();
        },
        enumerable: false,
        configurable: true
      });
      Light2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
        return this;
      };
      Light2.prototype._bindLight = function(lightIndex, scene, effect, useSpecular, receiveShadows) {
        if (receiveShadows === void 0) {
          receiveShadows = true;
        }
        var iAsString = lightIndex.toString();
        var needUpdate = false;
        this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
          this._renderId = scene.getRenderId();
          this._lastUseSpecular = useSpecular;
          var scaledIntensity = this.getScaledIntensity();
          this.transferToEffect(effect, iAsString);
          this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
          this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
          if (useSpecular) {
            this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
            this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
          }
          needUpdate = true;
        }
        this.transferTexturesToEffect(effect, iAsString);
        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
          var shadowGenerator = this.getShadowGenerator();
          if (shadowGenerator) {
            shadowGenerator.bindShadowLight(iAsString, effect);
            needUpdate = true;
          }
        }
        if (needUpdate) {
          this._uniformBuffer.update();
        } else {
          this._uniformBuffer.bindUniformBuffer();
        }
      };
      Light2.prototype.getClassName = function() {
        return "Light";
      };
      Light2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name;
        ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
        if (this.animations) {
          for (var i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      };
      Light2.prototype._syncParentEnabledState = function() {
        _super.prototype._syncParentEnabledState.call(this);
        if (!this.isDisposed()) {
          this._resyncMeshes();
        }
      };
      Light2.prototype.setEnabled = function(value) {
        _super.prototype.setEnabled.call(this, value);
        this._resyncMeshes();
      };
      Light2.prototype.getShadowGenerator = function() {
        return this._shadowGenerator;
      };
      Light2.prototype.getAbsolutePosition = function() {
        return Vector3.Zero();
      };
      Light2.prototype.canAffectMesh = function(mesh) {
        if (!mesh) {
          return true;
        }
        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
          return false;
        }
        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
          return false;
        }
        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
          return false;
        }
        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
          return false;
        }
        return true;
      };
      Light2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        if (this._shadowGenerator) {
          this._shadowGenerator.dispose();
          this._shadowGenerator = null;
        }
        this.getScene().stopAnimation(this);
        if (this._parentContainer) {
          var index = this._parentContainer.lights.indexOf(this);
          if (index > -1) {
            this._parentContainer.lights.splice(index, 1);
          }
          this._parentContainer = null;
        }
        for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._removeLightSource(this, true);
        }
        this._uniformBuffer.dispose();
        this.getScene().removeLight(this);
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
      };
      Light2.prototype.getTypeID = function() {
        return 0;
      };
      Light2.prototype.getScaledIntensity = function() {
        return this._photometricScale * this.intensity;
      };
      Light2.prototype.clone = function(name105, newParent) {
        if (newParent === void 0) {
          newParent = null;
        }
        var constructor = Light2.GetConstructorFromName(this.getTypeID(), name105, this.getScene());
        if (!constructor) {
          return null;
        }
        var clonedLight = SerializationHelper.Clone(constructor, this);
        if (name105) {
          clonedLight.name = name105;
        }
        if (newParent) {
          clonedLight.parent = newParent;
        }
        clonedLight.setEnabled(this.isEnabled());
        this.onClonedObservable.notifyObservers(clonedLight);
        return clonedLight;
      };
      Light2.prototype.serialize = function() {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getTypeID();
        if (this.parent) {
          serializationObject.parentId = this.parent.uniqueId;
        }
        if (this.excludedMeshes.length > 0) {
          serializationObject.excludedMeshesIds = [];
          this.excludedMeshes.forEach(function(mesh) {
            serializationObject.excludedMeshesIds.push(mesh.id);
          });
        }
        if (this.includedOnlyMeshes.length > 0) {
          serializationObject.includedOnlyMeshesIds = [];
          this.includedOnlyMeshes.forEach(function(mesh) {
            serializationObject.includedOnlyMeshesIds.push(mesh.id);
          });
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      };
      Light2.GetConstructorFromName = function(type, name105, scene) {
        var constructorFunc = Node.Construct("Light_Type_" + type, name105, scene);
        if (constructorFunc) {
          return constructorFunc;
        }
        return null;
      };
      Light2.Parse = function(parsedLight, scene) {
        var constructor = Light2.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
        if (!constructor) {
          return null;
        }
        var light = SerializationHelper.Parse(constructor, parsedLight, scene);
        if (parsedLight.excludedMeshesIds) {
          light._excludedMeshesIds = parsedLight.excludedMeshesIds;
        }
        if (parsedLight.includedOnlyMeshesIds) {
          light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
        }
        if (parsedLight.parentId !== void 0) {
          light._waitingParentId = parsedLight.parentId;
        }
        if (parsedLight.falloffType !== void 0) {
          light.falloffType = parsedLight.falloffType;
        }
        if (parsedLight.lightmapMode !== void 0) {
          light.lightmapMode = parsedLight.lightmapMode;
        }
        if (parsedLight.animations) {
          for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
            var parsedAnimation = parsedLight.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              light.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(light, parsedLight, scene);
        }
        if (parsedLight.autoAnimate) {
          scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
        }
        if (parsedLight.isEnabled !== void 0) {
          light.setEnabled(parsedLight.isEnabled);
        }
        return light;
      };
      Light2.prototype._hookArrayForExcluded = function(array) {
        var _this = this;
        var oldPush = array.push;
        array.push = function() {
          var items = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            items[_i2] = arguments[_i2];
          }
          var result = oldPush.apply(array, items);
          for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {
            var item2 = items_1[_a];
            item2._resyncLightSource(_this);
          }
          return result;
        };
        var oldSplice = array.splice;
        array.splice = function(index, deleteCount) {
          var deleted = oldSplice.apply(array, [index, deleteCount]);
          for (var _i2 = 0, deleted_1 = deleted; _i2 < deleted_1.length; _i2++) {
            var item2 = deleted_1[_i2];
            item2._resyncLightSource(_this);
          }
          return deleted;
        };
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
          var item = array_1[_i];
          item._resyncLightSource(this);
        }
      };
      Light2.prototype._hookArrayForIncludedOnly = function(array) {
        var _this = this;
        var oldPush = array.push;
        array.push = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          var result = oldPush.apply(array, items);
          _this._resyncMeshes();
          return result;
        };
        var oldSplice = array.splice;
        array.splice = function(index, deleteCount) {
          var deleted = oldSplice.apply(array, [index, deleteCount]);
          _this._resyncMeshes();
          return deleted;
        };
        this._resyncMeshes();
      };
      Light2.prototype._resyncMeshes = function() {
        for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._resyncLightSource(this);
        }
      };
      Light2.prototype._markMeshesAsLightDirty = function() {
        for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          if (mesh.lightSources.indexOf(this) !== -1) {
            mesh._markSubMeshesAsLightDirty();
          }
        }
      };
      Light2.prototype._computePhotometricScale = function() {
        this._photometricScale = this._getPhotometricScale();
        this.getScene().resetCachedMaterial();
      };
      Light2.prototype._getPhotometricScale = function() {
        var photometricScale = 0;
        var lightTypeID = this.getTypeID();
        var photometricMode = this.intensityMode;
        if (photometricMode === Light2.INTENSITYMODE_AUTOMATIC) {
          if (lightTypeID === Light2.LIGHTTYPEID_DIRECTIONALLIGHT) {
            photometricMode = Light2.INTENSITYMODE_ILLUMINANCE;
          } else {
            photometricMode = Light2.INTENSITYMODE_LUMINOUSINTENSITY;
          }
        }
        switch (lightTypeID) {
          case Light2.LIGHTTYPEID_POINTLIGHT:
          case Light2.LIGHTTYPEID_SPOTLIGHT:
            switch (photometricMode) {
              case Light2.INTENSITYMODE_LUMINOUSPOWER:
                photometricScale = 1 / (4 * Math.PI);
                break;
              case Light2.INTENSITYMODE_LUMINOUSINTENSITY:
                photometricScale = 1;
                break;
              case Light2.INTENSITYMODE_LUMINANCE:
                photometricScale = this.radius * this.radius;
                break;
            }
            break;
          case Light2.LIGHTTYPEID_DIRECTIONALLIGHT:
            switch (photometricMode) {
              case Light2.INTENSITYMODE_ILLUMINANCE:
                photometricScale = 1;
                break;
              case Light2.INTENSITYMODE_LUMINANCE: {
                var apexAngleRadians = this.radius;
                apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
                var solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
                photometricScale = solidAngle;
                break;
              }
            }
            break;
          case Light2.LIGHTTYPEID_HEMISPHERICLIGHT:
            photometricScale = 1;
            break;
        }
        return photometricScale;
      };
      Light2.prototype._reorderLightsInScene = function() {
        var scene = this.getScene();
        if (this._renderPriority != 0) {
          scene.requireLightSorting = true;
        }
        this.getScene().sortLightsByPriority();
      };
      Light2.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
      Light2.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
      Light2.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
      Light2.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
      Light2.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
      Light2.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
      Light2.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
      Light2.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
      Light2.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
      Light2.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
      Light2.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
      Light2.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
      Light2.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
      Light2.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
      Light2.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
      Light2.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
      __decorate([
        serializeAsColor3()
      ], Light2.prototype, "diffuse", void 0);
      __decorate([
        serializeAsColor3()
      ], Light2.prototype, "specular", void 0);
      __decorate([
        serialize()
      ], Light2.prototype, "falloffType", void 0);
      __decorate([
        serialize()
      ], Light2.prototype, "intensity", void 0);
      __decorate([
        serialize()
      ], Light2.prototype, "range", null);
      __decorate([
        serialize()
      ], Light2.prototype, "intensityMode", null);
      __decorate([
        serialize()
      ], Light2.prototype, "radius", null);
      __decorate([
        serialize()
      ], Light2.prototype, "_renderPriority", void 0);
      __decorate([
        expandToProperty("_reorderLightsInScene")
      ], Light2.prototype, "renderPriority", void 0);
      __decorate([
        serialize("shadowEnabled")
      ], Light2.prototype, "_shadowEnabled", void 0);
      __decorate([
        serialize("excludeWithLayerMask")
      ], Light2.prototype, "_excludeWithLayerMask", void 0);
      __decorate([
        serialize("includeOnlyWithLayerMask")
      ], Light2.prototype, "_includeOnlyWithLayerMask", void 0);
      __decorate([
        serialize("lightmapMode")
      ], Light2.prototype, "_lightmapMode", void 0);
      return Light2;
    }(Node);
  }
});

// node_modules/@babylonjs/core/Materials/thinMaterialHelper.js
var ThinMaterialHelper;
var init_thinMaterialHelper = __esm({
  "node_modules/@babylonjs/core/Materials/thinMaterialHelper.js"() {
    ThinMaterialHelper = function() {
      function ThinMaterialHelper2() {
      }
      ThinMaterialHelper2.BindClipPlane = function(effect, holder) {
        if (holder.clipPlane) {
          var clipPlane = holder.clipPlane;
          effect.setFloat4("vClipPlane", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
        if (holder.clipPlane2) {
          var clipPlane = holder.clipPlane2;
          effect.setFloat4("vClipPlane2", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
        if (holder.clipPlane3) {
          var clipPlane = holder.clipPlane3;
          effect.setFloat4("vClipPlane3", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
        if (holder.clipPlane4) {
          var clipPlane = holder.clipPlane4;
          effect.setFloat4("vClipPlane4", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
        if (holder.clipPlane5) {
          var clipPlane = holder.clipPlane5;
          effect.setFloat4("vClipPlane5", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
        if (holder.clipPlane6) {
          var clipPlane = holder.clipPlane6;
          effect.setFloat4("vClipPlane6", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
        }
      };
      return ThinMaterialHelper2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/materialHelper.js
var MaterialHelper;
var init_materialHelper = __esm({
  "node_modules/@babylonjs/core/Materials/materialHelper.js"() {
    init_logger();
    init_camera();
    init_scene();
    init_engineStore();
    init_buffer();
    init_light();
    init_math_color();
    init_thinMaterialHelper();
    MaterialHelper = function() {
      function MaterialHelper2() {
      }
      MaterialHelper2.BindSceneUniformBuffer = function(effect, sceneUbo) {
        sceneUbo.bindToEffect(effect, "Scene");
      };
      MaterialHelper2.PrepareDefinesForMergedUV = function(texture, defines, key) {
        defines._needUVs = true;
        defines[key] = true;
        if (texture.getTextureMatrix().isIdentityAs3x2()) {
          defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
          defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
        } else {
          defines[key + "DIRECTUV"] = 0;
        }
      };
      MaterialHelper2.BindTextureMatrix = function(texture, uniformBuffer, key) {
        var matrix = texture.getTextureMatrix();
        uniformBuffer.updateMatrix(key + "Matrix", matrix);
      };
      MaterialHelper2.GetFogState = function(mesh, scene) {
        return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
      };
      MaterialHelper2.PrepareDefinesForMisc = function(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {
        if (defines._areMiscDirty) {
          defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
          defines["POINTSIZE"] = pointsCloud;
          defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
          defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
          defines["ALPHATEST"] = alphaTest;
        }
      };
      MaterialHelper2.PrepareDefinesForFrameBoundValues = function(scene, engine, defines, useInstances, useClipPlane, useThinInstances) {
        if (useClipPlane === void 0) {
          useClipPlane = null;
        }
        if (useThinInstances === void 0) {
          useThinInstances = false;
        }
        var changed = false;
        var useClipPlane1 = false;
        var useClipPlane2 = false;
        var useClipPlane3 = false;
        var useClipPlane4 = false;
        var useClipPlane5 = false;
        var useClipPlane6 = false;
        useClipPlane1 = useClipPlane == null ? scene.clipPlane !== void 0 && scene.clipPlane !== null : useClipPlane;
        useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== void 0 && scene.clipPlane2 !== null : useClipPlane;
        useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== void 0 && scene.clipPlane3 !== null : useClipPlane;
        useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== void 0 && scene.clipPlane4 !== null : useClipPlane;
        useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== void 0 && scene.clipPlane5 !== null : useClipPlane;
        useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== void 0 && scene.clipPlane6 !== null : useClipPlane;
        if (defines["CLIPPLANE"] !== useClipPlane1) {
          defines["CLIPPLANE"] = useClipPlane1;
          changed = true;
        }
        if (defines["CLIPPLANE2"] !== useClipPlane2) {
          defines["CLIPPLANE2"] = useClipPlane2;
          changed = true;
        }
        if (defines["CLIPPLANE3"] !== useClipPlane3) {
          defines["CLIPPLANE3"] = useClipPlane3;
          changed = true;
        }
        if (defines["CLIPPLANE4"] !== useClipPlane4) {
          defines["CLIPPLANE4"] = useClipPlane4;
          changed = true;
        }
        if (defines["CLIPPLANE5"] !== useClipPlane5) {
          defines["CLIPPLANE5"] = useClipPlane5;
          changed = true;
        }
        if (defines["CLIPPLANE6"] !== useClipPlane6) {
          defines["CLIPPLANE6"] = useClipPlane6;
          changed = true;
        }
        if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
          defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
          changed = true;
        }
        if (defines["INSTANCES"] !== useInstances) {
          defines["INSTANCES"] = useInstances;
          changed = true;
        }
        if (defines["INSTANCESCOLOR"] && !defines["INSTANCES"]) {
          defines["INSTANCESCOLOR"] = false;
          changed = true;
        }
        if (defines["THIN_INSTANCES"] !== useThinInstances) {
          defines["THIN_INSTANCES"] = useThinInstances;
          changed = true;
        }
        if (changed) {
          defines.markAsUnprocessed();
        }
      };
      MaterialHelper2.PrepareDefinesForBones = function(mesh, defines) {
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
          var materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
          if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
            defines["BONETEXTURE"] = true;
          } else {
            defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
            defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
            var prePassRenderer = mesh.getScene().prePassRenderer;
            if (prePassRenderer && prePassRenderer.enabled) {
              var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
              defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
            }
          }
        } else {
          defines["NUM_BONE_INFLUENCERS"] = 0;
          defines["BonesPerMesh"] = 0;
        }
      };
      MaterialHelper2.PrepareDefinesForMorphTargets = function(mesh, defines) {
        var manager = mesh.morphTargetManager;
        if (manager) {
          defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
          defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
          defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
          defines["MORPHTARGETS"] = manager.numInfluencers > 0;
          defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
          defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
        } else {
          defines["MORPHTARGETS_UV"] = false;
          defines["MORPHTARGETS_TANGENT"] = false;
          defines["MORPHTARGETS_NORMAL"] = false;
          defines["MORPHTARGETS"] = false;
          defines["NUM_MORPH_INFLUENCERS"] = 0;
        }
      };
      MaterialHelper2.PrepareDefinesForBakedVertexAnimation = function(mesh, defines) {
        var manager = mesh.bakedVertexAnimationManager;
        defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
      };
      MaterialHelper2.PrepareDefinesForAttributes = function(mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha, useBakedVertexAnimation) {
        if (useMorphTargets === void 0) {
          useMorphTargets = false;
        }
        if (useVertexAlpha === void 0) {
          useVertexAlpha = true;
        }
        if (useBakedVertexAnimation === void 0) {
          useBakedVertexAnimation = true;
        }
        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
          return false;
        }
        defines._normals = defines._needNormals;
        defines._uvs = defines._needUVs;
        defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          defines["TANGENT"] = true;
        }
        for (var i = 1; i <= 6; ++i) {
          defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent("uv".concat(i === 1 ? "" : i)) : false;
        }
        if (useVertexColor) {
          var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
          defines["VERTEXCOLOR"] = hasVertexColors;
          defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {
          defines["INSTANCESCOLOR"] = true;
        }
        if (useBones) {
          this.PrepareDefinesForBones(mesh, defines);
        }
        if (useMorphTargets) {
          this.PrepareDefinesForMorphTargets(mesh, defines);
        }
        if (useBakedVertexAnimation) {
          this.PrepareDefinesForBakedVertexAnimation(mesh, defines);
        }
        return true;
      };
      MaterialHelper2.PrepareDefinesForMultiview = function(scene, defines) {
        if (scene.activeCamera) {
          var previousMultiview = defines.MULTIVIEW;
          defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
          if (defines.MULTIVIEW != previousMultiview) {
            defines.markAsUnprocessed();
          }
        }
      };
      MaterialHelper2.PrepareDefinesForOIT = function(scene, defines, needAlphaBlending) {
        var previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
        var previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
        defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
        defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
        if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
          defines.markAsUnprocessed();
        }
      };
      MaterialHelper2.PrepareDefinesForPrePass = function(scene, defines, canRenderToMRT) {
        var previousPrePass = defines.PREPASS;
        if (!defines._arePrePassDirty) {
          return;
        }
        var texturesList = [
          {
            type: 1,
            define: "PREPASS_POSITION",
            index: "PREPASS_POSITION_INDEX"
          },
          {
            type: 2,
            define: "PREPASS_VELOCITY",
            index: "PREPASS_VELOCITY_INDEX"
          },
          {
            type: 3,
            define: "PREPASS_REFLECTIVITY",
            index: "PREPASS_REFLECTIVITY_INDEX"
          },
          {
            type: 0,
            define: "PREPASS_IRRADIANCE",
            index: "PREPASS_IRRADIANCE_INDEX"
          },
          {
            type: 7,
            define: "PREPASS_ALBEDO_SQRT",
            index: "PREPASS_ALBEDO_SQRT_INDEX"
          },
          {
            type: 5,
            define: "PREPASS_DEPTH",
            index: "PREPASS_DEPTH_INDEX"
          },
          {
            type: 6,
            define: "PREPASS_NORMAL",
            index: "PREPASS_NORMAL_INDEX"
          }
        ];
        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
          defines.PREPASS = true;
          defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
          for (var i = 0; i < texturesList.length; i++) {
            var index = scene.prePassRenderer.getIndex(texturesList[i].type);
            if (index !== -1) {
              defines[texturesList[i].define] = true;
              defines[texturesList[i].index] = index;
            } else {
              defines[texturesList[i].define] = false;
            }
          }
        } else {
          defines.PREPASS = false;
          for (var i = 0; i < texturesList.length; i++) {
            defines[texturesList[i].define] = false;
          }
        }
        if (defines.PREPASS != previousPrePass) {
          defines.markAsUnprocessed();
          defines.markAsImageProcessingDirty();
        }
      };
      MaterialHelper2.PrepareDefinesForLight = function(scene, mesh, light, lightIndex, defines, specularSupported, state) {
        state.needNormals = true;
        if (defines["LIGHT" + lightIndex] === void 0) {
          state.needRebuild = true;
        }
        defines["LIGHT" + lightIndex] = true;
        defines["SPOTLIGHT" + lightIndex] = false;
        defines["HEMILIGHT" + lightIndex] = false;
        defines["POINTLIGHT" + lightIndex] = false;
        defines["DIRLIGHT" + lightIndex] = false;
        light.prepareLightSpecificDefines(defines, lightIndex);
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
        switch (light.falloffType) {
          case Light.FALLOFF_GLTF:
            defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
            break;
          case Light.FALLOFF_PHYSICAL:
            defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
            break;
          case Light.FALLOFF_STANDARD:
            defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
            break;
        }
        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
          state.specularEnabled = true;
        }
        defines["SHADOW" + lightIndex] = false;
        defines["SHADOWCSM" + lightIndex] = false;
        defines["SHADOWCSMDEBUG" + lightIndex] = false;
        defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
        defines["SHADOWCSMNOBLEND" + lightIndex] = false;
        defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
        defines["SHADOWPCF" + lightIndex] = false;
        defines["SHADOWPCSS" + lightIndex] = false;
        defines["SHADOWPOISSON" + lightIndex] = false;
        defines["SHADOWESM" + lightIndex] = false;
        defines["SHADOWCLOSEESM" + lightIndex] = false;
        defines["SHADOWCUBE" + lightIndex] = false;
        defines["SHADOWLOWQUALITY" + lightIndex] = false;
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
          var shadowGenerator = light.getShadowGenerator();
          if (shadowGenerator) {
            var shadowMap = shadowGenerator.getShadowMap();
            if (shadowMap) {
              if (shadowMap.renderList && shadowMap.renderList.length > 0) {
                state.shadowEnabled = true;
                shadowGenerator.prepareDefines(defines, lightIndex);
              }
            }
          }
        }
        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {
          state.lightmapMode = true;
          defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
          defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;
        } else {
          defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
          defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
        }
      };
      MaterialHelper2.PrepareDefinesForLights = function(scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {
        if (maxSimultaneousLights === void 0) {
          maxSimultaneousLights = 4;
        }
        if (disableLighting === void 0) {
          disableLighting = false;
        }
        if (!defines._areLightsDirty) {
          return defines._needNormals;
        }
        var lightIndex = 0;
        var state = {
          needNormals: false,
          needRebuild: false,
          lightmapMode: false,
          shadowEnabled: false,
          specularEnabled: false
        };
        if (scene.lightsEnabled && !disableLighting) {
          for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {
            var light = _a[_i];
            this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
            lightIndex++;
            if (lightIndex === maxSimultaneousLights) {
              break;
            }
          }
        }
        defines["SPECULARTERM"] = state.specularEnabled;
        defines["SHADOWS"] = state.shadowEnabled;
        for (var index = lightIndex; index < maxSimultaneousLights; index++) {
          if (defines["LIGHT" + index] !== void 0) {
            defines["LIGHT" + index] = false;
            defines["HEMILIGHT" + index] = false;
            defines["POINTLIGHT" + index] = false;
            defines["DIRLIGHT" + index] = false;
            defines["SPOTLIGHT" + index] = false;
            defines["SHADOW" + index] = false;
            defines["SHADOWCSM" + index] = false;
            defines["SHADOWCSMDEBUG" + index] = false;
            defines["SHADOWCSMNUM_CASCADES" + index] = false;
            defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
            defines["SHADOWCSMNOBLEND" + index] = false;
            defines["SHADOWCSM_RIGHTHANDED" + index] = false;
            defines["SHADOWPCF" + index] = false;
            defines["SHADOWPCSS" + index] = false;
            defines["SHADOWPOISSON" + index] = false;
            defines["SHADOWESM" + index] = false;
            defines["SHADOWCLOSEESM" + index] = false;
            defines["SHADOWCUBE" + index] = false;
            defines["SHADOWLOWQUALITY" + index] = false;
            defines["SHADOWMEDIUMQUALITY" + index] = false;
          }
        }
        var caps = scene.getEngine().getCaps();
        if (defines["SHADOWFLOAT"] === void 0) {
          state.needRebuild = true;
        }
        defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
        defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
        if (state.needRebuild) {
          defines.rebuild();
        }
        return state.needNormals;
      };
      MaterialHelper2.PrepareUniformsAndSamplersForLight = function(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {
        if (uniformBuffersList === void 0) {
          uniformBuffersList = null;
        }
        if (updateOnlyBuffersList === void 0) {
          updateOnlyBuffersList = false;
        }
        if (uniformBuffersList) {
          uniformBuffersList.push("Light" + lightIndex);
        }
        if (updateOnlyBuffersList) {
          return;
        }
        uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
        samplersList.push("shadowSampler" + lightIndex);
        samplersList.push("depthSampler" + lightIndex);
        uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
        if (projectedLightTexture) {
          samplersList.push("projectionLightSampler" + lightIndex);
          uniformsList.push("textureProjectionMatrix" + lightIndex);
        }
      };
      MaterialHelper2.PrepareUniformsAndSamplersList = function(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {
        if (maxSimultaneousLights === void 0) {
          maxSimultaneousLights = 4;
        }
        var uniformsList;
        var uniformBuffersList = null;
        if (uniformsListOrOptions.uniformsNames) {
          var options = uniformsListOrOptions;
          uniformsList = options.uniformsNames;
          uniformBuffersList = options.uniformBuffersNames;
          samplersList = options.samplers;
          defines = options.defines;
          maxSimultaneousLights = options.maxSimultaneousLights || 0;
        } else {
          uniformsList = uniformsListOrOptions;
          if (!samplersList) {
            samplersList = [];
          }
        }
        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
          if (!defines["LIGHT" + lightIndex]) {
            break;
          }
          this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
        }
        if (defines["NUM_MORPH_INFLUENCERS"]) {
          uniformsList.push("morphTargetInfluences");
        }
        if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
          uniformsList.push("bakedVertexAnimationSettings");
          uniformsList.push("bakedVertexAnimationTextureSizeInverted");
          uniformsList.push("bakedVertexAnimationTime");
          samplersList.push("bakedVertexAnimationTexture");
        }
      };
      MaterialHelper2.HandleFallbacksForShadows = function(defines, fallbacks, maxSimultaneousLights, rank) {
        if (maxSimultaneousLights === void 0) {
          maxSimultaneousLights = 4;
        }
        if (rank === void 0) {
          rank = 0;
        }
        var lightFallbackRank = 0;
        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
          if (!defines["LIGHT" + lightIndex]) {
            break;
          }
          if (lightIndex > 0) {
            lightFallbackRank = rank + lightIndex;
            fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
          }
          if (!defines["SHADOWS"]) {
            if (defines["SHADOW" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOW" + lightIndex);
            }
            if (defines["SHADOWPCF" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
            }
            if (defines["SHADOWPCSS" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
            }
            if (defines["SHADOWPOISSON" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
            }
            if (defines["SHADOWESM" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
            }
            if (defines["SHADOWCLOSEESM" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
            }
          }
        }
        return lightFallbackRank++;
      };
      MaterialHelper2.PrepareAttributesForMorphTargetsInfluencers = function(attribs, mesh, influencers) {
        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
      };
      MaterialHelper2.PrepareAttributesForMorphTargets = function(attribs, mesh, defines) {
        var influencers = defines["NUM_MORPH_INFLUENCERS"];
        if (influencers > 0 && EngineStore.LastCreatedEngine) {
          var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
          var manager = mesh.morphTargetManager;
          if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
            return;
          }
          var normal = manager && manager.supportsNormals && defines["NORMAL"];
          var tangent = manager && manager.supportsTangents && defines["TANGENT"];
          var uv = manager && manager.supportsUVs && defines["UV1"];
          for (var index = 0; index < influencers; index++) {
            attribs.push(VertexBuffer.PositionKind + index);
            if (normal) {
              attribs.push(VertexBuffer.NormalKind + index);
            }
            if (tangent) {
              attribs.push(VertexBuffer.TangentKind + index);
            }
            if (uv) {
              attribs.push(VertexBuffer.UVKind + "_" + index);
            }
            if (attribs.length > maxAttributesCount) {
              Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
            }
          }
        }
      };
      MaterialHelper2.PrepareAttributesForBakedVertexAnimation = function(attribs, mesh, defines) {
        var enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
        if (enabled) {
          attribs.push("bakedVertexAnimationSettingsInstanced");
        }
      };
      MaterialHelper2.PrepareAttributesForBones = function(attribs, mesh, defines, fallbacks) {
        if (defines["NUM_BONE_INFLUENCERS"] > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (defines["NUM_BONE_INFLUENCERS"] > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
        }
      };
      MaterialHelper2.PrepareAttributesForInstances = function(attribs, defines) {
        if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
          this.PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
        }
      };
      MaterialHelper2.PushAttributesForInstances = function(attribs, needsPreviousMatrices) {
        if (needsPreviousMatrices === void 0) {
          needsPreviousMatrices = false;
        }
        attribs.push("world0");
        attribs.push("world1");
        attribs.push("world2");
        attribs.push("world3");
        if (needsPreviousMatrices) {
          attribs.push("previousWorld0");
          attribs.push("previousWorld1");
          attribs.push("previousWorld2");
          attribs.push("previousWorld3");
        }
      };
      MaterialHelper2.BindLightProperties = function(light, effect, lightIndex) {
        light.transferToEffect(effect, lightIndex + "");
      };
      MaterialHelper2.BindLight = function(light, lightIndex, scene, effect, useSpecular, receiveShadows) {
        if (receiveShadows === void 0) {
          receiveShadows = true;
        }
        light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
      };
      MaterialHelper2.BindLights = function(scene, mesh, effect, defines, maxSimultaneousLights) {
        if (maxSimultaneousLights === void 0) {
          maxSimultaneousLights = 4;
        }
        var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
        for (var i = 0; i < len; i++) {
          var light = mesh.lightSources[i];
          this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
        }
      };
      MaterialHelper2.BindFogParameters = function(scene, mesh, effect, linearSpace) {
        if (linearSpace === void 0) {
          linearSpace = false;
        }
        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
          effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
          if (linearSpace) {
            scene.fogColor.toLinearSpaceToRef(this._TempFogColor);
            effect.setColor3("vFogColor", this._TempFogColor);
          } else {
            effect.setColor3("vFogColor", scene.fogColor);
          }
        }
      };
      MaterialHelper2.BindBonesParameters = function(mesh, effect, prePassConfiguration) {
        if (!effect || !mesh) {
          return;
        }
        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
          mesh.computeBonesUsingShaders = false;
        }
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          var skeleton = mesh.skeleton;
          if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
            var boneTexture = skeleton.getTransformMatrixTexture(mesh);
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            var matrices = skeleton.getTransformMatrices(mesh);
            if (matrices) {
              effect.setMatrices("mBones", matrices);
              if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
                if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
                  prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
                }
                effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
                MaterialHelper2._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
              }
            }
          }
        }
      };
      MaterialHelper2._CopyBonesTransformationMatrices = function(source, target) {
        target.set(source);
        return target;
      };
      MaterialHelper2.BindMorphTargetParameters = function(abstractMesh, effect) {
        var manager = abstractMesh.morphTargetManager;
        if (!abstractMesh || !manager) {
          return;
        }
        effect.setFloatArray("morphTargetInfluences", manager.influences);
      };
      MaterialHelper2.BindLogDepth = function(defines, effect, scene) {
        if (!defines || defines["LOGARITHMICDEPTH"]) {
          var camera = scene.activeCamera;
          if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
            Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
          }
          effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
        }
      };
      MaterialHelper2.BindClipPlane = function(effect, scene) {
        ThinMaterialHelper.BindClipPlane(effect, scene);
      };
      MaterialHelper2._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
      MaterialHelper2._TempFogColor = Color3.Black();
      return MaterialHelper2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/materialStencilState.js
var MaterialStencilState;
var init_materialStencilState = __esm({
  "node_modules/@babylonjs/core/Materials/materialStencilState.js"() {
    init_tslib_es6();
    init_decorators();
    MaterialStencilState = function() {
      function MaterialStencilState2() {
        this.reset();
      }
      MaterialStencilState2.prototype.reset = function() {
        this.enabled = false;
        this.mask = 255;
        this.func = 519;
        this.funcRef = 1;
        this.funcMask = 255;
        this.opStencilFail = 7680;
        this.opDepthFail = 7680;
        this.opStencilDepthPass = 7681;
      };
      Object.defineProperty(MaterialStencilState2.prototype, "func", {
        get: function() {
          return this._func;
        },
        set: function(value) {
          this._func = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "funcRef", {
        get: function() {
          return this._funcRef;
        },
        set: function(value) {
          this._funcRef = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "funcMask", {
        get: function() {
          return this._funcMask;
        },
        set: function(value) {
          this._funcMask = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "opStencilFail", {
        get: function() {
          return this._opStencilFail;
        },
        set: function(value) {
          this._opStencilFail = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "opDepthFail", {
        get: function() {
          return this._opDepthFail;
        },
        set: function(value) {
          this._opDepthFail = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "opStencilDepthPass", {
        get: function() {
          return this._opStencilDepthPass;
        },
        set: function(value) {
          this._opStencilDepthPass = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "mask", {
        get: function() {
          return this._mask;
        },
        set: function(value) {
          this._mask = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialStencilState2.prototype, "enabled", {
        get: function() {
          return this._enabled;
        },
        set: function(value) {
          this._enabled = value;
        },
        enumerable: false,
        configurable: true
      });
      MaterialStencilState2.prototype.getClassName = function() {
        return "MaterialStencilState";
      };
      MaterialStencilState2.prototype.copyTo = function(stencilState) {
        SerializationHelper.Clone(function() {
          return stencilState;
        }, this);
      };
      MaterialStencilState2.prototype.serialize = function() {
        return SerializationHelper.Serialize(this);
      };
      MaterialStencilState2.prototype.parse = function(source, scene, rootUrl) {
        var _this = this;
        SerializationHelper.Parse(function() {
          return _this;
        }, source, scene, rootUrl);
      };
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "func", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "funcRef", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "funcMask", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "opStencilFail", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "opDepthFail", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "opStencilDepthPass", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "mask", null);
      __decorate([
        serialize()
      ], MaterialStencilState2.prototype, "enabled", null);
      return MaterialStencilState2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginEvent.js
var MaterialPluginEvent;
var init_materialPluginEvent = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginEvent.js"() {
    (function(MaterialPluginEvent2) {
      MaterialPluginEvent2[MaterialPluginEvent2["Created"] = 1] = "Created";
      MaterialPluginEvent2[MaterialPluginEvent2["Disposed"] = 2] = "Disposed";
      MaterialPluginEvent2[MaterialPluginEvent2["GetDefineNames"] = 4] = "GetDefineNames";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareUniformBuffer"] = 8] = "PrepareUniformBuffer";
      MaterialPluginEvent2[MaterialPluginEvent2["IsReadyForSubMesh"] = 16] = "IsReadyForSubMesh";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareDefines"] = 32] = "PrepareDefines";
      MaterialPluginEvent2[MaterialPluginEvent2["BindForSubMesh"] = 64] = "BindForSubMesh";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareEffect"] = 128] = "PrepareEffect";
      MaterialPluginEvent2[MaterialPluginEvent2["GetAnimatables"] = 256] = "GetAnimatables";
      MaterialPluginEvent2[MaterialPluginEvent2["GetActiveTextures"] = 512] = "GetActiveTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HasTexture"] = 1024] = "HasTexture";
      MaterialPluginEvent2[MaterialPluginEvent2["FillRenderTargetTextures"] = 2048] = "FillRenderTargetTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HasRenderTargetTextures"] = 4096] = "HasRenderTargetTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HardBindForSubMesh"] = 8192] = "HardBindForSubMesh";
    })(MaterialPluginEvent || (MaterialPluginEvent = {}));
  }
});

// node_modules/@babylonjs/core/Materials/material.js
var Material;
var init_material = __esm({
  "node_modules/@babylonjs/core/Materials/material.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_observable();
    init_engineStore();
    init_subMesh();
    init_uniformBuffer();
    init_logger();
    init_math_plane();
    init_materialHelper();
    init_drawWrapper();
    init_materialStencilState();
    init_materialPluginEvent();
    Material = function() {
      function Material2(name105, scene, doNotAdd) {
        this.shadowDepthWrapper = null;
        this.allowShaderHotSwapping = true;
        this.metadata = null;
        this.reservedDataStore = null;
        this.checkReadyOnEveryCall = false;
        this.checkReadyOnlyOnce = false;
        this.state = "";
        this._alpha = 1;
        this._backFaceCulling = true;
        this._cullBackFaces = true;
        this.onCompiled = null;
        this.onError = null;
        this.getRenderTargetTextures = null;
        this.doNotSerialize = false;
        this._storeEffectOnSubMeshes = false;
        this.animations = null;
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this._onUnBindObservable = null;
        this._onBindObserver = null;
        this._alphaMode = 2;
        this._needDepthPrePass = false;
        this.disableDepthWrite = false;
        this.disableColorWrite = false;
        this.forceDepthWrite = false;
        this.depthFunction = 0;
        this.separateCullingPass = false;
        this._fogEnabled = true;
        this.pointSize = 1;
        this.zOffset = 0;
        this.zOffsetUnits = 0;
        this.stencil = new MaterialStencilState();
        this._useUBO = false;
        this._fillMode = Material2.TriangleFillMode;
        this._cachedDepthWriteState = false;
        this._cachedColorWriteState = false;
        this._cachedDepthFunctionState = 0;
        this._indexInSceneMaterialArray = -1;
        this.meshMap = null;
        this._parentContainer = null;
        this._uniformBufferLayoutBuilt = false;
        this._eventInfo = {};
        this._callbackPluginEventGeneric = function() {
          return void 0;
        };
        this._callbackPluginEventIsReadyForSubMesh = function() {
          return void 0;
        };
        this._callbackPluginEventPrepareDefines = function() {
          return void 0;
        };
        this._callbackPluginEventHardBindForSubMesh = function() {
          return void 0;
        };
        this._callbackPluginEventBindForSubMesh = function() {
          return void 0;
        };
        this._callbackPluginEventHasRenderTargetTextures = function() {
          return void 0;
        };
        this._callbackPluginEventFillRenderTargetTextures = function() {
          return void 0;
        };
        this._forceAlphaTest = false;
        this._transparencyMode = null;
        this.name = name105;
        var setScene = scene || EngineStore.LastCreatedScene;
        if (!setScene) {
          return;
        }
        this._scene = setScene;
        this._dirtyCallbacks = {};
        this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
        this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
        this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
        this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
        this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
        this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
        this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);
        this.id = name105 || Tools.RandomId();
        this.uniqueId = this._scene.getUniqueId();
        this._materialContext = this._scene.getEngine().createMaterialContext();
        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
        this._drawWrapper.materialContext = this._materialContext;
        if (this._scene.useRightHandedSystem) {
          this.sideOrientation = Material2.ClockWiseSideOrientation;
        } else {
          this.sideOrientation = Material2.CounterClockWiseSideOrientation;
        }
        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name105);
        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
        if (!doNotAdd) {
          this._scene.addMaterial(this);
        }
        if (this._scene.useMaterialMeshMap) {
          this.meshMap = {};
        }
        Material2.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);
      }
      Object.defineProperty(Material2.prototype, "canRenderToMRT", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "alpha", {
        get: function() {
          return this._alpha;
        },
        set: function(value) {
          if (this._alpha === value) {
            return;
          }
          this._alpha = value;
          this.markAsDirty(Material2.MiscDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "backFaceCulling", {
        get: function() {
          return this._backFaceCulling;
        },
        set: function(value) {
          if (this._backFaceCulling === value) {
            return;
          }
          this._backFaceCulling = value;
          this.markAsDirty(Material2.TextureDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "cullBackFaces", {
        get: function() {
          return this._cullBackFaces;
        },
        set: function(value) {
          if (this._cullBackFaces === value) {
            return;
          }
          this._cullBackFaces = value;
          this.markAsDirty(Material2.TextureDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "hasRenderTargetTextures", {
        get: function() {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          return this._eventInfo.hasRenderTargetTextures;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "onDispose", {
        set: function(callback) {
          if (this._onDisposeObserver) {
            this.onDisposeObservable.remove(this._onDisposeObserver);
          }
          this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "onBindObservable", {
        get: function() {
          if (!this._onBindObservable) {
            this._onBindObservable = new Observable();
          }
          return this._onBindObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "onBind", {
        set: function(callback) {
          if (this._onBindObserver) {
            this.onBindObservable.remove(this._onBindObserver);
          }
          this._onBindObserver = this.onBindObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "onUnBindObservable", {
        get: function() {
          if (!this._onUnBindObservable) {
            this._onUnBindObservable = new Observable();
          }
          return this._onUnBindObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "onEffectCreatedObservable", {
        get: function() {
          if (!this._onEffectCreatedObservable) {
            this._onEffectCreatedObservable = new Observable();
          }
          return this._onEffectCreatedObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "alphaMode", {
        get: function() {
          return this._alphaMode;
        },
        set: function(value) {
          if (this._alphaMode === value) {
            return;
          }
          this._alphaMode = value;
          this.markAsDirty(Material2.TextureDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "needDepthPrePass", {
        get: function() {
          return this._needDepthPrePass;
        },
        set: function(value) {
          if (this._needDepthPrePass === value) {
            return;
          }
          this._needDepthPrePass = value;
          if (this._needDepthPrePass) {
            this.checkReadyOnEveryCall = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "isPrePassCapable", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "fogEnabled", {
        get: function() {
          return this._fogEnabled;
        },
        set: function(value) {
          if (this._fogEnabled === value) {
            return;
          }
          this._fogEnabled = value;
          this.markAsDirty(Material2.MiscDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "wireframe", {
        get: function() {
          switch (this._fillMode) {
            case Material2.WireFrameFillMode:
            case Material2.LineListDrawMode:
            case Material2.LineLoopDrawMode:
            case Material2.LineStripDrawMode:
              return true;
          }
          return this._scene.forceWireframe;
        },
        set: function(value) {
          this.fillMode = value ? Material2.WireFrameFillMode : Material2.TriangleFillMode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "pointsCloud", {
        get: function() {
          switch (this._fillMode) {
            case Material2.PointFillMode:
            case Material2.PointListDrawMode:
              return true;
          }
          return this._scene.forcePointsCloud;
        },
        set: function(value) {
          this.fillMode = value ? Material2.PointFillMode : Material2.TriangleFillMode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "fillMode", {
        get: function() {
          return this._fillMode;
        },
        set: function(value) {
          if (this._fillMode === value) {
            return;
          }
          this._fillMode = value;
          this.markAsDirty(Material2.MiscDirtyFlag);
        },
        enumerable: false,
        configurable: true
      });
      Material2.prototype._getDrawWrapper = function() {
        return this._drawWrapper;
      };
      Material2.prototype._setDrawWrapper = function(drawWrapper) {
        this._drawWrapper = drawWrapper;
      };
      Material2.prototype.toString = function(fullDetails) {
        var ret = "Name: " + this.name;
        return ret;
      };
      Material2.prototype.getClassName = function() {
        return "Material";
      };
      Object.defineProperty(Material2.prototype, "isFrozen", {
        get: function() {
          return this.checkReadyOnlyOnce;
        },
        enumerable: false,
        configurable: true
      });
      Material2.prototype.freeze = function() {
        this.markDirty();
        this.checkReadyOnlyOnce = true;
      };
      Material2.prototype.unfreeze = function() {
        this.markDirty();
        this.checkReadyOnlyOnce = false;
      };
      Material2.prototype.isReady = function(mesh, useInstances) {
        return true;
      };
      Material2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
        var defines = subMesh.materialDefines;
        if (!defines) {
          return false;
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        return this._eventInfo.isReadyForSubMesh;
      };
      Material2.prototype.getEffect = function() {
        return this._drawWrapper.effect;
      };
      Material2.prototype.getScene = function() {
        return this._scene;
      };
      Object.defineProperty(Material2.prototype, "transparencyMode", {
        get: function() {
          return this._transparencyMode;
        },
        set: function(value) {
          if (this._transparencyMode === value) {
            return;
          }
          this._transparencyMode = value;
          this._forceAlphaTest = value === Material2.MATERIAL_ALPHATESTANDBLEND;
          this._markAllSubMeshesAsTexturesAndMiscDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Material2.prototype, "_disableAlphaBlending", {
        get: function() {
          return this._transparencyMode === Material2.MATERIAL_OPAQUE || this._transparencyMode === Material2.MATERIAL_ALPHATEST;
        },
        enumerable: false,
        configurable: true
      });
      Material2.prototype.needAlphaBlending = function() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1;
      };
      Material2.prototype.needAlphaBlendingForMesh = function(mesh) {
        if (this._disableAlphaBlending && mesh.visibility >= 1) {
          return false;
        }
        return this.needAlphaBlending() || mesh.visibility < 1 || mesh.hasVertexAlpha;
      };
      Material2.prototype.needAlphaTesting = function() {
        if (this._forceAlphaTest) {
          return true;
        }
        return false;
      };
      Material2.prototype._shouldTurnAlphaTestOn = function(mesh) {
        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
      };
      Material2.prototype.getAlphaTestTexture = function() {
        return null;
      };
      Material2.prototype.markDirty = function() {
        var meshes = this.getScene().meshes;
        for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
          var mesh = meshes_1[_i];
          if (!mesh.subMeshes) {
            continue;
          }
          for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
            var subMesh = _b[_a];
            if (subMesh.getMaterial() !== this) {
              continue;
            }
            if (!subMesh.effect) {
              continue;
            }
            subMesh.effect._wasPreviouslyReady = false;
          }
        }
      };
      Material2.prototype._preBind = function(effect, overrideOrientation) {
        if (overrideOrientation === void 0) {
          overrideOrientation = null;
        }
        var engine = this._scene.getEngine();
        var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
        var reverse = orientation === Material2.ClockWiseSideOrientation;
        engine.enableEffect(effect ? effect : this._getDrawWrapper());
        engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this.cullBackFaces, this.stencil, this.zOffsetUnits);
        return reverse;
      };
      Material2.prototype.bind = function(world, mesh) {
      };
      Material2.prototype.buildUniformLayout = function() {
        var ubo = this._uniformBuffer;
        this._eventInfo.ubo = ubo;
        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);
        ubo.create();
        this._uniformBufferLayoutBuilt = true;
      };
      Material2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
        var effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventBindForSubMesh(this._eventInfo);
      };
      Material2.prototype.bindOnlyWorldMatrix = function(world) {
      };
      Material2.prototype.bindView = function(effect) {
        if (!this._useUBO) {
          effect.setMatrix("view", this.getScene().getViewMatrix());
        } else {
          this._needToBindSceneUbo = true;
        }
      };
      Material2.prototype.bindViewProjection = function(effect) {
        if (!this._useUBO) {
          effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
          effect.setMatrix("projection", this.getScene().getProjectionMatrix());
        } else {
          this._needToBindSceneUbo = true;
        }
      };
      Material2.prototype.bindEyePosition = function(effect, variableName) {
        if (!this._useUBO) {
          this._scene.bindEyePosition(effect, variableName);
        } else {
          this._needToBindSceneUbo = true;
        }
      };
      Material2.prototype._afterBind = function(mesh, effect) {
        if (effect === void 0) {
          effect = null;
        }
        this._scene._cachedMaterial = this;
        if (this._needToBindSceneUbo) {
          if (effect) {
            this._needToBindSceneUbo = false;
            MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
            this._scene.finalizeSceneUbo();
          }
        }
        if (mesh) {
          this._scene._cachedVisibility = mesh.visibility;
        } else {
          this._scene._cachedVisibility = 1;
        }
        if (this._onBindObservable && mesh) {
          this._onBindObservable.notifyObservers(mesh);
        }
        if (this.disableDepthWrite) {
          var engine = this._scene.getEngine();
          this._cachedDepthWriteState = engine.getDepthWrite();
          engine.setDepthWrite(false);
        }
        if (this.disableColorWrite) {
          var engine = this._scene.getEngine();
          this._cachedColorWriteState = engine.getColorWrite();
          engine.setColorWrite(false);
        }
        if (this.depthFunction !== 0) {
          var engine = this._scene.getEngine();
          this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
          engine.setDepthFunction(this.depthFunction);
        }
      };
      Material2.prototype.unbind = function() {
        if (this._onUnBindObservable) {
          this._onUnBindObservable.notifyObservers(this);
        }
        if (this.depthFunction !== 0) {
          var engine = this._scene.getEngine();
          engine.setDepthFunction(this._cachedDepthFunctionState);
        }
        if (this.disableDepthWrite) {
          var engine = this._scene.getEngine();
          engine.setDepthWrite(this._cachedDepthWriteState);
        }
        if (this.disableColorWrite) {
          var engine = this._scene.getEngine();
          engine.setColorWrite(this._cachedColorWriteState);
        }
      };
      Material2.prototype.getAnimatables = function() {
        this._eventInfo.animatables = [];
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);
        return this._eventInfo.animatables;
      };
      Material2.prototype.getActiveTextures = function() {
        this._eventInfo.activeTextures = [];
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);
        return this._eventInfo.activeTextures;
      };
      Material2.prototype.hasTexture = function(texture) {
        this._eventInfo.hasTexture = false;
        this._eventInfo.texture = texture;
        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);
        return this._eventInfo.hasTexture;
      };
      Material2.prototype.clone = function(name105) {
        return null;
      };
      Material2.prototype.getBindedMeshes = function() {
        var _this = this;
        if (this.meshMap) {
          var result = new Array();
          for (var meshId in this.meshMap) {
            var mesh = this.meshMap[meshId];
            if (mesh) {
              result.push(mesh);
            }
          }
          return result;
        } else {
          var meshes = this._scene.meshes;
          return meshes.filter(function(mesh2) {
            return mesh2.material === _this;
          });
        }
      };
      Material2.prototype.forceCompilation = function(mesh, onCompiled, options, onError) {
        var _this = this;
        var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
        var scene = this.getScene();
        var currentHotSwapingState = this.allowShaderHotSwapping;
        this.allowShaderHotSwapping = false;
        var checkReady = function() {
          if (!_this._scene || !_this._scene.getEngine()) {
            return;
          }
          var clipPlaneState = scene.clipPlane;
          if (localOptions.clipPlane) {
            scene.clipPlane = new Plane(0, 0, 0, 1);
          }
          if (_this._storeEffectOnSubMeshes) {
            var allDone = true, lastError = null;
            if (mesh.subMeshes) {
              var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
              if (tempSubMesh.materialDefines) {
                tempSubMesh.materialDefines._renderId = -1;
              }
              if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
                if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
                  lastError = tempSubMesh.effect.getCompilationError();
                } else {
                  allDone = false;
                  setTimeout(checkReady, 16);
                }
              }
            }
            if (allDone) {
              _this.allowShaderHotSwapping = currentHotSwapingState;
              if (lastError) {
                if (onError) {
                  onError(lastError);
                }
              }
              if (onCompiled) {
                onCompiled(_this);
              }
            }
          } else {
            if (_this.isReady()) {
              _this.allowShaderHotSwapping = currentHotSwapingState;
              if (onCompiled) {
                onCompiled(_this);
              }
            } else {
              setTimeout(checkReady, 16);
            }
          }
          if (localOptions.clipPlane) {
            scene.clipPlane = clipPlaneState;
          }
        };
        checkReady();
      };
      Material2.prototype.forceCompilationAsync = function(mesh, options) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.forceCompilation(mesh, function() {
            resolve();
          }, options, function(reason) {
            reject(reason);
          });
        });
      };
      Material2.prototype.markAsDirty = function(flag) {
        if (this.getScene().blockMaterialDirtyMechanism) {
          return;
        }
        Material2._DirtyCallbackArray.length = 0;
        if (flag & Material2.TextureDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._TextureDirtyCallBack);
        }
        if (flag & Material2.LightDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._LightsDirtyCallBack);
        }
        if (flag & Material2.FresnelDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._FresnelDirtyCallBack);
        }
        if (flag & Material2.AttributesDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._AttributeDirtyCallBack);
        }
        if (flag & Material2.MiscDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._MiscDirtyCallBack);
        }
        if (flag & Material2.PrePassDirtyFlag) {
          Material2._DirtyCallbackArray.push(Material2._PrePassDirtyCallBack);
        }
        if (Material2._DirtyCallbackArray.length) {
          this._markAllSubMeshesAsDirty(Material2._RunDirtyCallBacks);
        }
        this.getScene().resetCachedMaterial();
      };
      Material2.prototype.resetDrawCache = function() {
        var meshes = this.getScene().meshes;
        for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {
          var mesh = meshes_2[_i];
          if (!mesh.subMeshes) {
            continue;
          }
          for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
            var subMesh = _b[_a];
            if (subMesh.getMaterial() !== this) {
              continue;
            }
            subMesh.resetDrawCache();
          }
        }
      };
      Material2.prototype._markAllSubMeshesAsDirty = function(func) {
        if (this.getScene().blockMaterialDirtyMechanism) {
          return;
        }
        var meshes = this.getScene().meshes;
        for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {
          var mesh = meshes_3[_i];
          if (!mesh.subMeshes) {
            continue;
          }
          for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
            var subMesh = _b[_a];
            if (mesh._renderId === 0 || subMesh.getMaterial() !== this) {
              continue;
            }
            for (var _c = 0, _d = subMesh._drawWrappers; _c < _d.length; _c++) {
              var drawWrapper = _d[_c];
              if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
                continue;
              }
              if (this._materialContext === drawWrapper.materialContext) {
                func(drawWrapper.defines);
              }
            }
          }
        }
      };
      Material2.prototype._markScenePrePassDirty = function() {
        if (this.getScene().blockMaterialDirtyMechanism) {
          return;
        }
        var prePassRenderer = this.getScene().enablePrePassRenderer();
        if (prePassRenderer) {
          prePassRenderer.markAsDirty();
        }
      };
      Material2.prototype._markAllSubMeshesAsAllDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._AllDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsImageProcessingDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._ImageProcessingDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._TextureDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsFresnelDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._FresnelDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._FresnelAndMiscDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsLightsDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._LightsDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsAttributesDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._AttributeDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsMiscDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsPrePassDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
      };
      Material2.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function() {
        this._markAllSubMeshesAsDirty(Material2._TextureAndMiscDirtyCallBack);
      };
      Material2.prototype.setPrePassRenderer = function(prePassRenderer) {
        return false;
      };
      Material2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        var scene = this.getScene();
        scene.stopAnimation(this);
        scene.freeProcessedMaterials();
        scene.removeMaterial(this);
        this._eventInfo.forceDisposeTextures = forceDisposeTextures;
        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);
        if (this._parentContainer) {
          var index = this._parentContainer.materials.indexOf(this);
          if (index > -1) {
            this._parentContainer.materials.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (notBoundToMesh !== true) {
          if (this.meshMap) {
            for (var meshId in this.meshMap) {
              var mesh = this.meshMap[meshId];
              if (mesh) {
                mesh.material = null;
                this.releaseVertexArrayObject(mesh, forceDisposeEffect);
              }
            }
          } else {
            var meshes = scene.meshes;
            for (var _i = 0, meshes_4 = meshes; _i < meshes_4.length; _i++) {
              var mesh = meshes_4[_i];
              if (mesh.material === this && !mesh.sourceMesh) {
                mesh.material = null;
                this.releaseVertexArrayObject(mesh, forceDisposeEffect);
              }
            }
          }
        }
        this._uniformBuffer.dispose();
        if (forceDisposeEffect && this._drawWrapper.effect) {
          if (!this._storeEffectOnSubMeshes) {
            this._drawWrapper.effect.dispose();
          }
          this._drawWrapper.effect = null;
        }
        this.metadata = null;
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        if (this._onBindObservable) {
          this._onBindObservable.clear();
        }
        if (this._onUnBindObservable) {
          this._onUnBindObservable.clear();
        }
        if (this._onEffectCreatedObservable) {
          this._onEffectCreatedObservable.clear();
        }
      };
      Material2.prototype.releaseVertexArrayObject = function(mesh, forceDisposeEffect) {
        if (mesh.geometry) {
          var geometry = mesh.geometry;
          if (this._storeEffectOnSubMeshes) {
            for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {
              var subMesh = _a[_i];
              geometry._releaseVertexArrayObject(subMesh.effect);
              if (forceDisposeEffect && subMesh.effect) {
                subMesh.effect.dispose();
              }
            }
          } else {
            geometry._releaseVertexArrayObject(this._drawWrapper.effect);
          }
        }
      };
      Material2.prototype.serialize = function() {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.stencil = this.stencil.serialize();
        serializationObject.uniqueId = this.uniqueId;
        return serializationObject;
      };
      Material2.Parse = function(parsedMaterial, scene, rootUrl) {
        if (!parsedMaterial.customType) {
          parsedMaterial.customType = "BABYLON.StandardMaterial";
        } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
          parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
          if (!BABYLON.LegacyPBRMaterial) {
            Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
            return null;
          }
        }
        var materialType = Tools.Instantiate(parsedMaterial.customType);
        var material = materialType.Parse(parsedMaterial, scene, rootUrl);
        material._loadedUniqueId = parsedMaterial.uniqueId;
        return material;
      };
      Material2.TriangleFillMode = 0;
      Material2.WireFrameFillMode = 1;
      Material2.PointFillMode = 2;
      Material2.PointListDrawMode = 3;
      Material2.LineListDrawMode = 4;
      Material2.LineLoopDrawMode = 5;
      Material2.LineStripDrawMode = 6;
      Material2.TriangleStripDrawMode = 7;
      Material2.TriangleFanDrawMode = 8;
      Material2.ClockWiseSideOrientation = 0;
      Material2.CounterClockWiseSideOrientation = 1;
      Material2.TextureDirtyFlag = 1;
      Material2.LightDirtyFlag = 2;
      Material2.FresnelDirtyFlag = 4;
      Material2.AttributesDirtyFlag = 8;
      Material2.MiscDirtyFlag = 16;
      Material2.PrePassDirtyFlag = 32;
      Material2.AllDirtyFlag = 63;
      Material2.MATERIAL_OPAQUE = 0;
      Material2.MATERIAL_ALPHATEST = 1;
      Material2.MATERIAL_ALPHABLEND = 2;
      Material2.MATERIAL_ALPHATESTANDBLEND = 3;
      Material2.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
      Material2.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
      Material2.OnEventObservable = new Observable();
      Material2._AllDirtyCallBack = function(defines) {
        return defines.markAllAsDirty();
      };
      Material2._ImageProcessingDirtyCallBack = function(defines) {
        return defines.markAsImageProcessingDirty();
      };
      Material2._TextureDirtyCallBack = function(defines) {
        return defines.markAsTexturesDirty();
      };
      Material2._FresnelDirtyCallBack = function(defines) {
        return defines.markAsFresnelDirty();
      };
      Material2._MiscDirtyCallBack = function(defines) {
        return defines.markAsMiscDirty();
      };
      Material2._PrePassDirtyCallBack = function(defines) {
        return defines.markAsPrePassDirty();
      };
      Material2._LightsDirtyCallBack = function(defines) {
        return defines.markAsLightDirty();
      };
      Material2._AttributeDirtyCallBack = function(defines) {
        return defines.markAsAttributesDirty();
      };
      Material2._FresnelAndMiscDirtyCallBack = function(defines) {
        Material2._FresnelDirtyCallBack(defines);
        Material2._MiscDirtyCallBack(defines);
      };
      Material2._TextureAndMiscDirtyCallBack = function(defines) {
        Material2._TextureDirtyCallBack(defines);
        Material2._MiscDirtyCallBack(defines);
      };
      Material2._DirtyCallbackArray = [];
      Material2._RunDirtyCallBacks = function(defines) {
        for (var _i = 0, _a = Material2._DirtyCallbackArray; _i < _a.length; _i++) {
          var cb = _a[_i];
          cb(defines);
        }
      };
      __decorate([
        serialize()
      ], Material2.prototype, "id", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "uniqueId", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "name", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "metadata", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "checkReadyOnEveryCall", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "checkReadyOnlyOnce", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "state", void 0);
      __decorate([
        serialize("alpha")
      ], Material2.prototype, "_alpha", void 0);
      __decorate([
        serialize("backFaceCulling")
      ], Material2.prototype, "_backFaceCulling", void 0);
      __decorate([
        serialize("cullBackFaces")
      ], Material2.prototype, "_cullBackFaces", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "sideOrientation", void 0);
      __decorate([
        serialize("alphaMode")
      ], Material2.prototype, "_alphaMode", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "_needDepthPrePass", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "disableDepthWrite", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "disableColorWrite", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "forceDepthWrite", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "depthFunction", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "separateCullingPass", void 0);
      __decorate([
        serialize("fogEnabled")
      ], Material2.prototype, "_fogEnabled", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "pointSize", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "zOffset", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "zOffsetUnits", void 0);
      __decorate([
        serialize()
      ], Material2.prototype, "pointsCloud", null);
      __decorate([
        serialize()
      ], Material2.prototype, "fillMode", null);
      __decorate([
        serialize()
      ], Material2.prototype, "transparencyMode", null);
      return Material2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/multiMaterial.js
var MultiMaterial;
var init_multiMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/multiMaterial.js"() {
    init_tslib_es6();
    init_material();
    init_tags();
    init_typeStore();
    MultiMaterial = function(_super) {
      __extends(MultiMaterial2, _super);
      function MultiMaterial2(name105, scene) {
        var _this = _super.call(this, name105, scene, true) || this;
        _this._waitingSubMaterialsUniqueIds = [];
        _this.getScene().multiMaterials.push(_this);
        _this.subMaterials = new Array();
        _this._storeEffectOnSubMeshes = true;
        return _this;
      }
      Object.defineProperty(MultiMaterial2.prototype, "subMaterials", {
        get: function() {
          return this._subMaterials;
        },
        set: function(value) {
          this._subMaterials = value;
          this._hookArray(value);
        },
        enumerable: false,
        configurable: true
      });
      MultiMaterial2.prototype.getChildren = function() {
        return this.subMaterials;
      };
      MultiMaterial2.prototype._hookArray = function(array) {
        var _this = this;
        var oldPush = array.push;
        array.push = function() {
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          var result = oldPush.apply(array, items);
          _this._markAllSubMeshesAsTexturesDirty();
          return result;
        };
        var oldSplice = array.splice;
        array.splice = function(index, deleteCount) {
          var deleted = oldSplice.apply(array, [index, deleteCount]);
          _this._markAllSubMeshesAsTexturesDirty();
          return deleted;
        };
      };
      MultiMaterial2.prototype.getSubMaterial = function(index) {
        if (index < 0 || index >= this.subMaterials.length) {
          return this.getScene().defaultMaterial;
        }
        return this.subMaterials[index];
      };
      MultiMaterial2.prototype.getActiveTextures = function() {
        var _a;
        return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function(subMaterial) {
          if (subMaterial) {
            return subMaterial.getActiveTextures();
          } else {
            return [];
          }
        }));
      };
      MultiMaterial2.prototype.hasTexture = function(texture) {
        var _a;
        if (_super.prototype.hasTexture.call(this, texture)) {
          return true;
        }
        for (var i = 0; i < this.subMaterials.length; i++) {
          if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {
            return true;
          }
        }
        return false;
      };
      MultiMaterial2.prototype.getClassName = function() {
        return "MultiMaterial";
      };
      MultiMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
        for (var index = 0; index < this.subMaterials.length; index++) {
          var subMaterial = this.subMaterials[index];
          if (subMaterial) {
            if (subMaterial._storeEffectOnSubMeshes) {
              if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
                return false;
              }
              continue;
            }
            if (!subMaterial.isReady(mesh)) {
              return false;
            }
          }
        }
        return true;
      };
      MultiMaterial2.prototype.clone = function(name105, cloneChildren) {
        var newMultiMaterial = new MultiMaterial2(name105, this.getScene());
        for (var index = 0; index < this.subMaterials.length; index++) {
          var subMaterial = null;
          var current = this.subMaterials[index];
          if (cloneChildren && current) {
            subMaterial = current.clone(name105 + "-" + current.name);
          } else {
            subMaterial = this.subMaterials[index];
          }
          newMultiMaterial.subMaterials.push(subMaterial);
        }
        return newMultiMaterial;
      };
      MultiMaterial2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        if (Tags) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.materialsUniqueIds = [];
        serializationObject.materials = [];
        for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
          var subMat = this.subMaterials[matIndex];
          if (subMat) {
            serializationObject.materialsUniqueIds.push(subMat.uniqueId);
            serializationObject.materials.push(subMat.id);
          } else {
            serializationObject.materialsUniqueIds.push(null);
            serializationObject.materials.push(null);
          }
        }
        return serializationObject;
      };
      MultiMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        if (forceDisposeChildren) {
          for (var index_1 = 0; index_1 < this.subMaterials.length; index_1++) {
            var subMaterial = this.subMaterials[index_1];
            if (subMaterial) {
              subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
            }
          }
        }
        var index = scene.multiMaterials.indexOf(this);
        if (index >= 0) {
          scene.multiMaterials.splice(index, 1);
        }
        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
      };
      MultiMaterial2.ParseMultiMaterial = function(parsedMultiMaterial, scene) {
        var multiMaterial = new MultiMaterial2(parsedMultiMaterial.name, scene);
        multiMaterial.id = parsedMultiMaterial.id;
        multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
        }
        if (parsedMultiMaterial.materialsUniqueIds) {
          multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
        } else {
          parsedMultiMaterial.materials.forEach(function(subMatId) {
            return multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId));
          });
        }
        return multiMaterial;
      };
      return MultiMaterial2;
    }(Material);
    RegisterClass("BABYLON.MultiMaterial", MultiMaterial);
  }
});

// node_modules/@babylonjs/core/Meshes/meshLODLevel.js
var MeshLODLevel;
var init_meshLODLevel = __esm({
  "node_modules/@babylonjs/core/Meshes/meshLODLevel.js"() {
    MeshLODLevel = function() {
      function MeshLODLevel2(distanceOrScreenCoverage, mesh) {
        this.distanceOrScreenCoverage = distanceOrScreenCoverage;
        this.mesh = mesh;
      }
      return MeshLODLevel2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/mesh.js
var _CreationDataStorage, _InstanceDataStorage, _InstancesBatch, _ThinInstanceDataStorage, _InternalMeshDataInfo, Mesh;
var init_mesh = __esm({
  "node_modules/@babylonjs/core/Meshes/mesh.js"() {
    init_tslib_es6();
    init_observable();
    init_tools();
    init_deepCopier();
    init_tags();
    init_coroutine();
    init_math_vector();
    init_math_color();
    init_node();
    init_buffer();
    init_mesh_vertexData();
    init_geometry();
    init_abstractMesh();
    init_subMesh();
    init_material();
    init_multiMaterial();
    init_sceneLoaderFlags();
    init_decorators();
    init_logger();
    init_typeStore();
    init_devTools();
    init_sceneComponent();
    init_meshLODLevel();
    _CreationDataStorage = function() {
      function _CreationDataStorage2() {
      }
      return _CreationDataStorage2;
    }();
    _InstanceDataStorage = function() {
      function _InstanceDataStorage2() {
        this.visibleInstances = {};
        this.batchCache = new _InstancesBatch();
        this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();
        this.instancesBufferSize = 32 * 16 * 4;
      }
      return _InstanceDataStorage2;
    }();
    _InstancesBatch = function() {
      function _InstancesBatch2() {
        this.mustReturn = false;
        this.visibleInstances = new Array();
        this.renderSelf = new Array();
        this.hardwareInstancedRendering = new Array();
      }
      return _InstancesBatch2;
    }();
    _ThinInstanceDataStorage = function() {
      function _ThinInstanceDataStorage2() {
        this.instancesCount = 0;
        this.matrixBuffer = null;
        this.previousMatrixBuffer = null;
        this.matrixBufferSize = 32 * 16;
        this.matrixData = null;
        this.boundingVectors = [];
        this.worldMatrices = null;
      }
      return _ThinInstanceDataStorage2;
    }();
    _InternalMeshDataInfo = function() {
      function _InternalMeshDataInfo2() {
        this._areNormalsFrozen = false;
        this._source = null;
        this.meshMap = null;
        this._preActivateId = -1;
        this._LODLevels = new Array();
        this._useLODScreenCoverage = false;
        this._effectiveMaterial = null;
        this._forcedInstanceCount = 0;
      }
      return _InternalMeshDataInfo2;
    }();
    Mesh = function(_super) {
      __extends(Mesh2, _super);
      function Mesh2(name105, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {
        if (scene === void 0) {
          scene = null;
        }
        if (parent === void 0) {
          parent = null;
        }
        if (source === void 0) {
          source = null;
        }
        if (clonePhysicsImpostor === void 0) {
          clonePhysicsImpostor = true;
        }
        var _this = _super.call(this, name105, scene) || this;
        _this._internalMeshDataInfo = new _InternalMeshDataInfo();
        _this.delayLoadState = 0;
        _this.instances = new Array();
        _this._creationDataStorage = null;
        _this._geometry = null;
        _this._instanceDataStorage = new _InstanceDataStorage();
        _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
        _this._shouldGenerateFlatShading = false;
        _this._originalBuilderSideOrientation = Mesh2.DEFAULTSIDE;
        _this.overrideMaterialSideOrientation = null;
        _this.ignoreCameraMaxZ = false;
        scene = _this.getScene();
        _this._onBeforeDraw = function(isInstance, world, effectiveMaterial) {
          if (isInstance && effectiveMaterial) {
            if (_this._uniformBuffer) {
              _this.transferToEffect(world);
            } else {
              effectiveMaterial.bindOnlyWorldMatrix(world);
            }
          }
        };
        if (source) {
          if (source._geometry) {
            source._geometry.applyToMesh(_this);
          }
          DeepCopier.DeepCopy(source, _this, [
            "name",
            "material",
            "skeleton",
            "instances",
            "parent",
            "uniqueId",
            "source",
            "metadata",
            "morphTargetManager",
            "hasInstances",
            "worldMatrixInstancedBuffer",
            "previousWorldMatrixInstancedBuffer",
            "hasLODLevels",
            "geometry",
            "isBlocked",
            "areNormalsFrozen",
            "facetNb",
            "isFacetDataEnabled",
            "lightSources",
            "useBones",
            "isAnInstance",
            "collider",
            "edgesRenderer",
            "forward",
            "up",
            "right",
            "absolutePosition",
            "absoluteScaling",
            "absoluteRotationQuaternion",
            "isWorldMatrixFrozen",
            "nonUniformScaling",
            "behaviors",
            "worldMatrixFromCache",
            "hasThinInstances",
            "cloneMeshMap",
            "hasBoundingInfo"
          ], ["_poseMatrix"]);
          _this._internalMeshDataInfo._source = source;
          if (scene.useClonedMeshMap) {
            if (!source._internalMeshDataInfo.meshMap) {
              source._internalMeshDataInfo.meshMap = {};
            }
            source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;
          }
          _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
          _this._creationDataStorage = source._creationDataStorage;
          if (source._ranges) {
            var ranges = source._ranges;
            for (var name_1 in ranges) {
              if (!Object.prototype.hasOwnProperty.call(ranges, name_1)) {
                continue;
              }
              if (!ranges[name_1]) {
                continue;
              }
              _this.createAnimationRange(name_1, ranges[name_1].from, ranges[name_1].to);
            }
          }
          if (source.metadata && source.metadata.clone) {
            _this.metadata = source.metadata.clone();
          } else {
            _this.metadata = source.metadata;
          }
          if (Tags && Tags.HasTags(source)) {
            Tags.AddTagsTo(_this, Tags.GetTags(source, true));
          }
          _this.setEnabled(source.isEnabled());
          _this.parent = source.parent;
          _this.setPivotMatrix(source.getPivotMatrix());
          _this.id = name105 + "." + source.id;
          _this.material = source.material;
          if (!doNotCloneChildren) {
            var directDescendants = source.getDescendants(true);
            for (var index = 0; index < directDescendants.length; index++) {
              var child = directDescendants[index];
              if (child.clone) {
                child.clone(name105 + "." + child.name, _this);
              }
            }
          }
          if (source.morphTargetManager) {
            _this.morphTargetManager = source.morphTargetManager;
          }
          if (scene.getPhysicsEngine) {
            var physicsEngine = scene.getPhysicsEngine();
            if (clonePhysicsImpostor && physicsEngine) {
              var impostor = physicsEngine.getImpostorForPhysicsObject(source);
              if (impostor) {
                _this.physicsImpostor = impostor.clone(_this);
              }
            }
          }
          for (var index = 0; index < scene.particleSystems.length; index++) {
            var system = scene.particleSystems[index];
            if (system.emitter === source) {
              system.clone(system.name, _this);
            }
          }
          _this.skeleton = source.skeleton;
          _this.refreshBoundingInfo(true, true);
          _this.computeWorldMatrix(true);
        }
        if (parent !== null) {
          _this.parent = parent;
        }
        _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;
        _this._internalMeshDataInfo._onMeshReadyObserverAdded = function(observer) {
          observer.unregisterOnNextCall = true;
          if (_this.isReady(true)) {
            _this.onMeshReadyObservable.notifyObservers(_this);
          } else {
            if (!_this._internalMeshDataInfo._checkReadinessObserver) {
              _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function() {
                if (_this.isReady(true)) {
                  _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);
                  _this._internalMeshDataInfo._checkReadinessObserver = null;
                  _this.onMeshReadyObservable.notifyObservers(_this);
                }
              });
            }
          }
        };
        _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);
        if (source) {
          source.onClonedObservable.notifyObservers(_this);
        }
        return _this;
      }
      Mesh2._GetDefaultSideOrientation = function(orientation) {
        return orientation || Mesh2.FRONTSIDE;
      };
      Object.defineProperty(Mesh2.prototype, "useLODScreenCoverage", {
        get: function() {
          return this._internalMeshDataInfo._useLODScreenCoverage;
        },
        set: function(value) {
          this._internalMeshDataInfo._useLODScreenCoverage = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "computeBonesUsingShaders", {
        get: function() {
          return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
        },
        set: function(value) {
          if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
            return;
          }
          if (value && this._internalMeshDataInfo._sourcePositions) {
            this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);
            if (this._internalMeshDataInfo._sourceNormals) {
              this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);
            }
            this._internalMeshDataInfo._sourcePositions = null;
            this._internalMeshDataInfo._sourceNormals = null;
          }
          this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
          this._markSubMeshesAsAttributesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onBeforeRenderObservable", {
        get: function() {
          if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
            this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
          }
          return this._internalMeshDataInfo._onBeforeRenderObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onBeforeBindObservable", {
        get: function() {
          if (!this._internalMeshDataInfo._onBeforeBindObservable) {
            this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
          }
          return this._internalMeshDataInfo._onBeforeBindObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onAfterRenderObservable", {
        get: function() {
          if (!this._internalMeshDataInfo._onAfterRenderObservable) {
            this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
          }
          return this._internalMeshDataInfo._onAfterRenderObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onBetweenPassObservable", {
        get: function() {
          if (!this._internalMeshDataInfo._onBetweenPassObservable) {
            this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
          }
          return this._internalMeshDataInfo._onBetweenPassObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onBeforeDrawObservable", {
        get: function() {
          if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
            this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
          }
          return this._internalMeshDataInfo._onBeforeDrawObservable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "onBeforeDraw", {
        set: function(callback) {
          if (this._onBeforeDrawObserver) {
            this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
          }
          this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "hasInstances", {
        get: function() {
          return this.instances.length > 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "hasThinInstances", {
        get: function() {
          var _a;
          return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "forcedInstanceCount", {
        get: function() {
          return this._internalMeshDataInfo._forcedInstanceCount;
        },
        set: function(count) {
          this._internalMeshDataInfo._forcedInstanceCount = count;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "source", {
        get: function() {
          return this._internalMeshDataInfo._source;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "cloneMeshMap", {
        get: function() {
          return this._internalMeshDataInfo.meshMap;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "isUnIndexed", {
        get: function() {
          return this._unIndexed;
        },
        set: function(value) {
          if (this._unIndexed !== value) {
            this._unIndexed = value;
            this._markSubMeshesAsAttributesDirty();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "worldMatrixInstancedBuffer", {
        get: function() {
          return this._instanceDataStorage.instancesData;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "previousWorldMatrixInstancedBuffer", {
        get: function() {
          return this._instanceDataStorage.instancesPreviousData;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "manualUpdateOfWorldMatrixInstancedBuffer", {
        get: function() {
          return this._instanceDataStorage.manualUpdate;
        },
        set: function(value) {
          this._instanceDataStorage.manualUpdate = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "manualUpdateOfPreviousWorldMatrixInstancedBuffer", {
        get: function() {
          return this._instanceDataStorage.previousManualUpdate;
        },
        set: function(value) {
          this._instanceDataStorage.previousManualUpdate = value;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
        if (newParent === void 0) {
          newParent = null;
        }
        var instance = this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate) ? this.createInstance("instance of " + (this.name || this.id)) : this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
        instance.parent = newParent || this.parent;
        instance.position = this.position.clone();
        instance.scaling = this.scaling.clone();
        if (this.rotationQuaternion) {
          instance.rotationQuaternion = this.rotationQuaternion.clone();
        } else {
          instance.rotation = this.rotation.clone();
        }
        if (onNewNodeCreated) {
          onNewNodeCreated(this, instance);
        }
        for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
          var child = _a[_i];
          child.instantiateHierarchy(instance, options, onNewNodeCreated);
        }
        return instance;
      };
      Mesh2.prototype.getClassName = function() {
        return "Mesh";
      };
      Object.defineProperty(Mesh2.prototype, "_isMesh", {
        get: function() {
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.toString = function(fullDetails) {
        var ret = _super.prototype.toString.call(this, fullDetails);
        ret += ", n vertices: " + this.getTotalVertices();
        ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
        if (this.animations) {
          for (var i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        if (fullDetails) {
          if (this._geometry) {
            var ib = this.getIndices();
            var vb = this.getVerticesData(VertexBuffer.PositionKind);
            if (vb && ib) {
              ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
            }
          } else {
            ret += ", flat shading: UNKNOWN";
          }
        }
        return ret;
      };
      Mesh2.prototype._unBindEffect = function() {
        _super.prototype._unBindEffect.call(this);
        for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {
          var instance = _a[_i];
          instance._unBindEffect();
        }
      };
      Object.defineProperty(Mesh2.prototype, "hasLODLevels", {
        get: function() {
          return this._internalMeshDataInfo._LODLevels.length > 0;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.getLODLevels = function() {
        return this._internalMeshDataInfo._LODLevels;
      };
      Mesh2.prototype._sortLODLevels = function() {
        var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
        this._internalMeshDataInfo._LODLevels.sort(function(a, b) {
          if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
            return sortingOrderFactor;
          }
          if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
            return -sortingOrderFactor;
          }
          return 0;
        });
      };
      Mesh2.prototype.addLODLevel = function(distanceOrScreenCoverage, mesh) {
        if (mesh && mesh._masterMesh) {
          Logger.Warn("You cannot use a mesh as LOD level twice");
          return this;
        }
        var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
        this._internalMeshDataInfo._LODLevels.push(level);
        if (mesh) {
          mesh._masterMesh = this;
        }
        this._sortLODLevels();
        return this;
      };
      Mesh2.prototype.getLODLevelAtDistance = function(distance) {
        var internalDataInfo = this._internalMeshDataInfo;
        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
          var level = internalDataInfo._LODLevels[index];
          if (level.distanceOrScreenCoverage === distance) {
            return level.mesh;
          }
        }
        return null;
      };
      Mesh2.prototype.removeLODLevel = function(mesh) {
        var internalDataInfo = this._internalMeshDataInfo;
        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
          if (internalDataInfo._LODLevels[index].mesh === mesh) {
            internalDataInfo._LODLevels.splice(index, 1);
            if (mesh) {
              mesh._masterMesh = null;
            }
          }
        }
        this._sortLODLevels();
        return this;
      };
      Mesh2.prototype.getLOD = function(camera, boundingSphere) {
        var internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
          return this;
        }
        var bSphere;
        if (boundingSphere) {
          bSphere = boundingSphere;
        } else {
          var boundingInfo = this.getBoundingInfo();
          bSphere = boundingInfo.boundingSphere;
        }
        var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();
        var useScreenCoverage = internalDataInfo._useLODScreenCoverage;
        var compareValue = distanceToCamera;
        var compareSign = 1;
        if (useScreenCoverage) {
          var screenArea = camera.screenArea;
          var meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
          meshArea = meshArea * meshArea * Math.PI;
          compareValue = meshArea / screenArea;
          compareSign = -1;
        }
        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
          if (this.onLODLevelSelection) {
            this.onLODLevelSelection(compareValue, this, this);
          }
          return this;
        }
        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
          var level = internalDataInfo._LODLevels[index];
          if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
            if (level.mesh) {
              if (level.mesh.delayLoadState === 4) {
                level.mesh._checkDelayState();
                return this;
              }
              if (level.mesh.delayLoadState === 2) {
                return this;
              }
              level.mesh._preActivate();
              level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
            }
            if (this.onLODLevelSelection) {
              this.onLODLevelSelection(compareValue, this, level.mesh);
            }
            return level.mesh;
          }
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, this);
        }
        return this;
      };
      Object.defineProperty(Mesh2.prototype, "geometry", {
        get: function() {
          return this._geometry;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.getTotalVertices = function() {
        if (this._geometry === null || this._geometry === void 0) {
          return 0;
        }
        return this._geometry.getTotalVertices();
      };
      Mesh2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
        var _a, _b;
        if (!this._geometry) {
          return null;
        }
        var data = (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this._geometry.getTotalVertices(), forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);
        if (!data) {
          data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
        }
        return data;
      };
      Mesh2.prototype.getVertexBuffer = function(kind) {
        var _a, _b;
        if (!this._geometry) {
          return null;
        }
        return (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);
      };
      Mesh2.prototype.isVerticesDataPresent = function(kind) {
        var _a;
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== void 0 || this._geometry.isVerticesDataPresent(kind);
      };
      Mesh2.prototype.isVertexBufferUpdatable = function(kind) {
        var _a, _b;
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return ((_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);
      };
      Mesh2.prototype.getVerticesDataKinds = function() {
        if (!this._geometry) {
          var result_1 = new Array();
          if (this._delayInfo) {
            this._delayInfo.forEach(function(kind2) {
              result_1.push(kind2);
            });
          }
          return result_1;
        }
        var kinds = this._geometry.getVerticesDataKinds();
        if (this._userInstancedBuffersStorage) {
          for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
            kinds.push(kind);
          }
        }
        return kinds;
      };
      Mesh2.prototype.getTotalIndices = function() {
        if (!this._geometry) {
          return 0;
        }
        return this._geometry.getTotalIndices();
      };
      Mesh2.prototype.getIndices = function(copyWhenShared, forceCopy) {
        if (!this._geometry) {
          return [];
        }
        return this._geometry.getIndices(copyWhenShared, forceCopy);
      };
      Object.defineProperty(Mesh2.prototype, "isBlocked", {
        get: function() {
          return this._masterMesh !== null && this._masterMesh !== void 0;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.isReady = function(completeCheck, forceInstanceSupport) {
        var _a, _b, _c, _d, _e, _f;
        if (completeCheck === void 0) {
          completeCheck = false;
        }
        if (forceInstanceSupport === void 0) {
          forceInstanceSupport = false;
        }
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!_super.prototype.isReady.call(this, completeCheck)) {
          return false;
        }
        if (!this.subMeshes || this.subMeshes.length === 0) {
          return true;
        }
        if (!completeCheck) {
          return true;
        }
        var engine = this.getEngine();
        var scene = this.getScene();
        var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
        this.computeWorldMatrix();
        var mat = this.material || scene.defaultMaterial;
        if (mat) {
          if (mat._storeEffectOnSubMeshes) {
            for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {
              var subMesh = _g[_i];
              var effectiveMaterial = subMesh.getMaterial();
              if (effectiveMaterial) {
                if (effectiveMaterial._storeEffectOnSubMeshes) {
                  if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                    return false;
                  }
                } else {
                  if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                    return false;
                  }
                }
              }
            }
          } else {
            if (!mat.isReady(this, hardwareInstancedRendering)) {
              return false;
            }
          }
        }
        var currentRenderPassId = engine.currentRenderPassId;
        for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {
          var light = _j[_h];
          var generator = light.getShadowGenerator();
          if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
            if (generator.getShadowMap()) {
              engine.currentRenderPassId = generator.getShadowMap().renderPassId;
            }
            for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {
              var subMesh = _l[_k];
              if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {
                engine.currentRenderPassId = currentRenderPassId;
                return false;
              }
            }
            engine.currentRenderPassId = currentRenderPassId;
          }
        }
        for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {
          var lod = _o[_m];
          if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
            return false;
          }
        }
        return true;
      };
      Object.defineProperty(Mesh2.prototype, "areNormalsFrozen", {
        get: function() {
          return this._internalMeshDataInfo._areNormalsFrozen;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype.freezeNormals = function() {
        this._internalMeshDataInfo._areNormalsFrozen = true;
        return this;
      };
      Mesh2.prototype.unfreezeNormals = function() {
        this._internalMeshDataInfo._areNormalsFrozen = false;
        return this;
      };
      Object.defineProperty(Mesh2.prototype, "overridenInstanceCount", {
        set: function(count) {
          this._instanceDataStorage.overridenInstanceCount = count;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._preActivate = function() {
        var internalDataInfo = this._internalMeshDataInfo;
        var sceneRenderId = this.getScene().getRenderId();
        if (internalDataInfo._preActivateId === sceneRenderId) {
          return this;
        }
        internalDataInfo._preActivateId = sceneRenderId;
        this._instanceDataStorage.visibleInstances = null;
        return this;
      };
      Mesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
        if (this._instanceDataStorage.visibleInstances) {
          this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
        }
        return this;
      };
      Mesh2.prototype._registerInstanceForRenderId = function(instance, renderId) {
        if (!this._instanceDataStorage.visibleInstances) {
          this._instanceDataStorage.visibleInstances = {
            defaultRenderId: renderId,
            selfDefaultRenderId: this._renderId
          };
        }
        if (!this._instanceDataStorage.visibleInstances[renderId]) {
          if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
            this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
          }
          this._instanceDataStorage.previousRenderId = renderId;
          this._instanceDataStorage.visibleInstances[renderId] = new Array();
        }
        this._instanceDataStorage.visibleInstances[renderId].push(instance);
        return this;
      };
      Mesh2.prototype._afterComputeWorldMatrix = function() {
        _super.prototype._afterComputeWorldMatrix.call(this);
        if (!this.hasThinInstances) {
          return;
        }
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      };
      Mesh2.prototype._postActivate = function() {
        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
          this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
          this.edgesRenderer.customInstances.push(this.getWorldMatrix());
        }
      };
      Mesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
        if (applySkeleton === void 0) {
          applySkeleton = false;
        }
        if (applyMorph === void 0) {
          applyMorph = false;
        }
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
          return this;
        }
        var bias = this.geometry ? this.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);
        return this;
      };
      Mesh2.prototype._createGlobalSubMesh = function(force) {
        var totalVertices = this.getTotalVertices();
        if (!totalVertices || !this.getIndices()) {
          return null;
        }
        if (this.subMeshes && this.subMeshes.length > 0) {
          var ib = this.getIndices();
          if (!ib) {
            return null;
          }
          var totalIndices = ib.length;
          var needToRecreate = false;
          if (force) {
            needToRecreate = true;
          } else {
            for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
              var submesh = _a[_i];
              if (submesh.indexStart + submesh.indexCount > totalIndices) {
                needToRecreate = true;
                break;
              }
              if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
                needToRecreate = true;
                break;
              }
            }
          }
          if (!needToRecreate) {
            return this.subMeshes[0];
          }
        }
        this.releaseSubMeshes();
        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
      };
      Mesh2.prototype.subdivide = function(count) {
        if (count < 1) {
          return;
        }
        var totalIndices = this.getTotalIndices();
        var subdivisionSize = totalIndices / count | 0;
        var offset = 0;
        while (subdivisionSize % 3 !== 0) {
          subdivisionSize++;
        }
        this.releaseSubMeshes();
        for (var index = 0; index < count; index++) {
          if (offset >= totalIndices) {
            break;
          }
          SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);
          offset += subdivisionSize;
        }
        this.synchronizeInstances();
      };
      Mesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
        if (updatable === void 0) {
          updatable = false;
        }
        if (!this._geometry) {
          var vertexData = new VertexData();
          vertexData.set(data, kind);
          var scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
        } else {
          this._geometry.setVerticesData(kind, data, updatable, stride);
        }
        return this;
      };
      Mesh2.prototype.removeVerticesData = function(kind) {
        if (!this._geometry) {
          return;
        }
        this._geometry.removeVerticesData(kind);
      };
      Mesh2.prototype.markVerticesDataAsUpdatable = function(kind, updatable) {
        if (updatable === void 0) {
          updatable = true;
        }
        var vb = this.getVertexBuffer(kind);
        if (!vb || vb.isUpdatable() === updatable) {
          return;
        }
        this.setVerticesData(kind, this.getVerticesData(kind), updatable);
      };
      Mesh2.prototype.setVerticesBuffer = function(buffer, disposeExistingBuffer) {
        if (disposeExistingBuffer === void 0) {
          disposeExistingBuffer = true;
        }
        if (!this._geometry) {
          this._geometry = Geometry.CreateGeometryForMesh(this);
        }
        this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);
        return this;
      };
      Mesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
        if (!this._geometry) {
          return this;
        }
        if (!makeItUnique) {
          this._geometry.updateVerticesData(kind, data, updateExtends);
        } else {
          this.makeGeometryUnique();
          this.updateVerticesData(kind, data, updateExtends, false);
        }
        return this;
      };
      Mesh2.prototype.updateMeshPositions = function(positionFunction, computeNormals) {
        if (computeNormals === void 0) {
          computeNormals = true;
        }
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
          return this;
        }
        positionFunction(positions);
        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
        if (computeNormals) {
          var indices = this.getIndices();
          var normals = this.getVerticesData(VertexBuffer.NormalKind);
          if (!normals) {
            return this;
          }
          VertexData.ComputeNormals(positions, indices, normals);
          this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
        }
        return this;
      };
      Mesh2.prototype.makeGeometryUnique = function() {
        if (!this._geometry) {
          return this;
        }
        if (this._geometry.meshes.length === 1) {
          return this;
        }
        var oldGeometry = this._geometry;
        var geometry = this._geometry.copy(Geometry.RandomId());
        oldGeometry.releaseForMesh(this, true);
        geometry.applyToMesh(this);
        return this;
      };
      Mesh2.prototype.setIndices = function(indices, totalVertices, updatable) {
        if (totalVertices === void 0) {
          totalVertices = null;
        }
        if (updatable === void 0) {
          updatable = false;
        }
        if (!this._geometry) {
          var vertexData = new VertexData();
          vertexData.indices = indices;
          var scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
        } else {
          this._geometry.setIndices(indices, totalVertices, updatable);
        }
        return this;
      };
      Mesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
        if (gpuMemoryOnly === void 0) {
          gpuMemoryOnly = false;
        }
        if (!this._geometry) {
          return this;
        }
        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
        return this;
      };
      Mesh2.prototype.toLeftHanded = function() {
        if (!this._geometry) {
          return this;
        }
        this._geometry.toLeftHanded();
        return this;
      };
      Mesh2.prototype._bind = function(subMesh, effect, fillMode) {
        if (!this._geometry) {
          return this;
        }
        var engine = this.getScene().getEngine();
        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
          this.morphTargetManager._bind(effect);
        }
        var indexToBind;
        if (this._unIndexed) {
          indexToBind = null;
        } else {
          switch (fillMode) {
            case Material.PointFillMode:
              indexToBind = null;
              break;
            case Material.WireFrameFillMode:
              indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
              break;
            default:
            case Material.TriangleFillMode:
              indexToBind = this._geometry.getIndexBuffer();
              break;
          }
        }
        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
          this._geometry._bind(effect, indexToBind);
        } else {
          this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
        }
        return this;
      };
      Mesh2.prototype._draw = function(subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        if (this._internalMeshDataInfo._onBeforeDrawObservable) {
          this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
        }
        var scene = this.getScene();
        var engine = scene.getEngine();
        if (this._unIndexed || fillMode == Material.PointFillMode) {
          engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
        } else if (fillMode == Material.WireFrameFillMode) {
          engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
        } else {
          engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
        }
        return this;
      };
      Mesh2.prototype.registerBeforeRender = function(func) {
        this.onBeforeRenderObservable.add(func);
        return this;
      };
      Mesh2.prototype.unregisterBeforeRender = function(func) {
        this.onBeforeRenderObservable.removeCallback(func);
        return this;
      };
      Mesh2.prototype.registerAfterRender = function(func) {
        this.onAfterRenderObservable.add(func);
        return this;
      };
      Mesh2.prototype.unregisterAfterRender = function(func) {
        this.onAfterRenderObservable.removeCallback(func);
        return this;
      };
      Mesh2.prototype._getInstancesRenderList = function(subMeshId, isReplacementMode) {
        if (isReplacementMode === void 0) {
          isReplacementMode = false;
        }
        if (this._instanceDataStorage.isFrozen) {
          if (isReplacementMode) {
            this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
            this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
            return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
          }
          if (this._instanceDataStorage.previousBatch) {
            return this._instanceDataStorage.previousBatch;
          }
        }
        var scene = this.getScene();
        var isInIntermediateRendering = scene._isInIntermediateRendering();
        var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
        var batchCache = this._instanceDataStorage.batchCache;
        batchCache.mustReturn = false;
        batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
        batchCache.visibleInstances[subMeshId] = null;
        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
          var visibleInstances = this._instanceDataStorage.visibleInstances;
          var currentRenderId = scene.getRenderId();
          var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
          batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
          if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
            batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
          }
        }
        batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
        this._instanceDataStorage.previousBatch = batchCache;
        return batchCache;
      };
      Mesh2.prototype._renderWithInstances = function(subMesh, fillMode, batch, effect, engine) {
        var _a;
        var visibleInstances = batch.visibleInstances[subMesh._id];
        if (!visibleInstances) {
          return this;
        }
        var instanceStorage = this._instanceDataStorage;
        var currentInstancesBufferSize = instanceStorage.instancesBufferSize;
        var instancesBuffer = instanceStorage.instancesBuffer;
        var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
        var matricesCount = visibleInstances.length + 1;
        var bufferSize = matricesCount * 16 * 4;
        while (instanceStorage.instancesBufferSize < bufferSize) {
          instanceStorage.instancesBufferSize *= 2;
        }
        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        var offset = 0;
        var instancesCount = 0;
        var renderSelf = batch.renderSelf[subMesh._id];
        var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
          var world = this.getWorldMatrix();
          if (renderSelf) {
            if (this._scene.needsPreviousWorldMatrices) {
              if (!instanceStorage.masterMeshPreviousWorldMatrix) {
                instanceStorage.masterMeshPreviousWorldMatrix = world.clone();
                instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              } else {
                instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
              }
            }
            world.copyToArray(instanceStorage.instancesData, offset);
            offset += 16;
            instancesCount++;
          }
          if (visibleInstances) {
            if (Mesh2.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {
              var cameraPosition = this._scene.activeCamera.globalPosition;
              for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
                var instanceMesh = visibleInstances[instanceIndex];
                instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
              }
              visibleInstances.sort(function(m1, m2) {
                return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
              });
            }
            for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
              var instance = visibleInstances[instanceIndex];
              var matrix = instance.getWorldMatrix();
              matrix.copyToArray(instanceStorage.instancesData, offset);
              if (this._scene.needsPreviousWorldMatrices) {
                if (!instance._previousWorldMatrix) {
                  instance._previousWorldMatrix = matrix.clone();
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                } else {
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                  instance._previousWorldMatrix.copyFrom(matrix);
                }
              }
              offset += 16;
              instancesCount++;
            }
          }
        } else {
          instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;
        }
        if (needUpdateBuffer) {
          if (instancesBuffer) {
            instancesBuffer.dispose();
          }
          if (instancesPreviousBuffer) {
            instancesPreviousBuffer.dispose();
          }
          instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);
          instanceStorage.instancesBuffer = instancesBuffer;
          if (!this._userInstancedBuffersStorage) {
            this._userInstancedBuffersStorage = {
              data: {},
              vertexBuffers: {},
              strides: {},
              sizes: {},
              vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
            };
          }
          this._userInstancedBuffersStorage.vertexBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
          if (this._scene.needsPreviousWorldMatrices) {
            instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
            instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
          }
          this._invalidateInstanceVertexArrayObject();
        } else {
          if (!this._instanceDataStorage.isFrozen) {
            instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
            if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
              instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
            }
          }
        }
        this._processInstancedBuffers(visibleInstances, renderSelf);
        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
        if (engine._currentDrawContext) {
          engine._currentDrawContext.useInstancing = true;
        }
        this._bind(subMesh, effect, fillMode);
        this._draw(subMesh, fillMode, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        }
        engine.unbindInstanceAttributes();
        return this;
      };
      Mesh2.prototype._renderWithThinInstances = function(subMesh, fillMode, effect, engine) {
        var _a, _b;
        var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;
        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
        if (engine._currentDrawContext) {
          engine._currentDrawContext.useInstancing = true;
        }
        this._bind(subMesh, effect, fillMode);
        this._draw(subMesh, fillMode, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
          if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
          } else {
            this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
          }
        }
        engine.unbindInstanceAttributes();
      };
      Mesh2.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
      };
      Mesh2.prototype._processRendering = function(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
        var scene = this.getScene();
        var engine = scene.getEngine();
        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
          this._renderWithThinInstances(subMesh, fillMode, effect, engine);
          return this;
        }
        if (hardwareInstancedRendering) {
          this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
        } else {
          if (engine._currentDrawContext) {
            engine._currentDrawContext.useInstancing = false;
          }
          var instanceCount = 0;
          if (batch.renderSelf[subMesh._id]) {
            if (onBeforeDraw) {
              onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
            }
            instanceCount++;
            this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
          }
          var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
          if (visibleInstancesForSubMesh) {
            var visibleInstanceCount = visibleInstancesForSubMesh.length;
            instanceCount += visibleInstanceCount;
            for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
              var instance = visibleInstancesForSubMesh[instanceIndex];
              var world = instance.getWorldMatrix();
              if (onBeforeDraw) {
                onBeforeDraw(true, world, effectiveMaterial);
              }
              this._draw(subMesh, fillMode);
            }
          }
          scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
        }
        return this;
      };
      Mesh2.prototype._rebuild = function(dispose) {
        if (dispose === void 0) {
          dispose = false;
        }
        if (this._instanceDataStorage.instancesBuffer) {
          if (dispose) {
            this._instanceDataStorage.instancesBuffer.dispose();
          }
          this._instanceDataStorage.instancesBuffer = null;
        }
        if (this._userInstancedBuffersStorage) {
          for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
            var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
            if (buffer) {
              if (dispose) {
                buffer.dispose();
              }
              this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
            }
          }
          if (this._userInstancedBuffersStorage.vertexArrayObjects) {
            this._userInstancedBuffersStorage.vertexArrayObjects = {};
          }
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        _super.prototype._rebuild.call(this, dispose);
      };
      Mesh2.prototype._freeze = function() {
        if (!this.subMeshes) {
          return;
        }
        for (var index = 0; index < this.subMeshes.length; index++) {
          this._getInstancesRenderList(index);
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        this._instanceDataStorage.isFrozen = true;
      };
      Mesh2.prototype._unFreeze = function() {
        this._instanceDataStorage.isFrozen = false;
        this._instanceDataStorage.previousBatch = null;
      };
      Mesh2.prototype.render = function(subMesh, enableAlphaMode, effectiveMeshReplacement) {
        var _a, _b, _c;
        var scene = this.getScene();
        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        } else {
          this._internalAbstractMeshDataInfo._isActive = false;
        }
        if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
          return this;
        }
        var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
        if (batch.mustReturn) {
          return this;
        }
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        var engine = scene.getEngine();
        var oldCameraMaxZ = 0;
        var oldCamera = null;
        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
          oldCameraMaxZ = scene.activeCamera.maxZ;
          oldCamera = scene.activeCamera;
          scene.activeCamera.maxZ = 0;
          scene.updateTransformMatrix(true);
        }
        if (this._internalMeshDataInfo._onBeforeRenderObservable) {
          this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
        }
        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;
        var instanceDataStorage = this._instanceDataStorage;
        var material = subMesh.getMaterial();
        if (!material) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
          if (material._storeEffectOnSubMeshes) {
            if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
              if (oldCamera) {
                oldCamera.maxZ = oldCameraMaxZ;
                scene.updateTransformMatrix(true);
              }
              return this;
            }
          } else if (!material.isReady(this, hardwareInstancedRendering)) {
            if (oldCamera) {
              oldCamera.maxZ = oldCameraMaxZ;
              scene.updateTransformMatrix(true);
            }
            return this;
          }
          this._internalMeshDataInfo._effectiveMaterial = material;
        } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (enableAlphaMode) {
          engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
        }
        var drawWrapper;
        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
          drawWrapper = subMesh._drawWrapper;
        } else {
          drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
        }
        var effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;
        for (var _i = 0, _d = scene._beforeRenderingMeshStage; _i < _d.length; _i++) {
          var step = _d[_i];
          step.action(this, subMesh, batch, effect);
        }
        if (!drawWrapper || !effect) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        var effectiveMesh = effectiveMeshReplacement || this;
        var sideOrientation;
        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
          var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
          sideOrientation = this.overrideMaterialSideOrientation;
          if (sideOrientation == null) {
            sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;
          }
          if (mainDeterminant < 0) {
            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
          }
          instanceDataStorage.sideOrientation = sideOrientation;
        } else {
          sideOrientation = instanceDataStorage.sideOrientation;
        }
        var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);
        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
          engine.setDepthWrite(true);
        }
        var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
        if (this._internalMeshDataInfo._onBeforeBindObservable) {
          this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
        }
        if (!hardwareInstancedRendering) {
          this._bind(subMesh, effect, fillMode);
        }
        var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
        var world = effectiveMesh.getWorldMatrix();
        if (effectiveMaterial._storeEffectOnSubMeshes) {
          effectiveMaterial.bindForSubMesh(world, this, subMesh);
        } else {
          effectiveMaterial.bind(world, this);
        }
        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
          engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
          engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          if (this._internalMeshDataInfo._onBetweenPassObservable) {
            this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
          }
        }
        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
        this._internalMeshDataInfo._effectiveMaterial.unbind();
        for (var _e = 0, _f = scene._afterRenderingMeshStage; _e < _f.length; _e++) {
          var step = _f[_e];
          step.action(this, subMesh, batch, effect);
        }
        if (this._internalMeshDataInfo._onAfterRenderObservable) {
          this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
        }
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        return this;
      };
      Mesh2.prototype.cleanMatrixWeights = function() {
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
            this._normalizeSkinWeightsAndExtra();
          } else {
            this._normalizeSkinFourWeights();
          }
        }
      };
      Mesh2.prototype._normalizeSkinFourWeights = function() {
        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        var numWeights = matricesWeights.length;
        for (var a = 0; a < numWeights; a += 4) {
          var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            var recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
      };
      Mesh2.prototype._normalizeSkinWeightsAndExtra = function() {
        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        var numWeights = matricesWeights.length;
        for (var a = 0; a < numWeights; a += 4) {
          var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            var recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
            matricesWeightsExtra[a] *= recip;
            matricesWeightsExtra[a + 1] *= recip;
            matricesWeightsExtra[a + 2] *= recip;
            matricesWeightsExtra[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
      };
      Mesh2.prototype.validateSkinning = function() {
        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (matricesWeights === null || this.skeleton == null) {
          return { skinned: false, valid: true, report: "not skinned" };
        }
        var numWeights = matricesWeights.length;
        var numberNotSorted = 0;
        var missingWeights = 0;
        var maxUsedWeights = 0;
        var numberNotNormalized = 0;
        var numInfluences = matricesWeightsExtra === null ? 4 : 8;
        var usedWeightCounts = new Array();
        for (var a = 0; a <= numInfluences; a++) {
          usedWeightCounts[a] = 0;
        }
        var toleranceEpsilon = 1e-3;
        for (var a = 0; a < numWeights; a += 4) {
          var lastWeight = matricesWeights[a];
          var t = lastWeight;
          var usedWeights = t === 0 ? 0 : 1;
          for (var b = 1; b < numInfluences; b++) {
            var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
            if (d > lastWeight) {
              numberNotSorted++;
            }
            if (d !== 0) {
              usedWeights++;
            }
            t += d;
            lastWeight = d;
          }
          usedWeightCounts[usedWeights]++;
          if (usedWeights > maxUsedWeights) {
            maxUsedWeights = usedWeights;
          }
          if (t === 0) {
            missingWeights++;
          } else {
            var recip = 1 / t;
            var tolerance = 0;
            for (var b = 0; b < numInfluences; b++) {
              if (b < 4) {
                tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
              } else {
                tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
              }
            }
            if (tolerance > toleranceEpsilon) {
              numberNotNormalized++;
            }
          }
        }
        var numBones = this.skeleton.bones.length;
        var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        var numBadBoneIndices = 0;
        for (var a = 0; a < numWeights; a += 4) {
          for (var b = 0; b < numInfluences; b++) {
            var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
            if (index >= numBones || index < 0) {
              numBadBoneIndices++;
            }
          }
        }
        var output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
      };
      Mesh2.prototype._checkDelayState = function() {
        var scene = this.getScene();
        if (this._geometry) {
          this._geometry.load(scene);
        } else if (this.delayLoadState === 4) {
          this.delayLoadState = 2;
          this._queueLoad(scene);
        }
        return this;
      };
      Mesh2.prototype._queueLoad = function(scene) {
        var _this = this;
        scene._addPendingData(this);
        var getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
        Tools.LoadFile(this.delayLoadingFile, function(data) {
          if (data instanceof ArrayBuffer) {
            _this._delayLoadingFunction(data, _this);
          } else {
            _this._delayLoadingFunction(JSON.parse(data), _this);
          }
          _this.instances.forEach(function(instance) {
            instance.refreshBoundingInfo();
            instance._syncSubMeshes();
          });
          _this.delayLoadState = 1;
          scene._removePendingData(_this);
        }, function() {
        }, scene.offlineProvider, getBinaryData);
        return this;
      };
      Mesh2.prototype.isInFrustum = function(frustumPlanes) {
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {
          return false;
        }
        this._checkDelayState();
        return true;
      };
      Mesh2.prototype.setMaterialById = function(id) {
        var materials = this.getScene().materials;
        var index;
        for (index = materials.length - 1; index > -1; index--) {
          if (materials[index].id === id) {
            this.material = materials[index];
            return this;
          }
        }
        var multiMaterials = this.getScene().multiMaterials;
        for (index = multiMaterials.length - 1; index > -1; index--) {
          if (multiMaterials[index].id === id) {
            this.material = multiMaterials[index];
            return this;
          }
        }
        return this;
      };
      Mesh2.prototype.getAnimatables = function() {
        var results = new Array();
        if (this.material) {
          results.push(this.material);
        }
        if (this.skeleton) {
          results.push(this.skeleton);
        }
        return results;
      };
      Mesh2.prototype.bakeTransformIntoVertices = function(transform) {
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        var submeshes = this.subMeshes.splice(0);
        this._resetPointsArrayCache();
        var data = this.getVerticesData(VertexBuffer.PositionKind);
        var temp = new Array();
        var index;
        for (index = 0; index < data.length; index += 3) {
          Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);
        }
        this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          data = this.getVerticesData(VertexBuffer.NormalKind);
          temp = [];
          for (index = 0; index < data.length; index += 3) {
            Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);
          }
          this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
        }
        if (transform.determinant() < 0) {
          this.flipFaces();
        }
        this.releaseSubMeshes();
        this.subMeshes = submeshes;
        return this;
      };
      Mesh2.prototype.bakeCurrentTransformIntoVertices = function(bakeIndependenlyOfChildren) {
        if (bakeIndependenlyOfChildren === void 0) {
          bakeIndependenlyOfChildren = true;
        }
        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
        this.resetLocalMatrix(bakeIndependenlyOfChildren);
        return this;
      };
      Object.defineProperty(Mesh2.prototype, "_positions", {
        get: function() {
          if (this._internalAbstractMeshDataInfo._positions) {
            return this._internalAbstractMeshDataInfo._positions;
          }
          if (this._geometry) {
            return this._geometry._positions;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._resetPointsArrayCache = function() {
        if (this._geometry) {
          this._geometry._resetPointsArrayCache();
        }
        return this;
      };
      Mesh2.prototype._generatePointsArray = function() {
        if (this._geometry) {
          return this._geometry._generatePointsArray();
        }
        return false;
      };
      Mesh2.prototype.clone = function(name105, newParent, doNotCloneChildren, clonePhysicsImpostor) {
        if (name105 === void 0) {
          name105 = "";
        }
        if (newParent === void 0) {
          newParent = null;
        }
        if (clonePhysicsImpostor === void 0) {
          clonePhysicsImpostor = true;
        }
        return new Mesh2(name105, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
      };
      Mesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
        if (disposeMaterialAndTextures === void 0) {
          disposeMaterialAndTextures = false;
        }
        this.morphTargetManager = null;
        if (this._geometry) {
          this._geometry.releaseForMesh(this, true);
        }
        var internalDataInfo = this._internalMeshDataInfo;
        if (internalDataInfo._onBeforeDrawObservable) {
          internalDataInfo._onBeforeDrawObservable.clear();
        }
        if (internalDataInfo._onBeforeBindObservable) {
          internalDataInfo._onBeforeBindObservable.clear();
        }
        if (internalDataInfo._onBeforeRenderObservable) {
          internalDataInfo._onBeforeRenderObservable.clear();
        }
        if (internalDataInfo._onAfterRenderObservable) {
          internalDataInfo._onAfterRenderObservable.clear();
        }
        if (internalDataInfo._onBetweenPassObservable) {
          internalDataInfo._onBetweenPassObservable.clear();
        }
        if (this._scene.useClonedMeshMap) {
          if (internalDataInfo.meshMap) {
            for (var uniqueId in internalDataInfo.meshMap) {
              var mesh = internalDataInfo.meshMap[uniqueId];
              if (mesh) {
                mesh._internalMeshDataInfo._source = null;
                internalDataInfo.meshMap[uniqueId] = void 0;
              }
            }
          }
          if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
            internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
          }
        } else {
          var meshes = this.getScene().meshes;
          for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
            var abstractMesh = meshes_1[_i];
            var mesh = abstractMesh;
            if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
              mesh._internalMeshDataInfo._source = null;
            }
          }
        }
        internalDataInfo._source = null;
        this._disposeInstanceSpecificData();
        this._disposeThinInstanceSpecificData();
        if (this._internalMeshDataInfo._checkReadinessObserver) {
          this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
        }
        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
      };
      Mesh2.prototype._disposeInstanceSpecificData = function() {
      };
      Mesh2.prototype._disposeThinInstanceSpecificData = function() {
      };
      Mesh2.prototype._invalidateInstanceVertexArrayObject = function() {
      };
      Mesh2.prototype.applyDisplacementMap = function(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {
        var _this = this;
        if (forceUpdate === void 0) {
          forceUpdate = false;
        }
        var scene = this.getScene();
        var onload = function(img) {
          var heightMapWidth = img.width;
          var heightMapHeight = img.height;
          var canvas = _this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
          var context = canvas.getContext("2d");
          context.drawImage(img, 0, 0);
          var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
          _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
          if (onSuccess) {
            onSuccess(_this);
          }
        };
        Tools.LoadImage(url, onload, function() {
        }, scene.offlineProvider);
        return this;
      };
      Mesh2.prototype.applyDisplacementMapFromBuffer = function(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {
        if (forceUpdate === void 0) {
          forceUpdate = false;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
          return this;
        }
        var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
        var normals = this.getVerticesData(VertexBuffer.NormalKind);
        var uvs = this.getVerticesData(VertexBuffer.UVKind);
        var position = Vector3.Zero();
        var normal = Vector3.Zero();
        var uv = Vector2.Zero();
        uvOffset = uvOffset || Vector2.Zero();
        uvScale = uvScale || new Vector2(1, 1);
        for (var index = 0; index < positions.length; index += 3) {
          Vector3.FromArrayToRef(positions, index, position);
          Vector3.FromArrayToRef(normals, index, normal);
          Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
          var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
          var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
          var pos = (u + v * heightMapWidth) * 4;
          var r = buffer[pos] / 255;
          var g = buffer[pos + 1] / 255;
          var b = buffer[pos + 2] / 255;
          var gradient = r * 0.3 + g * 0.59 + b * 0.11;
          normal.normalize();
          normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
          position = position.add(normal);
          position.toArray(positions, index);
        }
        VertexData.ComputeNormals(positions, this.getIndices(), normals);
        if (forceUpdate) {
          this.setVerticesData(VertexBuffer.PositionKind, positions);
          this.setVerticesData(VertexBuffer.NormalKind, normals);
          this.setVerticesData(VertexBuffer.UVKind, uvs);
        } else {
          this.updateVerticesData(VertexBuffer.PositionKind, positions);
          this.updateVerticesData(VertexBuffer.NormalKind, normals);
        }
        return this;
      };
      Mesh2.prototype.convertToFlatShadedMesh = function() {
        var kinds = this.getVerticesDataKinds();
        var vbs = {};
        var data = {};
        var newdata = {};
        var updatableNormals = false;
        var kindIndex;
        var kind;
        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
          kind = kinds[kindIndex];
          var vertexBuffer = this.getVertexBuffer(kind);
          var vertexData = vertexBuffer.getData();
          if (vertexData instanceof Array || vertexData instanceof Float32Array) {
            if (vertexData.length === 0) {
              continue;
            }
          }
          if (kind === VertexBuffer.NormalKind) {
            updatableNormals = vertexBuffer.isUpdatable();
            kinds.splice(kindIndex, 1);
            kindIndex--;
            continue;
          }
          vbs[kind] = vertexBuffer;
          data[kind] = this.getVerticesData(kind);
          newdata[kind] = [];
        }
        var previousSubmeshes = this.subMeshes.slice(0);
        var indices = this.getIndices();
        var totalIndices = this.getTotalIndices();
        var index;
        for (index = 0; index < totalIndices; index++) {
          var vertexIndex = indices[index];
          for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
            kind = kinds[kindIndex];
            if (!vbs[kind]) {
              continue;
            }
            var stride = vbs[kind].getStrideSize();
            for (var offset = 0; offset < stride; offset++) {
              newdata[kind].push(data[kind][vertexIndex * stride + offset]);
            }
          }
        }
        var normals = [];
        var positions = newdata[VertexBuffer.PositionKind];
        var useRightHandedSystem = this.getScene().useRightHandedSystem;
        var flipNormalGeneration;
        if (useRightHandedSystem) {
          flipNormalGeneration = this.overrideMaterialSideOrientation === 1;
        } else {
          flipNormalGeneration = this.overrideMaterialSideOrientation === 0;
        }
        for (index = 0; index < totalIndices; index += 3) {
          indices[index] = index;
          indices[index + 1] = index + 1;
          indices[index + 2] = index + 2;
          var p1 = Vector3.FromArray(positions, index * 3);
          var p2 = Vector3.FromArray(positions, (index + 1) * 3);
          var p3 = Vector3.FromArray(positions, (index + 2) * 3);
          var p1p2 = p1.subtract(p2);
          var p3p2 = p3.subtract(p2);
          var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
          if (flipNormalGeneration) {
            normal.scaleInPlace(-1);
          }
          for (var localIndex = 0; localIndex < 3; localIndex++) {
            normals.push(normal.x);
            normals.push(normal.y);
            normals.push(normal.z);
          }
        }
        this.setIndices(indices);
        this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);
        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
          kind = kinds[kindIndex];
          if (!newdata[kind]) {
            continue;
          }
          this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
        }
        this.releaseSubMeshes();
        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
          var previousOne = previousSubmeshes[submeshIndex];
          SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
        }
        this.synchronizeInstances();
        return this;
      };
      Mesh2.prototype.convertToUnIndexedMesh = function() {
        var kinds = this.getVerticesDataKinds();
        var vbs = {};
        var data = {};
        var newdata = {};
        var kindIndex;
        var kind;
        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
          kind = kinds[kindIndex];
          var vertexBuffer = this.getVertexBuffer(kind);
          vbs[kind] = vertexBuffer;
          data[kind] = vbs[kind].getData();
          newdata[kind] = [];
        }
        var previousSubmeshes = this.subMeshes.slice(0);
        var indices = this.getIndices();
        var totalIndices = this.getTotalIndices();
        var index;
        for (index = 0; index < totalIndices; index++) {
          var vertexIndex = indices[index];
          for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
            kind = kinds[kindIndex];
            var stride = vbs[kind].getStrideSize();
            for (var offset = 0; offset < stride; offset++) {
              newdata[kind].push(data[kind][vertexIndex * stride + offset]);
            }
          }
        }
        for (index = 0; index < totalIndices; index += 3) {
          indices[index] = index;
          indices[index + 1] = index + 1;
          indices[index + 2] = index + 2;
        }
        this.setIndices(indices);
        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
          kind = kinds[kindIndex];
          this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
        }
        this.releaseSubMeshes();
        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
          var previousOne = previousSubmeshes[submeshIndex];
          SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
        }
        this._unIndexed = true;
        this.synchronizeInstances();
        return this;
      };
      Mesh2.prototype.flipFaces = function(flipNormals) {
        if (flipNormals === void 0) {
          flipNormals = false;
        }
        var vertex_data = VertexData.ExtractFromMesh(this);
        var i;
        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
          for (i = 0; i < vertex_data.normals.length; i++) {
            vertex_data.normals[i] *= -1;
          }
        }
        if (vertex_data.indices) {
          var temp = void 0;
          for (i = 0; i < vertex_data.indices.length; i += 3) {
            temp = vertex_data.indices[i + 1];
            vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
            vertex_data.indices[i + 2] = temp;
          }
        }
        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        return this;
      };
      Mesh2.prototype.increaseVertices = function(numberPerEdge) {
        var vertex_data = VertexData.ExtractFromMesh(this);
        var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;
        var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;
        var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;
        var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;
        if (!currentIndices || !positions || !normals || !uvs) {
          Logger.Warn("VertexData contains null entries");
        } else {
          vertex_data.indices = currentIndices;
          vertex_data.positions = positions;
          vertex_data.normals = normals;
          vertex_data.uvs = uvs;
          var segments = numberPerEdge + 1;
          var tempIndices = new Array();
          for (var i = 0; i < segments + 1; i++) {
            tempIndices[i] = new Array();
          }
          var a = void 0;
          var b = void 0;
          var deltaPosition = new Vector3(0, 0, 0);
          var deltaNormal = new Vector3(0, 0, 0);
          var deltaUV = new Vector2(0, 0);
          var indices = new Array();
          var vertexIndex = new Array();
          var side = new Array();
          var len = void 0;
          var positionPtr = positions.length;
          var uvPtr = uvs.length;
          for (var i = 0; i < currentIndices.length; i += 3) {
            vertexIndex[0] = currentIndices[i];
            vertexIndex[1] = currentIndices[i + 1];
            vertexIndex[2] = currentIndices[i + 2];
            for (var j = 0; j < 3; j++) {
              a = vertexIndex[j];
              b = vertexIndex[(j + 1) % 3];
              if (side[a] === void 0 && side[b] === void 0) {
                side[a] = new Array();
                side[b] = new Array();
              } else {
                if (side[a] === void 0) {
                  side[a] = new Array();
                }
                if (side[b] === void 0) {
                  side[b] = new Array();
                }
              }
              if (side[a][b] === void 0 && side[b][a] === void 0) {
                side[a][b] = [];
                deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
                deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
                deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
                deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
                deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
                deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
                deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
                deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
                side[a][b].push(a);
                for (var k = 1; k < segments; k++) {
                  side[a][b].push(positions.length / 3);
                  positions[positionPtr] = positions[3 * a] + k * deltaPosition.x;
                  normals[positionPtr++] = normals[3 * a] + k * deltaNormal.x;
                  positions[positionPtr] = positions[3 * a + 1] + k * deltaPosition.y;
                  normals[positionPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
                  positions[positionPtr] = positions[3 * a + 2] + k * deltaPosition.z;
                  normals[positionPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
                  uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
                  uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
                }
                side[a][b].push(b);
                side[b][a] = new Array();
                len = side[a][b].length;
                for (var idx = 0; idx < len; idx++) {
                  side[b][a][idx] = side[a][b][len - 1 - idx];
                }
              }
            }
            tempIndices[0][0] = currentIndices[i];
            tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
            tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
            for (var k = 2; k < segments; k++) {
              tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
              tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
              deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
              deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
              deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
              deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
              deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
              deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
              deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
              deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
              for (var j = 1; j < k; j++) {
                tempIndices[k][j] = positions.length / 3;
                positions[positionPtr] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
                normals[positionPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
                positions[positionPtr] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
                normals[positionPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
                positions[positionPtr] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
                normals[positionPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
                uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
                uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
              }
            }
            tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
            indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
            for (var k = 1; k < segments; k++) {
              var j = void 0;
              for (j = 0; j < k; j++) {
                indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
                indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
              }
              indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            }
          }
          vertex_data.indices = indices;
          vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      };
      Mesh2.prototype.forceSharedVertices = function() {
        var vertex_data = VertexData.ExtractFromMesh(this);
        var currentUVs = vertex_data.uvs;
        var currentIndices = vertex_data.indices;
        var currentPositions = vertex_data.positions;
        var currentColors = vertex_data.colors;
        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
          Logger.Warn("VertexData contains empty entries");
        } else {
          var positions = new Array();
          var indices = new Array();
          var uvs = new Array();
          var colors = new Array();
          var pstring = new Array();
          var indexPtr = 0;
          var uniquePositions = {};
          var ptr = void 0;
          var facet = void 0;
          for (var i = 0; i < currentIndices.length; i += 3) {
            facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
            pstring = new Array();
            for (var j = 0; j < 3; j++) {
              pstring[j] = "";
              for (var k = 0; k < 3; k++) {
                if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
                  currentPositions[3 * facet[j] + k] = 0;
                }
                pstring[j] += currentPositions[3 * facet[j] + k] + "|";
              }
            }
            if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
              for (var j = 0; j < 3; j++) {
                ptr = uniquePositions[pstring[j]];
                if (ptr === void 0) {
                  uniquePositions[pstring[j]] = indexPtr;
                  ptr = indexPtr++;
                  for (var k = 0; k < 3; k++) {
                    positions.push(currentPositions[3 * facet[j] + k]);
                  }
                  if (currentColors !== null && currentColors !== void 0) {
                    for (var k = 0; k < 4; k++) {
                      colors.push(currentColors[4 * facet[j] + k]);
                    }
                  }
                  if (currentUVs !== null && currentUVs !== void 0) {
                    for (var k = 0; k < 2; k++) {
                      uvs.push(currentUVs[2 * facet[j] + k]);
                    }
                  }
                }
                indices.push(ptr);
              }
            }
          }
          var normals = new Array();
          VertexData.ComputeNormals(positions, indices, normals);
          vertex_data.positions = positions;
          vertex_data.indices = indices;
          vertex_data.normals = normals;
          if (currentUVs !== null && currentUVs !== void 0) {
            vertex_data.uvs = uvs;
          }
          if (currentColors !== null && currentColors !== void 0) {
            vertex_data.colors = colors;
          }
          vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      };
      Mesh2._instancedMeshFactory = function(name105, mesh) {
        throw _WarnImport("InstancedMesh");
      };
      Mesh2._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
        throw _WarnImport("PhysicsImpostor");
      };
      Mesh2.prototype.createInstance = function(name105) {
        return Mesh2._instancedMeshFactory(name105, this);
      };
      Mesh2.prototype.synchronizeInstances = function() {
        for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
          var instance = this.instances[instanceIndex];
          instance._syncSubMeshes();
        }
        return this;
      };
      Mesh2.prototype.optimizeIndices = function(successCallback) {
        var _this = this;
        var indices = this.getIndices();
        var positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions || !indices) {
          return this;
        }
        var vectorPositions = new Array();
        for (var pos = 0; pos < positions.length; pos = pos + 3) {
          vectorPositions.push(Vector3.FromArray(positions, pos));
        }
        var dupes = new Array();
        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function(iteration) {
          var realPos = vectorPositions.length - 1 - iteration;
          var testedPosition = vectorPositions[realPos];
          for (var j = 0; j < realPos; ++j) {
            var againstPosition = vectorPositions[j];
            if (testedPosition.equals(againstPosition)) {
              dupes[realPos] = j;
              break;
            }
          }
        }, function() {
          for (var i = 0; i < indices.length; ++i) {
            indices[i] = dupes[indices[i]] || indices[i];
          }
          var originalSubMeshes = _this.subMeshes.slice(0);
          _this.setIndices(indices);
          _this.subMeshes = originalSubMeshes;
          if (successCallback) {
            successCallback(_this);
          }
        });
        return this;
      };
      Mesh2.prototype.serialize = function(serializationObject) {
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.position = this.position.asArray();
        if (this.rotationQuaternion) {
          serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
        } else if (this.rotation) {
          serializationObject.rotation = this.rotation.asArray();
        }
        serializationObject.scaling = this.scaling.asArray();
        if (this._postMultiplyPivotMatrix) {
          serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
        } else {
          serializationObject.localMatrix = this.getPivotMatrix().asArray();
        }
        serializationObject.isEnabled = this.isEnabled(false);
        serializationObject.isVisible = this.isVisible;
        serializationObject.infiniteDistance = this.infiniteDistance;
        serializationObject.pickable = this.isPickable;
        serializationObject.receiveShadows = this.receiveShadows;
        serializationObject.billboardMode = this.billboardMode;
        serializationObject.visibility = this.visibility;
        serializationObject.checkCollisions = this.checkCollisions;
        serializationObject.isBlocker = this.isBlocker;
        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
        if (this.parent) {
          serializationObject.parentId = this.parent.uniqueId;
        }
        serializationObject.isUnIndexed = this.isUnIndexed;
        var geometry = this._geometry;
        if (geometry && this.subMeshes) {
          serializationObject.geometryUniqueId = geometry.uniqueId;
          serializationObject.geometryId = geometry.id;
          serializationObject.subMeshes = [];
          for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
            var subMesh = this.subMeshes[subIndex];
            serializationObject.subMeshes.push({
              materialIndex: subMesh.materialIndex,
              verticesStart: subMesh.verticesStart,
              verticesCount: subMesh.verticesCount,
              indexStart: subMesh.indexStart,
              indexCount: subMesh.indexCount
            });
          }
        }
        if (this.material) {
          if (!this.material.doNotSerialize) {
            serializationObject.materialUniqueId = this.material.uniqueId;
            serializationObject.materialId = this.material.id;
          }
        } else {
          this.material = null;
          serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
          serializationObject.materialId = this._scene.defaultMaterial.id;
        }
        if (this.morphTargetManager) {
          serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
        }
        if (this.skeleton) {
          serializationObject.skeletonId = this.skeleton.id;
          serializationObject.numBoneInfluencers = this.numBoneInfluencers;
        }
        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
          var impostor = this.getPhysicsImpostor();
          if (impostor) {
            serializationObject.physicsMass = impostor.getParam("mass");
            serializationObject.physicsFriction = impostor.getParam("friction");
            serializationObject.physicsRestitution = impostor.getParam("mass");
            serializationObject.physicsImpostor = impostor.type;
          }
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        serializationObject.instances = [];
        for (var index = 0; index < this.instances.length; index++) {
          var instance = this.instances[index];
          if (instance.doNotSerialize) {
            continue;
          }
          var serializationInstance = {
            name: instance.name,
            id: instance.id,
            isEnabled: instance.isEnabled(false),
            isVisible: instance.isVisible,
            isPickable: instance.isPickable,
            checkCollisions: instance.checkCollisions,
            position: instance.position.asArray(),
            scaling: instance.scaling.asArray()
          };
          if (instance.parent) {
            serializationInstance.parentId = instance.parent.uniqueId;
          }
          if (instance.rotationQuaternion) {
            serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
          } else if (instance.rotation) {
            serializationInstance.rotation = instance.rotation.asArray();
          }
          if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
            var impostor = instance.getPhysicsImpostor();
            if (impostor) {
              serializationInstance.physicsMass = impostor.getParam("mass");
              serializationInstance.physicsFriction = impostor.getParam("friction");
              serializationInstance.physicsRestitution = impostor.getParam("mass");
              serializationInstance.physicsImpostor = impostor.type;
            }
          }
          if (instance.metadata) {
            serializationInstance.metadata = instance.metadata;
          }
          serializationObject.instances.push(serializationInstance);
          SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
          serializationInstance.ranges = instance.serializeAnimationRanges();
        }
        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
          serializationObject.thinInstances = {
            instancesCount: this._thinInstanceDataStorage.instancesCount,
            matrixData: Tools.SliceToArray(this._thinInstanceDataStorage.matrixData),
            matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
            enablePicking: this.thinInstanceEnablePicking
          };
          if (this._userThinInstanceBuffersStorage) {
            var userThinInstance = {
              data: {},
              sizes: {},
              strides: {}
            };
            for (var kind in this._userThinInstanceBuffersStorage.data) {
              userThinInstance.data[kind] = Tools.SliceToArray(this._userThinInstanceBuffersStorage.data[kind]);
              userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
              userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
            }
            serializationObject.thinInstances.userThinInstance = userThinInstance;
          }
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.layerMask = this.layerMask;
        serializationObject.alphaIndex = this.alphaIndex;
        serializationObject.hasVertexAlpha = this.hasVertexAlpha;
        serializationObject.overlayAlpha = this.overlayAlpha;
        serializationObject.overlayColor = this.overlayColor.asArray();
        serializationObject.renderOverlay = this.renderOverlay;
        serializationObject.applyFog = this.applyFog;
        if (this.actionManager) {
          serializationObject.actions = this.actionManager.serialize(this.name);
        }
      };
      Mesh2.prototype._syncGeometryWithMorphTargetManager = function() {
        if (!this.geometry) {
          return;
        }
        this._markSubMeshesAsAttributesDirty();
        var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
        if (morphTargetManager && morphTargetManager.vertexCount) {
          if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
            Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
            this.morphTargetManager = null;
            return;
          }
          if (morphTargetManager.isUsingTextureForTargets) {
            return;
          }
          for (var index = 0; index < morphTargetManager.numInfluencers; index++) {
            var morphTarget = morphTargetManager.getActiveTarget(index);
            var positions = morphTarget.getPositions();
            if (!positions) {
              Logger.Error("Invalid morph target. Target must have positions.");
              return;
            }
            this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
            var normals = morphTarget.getNormals();
            if (normals) {
              this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
            }
            var tangents = morphTarget.getTangents();
            if (tangents) {
              this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
            }
            var uvs = morphTarget.getUVs();
            if (uvs) {
              this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
            }
          }
        } else {
          var index = 0;
          while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
            this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
            if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
            }
            index++;
          }
        }
      };
      Mesh2.Parse = function(parsedMesh, scene, rootUrl) {
        var mesh;
        if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
          mesh = Mesh2._LinesMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
          mesh = Mesh2._GroundMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
          mesh = Mesh2._GoldbergMeshParser(parsedMesh, scene);
        } else {
          mesh = new Mesh2(parsedMesh.name, scene);
        }
        mesh.id = parsedMesh.id;
        if (Tags) {
          Tags.AddTagsTo(mesh, parsedMesh.tags);
        }
        mesh.position = Vector3.FromArray(parsedMesh.position);
        if (parsedMesh.metadata !== void 0) {
          mesh.metadata = parsedMesh.metadata;
        }
        if (parsedMesh.rotationQuaternion) {
          mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
        } else if (parsedMesh.rotation) {
          mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
        }
        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
        if (parsedMesh.localMatrix) {
          mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
        } else if (parsedMesh.pivotMatrix) {
          mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
        }
        mesh.setEnabled(parsedMesh.isEnabled);
        mesh.isVisible = parsedMesh.isVisible;
        mesh.infiniteDistance = parsedMesh.infiniteDistance;
        mesh.showBoundingBox = parsedMesh.showBoundingBox;
        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
        if (parsedMesh.applyFog !== void 0) {
          mesh.applyFog = parsedMesh.applyFog;
        }
        if (parsedMesh.pickable !== void 0) {
          mesh.isPickable = parsedMesh.pickable;
        }
        if (parsedMesh.alphaIndex !== void 0) {
          mesh.alphaIndex = parsedMesh.alphaIndex;
        }
        mesh.receiveShadows = parsedMesh.receiveShadows;
        mesh.billboardMode = parsedMesh.billboardMode;
        if (parsedMesh.visibility !== void 0) {
          mesh.visibility = parsedMesh.visibility;
        }
        mesh.checkCollisions = parsedMesh.checkCollisions;
        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
        if (parsedMesh.isBlocker !== void 0) {
          mesh.isBlocker = parsedMesh.isBlocker;
        }
        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
        if (parsedMesh.freezeWorldMatrix) {
          mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
        }
        if (parsedMesh.parentId !== void 0) {
          mesh._waitingParentId = parsedMesh.parentId;
        }
        if (parsedMesh.actions !== void 0) {
          mesh._waitingData.actions = parsedMesh.actions;
        }
        if (parsedMesh.overlayAlpha !== void 0) {
          mesh.overlayAlpha = parsedMesh.overlayAlpha;
        }
        if (parsedMesh.overlayColor !== void 0) {
          mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
        }
        if (parsedMesh.renderOverlay !== void 0) {
          mesh.renderOverlay = parsedMesh.renderOverlay;
        }
        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
        if (parsedMesh.delayLoadingFile) {
          mesh.delayLoadState = 4;
          mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
          mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
          if (parsedMesh._binaryInfo) {
            mesh._binaryInfo = parsedMesh._binaryInfo;
          }
          mesh._delayInfo = [];
          if (parsedMesh.hasUVs) {
            mesh._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedMesh.hasUVs2) {
            mesh._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedMesh.hasUVs3) {
            mesh._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedMesh.hasUVs4) {
            mesh._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedMesh.hasUVs5) {
            mesh._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedMesh.hasUVs6) {
            mesh._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedMesh.hasColors) {
            mesh._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedMesh.hasMatricesIndices) {
            mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedMesh.hasMatricesWeights) {
            mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          mesh._delayLoadingFunction = Geometry._ImportGeometry;
          if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
            mesh._checkDelayState();
          }
        } else {
          Geometry._ImportGeometry(parsedMesh, mesh);
        }
        if (parsedMesh.materialUniqueId) {
          mesh._waitingMaterialId = parsedMesh.materialUniqueId;
        } else if (parsedMesh.materialId) {
          mesh._waitingMaterialId = parsedMesh.materialId;
        }
        if (parsedMesh.morphTargetManagerId > -1) {
          mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
        }
        if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
          mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
          if (parsedMesh.numBoneInfluencers) {
            mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
          }
        }
        if (parsedMesh.animations) {
          for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
            var parsedAnimation = parsedMesh.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              mesh.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(mesh, parsedMesh, scene);
        }
        if (parsedMesh.autoAnimate) {
          scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
        }
        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
          mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
        } else {
          mesh.layerMask = 268435455;
        }
        if (parsedMesh.physicsImpostor) {
          Mesh2._PhysicsImpostorParser(scene, mesh, parsedMesh);
        }
        if (parsedMesh.lodMeshIds) {
          mesh._waitingData.lods = {
            ids: parsedMesh.lodMeshIds,
            distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
            coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
          };
        }
        if (parsedMesh.instances) {
          for (var index = 0; index < parsedMesh.instances.length; index++) {
            var parsedInstance = parsedMesh.instances[index];
            var instance = mesh.createInstance(parsedInstance.name);
            if (parsedInstance.id) {
              instance.id = parsedInstance.id;
            }
            if (Tags) {
              if (parsedInstance.tags) {
                Tags.AddTagsTo(instance, parsedInstance.tags);
              } else {
                Tags.AddTagsTo(instance, parsedMesh.tags);
              }
            }
            instance.position = Vector3.FromArray(parsedInstance.position);
            if (parsedInstance.metadata !== void 0) {
              instance.metadata = parsedInstance.metadata;
            }
            if (parsedInstance.parentId !== void 0) {
              instance._waitingParentId = parsedInstance.parentId;
            }
            if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
              instance.setEnabled(parsedInstance.isEnabled);
            }
            if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
              instance.isVisible = parsedInstance.isVisible;
            }
            if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
              instance.isPickable = parsedInstance.isPickable;
            }
            if (parsedInstance.rotationQuaternion) {
              instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
            } else if (parsedInstance.rotation) {
              instance.rotation = Vector3.FromArray(parsedInstance.rotation);
            }
            instance.scaling = Vector3.FromArray(parsedInstance.scaling);
            if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
              instance.checkCollisions = parsedInstance.checkCollisions;
            }
            if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
              instance.isPickable = parsedInstance.pickable;
            }
            if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
              instance.showBoundingBox = parsedInstance.showBoundingBox;
            }
            if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
            }
            if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.alphaIndex = parsedInstance.alphaIndex;
            }
            if (parsedInstance.physicsImpostor) {
              Mesh2._PhysicsImpostorParser(scene, instance, parsedInstance);
            }
            if (parsedInstance.animations) {
              for (var animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
                var parsedAnimation = parsedInstance.animations[animationIndex];
                var internalClass = GetClass("BABYLON.Animation");
                if (internalClass) {
                  instance.animations.push(internalClass.Parse(parsedAnimation));
                }
              }
              Node.ParseAnimationRanges(instance, parsedInstance, scene);
              if (parsedInstance.autoAnimate) {
                scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
              }
            }
          }
        }
        if (parsedMesh.thinInstances) {
          var thinInstances = parsedMesh.thinInstances;
          mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
          if (thinInstances.matrixData) {
            mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
            mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
          } else {
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
          }
          if (parsedMesh.thinInstances.userThinInstance) {
            var userThinInstance = parsedMesh.thinInstances.userThinInstance;
            for (var kind in userThinInstance.data) {
              mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
              mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
            }
          }
        }
        return mesh;
      };
      Mesh2.prototype.setPositionsForCPUSkinning = function() {
        var internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          var source = this.getVerticesData(VertexBuffer.PositionKind);
          if (!source) {
            return internalDataInfo._sourcePositions;
          }
          internalDataInfo._sourcePositions = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            this.setVerticesData(VertexBuffer.PositionKind, source, true);
          }
        }
        return internalDataInfo._sourcePositions;
      };
      Mesh2.prototype.setNormalsForCPUSkinning = function() {
        var internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourceNormals) {
          var source = this.getVerticesData(VertexBuffer.NormalKind);
          if (!source) {
            return internalDataInfo._sourceNormals;
          }
          internalDataInfo._sourceNormals = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            this.setVerticesData(VertexBuffer.NormalKind, source, true);
          }
        }
        return internalDataInfo._sourceNormals;
      };
      Mesh2.prototype.applySkeleton = function(skeleton) {
        if (!this.geometry) {
          return this;
        }
        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
          return this;
        }
        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          return this;
        }
        var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
        var internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          var submeshes = this.subMeshes.slice();
          this.setPositionsForCPUSkinning();
          this.subMeshes = submeshes;
        }
        if (hasNormals && !internalDataInfo._sourceNormals) {
          this.setNormalsForCPUSkinning();
        }
        var positionsData = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positionsData) {
          return this;
        }
        if (!(positionsData instanceof Float32Array)) {
          positionsData = new Float32Array(positionsData);
        }
        var normalsData = this.getVerticesData(VertexBuffer.NormalKind);
        if (hasNormals) {
          if (!normalsData) {
            return this;
          }
          if (!(normalsData instanceof Float32Array)) {
            normalsData = new Float32Array(normalsData);
          }
        }
        var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (!matricesWeightsData || !matricesIndicesData) {
          return this;
        }
        var needExtras = this.numBoneInfluencers > 4;
        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        var skeletonMatrices = skeleton.getTransformMatrices(this);
        var tempVector3 = Vector3.Zero();
        var finalMatrix = new Matrix();
        var tempMatrix = new Matrix();
        var matWeightIdx = 0;
        var inf;
        for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
          var weight = void 0;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
          tempVector3.toArray(positionsData, index);
          if (hasNormals) {
            Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
            tempVector3.toArray(normalsData, index);
          }
          finalMatrix.reset();
        }
        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
        if (hasNormals) {
          this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
        }
        return this;
      };
      Mesh2.MinMax = function(meshes) {
        var minVector = null;
        var maxVector = null;
        meshes.forEach(function(mesh) {
          var boundingInfo = mesh.getBoundingInfo();
          var boundingBox = boundingInfo.boundingBox;
          if (!minVector || !maxVector) {
            minVector = boundingBox.minimumWorld;
            maxVector = boundingBox.maximumWorld;
          } else {
            minVector.minimizeInPlace(boundingBox.minimumWorld);
            maxVector.maximizeInPlace(boundingBox.maximumWorld);
          }
        });
        if (!minVector || !maxVector) {
          return {
            min: Vector3.Zero(),
            max: Vector3.Zero()
          };
        }
        return {
          min: minVector,
          max: maxVector
        };
      };
      Mesh2.Center = function(meshesOrMinMaxVector) {
        var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh2.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
        return Vector3.Center(minMaxVector.min, minMaxVector.max);
      };
      Mesh2.MergeMeshes = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        if (disposeSource === void 0) {
          disposeSource = true;
        }
        return runCoroutineSync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
      };
      Mesh2.MergeMeshesAsync = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        if (disposeSource === void 0) {
          disposeSource = true;
        }
        return runCoroutineAsync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
      };
      Mesh2._MergeMeshesCoroutine = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
        var index, totalVertices, materialArray, materialIndexArray, indiceArray, currentOverrideMaterialSideOrientation, mesh, material, matIndex, subIndex, subIndex, subIndex, source, getVertexDataFromMesh, _a, sourceVertexData, sourceTransform, meshVertexDatas, i, mergeCoroutine, mergeCoroutineStep, vertexData, applyToCoroutine, applyToCoroutineStep, offset, _i, _b, subMesh, newMultiMaterial, subIndex;
        if (disposeSource === void 0) {
          disposeSource = true;
        }
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              meshes = meshes.filter(Boolean);
              if (meshes.length === 0) {
                return [2, null];
              }
              if (!allow32BitsIndices) {
                totalVertices = 0;
                for (index = 0; index < meshes.length; index++) {
                  totalVertices += meshes[index].getTotalVertices();
                  if (totalVertices >= 65536) {
                    Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
                    return [2, null];
                  }
                }
              }
              if (multiMultiMaterials) {
                subdivideWithSubMeshes = false;
              }
              materialArray = new Array();
              materialIndexArray = new Array();
              indiceArray = new Array();
              currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;
              for (index = 0; index < meshes.length; index++) {
                mesh = meshes[index];
                if (mesh.isAnInstance) {
                  Logger.Warn("Cannot merge instance meshes.");
                  return [2, null];
                }
                if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {
                  Logger.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values.");
                  return [2, null];
                }
                if (subdivideWithSubMeshes) {
                  indiceArray.push(mesh.getTotalIndices());
                }
                if (multiMultiMaterials) {
                  if (mesh.material) {
                    material = mesh.material;
                    if (material instanceof MultiMaterial) {
                      for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                        if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                          materialArray.push(material.subMaterials[matIndex]);
                        }
                      }
                      for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                        materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                      }
                    } else {
                      if (materialArray.indexOf(material) < 0) {
                        materialArray.push(material);
                      }
                      for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                        materialIndexArray.push(materialArray.indexOf(material));
                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                      }
                    }
                  } else {
                    for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                      materialIndexArray.push(0);
                      indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                    }
                  }
                }
              }
              source = meshes[0];
              getVertexDataFromMesh = function(mesh2) {
                var wm = mesh2.computeWorldMatrix(true);
                var vertexData2 = VertexData.ExtractFromMesh(mesh2, false, false);
                return [vertexData2, wm];
              };
              _a = getVertexDataFromMesh(source), sourceVertexData = _a[0], sourceTransform = _a[1];
              if (!isAsync)
                return [3, 2];
              return [4];
            case 1:
              _c.sent();
              _c.label = 2;
            case 2:
              meshVertexDatas = new Array(meshes.length - 1);
              i = 1;
              _c.label = 3;
            case 3:
              if (!(i < meshes.length))
                return [3, 6];
              meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
              if (!isAsync)
                return [3, 5];
              return [4];
            case 4:
              _c.sent();
              _c.label = 5;
            case 5:
              i++;
              return [3, 3];
            case 6:
              mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
              mergeCoroutineStep = mergeCoroutine.next();
              _c.label = 7;
            case 7:
              if (!!mergeCoroutineStep.done)
                return [3, 10];
              if (!isAsync)
                return [3, 9];
              return [4];
            case 8:
              _c.sent();
              _c.label = 9;
            case 9:
              mergeCoroutineStep = mergeCoroutine.next();
              return [3, 7];
            case 10:
              vertexData = mergeCoroutineStep.value;
              if (!meshSubclass) {
                meshSubclass = new Mesh2(source.name + "_merged", source.getScene());
              }
              applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
              applyToCoroutineStep = applyToCoroutine.next();
              _c.label = 11;
            case 11:
              if (!!applyToCoroutineStep.done)
                return [3, 14];
              if (!isAsync)
                return [3, 13];
              return [4];
            case 12:
              _c.sent();
              _c.label = 13;
            case 13:
              applyToCoroutineStep = applyToCoroutine.next();
              return [3, 11];
            case 14:
              meshSubclass.checkCollisions = source.checkCollisions;
              meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
              if (disposeSource) {
                for (index = 0; index < meshes.length; index++) {
                  meshes[index].dispose();
                }
              }
              if (subdivideWithSubMeshes || multiMultiMaterials) {
                meshSubclass.releaseSubMeshes();
                index = 0;
                offset = 0;
                while (index < indiceArray.length) {
                  SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, void 0, false);
                  offset += indiceArray[index];
                  index++;
                }
                for (_i = 0, _b = meshSubclass.subMeshes; _i < _b.length; _i++) {
                  subMesh = _b[_i];
                  subMesh.refreshBoundingInfo();
                }
                meshSubclass.computeWorldMatrix(true);
              }
              if (multiMultiMaterials) {
                newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
                newMultiMaterial.subMaterials = materialArray;
                for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
                  meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
                }
                meshSubclass.material = newMultiMaterial;
              } else {
                meshSubclass.material = source.material;
              }
              return [2, meshSubclass];
          }
        });
      };
      Mesh2.prototype.addInstance = function(instance) {
        instance._indexInSourceMeshInstanceArray = this.instances.length;
        this.instances.push(instance);
      };
      Mesh2.prototype.removeInstance = function(instance) {
        var index = instance._indexInSourceMeshInstanceArray;
        if (index != -1) {
          if (index !== this.instances.length - 1) {
            var last = this.instances[this.instances.length - 1];
            this.instances[index] = last;
            last._indexInSourceMeshInstanceArray = index;
          }
          instance._indexInSourceMeshInstanceArray = -1;
          this.instances.pop();
        }
      };
      Mesh2.prototype._shouldConvertRHS = function() {
        return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;
      };
      Mesh2.FRONTSIDE = VertexData.FRONTSIDE;
      Mesh2.BACKSIDE = VertexData.BACKSIDE;
      Mesh2.DOUBLESIDE = VertexData.DOUBLESIDE;
      Mesh2.DEFAULTSIDE = VertexData.DEFAULTSIDE;
      Mesh2.NO_CAP = 0;
      Mesh2.CAP_START = 1;
      Mesh2.CAP_END = 2;
      Mesh2.CAP_ALL = 3;
      Mesh2.NO_FLIP = 0;
      Mesh2.FLIP_TILE = 1;
      Mesh2.ROTATE_TILE = 2;
      Mesh2.FLIP_ROW = 3;
      Mesh2.ROTATE_ROW = 4;
      Mesh2.FLIP_N_ROTATE_TILE = 5;
      Mesh2.FLIP_N_ROTATE_ROW = 6;
      Mesh2.CENTER = 0;
      Mesh2.LEFT = 1;
      Mesh2.RIGHT = 2;
      Mesh2.TOP = 3;
      Mesh2.BOTTOM = 4;
      Mesh2.INSTANCEDMESH_SORT_TRANSPARENT = false;
      Mesh2._GroundMeshParser = function(parsedMesh, scene) {
        throw _WarnImport("GroundMesh");
      };
      Mesh2._GoldbergMeshParser = function(parsedMesh, scene) {
        throw _WarnImport("GoldbergMesh");
      };
      Mesh2._LinesMeshParser = function(parsedMesh, scene) {
        throw _WarnImport("LinesMesh");
      };
      return Mesh2;
    }(AbstractMesh);
    RegisterClass("BABYLON.Mesh", Mesh);
    Mesh.prototype.setMaterialByID = function(id) {
      return this.setMaterialById(id);
    };
    Mesh.CreateDisc = Mesh.CreateDisc || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateBox = Mesh.CreateBox || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateSphere = Mesh.CreateSphere || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateCylinder = Mesh.CreateCylinder || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateTorusKnot = Mesh.CreateTorusKnot || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateTorus = Mesh.CreateTorus || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreatePlane = Mesh.CreatePlane || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateGround = Mesh.CreateGround || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateTiledGround = Mesh.CreateTiledGround || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateTube = Mesh.CreateTube || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreatePolyhedron = Mesh.CreatePolyhedron || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateIcoSphere = Mesh.CreateIcoSphere || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateDecal = Mesh.CreateDecal || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.CreateCapsule = Mesh.CreateCapsule || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
    Mesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || function() {
      throw new Error("Import MeshBuilder to populate this function");
    };
  }
});

// node_modules/@babylonjs/core/assetContainer.js
var KeepAssets, InstantiatedEntries, AssetContainer;
var init_assetContainer = __esm({
  "node_modules/@babylonjs/core/assetContainer.js"() {
    init_tslib_es6();
    init_abstractScene();
    init_mesh();
    init_logger();
    init_engineStore();
    KeepAssets = function(_super) {
      __extends(KeepAssets2, _super);
      function KeepAssets2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return KeepAssets2;
    }(AbstractScene);
    InstantiatedEntries = function() {
      function InstantiatedEntries2() {
        this.rootNodes = [];
        this.skeletons = [];
        this.animationGroups = [];
      }
      return InstantiatedEntries2;
    }();
    AssetContainer = function(_super) {
      __extends(AssetContainer2, _super);
      function AssetContainer2(scene) {
        var _this = _super.call(this) || this;
        _this._wasAddedToScene = false;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return _this;
        }
        _this.scene = scene;
        _this["sounds"] = [];
        _this["effectLayers"] = [];
        _this["layers"] = [];
        _this["lensFlareSystems"] = [];
        _this["proceduralTextures"] = [];
        _this["reflectionProbes"] = [];
        scene.onDisposeObservable.add(function() {
          if (!_this._wasAddedToScene) {
            _this.dispose();
          }
        });
        _this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(function() {
          for (var _i = 0, _a = _this.geometries; _i < _a.length; _i++) {
            var geometry = _a[_i];
            geometry._rebuild();
          }
          for (var _b = 0, _c = _this.meshes; _b < _c.length; _b++) {
            var mesh = _c[_b];
            mesh._rebuild();
          }
          for (var _d = 0, _e = _this.particleSystems; _d < _e.length; _d++) {
            var system = _e[_d];
            system.rebuild();
          }
          for (var _f = 0, _g = _this.textures; _f < _g.length; _f++) {
            var texture = _g[_f];
            texture._rebuild();
          }
        });
        return _this;
      }
      AssetContainer2.prototype.instantiateModelsToScene = function(nameFunction, cloneMaterials, options) {
        var _this = this;
        if (cloneMaterials === void 0) {
          cloneMaterials = false;
        }
        var convertionMap = {};
        var storeMap = {};
        var result = new InstantiatedEntries();
        var alreadySwappedSkeletons = [];
        var alreadySwappedMaterials = [];
        if (!options) {
          options = {
            doNotInstantiate: true
          };
        }
        var onClone = function(source, clone) {
          convertionMap[source.uniqueId] = clone.uniqueId;
          storeMap[clone.uniqueId] = clone;
          if (nameFunction) {
            clone.name = nameFunction(source.name);
          }
          if (clone instanceof Mesh) {
            var clonedMesh = clone;
            if (clonedMesh.morphTargetManager) {
              var oldMorphTargetManager = source.morphTargetManager;
              clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
              for (var index = 0; index < oldMorphTargetManager.numTargets; index++) {
                var oldTarget = oldMorphTargetManager.getTarget(index);
                var newTarget = clonedMesh.morphTargetManager.getTarget(index);
                convertionMap[oldTarget.uniqueId] = newTarget.uniqueId;
                storeMap[newTarget.uniqueId] = newTarget;
              }
            }
          }
        };
        this.transformNodes.forEach(function(o) {
          if (options && options.predicate && !options.predicate(o)) {
            return;
          }
          if (!o.parent) {
            var newOne = o.instantiateHierarchy(null, options, function(source, clone) {
              onClone(source, clone);
            });
            if (newOne) {
              result.rootNodes.push(newOne);
            }
          }
        });
        this.meshes.forEach(function(o) {
          if (options && options.predicate && !options.predicate(o)) {
            return;
          }
          if (!o.parent) {
            var newOne = o.instantiateHierarchy(null, options, function(source, clone) {
              onClone(source, clone);
              if (clone.material) {
                var mesh = clone;
                if (mesh.material) {
                  if (cloneMaterials) {
                    var sourceMaterial = source.material;
                    if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
                      var swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
                      alreadySwappedMaterials.push(sourceMaterial);
                      convertionMap[sourceMaterial.uniqueId] = swap.uniqueId;
                      storeMap[swap.uniqueId] = swap;
                      if (sourceMaterial.getClassName() === "MultiMaterial") {
                        var multi = sourceMaterial;
                        for (var _i = 0, _a = multi.subMaterials; _i < _a.length; _i++) {
                          var material = _a[_i];
                          if (!material) {
                            continue;
                          }
                          swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                          alreadySwappedMaterials.push(material);
                          convertionMap[material.uniqueId] = swap.uniqueId;
                          storeMap[swap.uniqueId] = swap;
                        }
                        multi.subMaterials = multi.subMaterials.map(function(m) {
                          return m && storeMap[convertionMap[m.uniqueId]];
                        });
                      }
                    }
                    if (mesh.getClassName() !== "InstancedMesh") {
                      mesh.material = storeMap[convertionMap[sourceMaterial.uniqueId]];
                    }
                  } else {
                    if (mesh.material.getClassName() === "MultiMaterial") {
                      if (_this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                        _this.scene.addMultiMaterial(mesh.material);
                      }
                    } else {
                      if (_this.scene.materials.indexOf(mesh.material) === -1) {
                        _this.scene.addMaterial(mesh.material);
                      }
                    }
                  }
                }
              }
            });
            if (newOne) {
              result.rootNodes.push(newOne);
            }
          }
        });
        this.skeletons.forEach(function(s) {
          if (options && options.predicate && !options.predicate(s)) {
            return;
          }
          var clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
          for (var _i = 0, _a = _this.meshes; _i < _a.length; _i++) {
            var m = _a[_i];
            if (m.skeleton === s && !m.isAnInstance) {
              var copy = storeMap[convertionMap[m.uniqueId]];
              if (copy.isAnInstance) {
                continue;
              }
              copy.skeleton = clone;
              if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
                continue;
              }
              alreadySwappedSkeletons.push(clone);
              for (var _b = 0, _c = clone.bones; _b < _c.length; _b++) {
                var bone = _c[_b];
                if (bone._linkedTransformNode) {
                  bone._linkedTransformNode = storeMap[convertionMap[bone._linkedTransformNode.uniqueId]];
                }
              }
            }
          }
          result.skeletons.push(clone);
        });
        this.animationGroups.forEach(function(o) {
          if (options && options.predicate && !options.predicate(o)) {
            return;
          }
          var clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, function(oldTarget) {
            var newTarget = storeMap[convertionMap[oldTarget.uniqueId]];
            return newTarget || oldTarget;
          });
          result.animationGroups.push(clone);
        });
        return result;
      };
      AssetContainer2.prototype.addAllToScene = function() {
        if (this._wasAddedToScene) {
          return;
        }
        this._wasAddedToScene = true;
        this.addToScene(null);
        if (this.environmentTexture) {
          this.scene.environmentTexture = this.environmentTexture;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
          var component = _a[_i];
          component.addFromContainer(this);
        }
        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      };
      AssetContainer2.prototype.addToScene = function(predicate) {
        var _this = this;
        if (predicate === void 0) {
          predicate = null;
        }
        this.cameras.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addCamera(o);
        });
        this.lights.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addLight(o);
        });
        this.meshes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addMesh(o);
        });
        this.skeletons.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addSkeleton(o);
        });
        this.animations.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addAnimation(o);
        });
        this.animationGroups.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addAnimationGroup(o);
        });
        this.multiMaterials.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addMultiMaterial(o);
        });
        this.materials.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addMaterial(o);
        });
        this.morphTargetManagers.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addMorphTargetManager(o);
        });
        this.geometries.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addGeometry(o);
        });
        this.transformNodes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addTransformNode(o);
        });
        this.actionManagers.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addActionManager(o);
        });
        this.textures.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addTexture(o);
        });
        this.reflectionProbes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.addReflectionProbe(o);
        });
      };
      AssetContainer2.prototype.removeAllFromScene = function() {
        this._wasAddedToScene = false;
        this.removeFromScene(null);
        if (this.environmentTexture === this.scene.environmentTexture) {
          this.scene.environmentTexture = null;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
          var component = _a[_i];
          component.removeFromContainer(this);
        }
      };
      AssetContainer2.prototype.removeFromScene = function(predicate) {
        var _this = this;
        if (predicate === void 0) {
          predicate = null;
        }
        this.cameras.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeCamera(o);
        });
        this.lights.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeLight(o);
        });
        this.meshes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeMesh(o);
        });
        this.skeletons.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeSkeleton(o);
        });
        this.animations.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeAnimation(o);
        });
        this.animationGroups.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeAnimationGroup(o);
        });
        this.multiMaterials.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeMultiMaterial(o);
        });
        this.materials.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeMaterial(o);
        });
        this.morphTargetManagers.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeMorphTargetManager(o);
        });
        this.geometries.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeGeometry(o);
        });
        this.transformNodes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeTransformNode(o);
        });
        this.actionManagers.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeActionManager(o);
        });
        this.textures.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeTexture(o);
        });
        this.reflectionProbes.forEach(function(o) {
          if (predicate && !predicate(o)) {
            return;
          }
          _this.scene.removeReflectionProbe(o);
        });
      };
      AssetContainer2.prototype.dispose = function() {
        this.cameras.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.cameras = [];
        this.lights.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.lights = [];
        this.meshes.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.meshes = [];
        this.skeletons.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.skeletons = [];
        this.animationGroups.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.animationGroups = [];
        this.multiMaterials.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.multiMaterials = [];
        this.materials.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.materials = [];
        this.geometries.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.geometries = [];
        this.transformNodes.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.transformNodes = [];
        this.actionManagers.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.actionManagers = [];
        this.textures.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.textures = [];
        this.reflectionProbes.slice(0).forEach(function(o) {
          o.dispose();
        });
        this.reflectionProbes = [];
        if (this.environmentTexture) {
          this.environmentTexture.dispose();
          this.environmentTexture = null;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
          var component = _a[_i];
          component.removeFromContainer(this, true);
        }
        if (this._onContextRestoredObserver) {
          this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
      };
      AssetContainer2.prototype._moveAssets = function(sourceAssets, targetAssets, keepAssets) {
        if (!sourceAssets) {
          return;
        }
        for (var _i = 0, sourceAssets_1 = sourceAssets; _i < sourceAssets_1.length; _i++) {
          var asset = sourceAssets_1[_i];
          var move = true;
          if (keepAssets) {
            for (var _a = 0, keepAssets_1 = keepAssets; _a < keepAssets_1.length; _a++) {
              var keepAsset = keepAssets_1[_a];
              if (asset === keepAsset) {
                move = false;
                break;
              }
            }
          }
          if (move) {
            targetAssets.push(asset);
            asset._parentContainer = this;
          }
        }
      };
      AssetContainer2.prototype.moveAllFromScene = function(keepAssets) {
        this._wasAddedToScene = false;
        if (keepAssets === void 0) {
          keepAssets = new KeepAssets();
        }
        for (var key in this) {
          if (Object.prototype.hasOwnProperty.call(this, key)) {
            this[key] = this[key] || (key === "environmentTexture" ? null : []);
            this._moveAssets(this.scene[key], this[key], keepAssets[key]);
          }
        }
        this.environmentTexture = this.scene.environmentTexture;
        this.removeAllFromScene();
      };
      AssetContainer2.prototype.createRootMesh = function() {
        var rootMesh = new Mesh("assetContainerRootMesh", this.scene);
        this.meshes.forEach(function(m) {
          if (!m.parent) {
            rootMesh.addChild(m);
          }
        });
        this.meshes.unshift(rootMesh);
        return rootMesh;
      };
      AssetContainer2.prototype.mergeAnimationsTo = function(scene, animatables, targetConverter) {
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (targetConverter === void 0) {
          targetConverter = null;
        }
        if (!scene) {
          Logger.Error("No scene available to merge animations to");
          return [];
        }
        var _targetConverter = targetConverter ? targetConverter : function(target) {
          var node = null;
          var targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
          var name105 = target.name.split(".").join("").split("_primitive")[0];
          switch (targetProperty) {
            case "position":
            case "rotationQuaternion":
              node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name105);
              break;
            case "influence":
              node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name105);
              break;
            default:
              node = scene.getNodeByName(target.name) || scene.getNodeByName(name105);
          }
          return node;
        };
        var nodesInAC = this.getNodes();
        nodesInAC.forEach(function(nodeInAC) {
          var nodeInScene = _targetConverter(nodeInAC);
          if (nodeInScene !== null) {
            var _loop_1 = function(animationInAC2) {
              var animationsWithSameProperty = nodeInScene.animations.filter(function(animationInScene) {
                return animationInScene.targetProperty === animationInAC2.targetProperty;
              });
              for (var _b = 0, animationsWithSameProperty_1 = animationsWithSameProperty; _b < animationsWithSameProperty_1.length; _b++) {
                var animationWithSameProperty = animationsWithSameProperty_1[_b];
                var index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
                if (index > -1) {
                  nodeInScene.animations.splice(index, 1);
                }
              }
            };
            for (var _i = 0, _a = nodeInAC.animations; _i < _a.length; _i++) {
              var animationInAC = _a[_i];
              _loop_1(animationInAC);
            }
            nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
          }
        });
        var newAnimationGroups = new Array();
        this.animationGroups.slice().forEach(function(animationGroupInAC) {
          newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
          animationGroupInAC.animatables.forEach(function(animatable) {
            animatable.stop();
          });
        });
        animatables.forEach(function(animatable) {
          var target = _targetConverter(animatable.target);
          if (target) {
            scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
            scene.stopAnimation(animatable.target);
          }
        });
        return newAnimationGroups;
      };
      return AssetContainer2;
    }(AbstractScene);
  }
});

// node_modules/@babylonjs/core/Audio/sound.js
var Sound;
var init_sound = __esm({
  "node_modules/@babylonjs/core/Audio/sound.js"() {
    init_tools();
    init_observable();
    init_math_vector();
    init_engine();
    init_logger();
    init_devTools();
    init_engineStore();
    Sound = function() {
      function Sound2(name105, urlOrArrayBuffer, scene, readyToPlayCallback, options) {
        if (readyToPlayCallback === void 0) {
          readyToPlayCallback = null;
        }
        var _this = this;
        var _a, _b, _c, _d, _e;
        this.autoplay = false;
        this._loop = false;
        this.useCustomAttenuation = false;
        this.isPlaying = false;
        this.isPaused = false;
        this.refDistance = 1;
        this.rolloffFactor = 1;
        this.maxDistance = 100;
        this.distanceModel = "linear";
        this.metadata = null;
        this.onEndedObservable = new Observable();
        this._spatialSound = false;
        this._panningModel = "equalpower";
        this._playbackRate = 1;
        this._streaming = false;
        this._startTime = 0;
        this._startOffset = 0;
        this._position = Vector3.Zero();
        this._localDirection = new Vector3(1, 0, 0);
        this._volume = 1;
        this._isReadyToPlay = false;
        this._isDirectional = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._coneOuterGain = 0;
        this._isOutputConnected = false;
        this._urlType = "Unknown";
        this.name = name105;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this._scene = scene;
        Sound2._SceneComponentInitialization(scene);
        this._readyToPlayCallback = readyToPlayCallback;
        this._customAttenuationFunction = function(currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {
          if (currentDistance < maxDistance) {
            return currentVolume * (1 - currentDistance / maxDistance);
          } else {
            return 0;
          }
        };
        if (options) {
          this.autoplay = options.autoplay || false;
          this._loop = options.loop || false;
          if (options.volume !== void 0) {
            this._volume = options.volume;
          }
          this._spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;
          this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;
          this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;
          this.rolloffFactor = options.rolloffFactor || 1;
          this.refDistance = options.refDistance || 1;
          this.distanceModel = options.distanceModel || "linear";
          this._playbackRate = options.playbackRate || 1;
          this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;
          this._length = options.length;
          this._offset = options.offset;
        }
        if (((_e = Engine.audioEngine) === null || _e === void 0 ? void 0 : _e.canUseWebAudio) && Engine.audioEngine.audioContext) {
          this._soundGain = Engine.audioEngine.audioContext.createGain();
          this._soundGain.gain.value = this._volume;
          this._inputAudioNode = this._soundGain;
          this._outputAudioNode = this._soundGain;
          if (this._spatialSound) {
            this._createSpatialParameters();
          }
          this._scene.mainSoundTrack.addSound(this);
          var validParameter = true;
          if (urlOrArrayBuffer) {
            try {
              if (typeof urlOrArrayBuffer === "string") {
                this._urlType = "String";
              } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
                this._urlType = "ArrayBuffer";
              } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {
                this._urlType = "MediaElement";
              } else if (urlOrArrayBuffer instanceof MediaStream) {
                this._urlType = "MediaStream";
              } else if (Array.isArray(urlOrArrayBuffer)) {
                this._urlType = "Array";
              }
              var urls = [];
              var codecSupportedFound = false;
              switch (this._urlType) {
                case "MediaElement":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "MediaStream":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "ArrayBuffer":
                  if (urlOrArrayBuffer.byteLength > 0) {
                    codecSupportedFound = true;
                    this._soundLoaded(urlOrArrayBuffer);
                  }
                  break;
                case "String":
                  urls.push(urlOrArrayBuffer);
                case "Array":
                  if (urls.length === 0) {
                    urls = urlOrArrayBuffer;
                  }
                  var _loop_1 = function(i2) {
                    var url = urls[i2];
                    codecSupportedFound = options && options.skipCodecCheck || url.indexOf(".mp3", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(".ogg", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(".wav", url.length - 4) !== -1 || url.indexOf(".m4a", url.length - 4) !== -1 || url.indexOf(".mp4", url.length - 4) !== -1 || url.indexOf("blob:") !== -1;
                    if (codecSupportedFound) {
                      if (!this_1._streaming) {
                        this_1._scene._loadFile(url, function(data) {
                          _this._soundLoaded(data);
                        }, void 0, true, true, function(exception) {
                          if (exception) {
                            Logger.Error("XHR " + exception.status + " error on: " + url + ".");
                          }
                          Logger.Error("Sound creation aborted.");
                          _this._scene.mainSoundTrack.removeSound(_this);
                        });
                      } else {
                        this_1._htmlAudioElement = new Audio(url);
                        this_1._htmlAudioElement.controls = false;
                        this_1._htmlAudioElement.loop = this_1.loop;
                        Tools.SetCorsBehavior(url, this_1._htmlAudioElement);
                        this_1._htmlAudioElement.preload = "auto";
                        this_1._htmlAudioElement.addEventListener("canplaythrough", function() {
                          _this._isReadyToPlay = true;
                          if (_this.autoplay) {
                            _this.play(0, _this._offset, _this._length);
                          }
                          if (_this._readyToPlayCallback) {
                            _this._readyToPlayCallback();
                          }
                        });
                        document.body.appendChild(this_1._htmlAudioElement);
                        this_1._htmlAudioElement.load();
                      }
                      return "break";
                    }
                  };
                  var this_1 = this;
                  for (var i = 0; i < urls.length; i++) {
                    var state_1 = _loop_1(i);
                    if (state_1 === "break")
                      break;
                  }
                  break;
                default:
                  validParameter = false;
                  break;
              }
              if (!validParameter) {
                Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
              } else {
                if (!codecSupportedFound) {
                  this._isReadyToPlay = true;
                  if (this._readyToPlayCallback) {
                    window.setTimeout(function() {
                      if (_this._readyToPlayCallback) {
                        _this._readyToPlayCallback();
                      }
                    }, 1e3);
                  }
                }
              }
            } catch (ex) {
              Logger.Error("Unexpected error. Sound creation aborted.");
              this._scene.mainSoundTrack.removeSound(this);
            }
          }
        } else {
          this._scene.mainSoundTrack.addSound(this);
          if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {
            Logger.Error("Web Audio is not supported by your browser.");
            Engine.audioEngine.WarnedWebAudioUnsupported = true;
          }
          if (this._readyToPlayCallback) {
            window.setTimeout(function() {
              if (_this._readyToPlayCallback) {
                _this._readyToPlayCallback();
              }
            }, 1e3);
          }
        }
      }
      Object.defineProperty(Sound2.prototype, "loop", {
        get: function() {
          return this._loop;
        },
        set: function(value) {
          if (value === this._loop) {
            return;
          }
          this._loop = value;
          this.updateOptions({ loop: value });
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sound2.prototype, "currentTime", {
        get: function() {
          var _a;
          if (this._htmlAudioElement) {
            return this._htmlAudioElement.currentTime;
          }
          var currentTime = this._startOffset;
          if (this.isPlaying && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
            currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;
          }
          return currentTime;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sound2.prototype, "spatialSound", {
        get: function() {
          return this._spatialSound;
        },
        set: function(newValue) {
          var _a;
          this._spatialSound = newValue;
          if (this._spatialSound && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
            this._createSpatialParameters();
          }
        },
        enumerable: false,
        configurable: true
      });
      Sound2.prototype.dispose = function() {
        var _a;
        if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
          if (this.isPlaying) {
            this.stop();
          }
          this._isReadyToPlay = false;
          if (this.soundTrackId === -1) {
            this._scene.mainSoundTrack.removeSound(this);
          } else if (this._scene.soundTracks) {
            this._scene.soundTracks[this.soundTrackId].removeSound(this);
          }
          if (this._soundGain) {
            this._soundGain.disconnect();
            this._soundGain = null;
          }
          if (this._soundPanner) {
            this._soundPanner.disconnect();
            this._soundPanner = null;
          }
          if (this._soundSource) {
            this._soundSource.disconnect();
            this._soundSource = null;
          }
          this._audioBuffer = null;
          if (this._htmlAudioElement) {
            this._htmlAudioElement.pause();
            this._htmlAudioElement.src = "";
            document.body.removeChild(this._htmlAudioElement);
          }
          if (this._streamingSource) {
            this._streamingSource.disconnect();
          }
          if (this._connectedTransformNode && this._registerFunc) {
            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
            this._connectedTransformNode = null;
          }
        }
      };
      Sound2.prototype.isReady = function() {
        return this._isReadyToPlay;
      };
      Sound2.prototype.getClassName = function() {
        return "Sound";
      };
      Sound2.prototype._soundLoaded = function(audioData) {
        var _this = this;
        var _a;
        if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
          return;
        }
        Engine.audioEngine.audioContext.decodeAudioData(audioData, function(buffer) {
          _this._audioBuffer = buffer;
          _this._isReadyToPlay = true;
          if (_this.autoplay) {
            _this.play(0, _this._offset, _this._length);
          }
          if (_this._readyToPlayCallback) {
            _this._readyToPlayCallback();
          }
        }, function(err) {
          Logger.Error("Error while decoding audio data for: " + _this.name + " / Error: " + err);
        });
      };
      Sound2.prototype.setAudioBuffer = function(audioBuffer) {
        var _a;
        if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
          this._audioBuffer = audioBuffer;
          this._isReadyToPlay = true;
        }
      };
      Sound2.prototype.updateOptions = function(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (options) {
          this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;
          this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;
          this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;
          this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;
          this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;
          this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;
          this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;
          this._length = (_h = options.length) !== null && _h !== void 0 ? _h : void 0;
          this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : void 0;
          this.setVolume((_k = options.volume) !== null && _k !== void 0 ? _k : this._volume);
          this._updateSpatialParameters();
          if (this.isPlaying) {
            if (this._streaming && this._htmlAudioElement) {
              this._htmlAudioElement.playbackRate = this._playbackRate;
              if (this._htmlAudioElement.loop !== this.loop) {
                this._htmlAudioElement.loop = this.loop;
              }
            } else {
              if (this._soundSource) {
                this._soundSource.playbackRate.value = this._playbackRate;
                if (this._soundSource.loop !== this.loop) {
                  this._soundSource.loop = this.loop;
                }
                if (this._offset !== void 0 && this._soundSource.loopStart !== this._offset) {
                  this._soundSource.loopStart = this._offset;
                }
                if (this._length !== void 0 && this._length !== this._soundSource.loopEnd) {
                  this._soundSource.loopEnd = (this._offset | 0) + this._length;
                }
              }
            }
          }
        }
      };
      Sound2.prototype._createSpatialParameters = function() {
        var _a, _b;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
          if (this._scene.headphone) {
            this._panningModel = "HRTF";
          }
          this._soundPanner = (_b = this._soundPanner) !== null && _b !== void 0 ? _b : Engine.audioEngine.audioContext.createPanner();
          if (this._soundPanner && this._outputAudioNode) {
            this._updateSpatialParameters();
            this._soundPanner.connect(this._outputAudioNode);
            this._inputAudioNode = this._soundPanner;
          }
        }
      };
      Sound2.prototype._updateSpatialParameters = function() {
        if (this._spatialSound && this._soundPanner) {
          if (this.useCustomAttenuation) {
            this._soundPanner.distanceModel = "linear";
            this._soundPanner.maxDistance = Number.MAX_VALUE;
            this._soundPanner.refDistance = 1;
            this._soundPanner.rolloffFactor = 1;
            this._soundPanner.panningModel = this._panningModel;
          } else {
            this._soundPanner.distanceModel = this.distanceModel;
            this._soundPanner.maxDistance = this.maxDistance;
            this._soundPanner.refDistance = this.refDistance;
            this._soundPanner.rolloffFactor = this.rolloffFactor;
            this._soundPanner.panningModel = this._panningModel;
          }
        }
      };
      Sound2.prototype.switchPanningModelToHRTF = function() {
        this._panningModel = "HRTF";
        this._switchPanningModel();
      };
      Sound2.prototype.switchPanningModelToEqualPower = function() {
        this._panningModel = "equalpower";
        this._switchPanningModel();
      };
      Sound2.prototype._switchPanningModel = function() {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
          this._soundPanner.panningModel = this._panningModel;
        }
      };
      Sound2.prototype.connectToSoundTrackAudioNode = function(soundTrackAudioNode) {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          if (this._isOutputConnected) {
            this._outputAudioNode.disconnect();
          }
          this._outputAudioNode.connect(soundTrackAudioNode);
          this._isOutputConnected = true;
        }
      };
      Sound2.prototype.setDirectionalCone = function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        if (coneOuterAngle < coneInnerAngle) {
          Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneInnerAngle = coneInnerAngle;
        this._coneOuterAngle = coneOuterAngle;
        this._coneOuterGain = coneOuterGain;
        this._isDirectional = true;
        if (this.isPlaying && this.loop) {
          this.stop();
          this.play(0, this._offset, this._length);
        }
      };
      Object.defineProperty(Sound2.prototype, "directionalConeInnerAngle", {
        get: function() {
          return this._coneInnerAngle;
        },
        set: function(value) {
          var _a;
          if (value != this._coneInnerAngle) {
            if (this._coneOuterAngle < value) {
              Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
              return;
            }
            this._coneInnerAngle = value;
            if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
              this._soundPanner.coneInnerAngle = this._coneInnerAngle;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sound2.prototype, "directionalConeOuterAngle", {
        get: function() {
          return this._coneOuterAngle;
        },
        set: function(value) {
          var _a;
          if (value != this._coneOuterAngle) {
            if (value < this._coneInnerAngle) {
              Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
              return;
            }
            this._coneOuterAngle = value;
            if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
              this._soundPanner.coneOuterAngle = this._coneOuterAngle;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Sound2.prototype.setPosition = function(newPosition) {
        var _a;
        if (newPosition.equals(this._position)) {
          return;
        }
        this._position.copyFrom(newPosition);
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
          this._soundPanner.positionX.value = this._position.x;
          this._soundPanner.positionY.value = this._position.y;
          this._soundPanner.positionZ.value = this._position.z;
        }
      };
      Sound2.prototype.setLocalDirectionToMesh = function(newLocalDirection) {
        var _a;
        this._localDirection = newLocalDirection;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {
          this._updateDirection();
        }
      };
      Sound2.prototype._updateDirection = function() {
        if (!this._connectedTransformNode || !this._soundPanner) {
          return;
        }
        var mat = this._connectedTransformNode.getWorldMatrix();
        var direction = Vector3.TransformNormal(this._localDirection, mat);
        direction.normalize();
        this._soundPanner.orientationX.value = direction.x;
        this._soundPanner.orientationY.value = direction.y;
        this._soundPanner.orientationZ.value = direction.z;
      };
      Sound2.prototype.updateDistanceFromListener = function() {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
          var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
          this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
        }
      };
      Sound2.prototype.setAttenuationFunction = function(callback) {
        this._customAttenuationFunction = callback;
      };
      Sound2.prototype.play = function(time, offset, length) {
        var _this = this;
        var _a, _b, _c, _d;
        if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
          try {
            if (this._startOffset < 0) {
              time = -this._startOffset;
              this._startOffset = 0;
            }
            var startTime_1 = time ? ((_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime;
            if (!this._soundSource || !this._streamingSource) {
              if (this._spatialSound && this._soundPanner) {
                if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
                  this._soundPanner.positionX.value = this._position.x;
                  this._soundPanner.positionY.value = this._position.y;
                  this._soundPanner.positionZ.value = this._position.z;
                }
                if (this._isDirectional) {
                  this._soundPanner.coneInnerAngle = this._coneInnerAngle;
                  this._soundPanner.coneOuterAngle = this._coneOuterAngle;
                  this._soundPanner.coneOuterGain = this._coneOuterGain;
                  if (this._connectedTransformNode) {
                    this._updateDirection();
                  } else {
                    this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);
                  }
                }
              }
            }
            if (this._streaming) {
              if (!this._streamingSource) {
                this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);
                this._htmlAudioElement.onended = function() {
                  _this._onended();
                };
                this._htmlAudioElement.playbackRate = this._playbackRate;
              }
              this._streamingSource.disconnect();
              if (this._inputAudioNode) {
                this._streamingSource.connect(this._inputAudioNode);
              }
              if (this._htmlAudioElement) {
                var tryToPlay_1 = function() {
                  var _a2, _b2;
                  if ((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.unlocked) {
                    var playPromise = _this._htmlAudioElement.play();
                    if (playPromise !== void 0) {
                      playPromise.catch(function() {
                        var _a3, _b3;
                        (_a3 = Engine.audioEngine) === null || _a3 === void 0 ? void 0 : _a3.lock();
                        if (_this.loop || _this.autoplay) {
                          (_b3 = Engine.audioEngine) === null || _b3 === void 0 ? void 0 : _b3.onAudioUnlockedObservable.addOnce(function() {
                            tryToPlay_1();
                          });
                        }
                      });
                    }
                  } else {
                    if (_this.loop || _this.autoplay) {
                      (_b2 = Engine.audioEngine) === null || _b2 === void 0 ? void 0 : _b2.onAudioUnlockedObservable.addOnce(function() {
                        tryToPlay_1();
                      });
                    }
                  }
                };
                tryToPlay_1();
              }
            } else {
              var tryToPlay_2 = function() {
                var _a2, _b2, _c2;
                if ((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.audioContext) {
                  length = length || _this._length;
                  offset = offset || _this._offset;
                  if (_this._soundSource) {
                    var oldSource_1 = _this._soundSource;
                    oldSource_1.onended = function() {
                      oldSource_1.disconnect();
                    };
                  }
                  _this._soundSource = (_b2 = Engine.audioEngine) === null || _b2 === void 0 ? void 0 : _b2.audioContext.createBufferSource();
                  if (_this._soundSource && _this._inputAudioNode) {
                    _this._soundSource.buffer = _this._audioBuffer;
                    _this._soundSource.connect(_this._inputAudioNode);
                    _this._soundSource.loop = _this.loop;
                    if (offset !== void 0) {
                      _this._soundSource.loopStart = offset;
                    }
                    if (length !== void 0) {
                      _this._soundSource.loopEnd = (offset | 0) + length;
                    }
                    _this._soundSource.playbackRate.value = _this._playbackRate;
                    _this._soundSource.onended = function() {
                      _this._onended();
                    };
                    startTime_1 = time ? ((_c2 = Engine.audioEngine) === null || _c2 === void 0 ? void 0 : _c2.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;
                    var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;
                    _this._soundSource.start(startTime_1, actualOffset, _this.loop ? void 0 : length);
                  }
                }
              };
              if (((_d = Engine.audioEngine) === null || _d === void 0 ? void 0 : _d.audioContext.state) === "suspended") {
                setTimeout(function() {
                  var _a2;
                  if (((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.audioContext.state) === "suspended") {
                    Engine.audioEngine.lock();
                    if (_this.loop || _this.autoplay) {
                      Engine.audioEngine.onAudioUnlockedObservable.addOnce(function() {
                        tryToPlay_2();
                      });
                    }
                  } else {
                    tryToPlay_2();
                  }
                }, 500);
              } else {
                tryToPlay_2();
              }
            }
            this._startTime = startTime_1;
            this.isPlaying = true;
            this.isPaused = false;
          } catch (ex) {
            Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
          }
        }
      };
      Sound2.prototype._onended = function() {
        this.isPlaying = false;
        this._startOffset = 0;
        if (this.onended) {
          this.onended();
        }
        this.onEndedObservable.notifyObservers(this);
      };
      Sound2.prototype.stop = function(time) {
        var _this = this;
        var _a;
        if (this.isPlaying) {
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
              if (this._htmlAudioElement.currentTime > 0) {
                this._htmlAudioElement.currentTime = 0;
              }
            } else {
              this._streamingSource.disconnect();
            }
            this.isPlaying = false;
          } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {
            var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : void 0;
            this._soundSource.stop(stopTime);
            if (stopTime === void 0) {
              this.isPlaying = false;
              this._soundSource.onended = function() {
                return void 0;
              };
            } else {
              this._soundSource.onended = function() {
                _this.isPlaying = false;
              };
            }
            if (!this.isPaused) {
              this._startOffset = 0;
            }
          }
        }
      };
      Sound2.prototype.pause = function() {
        var _a;
        if (this.isPlaying) {
          this.isPaused = true;
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
            } else {
              this._streamingSource.disconnect();
            }
            this.isPlaying = false;
          } else if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {
            this.stop(0);
            this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;
          }
        }
      };
      Sound2.prototype.setVolume = function(newVolume, time) {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._soundGain) {
          if (time && Engine.audioEngine.audioContext) {
            this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);
          } else {
            this._soundGain.gain.value = newVolume;
          }
        }
        this._volume = newVolume;
      };
      Sound2.prototype.setPlaybackRate = function(newPlaybackRate) {
        this._playbackRate = newPlaybackRate;
        if (this.isPlaying) {
          if (this._streaming && this._htmlAudioElement) {
            this._htmlAudioElement.playbackRate = this._playbackRate;
          } else if (this._soundSource) {
            this._soundSource.playbackRate.value = this._playbackRate;
          }
        }
      };
      Sound2.prototype.getVolume = function() {
        return this._volume;
      };
      Sound2.prototype.attachToMesh = function(transformNode) {
        var _this = this;
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
        }
        this._connectedTransformNode = transformNode;
        if (!this._spatialSound) {
          this._spatialSound = true;
          this._createSpatialParameters();
          if (this.isPlaying && this.loop) {
            this.stop();
            this.play(0, this._offset, this._length);
          }
        }
        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
        this._registerFunc = function(transformNode2) {
          return _this._onRegisterAfterWorldMatrixUpdate(transformNode2);
        };
        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
      };
      Sound2.prototype.detachFromMesh = function() {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
          this._connectedTransformNode = null;
        }
      };
      Sound2.prototype._onRegisterAfterWorldMatrixUpdate = function(node) {
        var _a;
        if (!node.getBoundingInfo) {
          this.setPosition(node.absolutePosition);
        } else {
          var mesh = node;
          var boundingInfo = mesh.getBoundingInfo();
          this.setPosition(boundingInfo.boundingSphere.centerWorld);
        }
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {
          this._updateDirection();
        }
      };
      Sound2.prototype.clone = function() {
        var _this = this;
        if (!this._streaming) {
          var setBufferAndRun_1 = function() {
            if (_this._isReadyToPlay) {
              clonedSound_1._audioBuffer = _this.getAudioBuffer();
              clonedSound_1._isReadyToPlay = true;
              if (clonedSound_1.autoplay) {
                clonedSound_1.play(0, _this._offset, _this._length);
              }
            } else {
              window.setTimeout(setBufferAndRun_1, 300);
            }
          };
          var currentOptions = {
            autoplay: this.autoplay,
            loop: this.loop,
            volume: this._volume,
            spatialSound: this._spatialSound,
            maxDistance: this.maxDistance,
            useCustomAttenuation: this.useCustomAttenuation,
            rolloffFactor: this.rolloffFactor,
            refDistance: this.refDistance,
            distanceModel: this.distanceModel
          };
          var clonedSound_1 = new Sound2(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, currentOptions);
          if (this.useCustomAttenuation) {
            clonedSound_1.setAttenuationFunction(this._customAttenuationFunction);
          }
          clonedSound_1.setPosition(this._position);
          clonedSound_1.setPlaybackRate(this._playbackRate);
          setBufferAndRun_1();
          return clonedSound_1;
        } else {
          return null;
        }
      };
      Sound2.prototype.getAudioBuffer = function() {
        return this._audioBuffer;
      };
      Sound2.prototype.getSoundSource = function() {
        return this._soundSource;
      };
      Sound2.prototype.getSoundGain = function() {
        return this._soundGain;
      };
      Sound2.prototype.serialize = function() {
        var serializationObject = {
          name: this.name,
          url: this.name,
          autoplay: this.autoplay,
          loop: this.loop,
          volume: this._volume,
          spatialSound: this._spatialSound,
          maxDistance: this.maxDistance,
          rolloffFactor: this.rolloffFactor,
          refDistance: this.refDistance,
          distanceModel: this.distanceModel,
          playbackRate: this._playbackRate,
          panningModel: this._panningModel,
          soundTrackId: this.soundTrackId,
          metadata: this.metadata
        };
        if (this._spatialSound) {
          if (this._connectedTransformNode) {
            serializationObject.connectedMeshId = this._connectedTransformNode.id;
          }
          serializationObject.position = this._position.asArray();
          serializationObject.refDistance = this.refDistance;
          serializationObject.distanceModel = this.distanceModel;
          serializationObject.isDirectional = this._isDirectional;
          serializationObject.localDirectionToMesh = this._localDirection.asArray();
          serializationObject.coneInnerAngle = this._coneInnerAngle;
          serializationObject.coneOuterAngle = this._coneOuterAngle;
          serializationObject.coneOuterGain = this._coneOuterGain;
        }
        return serializationObject;
      };
      Sound2.Parse = function(parsedSound, scene, rootUrl, sourceSound) {
        var soundName = parsedSound.name;
        var soundUrl;
        if (parsedSound.url) {
          soundUrl = rootUrl + parsedSound.url;
        } else {
          soundUrl = rootUrl + soundName;
        }
        var options = {
          autoplay: parsedSound.autoplay,
          loop: parsedSound.loop,
          volume: parsedSound.volume,
          spatialSound: parsedSound.spatialSound,
          maxDistance: parsedSound.maxDistance,
          rolloffFactor: parsedSound.rolloffFactor,
          refDistance: parsedSound.refDistance,
          distanceModel: parsedSound.distanceModel,
          playbackRate: parsedSound.playbackRate
        };
        var newSound;
        if (!sourceSound) {
          newSound = new Sound2(soundName, soundUrl, scene, function() {
            scene._removePendingData(newSound);
          }, options);
          scene._addPendingData(newSound);
        } else {
          var setBufferAndRun_2 = function() {
            if (sourceSound._isReadyToPlay) {
              newSound._audioBuffer = sourceSound.getAudioBuffer();
              newSound._isReadyToPlay = true;
              if (newSound.autoplay) {
                newSound.play(0, newSound._offset, newSound._length);
              }
            } else {
              window.setTimeout(setBufferAndRun_2, 300);
            }
          };
          newSound = new Sound2(soundName, new ArrayBuffer(0), scene, null, options);
          setBufferAndRun_2();
        }
        if (parsedSound.position) {
          var soundPosition = Vector3.FromArray(parsedSound.position);
          newSound.setPosition(soundPosition);
        }
        if (parsedSound.isDirectional) {
          newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
          if (parsedSound.localDirectionToMesh) {
            var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
            newSound.setLocalDirectionToMesh(localDirectionToMesh);
          }
        }
        if (parsedSound.connectedMeshId) {
          var connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);
          if (connectedMesh) {
            newSound.attachToMesh(connectedMesh);
          }
        }
        if (parsedSound.metadata) {
          newSound.metadata = parsedSound.metadata;
        }
        return newSound;
      };
      Sound2._SceneComponentInitialization = function(_) {
        throw _WarnImport("AudioSceneComponent");
      };
      return Sound2;
    }();
  }
});

// node_modules/@babylonjs/core/Audio/weightedsound.js
var WeightedSound;
var init_weightedsound = __esm({
  "node_modules/@babylonjs/core/Audio/weightedsound.js"() {
    init_logger();
    WeightedSound = function() {
      function WeightedSound2(loop, sounds, weights) {
        var _this = this;
        this.loop = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._volume = 1;
        this.isPlaying = false;
        this.isPaused = false;
        this._sounds = [];
        this._weights = [];
        if (sounds.length !== weights.length) {
          throw new Error("Sounds length does not equal weights length");
        }
        this.loop = loop;
        this._weights = weights;
        var weightSum = 0;
        for (var _i = 0, weights_1 = weights; _i < weights_1.length; _i++) {
          var weight = weights_1[_i];
          weightSum += weight;
        }
        var invWeightSum = weightSum > 0 ? 1 / weightSum : 0;
        for (var i = 0; i < this._weights.length; i++) {
          this._weights[i] *= invWeightSum;
        }
        this._sounds = sounds;
        for (var _a = 0, _b = this._sounds; _a < _b.length; _a++) {
          var sound = _b[_a];
          sound.onEndedObservable.add(function() {
            _this._onended();
          });
        }
      }
      Object.defineProperty(WeightedSound2.prototype, "directionalConeInnerAngle", {
        get: function() {
          return this._coneInnerAngle;
        },
        set: function(value) {
          if (value !== this._coneInnerAngle) {
            if (this._coneOuterAngle < value) {
              Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
              return;
            }
            this._coneInnerAngle = value;
            for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
              var sound = _a[_i];
              sound.directionalConeInnerAngle = value;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WeightedSound2.prototype, "directionalConeOuterAngle", {
        get: function() {
          return this._coneOuterAngle;
        },
        set: function(value) {
          if (value !== this._coneOuterAngle) {
            if (value < this._coneInnerAngle) {
              Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
              return;
            }
            this._coneOuterAngle = value;
            for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
              var sound = _a[_i];
              sound.directionalConeOuterAngle = value;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WeightedSound2.prototype, "volume", {
        get: function() {
          return this._volume;
        },
        set: function(value) {
          if (value !== this._volume) {
            for (var _i = 0, _a = this._sounds; _i < _a.length; _i++) {
              var sound = _a[_i];
              sound.setVolume(value);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      WeightedSound2.prototype._onended = function() {
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].autoplay = false;
        }
        if (this.loop && this.isPlaying) {
          this.play();
        } else {
          this.isPlaying = false;
        }
      };
      WeightedSound2.prototype.pause = function() {
        this.isPaused = true;
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].pause();
        }
      };
      WeightedSound2.prototype.stop = function() {
        this.isPlaying = false;
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].stop();
        }
      };
      WeightedSound2.prototype.play = function(startOffset) {
        if (!this.isPaused) {
          this.stop();
          var randomValue = Math.random();
          var total = 0;
          for (var i = 0; i < this._weights.length; i++) {
            total += this._weights[i];
            if (randomValue <= total) {
              this._currentIndex = i;
              break;
            }
          }
        }
        var sound = this._sounds[this._currentIndex];
        if (sound.isReady()) {
          sound.play(0, this.isPaused ? void 0 : startOffset);
        } else {
          sound.autoplay = true;
        }
        this.isPlaying = true;
        this.isPaused = false;
      };
      return WeightedSound2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/thinTexture.js
var ThinTexture;
var init_thinTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/thinTexture.js"() {
    init_math_size();
    ThinTexture = function() {
      function ThinTexture2(internalTexture) {
        this._wrapU = 1;
        this._wrapV = 1;
        this.wrapR = 1;
        this.anisotropicFilteringLevel = 4;
        this.delayLoadState = 0;
        this._texture = null;
        this._engine = null;
        this._cachedSize = Size.Zero();
        this._cachedBaseSize = Size.Zero();
        this._initialSamplingMode = 2;
        this._texture = internalTexture;
        if (this._texture) {
          this._engine = this._texture.getEngine();
        }
      }
      Object.defineProperty(ThinTexture2.prototype, "wrapU", {
        get: function() {
          return this._wrapU;
        },
        set: function(value) {
          this._wrapU = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinTexture2.prototype, "wrapV", {
        get: function() {
          return this._wrapV;
        },
        set: function(value) {
          this._wrapV = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinTexture2.prototype, "coordinatesMode", {
        get: function() {
          return 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinTexture2.prototype, "isCube", {
        get: function() {
          if (!this._texture) {
            return false;
          }
          return this._texture.isCube;
        },
        set: function(value) {
          if (!this._texture) {
            return;
          }
          this._texture.isCube = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinTexture2.prototype, "is3D", {
        get: function() {
          if (!this._texture) {
            return false;
          }
          return this._texture.is3D;
        },
        set: function(value) {
          if (!this._texture) {
            return;
          }
          this._texture.is3D = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ThinTexture2.prototype, "is2DArray", {
        get: function() {
          if (!this._texture) {
            return false;
          }
          return this._texture.is2DArray;
        },
        set: function(value) {
          if (!this._texture) {
            return;
          }
          this._texture.is2DArray = value;
        },
        enumerable: false,
        configurable: true
      });
      ThinTexture2.prototype.getClassName = function() {
        return "ThinTexture";
      };
      ThinTexture2.prototype.isReady = function() {
        if (this.delayLoadState === 4) {
          this.delayLoad();
          return false;
        }
        if (this._texture) {
          return this._texture.isReady;
        }
        return false;
      };
      ThinTexture2.prototype.delayLoad = function() {
      };
      ThinTexture2.prototype.getInternalTexture = function() {
        return this._texture;
      };
      ThinTexture2.prototype.getSize = function() {
        if (this._texture) {
          if (this._texture.width) {
            this._cachedSize.width = this._texture.width;
            this._cachedSize.height = this._texture.height;
            return this._cachedSize;
          }
          if (this._texture._size) {
            this._cachedSize.width = this._texture._size;
            this._cachedSize.height = this._texture._size;
            return this._cachedSize;
          }
        }
        return this._cachedSize;
      };
      ThinTexture2.prototype.getBaseSize = function() {
        if (!this.isReady() || !this._texture) {
          this._cachedBaseSize.width = 0;
          this._cachedBaseSize.height = 0;
          return this._cachedBaseSize;
        }
        if (this._texture._size) {
          this._cachedBaseSize.width = this._texture._size;
          this._cachedBaseSize.height = this._texture._size;
          return this._cachedBaseSize;
        }
        this._cachedBaseSize.width = this._texture.baseWidth;
        this._cachedBaseSize.height = this._texture.baseHeight;
        return this._cachedBaseSize;
      };
      Object.defineProperty(ThinTexture2.prototype, "samplingMode", {
        get: function() {
          if (!this._texture) {
            return this._initialSamplingMode;
          }
          return this._texture.samplingMode;
        },
        enumerable: false,
        configurable: true
      });
      ThinTexture2.prototype.updateSamplingMode = function(samplingMode) {
        if (this._texture && this._engine) {
          this._engine.updateTextureSamplingMode(samplingMode, this._texture);
        }
      };
      ThinTexture2.prototype.releaseInternalTexture = function() {
        if (this._texture) {
          this._texture.dispose();
          this._texture = null;
        }
      };
      ThinTexture2.prototype.dispose = function() {
        if (this._texture) {
          this.releaseInternalTexture();
          this._engine = null;
        }
      };
      return ThinTexture2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.js
var BaseTexture;
var init_baseTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/baseTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_engineStore();
    init_guid();
    init_fileTools();
    init_thinTexture();
    BaseTexture = function(_super) {
      __extends(BaseTexture2, _super);
      function BaseTexture2(sceneOrEngine) {
        var _this = _super.call(this, null) || this;
        _this.metadata = null;
        _this.reservedDataStore = null;
        _this._hasAlpha = false;
        _this._getAlphaFromRGB = false;
        _this.level = 1;
        _this._coordinatesIndex = 0;
        _this._coordinatesMode = 0;
        _this.wrapR = 1;
        _this.anisotropicFilteringLevel = BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
        _this._isCube = false;
        _this._gammaSpace = true;
        _this.invertZ = false;
        _this.lodLevelInAlpha = false;
        _this.isRenderTarget = false;
        _this._prefiltered = false;
        _this._forceSerialize = false;
        _this.animations = new Array();
        _this.onDisposeObservable = new Observable();
        _this._onDisposeObserver = null;
        _this._scene = null;
        _this._uid = null;
        _this._parentContainer = null;
        _this._loadingError = false;
        if (sceneOrEngine) {
          if (BaseTexture2._IsScene(sceneOrEngine)) {
            _this._scene = sceneOrEngine;
          } else {
            _this._engine = sceneOrEngine;
          }
        } else {
          _this._scene = EngineStore.LastCreatedScene;
        }
        if (_this._scene) {
          _this.uniqueId = _this._scene.getUniqueId();
          _this._scene.addTexture(_this);
          _this._engine = _this._scene.getEngine();
        }
        _this._uid = null;
        return _this;
      }
      Object.defineProperty(BaseTexture2.prototype, "hasAlpha", {
        get: function() {
          return this._hasAlpha;
        },
        set: function(value) {
          var _this = this;
          if (this._hasAlpha === value) {
            return;
          }
          this._hasAlpha = value;
          if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, function(mat) {
              return mat.hasTexture(_this);
            });
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "getAlphaFromRGB", {
        get: function() {
          return this._getAlphaFromRGB;
        },
        set: function(value) {
          var _this = this;
          if (this._getAlphaFromRGB === value) {
            return;
          }
          this._getAlphaFromRGB = value;
          if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, function(mat) {
              return mat.hasTexture(_this);
            });
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "coordinatesIndex", {
        get: function() {
          return this._coordinatesIndex;
        },
        set: function(value) {
          var _this = this;
          if (this._coordinatesIndex === value) {
            return;
          }
          this._coordinatesIndex = value;
          if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, function(mat) {
              return mat.hasTexture(_this);
            });
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "coordinatesMode", {
        get: function() {
          return this._coordinatesMode;
        },
        set: function(value) {
          var _this = this;
          if (this._coordinatesMode === value) {
            return;
          }
          this._coordinatesMode = value;
          if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, function(mat) {
              return mat.hasTexture(_this);
            });
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "wrapU", {
        get: function() {
          return this._wrapU;
        },
        set: function(value) {
          this._wrapU = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "wrapV", {
        get: function() {
          return this._wrapV;
        },
        set: function(value) {
          this._wrapV = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "isCube", {
        get: function() {
          if (!this._texture) {
            return this._isCube;
          }
          return this._texture.isCube;
        },
        set: function(value) {
          if (!this._texture) {
            this._isCube = value;
          } else {
            this._texture.isCube = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "is3D", {
        get: function() {
          if (!this._texture) {
            return false;
          }
          return this._texture.is3D;
        },
        set: function(value) {
          if (!this._texture) {
            return;
          }
          this._texture.is3D = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "is2DArray", {
        get: function() {
          if (!this._texture) {
            return false;
          }
          return this._texture.is2DArray;
        },
        set: function(value) {
          if (!this._texture) {
            return;
          }
          this._texture.is2DArray = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "gammaSpace", {
        get: function() {
          if (!this._texture) {
            return this._gammaSpace;
          } else {
            if (this._texture._gammaSpace === null) {
              this._texture._gammaSpace = this._gammaSpace;
            }
          }
          return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
        },
        set: function(gamma) {
          if (!this._texture) {
            if (this._gammaSpace === gamma) {
              return;
            }
            this._gammaSpace = gamma;
          } else {
            if (this._texture._gammaSpace === gamma) {
              return;
            }
            this._texture._gammaSpace = gamma;
          }
          this._markAllSubMeshesAsTexturesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "isRGBD", {
        get: function() {
          return this._texture != null && this._texture._isRGBD;
        },
        set: function(value) {
          if (this._texture) {
            this._texture._isRGBD = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "noMipmap", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "lodGenerationOffset", {
        get: function() {
          if (this._texture) {
            return this._texture._lodGenerationOffset;
          }
          return 0;
        },
        set: function(value) {
          if (this._texture) {
            this._texture._lodGenerationOffset = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "lodGenerationScale", {
        get: function() {
          if (this._texture) {
            return this._texture._lodGenerationScale;
          }
          return 0;
        },
        set: function(value) {
          if (this._texture) {
            this._texture._lodGenerationScale = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "linearSpecularLOD", {
        get: function() {
          if (this._texture) {
            return this._texture._linearSpecularLOD;
          }
          return false;
        },
        set: function(value) {
          if (this._texture) {
            this._texture._linearSpecularLOD = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "irradianceTexture", {
        get: function() {
          if (this._texture) {
            return this._texture._irradianceTexture;
          }
          return null;
        },
        set: function(value) {
          if (this._texture) {
            this._texture._irradianceTexture = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "uid", {
        get: function() {
          if (!this._uid) {
            this._uid = RandomGUID();
          }
          return this._uid;
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.toString = function() {
        return this.name;
      };
      BaseTexture2.prototype.getClassName = function() {
        return "BaseTexture";
      };
      Object.defineProperty(BaseTexture2.prototype, "onDispose", {
        set: function(callback) {
          if (this._onDisposeObserver) {
            this.onDisposeObservable.remove(this._onDisposeObserver);
          }
          this._onDisposeObserver = this.onDisposeObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "isBlocking", {
        get: function() {
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "loadingError", {
        get: function() {
          return this._loadingError;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "errorObject", {
        get: function() {
          return this._errorObject;
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.getScene = function() {
        return this._scene;
      };
      BaseTexture2.prototype._getEngine = function() {
        return this._engine;
      };
      BaseTexture2.prototype.checkTransformsAreIdentical = function(texture) {
        return texture !== null;
      };
      BaseTexture2.prototype.getTextureMatrix = function() {
        return Matrix.IdentityReadOnly;
      };
      BaseTexture2.prototype.getReflectionTextureMatrix = function() {
        return Matrix.IdentityReadOnly;
      };
      BaseTexture2.prototype.isReadyOrNotBlocking = function() {
        return !this.isBlocking || this.isReady() || this.loadingError;
      };
      BaseTexture2.prototype.scale = function(ratio) {
      };
      Object.defineProperty(BaseTexture2.prototype, "canRescale", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype._getFromCache = function(url, noMipmap, sampling, invertY, useSRGBBuffer) {
        var engine = this._getEngine();
        if (!engine) {
          return null;
        }
        var correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
        var texturesCache = engine.getLoadedTexturesCache();
        for (var index = 0; index < texturesCache.length; index++) {
          var texturesCacheEntry = texturesCache[index];
          if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
            if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
              if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
                if (!sampling || sampling === texturesCacheEntry.samplingMode) {
                  texturesCacheEntry.incrementReferences();
                  return texturesCacheEntry;
                }
              }
            }
          }
        }
        return null;
      };
      BaseTexture2.prototype._rebuild = function() {
      };
      BaseTexture2.prototype.clone = function() {
        return null;
      };
      Object.defineProperty(BaseTexture2.prototype, "textureType", {
        get: function() {
          if (!this._texture) {
            return 0;
          }
          return this._texture.type !== void 0 ? this._texture.type : 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "textureFormat", {
        get: function() {
          if (!this._texture) {
            return 5;
          }
          return this._texture.format !== void 0 ? this._texture.format : 5;
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        scene.markAllMaterialsAsDirty(1);
      };
      BaseTexture2.prototype.readPixels = function(faceIndex, level, buffer, flushRenderer, noDataConversion, x, y, width, height) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (level === void 0) {
          level = 0;
        }
        if (buffer === void 0) {
          buffer = null;
        }
        if (flushRenderer === void 0) {
          flushRenderer = true;
        }
        if (noDataConversion === void 0) {
          noDataConversion = false;
        }
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (width === void 0) {
          width = Number.MAX_VALUE;
        }
        if (height === void 0) {
          height = Number.MAX_VALUE;
        }
        if (!this._texture) {
          return null;
        }
        var engine = this._getEngine();
        if (!engine) {
          return null;
        }
        var size = this.getSize();
        var maxWidth = size.width;
        var maxHeight = size.height;
        if (level !== 0) {
          maxWidth = maxWidth / Math.pow(2, level);
          maxHeight = maxHeight / Math.pow(2, level);
          maxWidth = Math.round(maxWidth);
          maxHeight = Math.round(maxHeight);
        }
        width = Math.min(maxWidth, width);
        height = Math.min(maxHeight, height);
        try {
          if (this._texture.isCube) {
            return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
          }
          return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
        } catch (e) {
          return null;
        }
      };
      BaseTexture2.prototype._readPixelsSync = function(faceIndex, level, buffer, flushRenderer, noDataConversion) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (level === void 0) {
          level = 0;
        }
        if (buffer === void 0) {
          buffer = null;
        }
        if (flushRenderer === void 0) {
          flushRenderer = true;
        }
        if (noDataConversion === void 0) {
          noDataConversion = false;
        }
        if (!this._texture) {
          return null;
        }
        var size = this.getSize();
        var width = size.width;
        var height = size.height;
        var engine = this._getEngine();
        if (!engine) {
          return null;
        }
        if (level != 0) {
          width = width / Math.pow(2, level);
          height = height / Math.pow(2, level);
          width = Math.round(width);
          height = Math.round(height);
        }
        try {
          if (this._texture.isCube) {
            return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
          }
          return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
        } catch (e) {
          return null;
        }
      };
      Object.defineProperty(BaseTexture2.prototype, "_lodTextureHigh", {
        get: function() {
          if (this._texture) {
            return this._texture._lodTextureHigh;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "_lodTextureMid", {
        get: function() {
          if (this._texture) {
            return this._texture._lodTextureMid;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "_lodTextureLow", {
        get: function() {
          if (this._texture) {
            return this._texture._lodTextureLow;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.dispose = function() {
        if (this._scene) {
          if (this._scene.stopAnimation) {
            this._scene.stopAnimation(this);
          }
          this._scene._removePendingData(this);
          var index = this._scene.textures.indexOf(this);
          if (index >= 0) {
            this._scene.textures.splice(index, 1);
          }
          this._scene.onTextureRemovedObservable.notifyObservers(this);
          this._scene = null;
          if (this._parentContainer) {
            var index_1 = this._parentContainer.textures.indexOf(this);
            if (index_1 > -1) {
              this._parentContainer.textures.splice(index_1, 1);
            }
            this._parentContainer = null;
          }
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.metadata = null;
        _super.prototype.dispose.call(this);
      };
      BaseTexture2.prototype.serialize = function() {
        if (!this.name) {
          return null;
        }
        var serializationObject = SerializationHelper.Serialize(this);
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      };
      BaseTexture2.WhenAllReady = function(textures, callback) {
        var numRemaining = textures.length;
        if (numRemaining === 0) {
          callback();
          return;
        }
        for (var i = 0; i < textures.length; i++) {
          var texture = textures[i];
          if (texture.isReady()) {
            if (--numRemaining === 0) {
              callback();
            }
          } else {
            var onLoadObservable = texture.onLoadObservable;
            if (onLoadObservable) {
              onLoadObservable.addOnce(function() {
                if (--numRemaining === 0) {
                  callback();
                }
              });
            } else {
              if (--numRemaining === 0) {
                callback();
              }
            }
          }
        }
      };
      BaseTexture2._IsScene = function(sceneOrEngine) {
        return sceneOrEngine.getClassName() === "Scene";
      };
      BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "uniqueId", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "name", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "metadata", void 0);
      __decorate([
        serialize("hasAlpha")
      ], BaseTexture2.prototype, "_hasAlpha", void 0);
      __decorate([
        serialize("getAlphaFromRGB")
      ], BaseTexture2.prototype, "_getAlphaFromRGB", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "level", void 0);
      __decorate([
        serialize("coordinatesIndex")
      ], BaseTexture2.prototype, "_coordinatesIndex", void 0);
      __decorate([
        serialize("coordinatesMode")
      ], BaseTexture2.prototype, "_coordinatesMode", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "wrapU", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "wrapV", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "wrapR", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "anisotropicFilteringLevel", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "isCube", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "is3D", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "is2DArray", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "gammaSpace", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "invertZ", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "lodLevelInAlpha", void 0);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "lodGenerationOffset", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "lodGenerationScale", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "linearSpecularLOD", null);
      __decorate([
        serializeAsTexture()
      ], BaseTexture2.prototype, "irradianceTexture", null);
      __decorate([
        serialize()
      ], BaseTexture2.prototype, "isRenderTarget", void 0);
      return BaseTexture2;
    }(ThinTexture);
  }
});

// node_modules/@babylonjs/core/Misc/copyTools.js
function GenerateBase64StringFromPixelData(pixels, size, invertY) {
  if (invertY === void 0) {
    invertY = false;
  }
  var width = size.width;
  var height = size.height;
  if (pixels instanceof Float32Array) {
    var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    var npixels = new Uint8Array(len);
    while (--len >= 0) {
      var val = pixels[len];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len] = val * 255;
    }
    pixels = npixels;
  }
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  var imageData = ctx.createImageData(width, height);
  var castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    var canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    var ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  var internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  var pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
function GenerateBase64StringFromTextureAsync(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  return __awaiter(this, void 0, void 0, function() {
    var internalTexture, pixels;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          internalTexture = texture.getInternalTexture();
          if (!internalTexture) {
            return [2, null];
          }
          return [4, texture.readPixels(faceIndex, level)];
        case 1:
          pixels = _a.sent();
          if (!pixels) {
            return [2, null];
          }
          return [2, GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY)];
      }
    });
  });
}
var CopyTools;
var init_copyTools = __esm({
  "node_modules/@babylonjs/core/Misc/copyTools.js"() {
    init_tslib_es6();
    CopyTools = {
      GenerateBase64StringFromPixelData,
      GenerateBase64StringFromTexture,
      GenerateBase64StringFromTextureAsync
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/texture.js
var Texture;
var init_texture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/texture.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_baseTexture();
    init_typeStore();
    init_devTools();
    init_timingTools();
    init_instantiationTools();
    init_math_plane();
    init_stringTools();
    init_copyTools();
    init_compatibilityOptions();
    Texture = function(_super) {
      __extends(Texture2, _super);
      function Texture2(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions, creationFlags) {
        if (samplingMode === void 0) {
          samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (buffer === void 0) {
          buffer = null;
        }
        if (deleteBuffer === void 0) {
          deleteBuffer = false;
        }
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        _this = _super.call(this, sceneOrEngine) || this;
        _this.url = null;
        _this.uOffset = 0;
        _this.vOffset = 0;
        _this.uScale = 1;
        _this.vScale = 1;
        _this.uAng = 0;
        _this.vAng = 0;
        _this.wAng = 0;
        _this.uRotationCenter = 0.5;
        _this.vRotationCenter = 0.5;
        _this.wRotationCenter = 0.5;
        _this.homogeneousRotationInUVTransform = false;
        _this.inspectableCustomProperties = null;
        _this._noMipmap = false;
        _this._invertY = false;
        _this._rowGenerationMatrix = null;
        _this._cachedTextureMatrix = null;
        _this._projectionModeMatrix = null;
        _this._t0 = null;
        _this._t1 = null;
        _this._t2 = null;
        _this._cachedUOffset = -1;
        _this._cachedVOffset = -1;
        _this._cachedUScale = 0;
        _this._cachedVScale = 0;
        _this._cachedUAng = -1;
        _this._cachedVAng = -1;
        _this._cachedWAng = -1;
        _this._cachedProjectionMatrixId = -1;
        _this._cachedURotationCenter = -1;
        _this._cachedVRotationCenter = -1;
        _this._cachedWRotationCenter = -1;
        _this._cachedHomogeneousRotationInUVTransform = false;
        _this._cachedCoordinatesMode = -1;
        _this._buffer = null;
        _this._deleteBuffer = false;
        _this._format = null;
        _this._delayedOnLoad = null;
        _this._delayedOnError = null;
        _this.onLoadObservable = new Observable();
        _this._isBlocking = true;
        _this.name = url || "";
        _this.url = url;
        var noMipmap;
        var useSRGBBuffer = false;
        var internalTexture = null;
        if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
          noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;
          invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;
          samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture2.TRILINEAR_SAMPLINGMODE;
          onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;
          onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;
          buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;
          deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;
          format = noMipmapOrOptions.format;
          mimeType = noMipmapOrOptions.mimeType;
          loaderOptions = noMipmapOrOptions.loaderOptions;
          creationFlags = noMipmapOrOptions.creationFlags;
          useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;
          internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;
        } else {
          noMipmap = !!noMipmapOrOptions;
        }
        _this._noMipmap = noMipmap;
        _this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
        _this._initialSamplingMode = samplingMode;
        _this._buffer = buffer;
        _this._deleteBuffer = deleteBuffer;
        _this._mimeType = mimeType;
        _this._loaderOptions = loaderOptions;
        _this._creationFlags = creationFlags;
        _this._useSRGBBuffer = useSRGBBuffer;
        if (format) {
          _this._format = format;
        }
        var scene = _this.getScene();
        var engine = _this._getEngine();
        if (!engine) {
          return _this;
        }
        engine.onBeforeTextureInitObservable.notifyObservers(_this);
        var load = function() {
          if (_this._texture) {
            if (_this._texture._invertVScale) {
              _this.vScale *= -1;
              _this.vOffset += 1;
            }
            if (_this._texture._cachedWrapU !== null) {
              _this.wrapU = _this._texture._cachedWrapU;
              _this._texture._cachedWrapU = null;
            }
            if (_this._texture._cachedWrapV !== null) {
              _this.wrapV = _this._texture._cachedWrapV;
              _this._texture._cachedWrapV = null;
            }
            if (_this._texture._cachedWrapR !== null) {
              _this.wrapR = _this._texture._cachedWrapR;
              _this._texture._cachedWrapR = null;
            }
          }
          if (_this.onLoadObservable.hasObservers()) {
            _this.onLoadObservable.notifyObservers(_this);
          }
          if (onLoad) {
            onLoad();
          }
          if (!_this.isBlocking && scene) {
            scene.resetCachedMaterial();
          }
        };
        var errorHandler = function(message, exception) {
          _this._loadingError = true;
          _this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture2.OnTextureLoadErrorObservable.notifyObservers(_this);
        };
        if (!_this.url) {
          _this._delayedOnLoad = load;
          _this._delayedOnError = errorHandler;
          return _this;
        }
        _this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : _this._getFromCache(_this.url, noMipmap, samplingMode, _this._invertY, useSRGBBuffer);
        if (!_this._texture) {
          if (!scene || !scene.useDelayedTextureLoading) {
            try {
              _this._texture = engine.createTexture(_this.url, noMipmap, _this._invertY, scene, samplingMode, load, errorHandler, _this._buffer, void 0, _this._format, null, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
            } catch (e) {
              errorHandler("error loading", e);
              throw e;
            }
            if (deleteBuffer) {
              _this._buffer = null;
            }
          } else {
            _this.delayLoadState = 4;
            _this._delayedOnLoad = load;
            _this._delayedOnError = errorHandler;
          }
        } else {
          if (_this._texture.isReady) {
            TimingTools.SetImmediate(function() {
              return load();
            });
          } else {
            var loadObserver_1 = _this._texture.onLoadedObservable.add(load);
            _this._texture.onErrorObservable.add(function(e) {
              var _a2;
              errorHandler(e.message, e.exception);
              (_a2 = _this._texture) === null || _a2 === void 0 ? void 0 : _a2.onLoadedObservable.remove(loadObserver_1);
            });
          }
        }
        return _this;
      }
      Object.defineProperty(Texture2.prototype, "noMipmap", {
        get: function() {
          return this._noMipmap;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "mimeType", {
        get: function() {
          return this._mimeType;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "isBlocking", {
        get: function() {
          return this._isBlocking;
        },
        set: function(value) {
          this._isBlocking = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "invertY", {
        get: function() {
          return this._invertY;
        },
        enumerable: false,
        configurable: true
      });
      Texture2.prototype.updateURL = function(url, buffer, onLoad) {
        if (buffer === void 0) {
          buffer = null;
        }
        if (this.url) {
          this.releaseInternalTexture();
          this.getScene().markAllMaterialsAsDirty(1);
        }
        if (!this.name || StartsWith(this.name, "data:")) {
          this.name = url;
        }
        this.url = url;
        this._buffer = buffer;
        this.delayLoadState = 4;
        if (onLoad) {
          this._delayedOnLoad = onLoad;
        }
        this.delayLoad();
      };
      Texture2.prototype.delayLoad = function() {
        if (this.delayLoadState !== 4) {
          return;
        }
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        this.delayLoadState = 1;
        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);
        if (!this._texture) {
          this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
          if (this._deleteBuffer) {
            this._buffer = null;
          }
        } else {
          if (this._delayedOnLoad) {
            if (this._texture.isReady) {
              TimingTools.SetImmediate(this._delayedOnLoad);
            } else {
              this._texture.onLoadedObservable.add(this._delayedOnLoad);
            }
          }
        }
        this._delayedOnLoad = null;
        this._delayedOnError = null;
      };
      Texture2.prototype._prepareRowForTextureGeneration = function(x, y, z, t) {
        x *= this._cachedUScale;
        y *= this._cachedVScale;
        x -= this.uRotationCenter * this._cachedUScale;
        y -= this.vRotationCenter * this._cachedVScale;
        z -= this.wRotationCenter;
        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
        t.z += this.wRotationCenter;
      };
      Texture2.prototype.checkTransformsAreIdentical = function(texture) {
        return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
      };
      Texture2.prototype.getTextureMatrix = function(uBase) {
        var _this = this;
        if (uBase === void 0) {
          uBase = 1;
        }
        if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
          return this._cachedTextureMatrix;
        }
        this._cachedUOffset = this.uOffset;
        this._cachedVOffset = this.vOffset;
        this._cachedUScale = this.uScale * uBase;
        this._cachedVScale = this.vScale;
        this._cachedUAng = this.uAng;
        this._cachedVAng = this.vAng;
        this._cachedWAng = this.wAng;
        this._cachedURotationCenter = this.uRotationCenter;
        this._cachedVRotationCenter = this.vRotationCenter;
        this._cachedWRotationCenter = this.wRotationCenter;
        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
          this._cachedTextureMatrix = Matrix.Zero();
          this._rowGenerationMatrix = new Matrix();
          this._t0 = Vector3.Zero();
          this._t1 = Vector3.Zero();
          this._t2 = Vector3.Zero();
        }
        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
        if (this.homogeneousRotationInUVTransform) {
          Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
          Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
          Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
          Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
          TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
          this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
        } else {
          this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
          this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
          this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
          this._t1.subtractInPlace(this._t0);
          this._t2.subtractInPlace(this._t0);
          Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
        }
        var scene = this.getScene();
        if (!scene) {
          return this._cachedTextureMatrix;
        }
        scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
        return this._cachedTextureMatrix;
      };
      Texture2.prototype.getReflectionTextureMatrix = function() {
        var _this = this;
        var scene = this.getScene();
        if (!scene) {
          return this._cachedTextureMatrix;
        }
        if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {
          if (this.coordinatesMode === Texture2.PROJECTION_MODE) {
            if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
              return this._cachedTextureMatrix;
            }
          } else {
            return this._cachedTextureMatrix;
          }
        }
        if (!this._cachedTextureMatrix) {
          this._cachedTextureMatrix = Matrix.Zero();
        }
        if (!this._projectionModeMatrix) {
          this._projectionModeMatrix = Matrix.Zero();
        }
        var flagMaterialsAsTextureDirty = this._cachedCoordinatesMode !== this.coordinatesMode;
        this._cachedUOffset = this.uOffset;
        this._cachedVOffset = this.vOffset;
        this._cachedUScale = this.uScale;
        this._cachedVScale = this.vScale;
        this._cachedCoordinatesMode = this.coordinatesMode;
        switch (this.coordinatesMode) {
          case Texture2.PLANAR_MODE: {
            Matrix.IdentityToRef(this._cachedTextureMatrix);
            this._cachedTextureMatrix[0] = this.uScale;
            this._cachedTextureMatrix[5] = this.vScale;
            this._cachedTextureMatrix[12] = this.uOffset;
            this._cachedTextureMatrix[13] = this.vOffset;
            break;
          }
          case Texture2.PROJECTION_MODE: {
            Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
            var projectionMatrix = scene.getProjectionMatrix();
            this._cachedProjectionMatrixId = projectionMatrix.updateFlag;
            projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
            break;
          }
          default:
            Matrix.IdentityToRef(this._cachedTextureMatrix);
            break;
        }
        if (flagMaterialsAsTextureDirty) {
          scene.markAllMaterialsAsDirty(1, function(mat) {
            return mat.getActiveTextures().indexOf(_this) !== -1;
          });
        }
        return this._cachedTextureMatrix;
      };
      Texture2.prototype.clone = function() {
        var _this = this;
        var options = {
          noMipmap: this._noMipmap,
          invertY: this._invertY,
          samplingMode: this.samplingMode,
          onLoad: void 0,
          onError: void 0,
          buffer: this._texture ? this._texture._buffer : void 0,
          deleteBuffer: this._deleteBuffer,
          format: this.textureFormat,
          mimeType: this.mimeType,
          loaderOptions: this._loaderOptions,
          creationFlags: this._creationFlags,
          useSRGBBuffer: this._useSRGBBuffer
        };
        return SerializationHelper.Clone(function() {
          return new Texture2(_this._texture ? _this._texture.url : null, _this.getScene(), options);
        }, this);
      };
      Texture2.prototype.serialize = function() {
        var savedName = this.name;
        if (!Texture2.SerializeBuffers) {
          if (StartsWith(this.name, "data:")) {
            this.name = "";
          }
        }
        if (StartsWith(this.name, "data:") && this.url === this.name) {
          this.url = "";
        }
        var serializationObject = _super.prototype.serialize.call(this);
        if (!serializationObject) {
          return null;
        }
        if (Texture2.SerializeBuffers || Texture2.ForceSerializeBuffers) {
          if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
            serializationObject.base64String = this._buffer;
            serializationObject.name = serializationObject.name.replace("data:", "");
          } else if (this.url && StartsWith(this.url, "data:") && this._buffer instanceof Uint8Array) {
            serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
          } else if (Texture2.ForceSerializeBuffers || this.url && StartsWith(this.url, "blob:") || this._forceSerialize) {
            serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
          }
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        serializationObject._creationFlags = this._creationFlags;
        serializationObject._useSRGBBuffer = this._useSRGBBuffer;
        this.name = savedName;
        return serializationObject;
      };
      Texture2.prototype.getClassName = function() {
        return "Texture";
      };
      Texture2.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this.onLoadObservable.clear();
        this._delayedOnLoad = null;
        this._delayedOnError = null;
      };
      Texture2.Parse = function(parsedTexture, scene, rootUrl) {
        if (parsedTexture.customType) {
          var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
          var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
          if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
            if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
              parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
            }
          }
          return parsedCustomTexture;
        }
        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
          return Texture2._CubeTextureParser(parsedTexture, scene, rootUrl);
        }
        if (!parsedTexture.name && !parsedTexture.isRenderTarget) {
          return null;
        }
        var onLoaded = function() {
          if (texture && texture._texture) {
            texture._texture._cachedWrapU = null;
            texture._texture._cachedWrapV = null;
            texture._texture._cachedWrapR = null;
          }
          if (parsedTexture.samplingMode) {
            var sampling = parsedTexture.samplingMode;
            if (texture && texture.samplingMode !== sampling) {
              texture.updateSamplingMode(sampling);
            }
          }
          if (texture && parsedTexture.animations) {
            for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
              var parsedAnimation = parsedTexture.animations[animationIndex];
              var internalClass = GetClass("BABYLON.Animation");
              if (internalClass) {
                texture.animations.push(internalClass.Parse(parsedAnimation));
              }
            }
          }
        };
        var texture = SerializationHelper.Parse(function() {
          var _a, _b, _c;
          var generateMipMaps = true;
          if (parsedTexture.noMipmap) {
            generateMipMaps = false;
          }
          if (parsedTexture.mirrorPlane) {
            var mirrorTexture = Texture2._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
            mirrorTexture._waitingRenderList = parsedTexture.renderList;
            mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
            onLoaded();
            return mirrorTexture;
          } else if (parsedTexture.isRenderTarget) {
            var renderTargetTexture = null;
            if (parsedTexture.isCube) {
              if (scene.reflectionProbes) {
                for (var index = 0; index < scene.reflectionProbes.length; index++) {
                  var probe = scene.reflectionProbes[index];
                  if (probe.name === parsedTexture.name) {
                    return probe.cubeTexture;
                  }
                }
              }
            } else {
              renderTargetTexture = Texture2._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);
              renderTargetTexture._waitingRenderList = parsedTexture.renderList;
            }
            onLoaded();
            return renderTargetTexture;
          } else {
            var texture_1;
            if (parsedTexture.base64String) {
              texture_1 = Texture2.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);
            } else {
              var url = void 0;
              if (parsedTexture.name && parsedTexture.name.indexOf("://") > 0) {
                url = parsedTexture.name;
              } else {
                url = rootUrl + parsedTexture.name;
              }
              if (StartsWith(parsedTexture.url, "data:") || Texture2.UseSerializedUrlIfAny && parsedTexture.url) {
                url = parsedTexture.url;
              }
              texture_1 = new Texture2(url, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded);
            }
            return texture_1;
          }
        }, parsedTexture, scene);
        return texture;
      };
      Texture2.CreateFromBase64String = function(data, name105, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
        if (samplingMode === void 0) {
          samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (format === void 0) {
          format = 5;
        }
        return new Texture2("data:" + name105, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
      };
      Texture2.LoadFromDataString = function(name105, buffer, scene, deleteBuffer, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
        if (deleteBuffer === void 0) {
          deleteBuffer = false;
        }
        if (invertY === void 0) {
          invertY = true;
        }
        if (samplingMode === void 0) {
          samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (format === void 0) {
          format = 5;
        }
        if (name105.substr(0, 5) !== "data:") {
          name105 = "data:" + name105;
        }
        return new Texture2(name105, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
      };
      Texture2.SerializeBuffers = true;
      Texture2.ForceSerializeBuffers = false;
      Texture2.OnTextureLoadErrorObservable = new Observable();
      Texture2._CubeTextureParser = function(jsonTexture, scene, rootUrl) {
        throw _WarnImport("CubeTexture");
      };
      Texture2._CreateMirror = function(name105, renderTargetSize, scene, generateMipMaps) {
        throw _WarnImport("MirrorTexture");
      };
      Texture2._CreateRenderTargetTexture = function(name105, renderTargetSize, scene, generateMipMaps, creationFlags) {
        throw _WarnImport("RenderTargetTexture");
      };
      Texture2.NEAREST_SAMPLINGMODE = 1;
      Texture2.NEAREST_NEAREST_MIPLINEAR = 8;
      Texture2.BILINEAR_SAMPLINGMODE = 2;
      Texture2.LINEAR_LINEAR_MIPNEAREST = 11;
      Texture2.TRILINEAR_SAMPLINGMODE = 3;
      Texture2.LINEAR_LINEAR_MIPLINEAR = 3;
      Texture2.NEAREST_NEAREST_MIPNEAREST = 4;
      Texture2.NEAREST_LINEAR_MIPNEAREST = 5;
      Texture2.NEAREST_LINEAR_MIPLINEAR = 6;
      Texture2.NEAREST_LINEAR = 7;
      Texture2.NEAREST_NEAREST = 1;
      Texture2.LINEAR_NEAREST_MIPNEAREST = 9;
      Texture2.LINEAR_NEAREST_MIPLINEAR = 10;
      Texture2.LINEAR_LINEAR = 2;
      Texture2.LINEAR_NEAREST = 12;
      Texture2.EXPLICIT_MODE = 0;
      Texture2.SPHERICAL_MODE = 1;
      Texture2.PLANAR_MODE = 2;
      Texture2.CUBIC_MODE = 3;
      Texture2.PROJECTION_MODE = 4;
      Texture2.SKYBOX_MODE = 5;
      Texture2.INVCUBIC_MODE = 6;
      Texture2.EQUIRECTANGULAR_MODE = 7;
      Texture2.FIXED_EQUIRECTANGULAR_MODE = 8;
      Texture2.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
      Texture2.CLAMP_ADDRESSMODE = 0;
      Texture2.WRAP_ADDRESSMODE = 1;
      Texture2.MIRROR_ADDRESSMODE = 2;
      Texture2.UseSerializedUrlIfAny = false;
      __decorate([
        serialize()
      ], Texture2.prototype, "url", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "uOffset", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "vOffset", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "uScale", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "vScale", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "uAng", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "vAng", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "wAng", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "uRotationCenter", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "vRotationCenter", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "wRotationCenter", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "homogeneousRotationInUVTransform", void 0);
      __decorate([
        serialize()
      ], Texture2.prototype, "isBlocking", null);
      return Texture2;
    }(BaseTexture);
    RegisterClass("BABYLON.Texture", Texture);
    SerializationHelper._TextureParser = Texture.Parse;
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  var rgbaData;
  var val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      var index = (y * width + x) * 3;
      var newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    var texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var internalType = this._getWebGLTextureType(textureType);
    var internalFormat = this._getInternalFormat(format);
    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
var init_engine_rawTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js"() {
    init_internalTexture();
    init_logger();
    init_tools();
    init_thinEngine();
    ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression, type) {
      if (compression === void 0) {
        compression = null;
      }
      if (type === void 0) {
        type = 0;
      }
      if (!texture) {
        return;
      }
      var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format);
      var internalFormat = this._getInternalFormat(format);
      var textureType = this._getWebGLTextureType(type);
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
      if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
        texture.format = format;
        texture.type = type;
        texture.invertY = invertY;
        texture._compression = compression;
      }
      if (texture.width % 4 !== 0) {
        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
      }
      if (compression && data) {
        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
      } else {
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
      }
      if (texture.generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      texture.isReady = true;
    };
    ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, creationFlags) {
      if (compression === void 0) {
        compression = null;
      }
      if (type === void 0) {
        type = 0;
      }
      if (creationFlags === void 0) {
        creationFlags = 0;
      }
      var texture = new InternalTexture(this, InternalTextureSource.Raw);
      texture.baseWidth = width;
      texture.baseHeight = height;
      texture.width = width;
      texture.height = height;
      texture.format = format;
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      texture.invertY = invertY;
      texture._compression = compression;
      texture.type = type;
      if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
      }
      this.updateRawTexture(texture, data, format, invertY, compression, type);
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
      if (generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
      if (compression === void 0) {
        compression = null;
      }
      var gl = this._gl;
      var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
      texture.isCube = true;
      texture.format = format;
      texture.type = type;
      if (!this._doNotHandleContextLost) {
        texture._bufferViewArray = data;
      }
      var textureType = this._getWebGLTextureType(type);
      var internalFormat = this._getInternalFormat(format);
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
      }
      if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
      } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
      } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
        generateMipMaps = false;
        Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
      } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
        generateMipMaps = false;
        Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
      }
      var width = size;
      var height = width;
      texture.width = width;
      texture.height = height;
      var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
      if (!isPot) {
        generateMipMaps = false;
      }
      if (data) {
        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (data && generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
      }
      var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      return texture;
    };
    ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression, level) {
      if (compression === void 0) {
        compression = null;
      }
      if (level === void 0) {
        level = 0;
      }
      texture._bufferViewArray = data;
      texture.format = format;
      texture.type = type;
      texture.invertY = invertY;
      texture._compression = compression;
      var gl = this._gl;
      var textureType = this._getWebGLTextureType(type);
      var internalFormat = this._getInternalFormat(format);
      var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
      var needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
      if (texture.width % 4 !== 0) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      }
      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
        var faceData = data[faceIndex];
        if (compression) {
          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
        } else {
          if (needConversion) {
            faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
          }
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
        }
      }
      var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
      if (isPot && texture.generateMipMaps && level === 0) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      texture.isReady = true;
    };
    ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {
      var _this = this;
      if (onLoad === void 0) {
        onLoad = null;
      }
      if (onError === void 0) {
        onError = null;
      }
      if (samplingMode === void 0) {
        samplingMode = 3;
      }
      if (invertY === void 0) {
        invertY = false;
      }
      var gl = this._gl;
      var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
      scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);
      texture.url = url;
      this._internalTexturesCache.push(texture);
      var onerror = function(request, exception) {
        scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
        if (onError && request) {
          onError(request.status + " " + request.statusText, exception);
        }
      };
      var internalCallback = function(data) {
        var width = texture.width;
        var faceDataArrays = callback(data);
        if (!faceDataArrays) {
          return;
        }
        if (mipmapGenerator) {
          var textureType = _this._getWebGLTextureType(type);
          var internalFormat = _this._getInternalFormat(format);
          var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);
          var needConversion = false;
          if (internalFormat === gl.RGB) {
            internalFormat = gl.RGBA;
            needConversion = true;
          }
          _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
          _this._unpackFlipY(false);
          var mipData = mipmapGenerator(faceDataArrays);
          for (var level = 0; level < mipData.length; level++) {
            var mipSize = width >> level;
            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
              var mipFaceData = mipData[level][faceIndex];
              if (needConversion) {
                mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
              }
              gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
            }
          }
          _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
        } else {
          _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
        }
        texture.isReady = true;
        scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
        if (onLoad) {
          onLoad();
        }
      };
      this._loadFile(url, function(data) {
        internalCallback(data);
      }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
      return texture;
    };
    ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
    ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
    ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
    ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture;
var init_rawTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture.js"() {
    init_tslib_es6();
    init_texture();
    init_engine_rawTexture();
    RawTexture = function(_super) {
      __extends(RawTexture2, _super);
      function RawTexture2(data, width, height, format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (type === void 0) {
          type = 0;
        }
        var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags) || this;
        _this.format = format;
        if (!_this._engine) {
          return _this;
        }
        if (!_this._engine._caps.textureFloatLinearFiltering && type === 1) {
          samplingMode = 1;
        }
        if (!_this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
          samplingMode = 1;
        }
        _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0);
        _this.wrapU = Texture.CLAMP_ADDRESSMODE;
        _this.wrapV = Texture.CLAMP_ADDRESSMODE;
        return _this;
      }
      RawTexture2.prototype.update = function(data) {
        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
      };
      RawTexture2.CreateLuminanceTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        return new RawTexture2(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      };
      RawTexture2.CreateLuminanceAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        return new RawTexture2(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      };
      RawTexture2.CreateAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        return new RawTexture2(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      };
      RawTexture2.CreateRGBTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (type === void 0) {
          type = 0;
        }
        return new RawTexture2(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
      };
      RawTexture2.CreateRGBATexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (type === void 0) {
          type = 0;
        }
        return new RawTexture2(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
      };
      RawTexture2.CreateRGBAStorageTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (type === void 0) {
          type = 0;
        }
        return new RawTexture2(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
      };
      RawTexture2.CreateRTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
        }
        if (type === void 0) {
          type = 1;
        }
        return new RawTexture2(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
      };
      RawTexture2.CreateRStorageTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
        }
        if (type === void 0) {
          type = 1;
        }
        return new RawTexture2(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
      };
      return RawTexture2;
    }(Texture);
  }
});

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "node_modules/@babylonjs/core/Bones/skeleton.js"() {
    init_bone();
    init_observable();
    init_math_vector();
    init_rawTexture();
    init_animation();
    init_animationRange();
    init_engineStore();
    init_logger();
    init_deepCopier();
    Skeleton = function() {
      function Skeleton2(name105, id, scene) {
        this.name = name105;
        this.id = id;
        this.bones = new Array();
        this.needInitialSkinMatrix = false;
        this._isDirty = true;
        this._meshesWithPoseMatrix = new Array();
        this._identity = Matrix.Identity();
        this._ranges = {};
        this._lastAbsoluteTransformsUpdateId = -1;
        this._canUseTextureForBones = false;
        this._uniqueId = 0;
        this._numBonesWithLinkedTransformNode = 0;
        this._hasWaitingData = null;
        this._parentContainer = null;
        this.doNotSerialize = false;
        this._useTextureToStoreBoneMatrices = true;
        this._animationPropertiesOverride = null;
        this.onBeforeComputeObservable = new Observable();
        this.bones = [];
        this._scene = scene || EngineStore.LastCreatedScene;
        this._uniqueId = this._scene.getUniqueId();
        this._scene.addSkeleton(this);
        this._isDirty = true;
        var engineCaps = this._scene.getEngine().getCaps();
        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
      }
      Object.defineProperty(Skeleton2.prototype, "useTextureToStoreBoneMatrices", {
        get: function() {
          return this._useTextureToStoreBoneMatrices;
        },
        set: function(value) {
          this._useTextureToStoreBoneMatrices = value;
          this._markAsDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Skeleton2.prototype, "animationPropertiesOverride", {
        get: function() {
          if (!this._animationPropertiesOverride) {
            return this._scene.animationPropertiesOverride;
          }
          return this._animationPropertiesOverride;
        },
        set: function(value) {
          this._animationPropertiesOverride = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Skeleton2.prototype, "isUsingTextureForMatrices", {
        get: function() {
          return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Skeleton2.prototype, "uniqueId", {
        get: function() {
          return this._uniqueId;
        },
        enumerable: false,
        configurable: true
      });
      Skeleton2.prototype.getClassName = function() {
        return "Skeleton";
      };
      Skeleton2.prototype.getChildren = function() {
        return this.bones.filter(function(b) {
          return !b.getParent();
        });
      };
      Skeleton2.prototype.getTransformMatrices = function(mesh) {
        if (this.needInitialSkinMatrix) {
          if (!mesh._bonesTransformMatrices) {
            this.prepare();
          }
          return mesh._bonesTransformMatrices;
        }
        if (!this._transformMatrices) {
          this.prepare();
        }
        return this._transformMatrices;
      };
      Skeleton2.prototype.getTransformMatrixTexture = function(mesh) {
        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
          return mesh._transformMatrixTexture;
        }
        return this._transformMatrixTexture;
      };
      Skeleton2.prototype.getScene = function() {
        return this._scene;
      };
      Skeleton2.prototype.toString = function(fullDetails) {
        var ret = "Name: ".concat(this.name, ", nBones: ").concat(this.bones.length);
        ret += ", nAnimationRanges: ".concat(this._ranges ? Object.keys(this._ranges).length : "none");
        if (fullDetails) {
          ret += ", Ranges: {";
          var first = true;
          for (var name_1 in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name_1;
          }
          ret += "}";
        }
        return ret;
      };
      Skeleton2.prototype.getBoneIndexByName = function(name105) {
        for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
          if (this.bones[boneIndex].name === name105) {
            return boneIndex;
          }
        }
        return -1;
      };
      Skeleton2.prototype.createAnimationRange = function(name105, from, to) {
        if (!this._ranges[name105]) {
          this._ranges[name105] = new AnimationRange(name105, from, to);
          for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
            if (this.bones[i].animations[0]) {
              this.bones[i].animations[0].createRange(name105, from, to);
            }
          }
        }
      };
      Skeleton2.prototype.deleteAnimationRange = function(name105, deleteFrames) {
        if (deleteFrames === void 0) {
          deleteFrames = true;
        }
        for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            this.bones[i].animations[0].deleteRange(name105, deleteFrames);
          }
        }
        this._ranges[name105] = null;
      };
      Skeleton2.prototype.getAnimationRange = function(name105) {
        return this._ranges[name105] || null;
      };
      Skeleton2.prototype.getAnimationRanges = function() {
        var animationRanges = [];
        var name105;
        for (name105 in this._ranges) {
          animationRanges.push(this._ranges[name105]);
        }
        return animationRanges;
      };
      Skeleton2.prototype.copyAnimationRange = function(source, name105, rescaleAsRequired) {
        if (rescaleAsRequired === void 0) {
          rescaleAsRequired = false;
        }
        if (this._ranges[name105] || !source.getAnimationRange(name105)) {
          return false;
        }
        var ret = true;
        var frameOffset = this._getHighestAnimationFrame() + 1;
        var boneDict = {};
        var sourceBones = source.bones;
        var nBones;
        var i;
        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
          boneDict[sourceBones[i].name] = sourceBones[i];
        }
        if (this.bones.length !== sourceBones.length) {
          Logger.Warn("copyAnimationRange: this rig has ".concat(this.bones.length, " bones, while source as ").concat(sourceBones.length));
          ret = false;
        }
        var skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
        for (i = 0, nBones = this.bones.length; i < nBones; i++) {
          var boneName = this.bones[i].name;
          var sourceBone = boneDict[boneName];
          if (sourceBone) {
            ret = ret && this.bones[i].copyAnimationRange(sourceBone, name105, frameOffset, rescaleAsRequired, skelDimensionsRatio);
          } else {
            Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
            ret = false;
          }
        }
        var range = source.getAnimationRange(name105);
        if (range) {
          this._ranges[name105] = new AnimationRange(name105, range.from + frameOffset, range.to + frameOffset);
        }
        return ret;
      };
      Skeleton2.prototype.returnToRest = function() {
        for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {
          var bone = _a[_i];
          if (bone._index !== -1) {
            bone.returnToRest();
          }
        }
      };
      Skeleton2.prototype._getHighestAnimationFrame = function() {
        var ret = 0;
        for (var i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            var highest = this.bones[i].animations[0].getHighestFrame();
            if (ret < highest) {
              ret = highest;
            }
          }
        }
        return ret;
      };
      Skeleton2.prototype.beginAnimation = function(name105, loop, speedRatio, onAnimationEnd) {
        var range = this.getAnimationRange(name105);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      };
      Skeleton2.MakeAnimationAdditive = function(skeleton, referenceFrame, range) {
        if (referenceFrame === void 0) {
          referenceFrame = 0;
        }
        var rangeValue = skeleton.getAnimationRange(range);
        if (!rangeValue) {
          return null;
        }
        var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
        var rangeAnimatable = null;
        for (var index = 0; index < sceneAnimatables.length; index++) {
          var sceneAnimatable = sceneAnimatables[index];
          if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {
            rangeAnimatable = sceneAnimatable;
            break;
          }
        }
        var animatables = skeleton.getAnimatables();
        for (var index = 0; index < animatables.length; index++) {
          var animatable = animatables[index];
          var animations = animatable.animations;
          if (!animations) {
            continue;
          }
          for (var animIndex = 0; animIndex < animations.length; animIndex++) {
            Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
          }
        }
        if (rangeAnimatable) {
          rangeAnimatable.isAdditive = true;
        }
        return skeleton;
      };
      Skeleton2.prototype._markAsDirty = function() {
        this._isDirty = true;
      };
      Skeleton2.prototype._registerMeshWithPoseMatrix = function(mesh) {
        this._meshesWithPoseMatrix.push(mesh);
      };
      Skeleton2.prototype._unregisterMeshWithPoseMatrix = function(mesh) {
        var index = this._meshesWithPoseMatrix.indexOf(mesh);
        if (index > -1) {
          this._meshesWithPoseMatrix.splice(index, 1);
        }
      };
      Skeleton2.prototype._computeTransformMatrices = function(targetMatrix, initialSkinMatrix) {
        this.onBeforeComputeObservable.notifyObservers(this);
        for (var index = 0; index < this.bones.length; index++) {
          var bone = this.bones[index];
          bone._childUpdateId++;
          var parentBone = bone.getParent();
          if (parentBone) {
            bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());
          } else {
            if (initialSkinMatrix) {
              bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());
            } else {
              bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());
            }
          }
          if (bone._index !== -1) {
            var mappedIndex = bone._index === null ? index : bone._index;
            bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);
          }
        }
        this._identity.copyToArray(targetMatrix, this.bones.length * 16);
      };
      Skeleton2.prototype.prepare = function() {
        if (this._numBonesWithLinkedTransformNode > 0) {
          for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {
            var bone = _a[_i];
            if (bone._linkedTransformNode) {
              bone._linkedTransformNode.computeWorldMatrix();
              bone._matrix = bone._linkedTransformNode._localMatrix;
            }
          }
        }
        if (this.needInitialSkinMatrix) {
          for (var _b = 0, _c = this._meshesWithPoseMatrix; _b < _c.length; _b++) {
            var mesh = _c[_b];
            var poseMatrix = mesh.getPoseMatrix();
            var needsUpdate = this._isDirty;
            if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
              mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
              needsUpdate = true;
            }
            if (!needsUpdate) {
              continue;
            }
            if (this._synchronizedWithMesh !== mesh) {
              this._synchronizedWithMesh = mesh;
              for (var _d = 0, _e = this.bones; _d < _e.length; _d++) {
                var bone = _e[_d];
                if (!bone.getParent()) {
                  var matrix = bone.getBaseMatrix();
                  matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
                  bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);
                }
              }
              if (this.isUsingTextureForMatrices) {
                var textureWidth = (this.bones.length + 1) * 4;
                if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
                  if (mesh._transformMatrixTexture) {
                    mesh._transformMatrixTexture.dispose();
                  }
                  mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
                }
              }
            }
            this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
            if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
              mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
            }
          }
        } else {
          if (!this._isDirty) {
            return;
          }
          if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
            this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
            if (this.isUsingTextureForMatrices) {
              if (this._transformMatrixTexture) {
                this._transformMatrixTexture.dispose();
              }
              this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
          this._computeTransformMatrices(this._transformMatrices, null);
          if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
            this._transformMatrixTexture.update(this._transformMatrices);
          }
        }
        this._isDirty = false;
      };
      Skeleton2.prototype.getAnimatables = function() {
        if (!this._animatables || this._animatables.length !== this.bones.length) {
          this._animatables = [];
          for (var index = 0; index < this.bones.length; index++) {
            this._animatables.push(this.bones[index]);
          }
        }
        return this._animatables;
      };
      Skeleton2.prototype.clone = function(name105, id) {
        var result = new Skeleton2(name105, id || name105, this._scene);
        result.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (var index = 0; index < this.bones.length; index++) {
          var source = this.bones[index];
          var parentBone = null;
          var parent_1 = source.getParent();
          if (parent_1) {
            var parentIndex = this.bones.indexOf(parent_1);
            parentBone = result.bones[parentIndex];
          }
          var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());
          bone._index = source._index;
          if (source._linkedTransformNode) {
            bone.linkTransformNode(source._linkedTransformNode);
          }
          DeepCopier.DeepCopy(source.animations, bone.animations);
        }
        if (this._ranges) {
          result._ranges = {};
          for (var rangeName in this._ranges) {
            var range = this._ranges[rangeName];
            if (range) {
              result._ranges[rangeName] = range.clone();
            }
          }
        }
        this._isDirty = true;
        return result;
      };
      Skeleton2.prototype.enableBlending = function(blendingSpeed) {
        if (blendingSpeed === void 0) {
          blendingSpeed = 0.01;
        }
        this.bones.forEach(function(bone) {
          bone.animations.forEach(function(animation) {
            animation.enableBlending = true;
            animation.blendingSpeed = blendingSpeed;
          });
        });
      };
      Skeleton2.prototype.dispose = function() {
        this._meshesWithPoseMatrix = [];
        this.getScene().stopAnimation(this);
        this.getScene().removeSkeleton(this);
        if (this._parentContainer) {
          var index = this._parentContainer.skeletons.indexOf(this);
          if (index > -1) {
            this._parentContainer.skeletons.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
      };
      Skeleton2.prototype.serialize = function() {
        var _a;
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        if (this.dimensionsAtRest) {
          serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
        }
        serializationObject.bones = [];
        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (var index = 0; index < this.bones.length; index++) {
          var bone = this.bones[index];
          var parent_2 = bone.getParent();
          var serializedBone = {
            parentBoneIndex: parent_2 ? this.bones.indexOf(parent_2) : -1,
            index: bone.getIndex(),
            name: bone.name,
            id: bone.id,
            matrix: bone.getBaseMatrix().toArray(),
            rest: bone.getRestPose().toArray(),
            linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id
          };
          serializationObject.bones.push(serializedBone);
          if (bone.length) {
            serializedBone.length = bone.length;
          }
          if (bone.metadata) {
            serializedBone.metadata = bone.metadata;
          }
          if (bone.animations && bone.animations.length > 0) {
            serializedBone.animation = bone.animations[0].serialize();
          }
          serializationObject.ranges = [];
          for (var name_2 in this._ranges) {
            var source = this._ranges[name_2];
            if (!source) {
              continue;
            }
            var range = {};
            range.name = name_2;
            range.from = source.from;
            range.to = source.to;
            serializationObject.ranges.push(range);
          }
        }
        return serializationObject;
      };
      Skeleton2.Parse = function(parsedSkeleton, scene) {
        var skeleton = new Skeleton2(parsedSkeleton.name, parsedSkeleton.id, scene);
        if (parsedSkeleton.dimensionsAtRest) {
          skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
        }
        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
        var index;
        for (index = 0; index < parsedSkeleton.bones.length; index++) {
          var parsedBone = parsedSkeleton.bones[index];
          var parsedBoneIndex = parsedSkeleton.bones[index].index;
          var parentBone = null;
          if (parsedBone.parentBoneIndex > -1) {
            parentBone = skeleton.bones[parsedBone.parentBoneIndex];
          }
          var rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
          var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
          if (parsedBone.id !== void 0 && parsedBone.id !== null) {
            bone.id = parsedBone.id;
          }
          if (parsedBone.length) {
            bone.length = parsedBone.length;
          }
          if (parsedBone.metadata) {
            bone.metadata = parsedBone.metadata;
          }
          if (parsedBone.animation) {
            bone.animations.push(Animation.Parse(parsedBone.animation));
          }
          if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
            skeleton._hasWaitingData = true;
            bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
          }
        }
        if (parsedSkeleton.ranges) {
          for (index = 0; index < parsedSkeleton.ranges.length; index++) {
            var data = parsedSkeleton.ranges[index];
            skeleton.createAnimationRange(data.name, data.from, data.to);
          }
        }
        return skeleton;
      };
      Skeleton2.prototype.computeAbsoluteTransforms = function(forceUpdate) {
        if (forceUpdate === void 0) {
          forceUpdate = false;
        }
        var renderId = this._scene.getRenderId();
        if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {
          this.bones[0].computeAbsoluteTransforms();
          this._lastAbsoluteTransformsUpdateId = renderId;
        }
      };
      Skeleton2.prototype.getPoseMatrix = function() {
        var poseMatrix = null;
        if (this._meshesWithPoseMatrix.length > 0) {
          poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
        }
        return poseMatrix;
      };
      Skeleton2.prototype.sortBones = function() {
        var bones = new Array();
        var visited = new Array(this.bones.length);
        for (var index = 0; index < this.bones.length; index++) {
          this._sortBones(index, bones, visited);
        }
        this.bones = bones;
      };
      Skeleton2.prototype._sortBones = function(index, bones, visited) {
        if (visited[index]) {
          return;
        }
        visited[index] = true;
        var bone = this.bones[index];
        if (!bone)
          return;
        if (bone._index === void 0) {
          bone._index = index;
        }
        var parentBone = bone.getParent();
        if (parentBone) {
          this._sortBones(this.bones.indexOf(parentBone), bones, visited);
        }
        bones.push(bone);
      };
      Skeleton2.prototype.setCurrentPoseAsRest = function() {
        this.bones.forEach(function(b) {
          b.setCurrentPoseAsRest();
        });
      };
      return Skeleton2;
    }();
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput;
var init_BaseCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_pointerEvents();
    init_tools();
    init_deviceInputEvents();
    BaseCameraMouseWheelInput = function() {
      function BaseCameraMouseWheelInput2() {
        this.wheelPrecisionX = 3;
        this.wheelPrecisionY = 3;
        this.wheelPrecisionZ = 3;
        this.onChangedObservable = new Observable();
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
        this._ffMultiplier = 12;
        this._normalize = 120;
      }
      BaseCameraMouseWheelInput2.prototype.attachControl = function(noPreventDefault) {
        var _this = this;
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = function(pointer) {
          if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          var event = pointer.event;
          var platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? _this._ffMultiplier : 1;
          if (event.deltaY !== void 0) {
            _this._wheelDeltaX += _this.wheelPrecisionX * platformScale * event.deltaX / _this._normalize;
            _this._wheelDeltaY -= _this.wheelPrecisionY * platformScale * event.deltaY / _this._normalize;
            _this._wheelDeltaZ += _this.wheelPrecisionZ * platformScale * event.deltaZ / _this._normalize;
          } else if (event.wheelDeltaY !== void 0) {
            _this._wheelDeltaX += _this.wheelPrecisionX * platformScale * event.wheelDeltaX / _this._normalize;
            _this._wheelDeltaY -= _this.wheelPrecisionY * platformScale * event.wheelDeltaY / _this._normalize;
            _this._wheelDeltaZ += _this.wheelPrecisionZ * platformScale * event.wheelDeltaZ / _this._normalize;
          } else if (event.wheelDelta) {
            _this._wheelDeltaY -= _this.wheelPrecisionY * event.wheelDelta / _this._normalize;
          }
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, PointerEventTypes.POINTERWHEEL);
      };
      BaseCameraMouseWheelInput2.prototype.detachControl = function() {
        if (this._observer) {
          this.camera.getScene().onPointerObservable.remove(this._observer);
          this._observer = null;
          this._wheel = null;
        }
        if (this.onChangedObservable) {
          this.onChangedObservable.clear();
        }
      };
      BaseCameraMouseWheelInput2.prototype.checkInputs = function() {
        this.onChangedObservable.notifyObservers({
          wheelDeltaX: this._wheelDeltaX,
          wheelDeltaY: this._wheelDeltaY,
          wheelDeltaZ: this._wheelDeltaZ
        });
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
      };
      BaseCameraMouseWheelInput2.prototype.getClassName = function() {
        return "BaseCameraMouseWheelInput";
      };
      BaseCameraMouseWheelInput2.prototype.getSimpleName = function() {
        return "mousewheel";
      };
      __decorate([
        serialize()
      ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionX", void 0);
      __decorate([
        serialize()
      ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionY", void 0);
      __decorate([
        serialize()
      ], BaseCameraMouseWheelInput2.prototype, "wheelPrecisionZ", void 0);
      return BaseCameraMouseWheelInput2;
    }();
  }
});

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes, CameraInputsManager;
var init_cameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/cameraInputsManager.js"() {
    init_logger();
    init_decorators();
    init_camera();
    CameraInputTypes = {};
    CameraInputsManager = function() {
      function CameraInputsManager2(camera) {
        this.attachedToElement = false;
        this.attached = {};
        this.camera = camera;
        this.checkInputs = function() {
        };
      }
      CameraInputsManager2.prototype.add = function(input) {
        var type = input.getSimpleName();
        if (this.attached[type]) {
          Logger.Warn("camera input of type " + type + " already exists on camera");
          return;
        }
        this.attached[type] = input;
        input.camera = this.camera;
        if (input.checkInputs) {
          this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
        }
        if (this.attachedToElement) {
          input.attachControl();
        }
      };
      CameraInputsManager2.prototype.remove = function(inputToRemove) {
        for (var cam in this.attached) {
          var input = this.attached[cam];
          if (input === inputToRemove) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
          }
        }
      };
      CameraInputsManager2.prototype.removeByType = function(inputType) {
        for (var cam in this.attached) {
          var input = this.attached[cam];
          if (input.getClassName() === inputType) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
          }
        }
      };
      CameraInputsManager2.prototype._addCheckInputs = function(fn) {
        var current = this.checkInputs;
        return function() {
          current();
          fn();
        };
      };
      CameraInputsManager2.prototype.attachInput = function(input) {
        if (this.attachedToElement) {
          input.attachControl(this.noPreventDefault);
        }
      };
      CameraInputsManager2.prototype.attachElement = function(noPreventDefault) {
        if (noPreventDefault === void 0) {
          noPreventDefault = false;
        }
        if (this.attachedToElement) {
          return;
        }
        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
        this.attachedToElement = true;
        this.noPreventDefault = noPreventDefault;
        for (var cam in this.attached) {
          this.attached[cam].attachControl(noPreventDefault);
        }
      };
      CameraInputsManager2.prototype.detachElement = function(disconnect) {
        if (disconnect === void 0) {
          disconnect = false;
        }
        for (var cam in this.attached) {
          this.attached[cam].detachControl();
          if (disconnect) {
            this.attached[cam].camera = null;
          }
        }
        this.attachedToElement = false;
      };
      CameraInputsManager2.prototype.rebuildInputCheck = function() {
        this.checkInputs = function() {
        };
        for (var cam in this.attached) {
          var input = this.attached[cam];
          if (input.checkInputs) {
            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
          }
        }
      };
      CameraInputsManager2.prototype.clear = function() {
        if (this.attachedToElement) {
          this.detachElement(true);
        }
        this.attached = {};
        this.attachedToElement = false;
        this.checkInputs = function() {
        };
      };
      CameraInputsManager2.prototype.serialize = function(serializedCamera) {
        var inputs = {};
        for (var cam in this.attached) {
          var input = this.attached[cam];
          var res = SerializationHelper.Serialize(input);
          inputs[input.getClassName()] = res;
        }
        serializedCamera.inputsmgr = inputs;
      };
      CameraInputsManager2.prototype.parse = function(parsedCamera) {
        var parsedInputs = parsedCamera.inputsmgr;
        if (parsedInputs) {
          this.clear();
          var _loop_1 = function(n2) {
            var construct = CameraInputTypes[n2];
            if (construct) {
              var parsedinput = parsedInputs[n2];
              var input = SerializationHelper.Parse(function() {
                return new construct();
              }, parsedinput, null);
              this_1.add(input);
            }
          };
          var this_1 = this;
          for (var n in parsedInputs) {
            _loop_1(n);
          }
        } else {
          var _loop_2 = function(n2) {
            var construct = CameraInputTypes[this_2.attached[n2].getClassName()];
            if (construct) {
              var input = SerializationHelper.Parse(function() {
                return new construct();
              }, parsedCamera, null);
              this_2.remove(this_2.attached[n2]);
              this_2.add(input);
            }
          };
          var this_2 = this;
          for (var n in this.attached) {
            _loop_2(n);
          }
        }
      };
      return CameraInputsManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput;
var init_freeCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_math_vector();
    init_tools();
    FreeCameraKeyboardMoveInput = function() {
      function FreeCameraKeyboardMoveInput2() {
        this.keysUp = [38];
        this.keysUpward = [33];
        this.keysDown = [40];
        this.keysDownward = [34];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.rotationSpeed = 0.5;
        this.keysRotateLeft = [];
        this.keysRotateRight = [];
        this._keys = new Array();
      }
      FreeCameraKeyboardMoveInput2.prototype.attachControl = function(noPreventDefault) {
        var _this = this;
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function() {
          _this._keys = [];
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function(info) {
          var evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysUpward.indexOf(evt.keyCode) !== -1 || _this.keysDownward.indexOf(evt.keyCode) !== -1 || _this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || _this.keysRotateRight.indexOf(evt.keyCode) !== -1) {
                var index = _this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  _this._keys.push(evt.keyCode);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            } else {
              if (_this.keysUp.indexOf(evt.keyCode) !== -1 || _this.keysDown.indexOf(evt.keyCode) !== -1 || _this.keysLeft.indexOf(evt.keyCode) !== -1 || _this.keysRight.indexOf(evt.keyCode) !== -1 || _this.keysUpward.indexOf(evt.keyCode) !== -1 || _this.keysDownward.indexOf(evt.keyCode) !== -1 || _this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || _this.keysRotateRight.indexOf(evt.keyCode) !== -1) {
                var index = _this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  _this._keys.splice(index, 1);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          }
        });
      };
      FreeCameraKeyboardMoveInput2.prototype.detachControl = function() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys = [];
      };
      FreeCameraKeyboardMoveInput2.prototype.checkInputs = function() {
        if (this._onKeyboardObserver) {
          var camera = this.camera;
          for (var index = 0; index < this._keys.length; index++) {
            var keyCode = this._keys[index];
            var speed = camera._computeLocalCameraSpeed();
            if (this.keysLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, -speed);
            } else if (this.keysUpward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, speed, 0);
            } else if (this.keysDownward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, -speed, 0);
            } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y -= this._getLocalRotation();
            } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y += this._getLocalRotation();
            }
            if (camera.getScene().useRightHandedSystem) {
              camera._localDirection.z *= -1;
            }
            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
            Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
            camera.cameraDirection.addInPlace(camera._transformedDirection);
          }
        }
      };
      FreeCameraKeyboardMoveInput2.prototype.getClassName = function() {
        return "FreeCameraKeyboardMoveInput";
      };
      FreeCameraKeyboardMoveInput2.prototype._onLostFocus = function() {
        this._keys = [];
      };
      FreeCameraKeyboardMoveInput2.prototype.getSimpleName = function() {
        return "keyboard";
      };
      FreeCameraKeyboardMoveInput2.prototype._getLocalRotation = function() {
        var rotation = this.rotationSpeed * this._engine.getDeltaTime() / 1e3;
        if (this.camera.getScene().useRightHandedSystem) {
          rotation *= -1;
        }
        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {
          rotation *= -1;
        }
        return rotation;
      };
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysUp", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysUpward", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysDown", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysDownward", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysLeft", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysRight", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "rotationSpeed", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysRotateLeft", void 0);
      __decorate([
        serialize()
      ], FreeCameraKeyboardMoveInput2.prototype, "keysRotateRight", void 0);
      return FreeCameraKeyboardMoveInput2;
    }();
    CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput;
var init_freeCameraMouseInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js"() {
    init_tslib_es6();
    init_observable();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_tools();
    FreeCameraMouseInput = function() {
      function FreeCameraMouseInput2(touchEnabled) {
        if (touchEnabled === void 0) {
          touchEnabled = true;
        }
        this.touchEnabled = touchEnabled;
        this.buttons = [0, 1, 2];
        this.angularSensibility = 2e3;
        this._previousPosition = null;
        this.onPointerMovedObservable = new Observable();
        this._allowCameraRotation = true;
        this._currentActiveButton = -1;
      }
      FreeCameraMouseInput2.prototype.attachControl = function(noPreventDefault) {
        var _this = this;
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        var engine = this.camera.getEngine();
        var element = engine.getInputElement();
        if (!this._pointerInput) {
          this._pointerInput = function(p) {
            var evt = p.event;
            var isTouch = evt.pointerType === "touch";
            if (engine.isInVRExclusivePointerMode) {
              return;
            }
            if (!_this.touchEnabled && isTouch) {
              return;
            }
            if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {
              return;
            }
            var srcElement = evt.srcElement || evt.target;
            if (p.type === PointerEventTypes.POINTERDOWN && (_this._currentActiveButton === -1 || isTouch)) {
              try {
                srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);
              } catch (e) {
              }
              if (_this._currentActiveButton === -1) {
                _this._currentActiveButton = evt.button;
              }
              _this._previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
              if (!noPreventDefault) {
                evt.preventDefault();
                element && element.focus();
              }
              if (engine.isPointerLock && _this._onMouseMove) {
                _this._onMouseMove(p.event);
              }
            } else if (p.type === PointerEventTypes.POINTERUP && (_this._currentActiveButton === evt.button || isTouch)) {
              try {
                srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
              } catch (e) {
              }
              _this._currentActiveButton = -1;
              _this._previousPosition = null;
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            } else if (p.type === PointerEventTypes.POINTERMOVE) {
              if (engine.isPointerLock && _this._onMouseMove) {
                _this._onMouseMove(p.event);
              } else if (_this._previousPosition) {
                var offsetX = evt.clientX - _this._previousPosition.x;
                var offsetY = evt.clientY - _this._previousPosition.y;
                if (_this.camera.getScene().useRightHandedSystem) {
                  offsetX *= -1;
                }
                if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {
                  offsetX *= -1;
                }
                if (_this._allowCameraRotation) {
                  _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;
                  _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;
                }
                _this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
                _this._previousPosition = {
                  x: evt.clientX,
                  y: evt.clientY
                };
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          };
        }
        this._onMouseMove = function(evt) {
          if (!engine.isPointerLock) {
            return;
          }
          if (engine.isInVRExclusivePointerMode) {
            return;
          }
          var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
          if (_this.camera.getScene().useRightHandedSystem) {
            offsetX *= -1;
          }
          if (_this.camera.parent && _this.camera.parent._getWorldMatrixDeterminant() < 0) {
            offsetX *= -1;
          }
          _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;
          var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
          _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;
          _this._previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        };
        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (element) {
          this._contextMenuBind = this.onContextMenu.bind(this);
          element.addEventListener("contextmenu", this._contextMenuBind, false);
        }
      };
      FreeCameraMouseInput2.prototype.onContextMenu = function(evt) {
        evt.preventDefault();
      };
      FreeCameraMouseInput2.prototype.detachControl = function() {
        if (this._observer) {
          this.camera.getScene().onPointerObservable.remove(this._observer);
          if (this._contextMenuBind) {
            var engine = this.camera.getEngine();
            var element = engine.getInputElement();
            element && element.removeEventListener("contextmenu", this._contextMenuBind);
          }
          if (this.onPointerMovedObservable) {
            this.onPointerMovedObservable.clear();
          }
          this._observer = null;
          this._onMouseMove = null;
          this._previousPosition = null;
        }
        this._currentActiveButton = -1;
      };
      FreeCameraMouseInput2.prototype.getClassName = function() {
        return "FreeCameraMouseInput";
      };
      FreeCameraMouseInput2.prototype.getSimpleName = function() {
        return "mouse";
      };
      __decorate([
        serialize()
      ], FreeCameraMouseInput2.prototype, "buttons", void 0);
      __decorate([
        serialize()
      ], FreeCameraMouseInput2.prototype, "angularSensibility", void 0);
      return FreeCameraMouseInput2;
    }();
    CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty, FreeCameraMouseWheelInput;
var init_freeCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraMouseWheelInput();
    init_math_vector();
    init_math_axis();
    (function(_CameraProperty2) {
      _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
      _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
      _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
    })(_CameraProperty || (_CameraProperty = {}));
    FreeCameraMouseWheelInput = function(_super) {
      __extends(FreeCameraMouseWheelInput2, _super);
      function FreeCameraMouseWheelInput2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._moveRelative = Vector3.Zero();
        _this._rotateRelative = Vector3.Zero();
        _this._moveScene = Vector3.Zero();
        _this._wheelXAction = _CameraProperty.MoveRelative;
        _this._wheelXActionCoordinate = Coordinate.X;
        _this._wheelYAction = _CameraProperty.MoveRelative;
        _this._wheelYActionCoordinate = Coordinate.Z;
        _this._wheelZAction = null;
        _this._wheelZActionCoordinate = null;
        return _this;
      }
      FreeCameraMouseWheelInput2.prototype.getClassName = function() {
        return "FreeCameraMouseWheelInput";
      };
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXMoveRelative", {
        get: function() {
          if (this._wheelXAction !== _CameraProperty.MoveRelative) {
            return null;
          }
          return this._wheelXActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
            return;
          }
          this._wheelXAction = _CameraProperty.MoveRelative;
          this._wheelXActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYMoveRelative", {
        get: function() {
          if (this._wheelYAction !== _CameraProperty.MoveRelative) {
            return null;
          }
          return this._wheelYActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
            return;
          }
          this._wheelYAction = _CameraProperty.MoveRelative;
          this._wheelYActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZMoveRelative", {
        get: function() {
          if (this._wheelZAction !== _CameraProperty.MoveRelative) {
            return null;
          }
          return this._wheelZActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
            return;
          }
          this._wheelZAction = _CameraProperty.MoveRelative;
          this._wheelZActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXRotateRelative", {
        get: function() {
          if (this._wheelXAction !== _CameraProperty.RotateRelative) {
            return null;
          }
          return this._wheelXActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
            return;
          }
          this._wheelXAction = _CameraProperty.RotateRelative;
          this._wheelXActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYRotateRelative", {
        get: function() {
          if (this._wheelYAction !== _CameraProperty.RotateRelative) {
            return null;
          }
          return this._wheelYActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
            return;
          }
          this._wheelYAction = _CameraProperty.RotateRelative;
          this._wheelYActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZRotateRelative", {
        get: function() {
          if (this._wheelZAction !== _CameraProperty.RotateRelative) {
            return null;
          }
          return this._wheelZActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
            return;
          }
          this._wheelZAction = _CameraProperty.RotateRelative;
          this._wheelZActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelXMoveScene", {
        get: function() {
          if (this._wheelXAction !== _CameraProperty.MoveScene) {
            return null;
          }
          return this._wheelXActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
            return;
          }
          this._wheelXAction = _CameraProperty.MoveScene;
          this._wheelXActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelYMoveScene", {
        get: function() {
          if (this._wheelYAction !== _CameraProperty.MoveScene) {
            return null;
          }
          return this._wheelYActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
            return;
          }
          this._wheelYAction = _CameraProperty.MoveScene;
          this._wheelYActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCameraMouseWheelInput2.prototype, "wheelZMoveScene", {
        get: function() {
          if (this._wheelZAction !== _CameraProperty.MoveScene) {
            return null;
          }
          return this._wheelZActionCoordinate;
        },
        set: function(axis) {
          if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
            return;
          }
          this._wheelZAction = _CameraProperty.MoveScene;
          this._wheelZActionCoordinate = axis;
        },
        enumerable: false,
        configurable: true
      });
      FreeCameraMouseWheelInput2.prototype.checkInputs = function() {
        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
          return;
        }
        this._moveRelative.setAll(0);
        this._rotateRelative.setAll(0);
        this._moveScene.setAll(0);
        this._updateCamera();
        if (this.camera.getScene().useRightHandedSystem) {
          this._moveRelative.z *= -1;
        }
        var cameraTransformMatrix = Matrix.Zero();
        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
        var transformedDirection = Vector3.Zero();
        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
        this.camera.cameraRotation.x += this._rotateRelative.x / 200;
        this.camera.cameraRotation.y += this._rotateRelative.y / 200;
        this.camera.cameraDirection.addInPlace(transformedDirection);
        this.camera.cameraDirection.addInPlace(this._moveScene);
        _super.prototype.checkInputs.call(this);
      };
      FreeCameraMouseWheelInput2.prototype._updateCamera = function() {
        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
      };
      FreeCameraMouseWheelInput2.prototype._updateCameraProperty = function(value, cameraProperty, coordinate) {
        if (value === 0) {
          return;
        }
        if (cameraProperty === null || coordinate === null) {
          return;
        }
        var action = null;
        switch (cameraProperty) {
          case _CameraProperty.MoveRelative:
            action = this._moveRelative;
            break;
          case _CameraProperty.RotateRelative:
            action = this._rotateRelative;
            break;
          case _CameraProperty.MoveScene:
            action = this._moveScene;
            break;
        }
        switch (coordinate) {
          case Coordinate.X:
            action.set(value, 0, 0);
            break;
          case Coordinate.Y:
            action.set(0, value, 0);
            break;
          case Coordinate.Z:
            action.set(0, 0, value);
            break;
        }
      };
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelXMoveRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelYMoveRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelZMoveRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelXRotateRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelYRotateRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelZRotateRelative", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelXMoveScene", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelYMoveScene", null);
      __decorate([
        serialize()
      ], FreeCameraMouseWheelInput2.prototype, "wheelZMoveScene", null);
      return FreeCameraMouseWheelInput2;
    }(BaseCameraMouseWheelInput);
    CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput;
var init_freeCameraTouchInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_vector();
    init_tools();
    FreeCameraTouchInput = function() {
      function FreeCameraTouchInput2(allowMouse) {
        if (allowMouse === void 0) {
          allowMouse = false;
        }
        this.allowMouse = allowMouse;
        this.touchAngularSensibility = 2e5;
        this.touchMoveSensibility = 250;
        this.singleFingerRotate = false;
        this._offsetX = null;
        this._offsetY = null;
        this._pointerPressed = new Array();
      }
      FreeCameraTouchInput2.prototype.attachControl = function(noPreventDefault) {
        var _this = this;
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        var previousPosition = null;
        if (this._pointerInput === void 0) {
          this._onLostFocus = function() {
            _this._offsetX = null;
            _this._offsetY = null;
          };
          this._pointerInput = function(p) {
            var evt = p.event;
            var isMouseEvent = !_this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
            if (!_this.allowMouse && (evt.pointerType === "mouse" || isMouseEvent)) {
              return;
            }
            if (p.type === PointerEventTypes.POINTERDOWN) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              _this._pointerPressed.push(evt.pointerId);
              if (_this._pointerPressed.length !== 1) {
                return;
              }
              previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
            } else if (p.type === PointerEventTypes.POINTERUP) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              var index = _this._pointerPressed.indexOf(evt.pointerId);
              if (index === -1) {
                return;
              }
              _this._pointerPressed.splice(index, 1);
              if (index != 0) {
                return;
              }
              previousPosition = null;
              _this._offsetX = null;
              _this._offsetY = null;
            } else if (p.type === PointerEventTypes.POINTERMOVE) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              if (!previousPosition) {
                return;
              }
              var index = _this._pointerPressed.indexOf(evt.pointerId);
              if (index != 0) {
                return;
              }
              _this._offsetX = evt.clientX - previousPosition.x;
              _this._offsetY = -(evt.clientY - previousPosition.y);
            }
          };
        }
        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (this._onLostFocus) {
          var engine = this.camera.getEngine();
          var element = engine.getInputElement();
          element && element.addEventListener("blur", this._onLostFocus);
        }
      };
      FreeCameraTouchInput2.prototype.detachControl = function() {
        if (this._pointerInput) {
          if (this._observer) {
            this.camera.getScene().onPointerObservable.remove(this._observer);
            this._observer = null;
          }
          if (this._onLostFocus) {
            var engine = this.camera.getEngine();
            var element = engine.getInputElement();
            element && element.removeEventListener("blur", this._onLostFocus);
            this._onLostFocus = null;
          }
          this._pointerPressed = [];
          this._offsetX = null;
          this._offsetY = null;
        }
      };
      FreeCameraTouchInput2.prototype.checkInputs = function() {
        if (this._offsetX === null || this._offsetY === null) {
          return;
        }
        if (this._offsetX === 0 && this._offsetY === 0) {
          return;
        }
        var camera = this.camera;
        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;
        var rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;
        if (rotateCamera) {
          camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
        } else {
          var speed = camera._computeLocalCameraSpeed();
          var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);
          Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
          camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
        }
      };
      FreeCameraTouchInput2.prototype.getClassName = function() {
        return "FreeCameraTouchInput";
      };
      FreeCameraTouchInput2.prototype.getSimpleName = function() {
        return "touch";
      };
      __decorate([
        serialize()
      ], FreeCameraTouchInput2.prototype, "touchAngularSensibility", void 0);
      __decorate([
        serialize()
      ], FreeCameraTouchInput2.prototype, "touchMoveSensibility", void 0);
      return FreeCameraTouchInput2;
    }();
    CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;
  }
});

// node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager;
var init_freeCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js"() {
    init_tslib_es6();
    init_cameraInputsManager();
    init_freeCameraKeyboardMoveInput();
    init_freeCameraMouseInput();
    init_freeCameraMouseWheelInput();
    init_freeCameraTouchInput();
    FreeCameraInputsManager = function(_super) {
      __extends(FreeCameraInputsManager2, _super);
      function FreeCameraInputsManager2(camera) {
        var _this = _super.call(this, camera) || this;
        _this._mouseInput = null;
        _this._mouseWheelInput = null;
        return _this;
      }
      FreeCameraInputsManager2.prototype.addKeyboard = function() {
        this.add(new FreeCameraKeyboardMoveInput());
        return this;
      };
      FreeCameraInputsManager2.prototype.addMouse = function(touchEnabled) {
        if (touchEnabled === void 0) {
          touchEnabled = true;
        }
        if (!this._mouseInput) {
          this._mouseInput = new FreeCameraMouseInput(touchEnabled);
          this.add(this._mouseInput);
        }
        return this;
      };
      FreeCameraInputsManager2.prototype.removeMouse = function() {
        if (this._mouseInput) {
          this.remove(this._mouseInput);
        }
        return this;
      };
      FreeCameraInputsManager2.prototype.addMouseWheel = function() {
        if (!this._mouseWheelInput) {
          this._mouseWheelInput = new FreeCameraMouseWheelInput();
          this.add(this._mouseWheelInput);
        }
        return this;
      };
      FreeCameraInputsManager2.prototype.removeMouseWheel = function() {
        if (this._mouseWheelInput) {
          this.remove(this._mouseWheelInput);
        }
        return this;
      };
      FreeCameraInputsManager2.prototype.addTouch = function() {
        this.add(new FreeCameraTouchInput());
        return this;
      };
      FreeCameraInputsManager2.prototype.clear = function() {
        _super.prototype.clear.call(this);
        this._mouseInput = null;
      };
      return FreeCameraInputsManager2;
    }(CameraInputsManager);
  }
});

// node_modules/@babylonjs/core/Cameras/targetCamera.js
var TargetCamera;
var init_targetCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/targetCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_camera();
    init_math_vector();
    init_math_constants();
    init_math_axis();
    TargetCamera = function(_super) {
      __extends(TargetCamera2, _super);
      function TargetCamera2(name105, position, scene, setActiveOnSceneIfNoneActive) {
        if (setActiveOnSceneIfNoneActive === void 0) {
          setActiveOnSceneIfNoneActive = true;
        }
        var _this = _super.call(this, name105, position, scene, setActiveOnSceneIfNoneActive) || this;
        _this._tmpUpVector = Vector3.Zero();
        _this._tmpTargetVector = Vector3.Zero();
        _this.cameraDirection = new Vector3(0, 0, 0);
        _this.cameraRotation = new Vector2(0, 0);
        _this.ignoreParentScaling = false;
        _this.updateUpVectorFromRotation = false;
        _this._tmpQuaternion = new Quaternion();
        _this.rotation = new Vector3(0, 0, 0);
        _this.speed = 2;
        _this.noRotationConstraint = false;
        _this.invertRotation = false;
        _this.inverseRotationSpeed = 0.2;
        _this.lockedTarget = null;
        _this._currentTarget = Vector3.Zero();
        _this._initialFocalDistance = 1;
        _this._viewMatrix = Matrix.Zero();
        _this._camMatrix = Matrix.Zero();
        _this._cameraTransformMatrix = Matrix.Zero();
        _this._cameraRotationMatrix = Matrix.Zero();
        _this._referencePoint = new Vector3(0, 0, 1);
        _this._transformedReferencePoint = Vector3.Zero();
        _this._defaultUp = Vector3.Up();
        _this._cachedRotationZ = 0;
        _this._cachedQuaternionRotationZ = 0;
        return _this;
      }
      TargetCamera2.prototype.getFrontPosition = function(distance) {
        this.getWorldMatrix();
        var direction = this.getTarget().subtract(this.position);
        direction.normalize();
        direction.scaleInPlace(distance);
        return this.globalPosition.add(direction);
      };
      TargetCamera2.prototype._getLockedTargetPosition = function() {
        if (!this.lockedTarget) {
          return null;
        }
        if (this.lockedTarget.absolutePosition) {
          this.lockedTarget.computeWorldMatrix();
        }
        return this.lockedTarget.absolutePosition || this.lockedTarget;
      };
      TargetCamera2.prototype.storeState = function() {
        this._storedPosition = this.position.clone();
        this._storedRotation = this.rotation.clone();
        if (this.rotationQuaternion) {
          this._storedRotationQuaternion = this.rotationQuaternion.clone();
        }
        return _super.prototype.storeState.call(this);
      };
      TargetCamera2.prototype._restoreStateValues = function() {
        if (!_super.prototype._restoreStateValues.call(this)) {
          return false;
        }
        this.position = this._storedPosition.clone();
        this.rotation = this._storedRotation.clone();
        if (this.rotationQuaternion) {
          this.rotationQuaternion = this._storedRotationQuaternion.clone();
        }
        this.cameraDirection.copyFromFloats(0, 0, 0);
        this.cameraRotation.copyFromFloats(0, 0);
        return true;
      };
      TargetCamera2.prototype._initCache = function() {
        _super.prototype._initCache.call(this);
        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      };
      TargetCamera2.prototype._updateCache = function(ignoreParentClass) {
        if (!ignoreParentClass) {
          _super.prototype._updateCache.call(this);
        }
        var lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
          this._cache.lockedTarget = null;
        } else {
          if (!this._cache.lockedTarget) {
            this._cache.lockedTarget = lockedTargetPosition.clone();
          } else {
            this._cache.lockedTarget.copyFrom(lockedTargetPosition);
          }
        }
        this._cache.rotation.copyFrom(this.rotation);
        if (this.rotationQuaternion) {
          this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
        }
      };
      TargetCamera2.prototype._isSynchronizedViewMatrix = function() {
        if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
          return false;
        }
        var lockedTargetPosition = this._getLockedTargetPosition();
        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
      };
      TargetCamera2.prototype._computeLocalCameraSpeed = function() {
        var engine = this.getEngine();
        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
      };
      TargetCamera2.prototype.setTarget = function(target) {
        this.upVector.normalize();
        this._initialFocalDistance = target.subtract(this.position).length();
        if (this.position.z === target.z) {
          this.position.z += Epsilon;
        }
        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
        this._camMatrix.invert();
        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
        var vDir = target.subtract(this.position);
        if (vDir.x >= 0) {
          this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
        } else {
          this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
        }
        this.rotation.z = 0;
        if (isNaN(this.rotation.x)) {
          this.rotation.x = 0;
        }
        if (isNaN(this.rotation.y)) {
          this.rotation.y = 0;
        }
        if (isNaN(this.rotation.z)) {
          this.rotation.z = 0;
        }
        if (this.rotationQuaternion) {
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
        }
      };
      Object.defineProperty(TargetCamera2.prototype, "target", {
        get: function() {
          return this.getTarget();
        },
        set: function(value) {
          this.setTarget(value);
        },
        enumerable: false,
        configurable: true
      });
      TargetCamera2.prototype.getTarget = function() {
        return this._currentTarget;
      };
      TargetCamera2.prototype._decideIfNeedsToMove = function() {
        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      };
      TargetCamera2.prototype._updatePosition = function() {
        if (this.parent) {
          this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
          Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
          this.position.addInPlace(TmpVectors.Vector3[0]);
          return;
        }
        this.position.addInPlace(this.cameraDirection);
      };
      TargetCamera2.prototype._checkInputs = function() {
        var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
        var needToMove = this._decideIfNeedsToMove();
        var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
        if (needToMove) {
          this._updatePosition();
        }
        if (needToRotate) {
          if (this.rotationQuaternion) {
            this.rotationQuaternion.toEulerAnglesToRef(this.rotation);
          }
          this.rotation.x += this.cameraRotation.x * directionMultiplier;
          this.rotation.y += this.cameraRotation.y * directionMultiplier;
          if (!this.noRotationConstraint) {
            var limit = 1.570796;
            if (this.rotation.x > limit) {
              this.rotation.x = limit;
            }
            if (this.rotation.x < -limit) {
              this.rotation.x = -limit;
            }
          }
          if (this.rotationQuaternion) {
            var len = this.rotation.lengthSquared();
            if (len) {
              Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
            }
          }
        }
        if (needToMove) {
          if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
            this.cameraDirection.x = 0;
          }
          if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
            this.cameraDirection.y = 0;
          }
          if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
            this.cameraDirection.z = 0;
          }
          this.cameraDirection.scaleInPlace(this.inertia);
        }
        if (needToRotate) {
          if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
            this.cameraRotation.x = 0;
          }
          if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
            this.cameraRotation.y = 0;
          }
          this.cameraRotation.scaleInPlace(this.inertia);
        }
        _super.prototype._checkInputs.call(this);
      };
      TargetCamera2.prototype._updateCameraRotationMatrix = function() {
        if (this.rotationQuaternion) {
          this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
        } else {
          Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
        }
      };
      TargetCamera2.prototype._rotateUpVectorWithCameraRotationMatrix = function() {
        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
        return this;
      };
      TargetCamera2.prototype._getViewMatrix = function() {
        if (this.lockedTarget) {
          this.setTarget(this._getLockedTargetPosition());
        }
        this._updateCameraRotationMatrix();
        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
        } else if (this._cachedRotationZ !== this.rotation.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedRotationZ = this.rotation.z;
        }
        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        if (this.updateUpVectorFromRotation) {
          if (this.rotationQuaternion) {
            Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
          } else {
            Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
            Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
          }
        }
        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
        return this._viewMatrix;
      };
      TargetCamera2.prototype._computeViewMatrix = function(position, target, up) {
        if (this.ignoreParentScaling) {
          if (this.parent) {
            var parentWorldMatrix = this.parent.getWorldMatrix();
            Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
            Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
            Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
            this._markSyncedWithParent();
          } else {
            this._globalPosition.copyFrom(position);
            this._tmpTargetVector.copyFrom(target);
            this._tmpUpVector.copyFrom(up);
          }
          if (this.getScene().useRightHandedSystem) {
            Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
          } else {
            Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
          }
          return;
        }
        if (this.getScene().useRightHandedSystem) {
          Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
        } else {
          Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
        }
        if (this.parent) {
          var parentWorldMatrix = this.parent.getWorldMatrix();
          this._viewMatrix.invert();
          this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
          this._viewMatrix.getTranslationToRef(this._globalPosition);
          this._viewMatrix.invert();
          this._markSyncedWithParent();
        } else {
          this._globalPosition.copyFrom(position);
        }
      };
      TargetCamera2.prototype.createRigCamera = function(name105, cameraIndex) {
        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          var rigCamera = new TargetCamera2(name105, this.position.clone(), this.getScene());
          rigCamera.isRigCamera = true;
          rigCamera.rigParent = this;
          if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {
            if (!this.rotationQuaternion) {
              this.rotationQuaternion = new Quaternion();
            }
            rigCamera._cameraRigParams = {};
            rigCamera.rotationQuaternion = new Quaternion();
          }
          return rigCamera;
        }
        return null;
      };
      TargetCamera2.prototype._updateRigCameras = function() {
        var camLeft = this._rigCameras[0];
        var camRight = this._rigCameras[1];
        this.computeWorldMatrix();
        switch (this.cameraRigMode) {
          case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
          case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
          case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
            var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
            var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
            break;
          }
          case Camera.RIG_MODE_VR:
            if (camLeft.rotationQuaternion) {
              camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
              camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
            } else {
              camLeft.rotation.copyFrom(this.rotation);
              camRight.rotation.copyFrom(this.rotation);
            }
            camLeft.position.copyFrom(this.position);
            camRight.position.copyFrom(this.position);
            break;
        }
        _super.prototype._updateRigCameras.call(this);
      };
      TargetCamera2.prototype._getRigCamPositionAndTarget = function(halfSpace, rigCamera) {
        var target = this.getTarget();
        target.subtractToRef(this.position, TargetCamera2._TargetFocalPoint);
        TargetCamera2._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
        var newFocalTarget = TargetCamera2._TargetFocalPoint.addInPlace(this.position);
        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
        TargetCamera2._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera2._RigCamTransformMatrix);
        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
        TargetCamera2._RigCamTransformMatrix.multiplyToRef(TargetCamera2._TargetTransformMatrix, TargetCamera2._RigCamTransformMatrix);
        Vector3.TransformCoordinatesToRef(this.position, TargetCamera2._RigCamTransformMatrix, rigCamera.position);
        rigCamera.setTarget(newFocalTarget);
      };
      TargetCamera2.prototype.getClassName = function() {
        return "TargetCamera";
      };
      TargetCamera2._RigCamTransformMatrix = new Matrix();
      TargetCamera2._TargetTransformMatrix = new Matrix();
      TargetCamera2._TargetFocalPoint = new Vector3();
      __decorate([
        serializeAsVector3()
      ], TargetCamera2.prototype, "rotation", void 0);
      __decorate([
        serialize()
      ], TargetCamera2.prototype, "speed", void 0);
      __decorate([
        serializeAsMeshReference("lockedTargetId")
      ], TargetCamera2.prototype, "lockedTarget", void 0);
      return TargetCamera2;
    }(Camera);
  }
});

// node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera;
var init_freeCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_engine();
    init_targetCamera();
    init_freeCameraInputsManager();
    init_tools();
    FreeCamera = function(_super) {
      __extends(FreeCamera2, _super);
      function FreeCamera2(name105, position, scene, setActiveOnSceneIfNoneActive) {
        if (setActiveOnSceneIfNoneActive === void 0) {
          setActiveOnSceneIfNoneActive = true;
        }
        var _this = _super.call(this, name105, position, scene, setActiveOnSceneIfNoneActive) || this;
        _this.ellipsoid = new Vector3(0.5, 1, 0.5);
        _this.ellipsoidOffset = new Vector3(0, 0, 0);
        _this.checkCollisions = false;
        _this.applyGravity = false;
        _this._needMoveForGravity = false;
        _this._oldPosition = Vector3.Zero();
        _this._diffPosition = Vector3.Zero();
        _this._newPosition = Vector3.Zero();
        _this._collisionMask = -1;
        _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
          if (collidedMesh === void 0) {
            collidedMesh = null;
          }
          var updatePosition = function(newPos) {
            _this._newPosition.copyFrom(newPos);
            _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);
            if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {
              _this.position.addInPlace(_this._diffPosition);
              if (_this.onCollide && collidedMesh) {
                _this.onCollide(collidedMesh);
              }
            }
          };
          updatePosition(newPosition);
        };
        _this.inputs = new FreeCameraInputsManager(_this);
        _this.inputs.addKeyboard().addMouse();
        return _this;
      }
      Object.defineProperty(FreeCamera2.prototype, "angularSensibility", {
        get: function() {
          var mouse = this.inputs.attached["mouse"];
          if (mouse) {
            return mouse.angularSensibility;
          }
          return 0;
        },
        set: function(value) {
          var mouse = this.inputs.attached["mouse"];
          if (mouse) {
            mouse.angularSensibility = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysUp", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysUp;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysUp = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysUpward", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysUpward;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysUpward = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysDown", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysDown;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysDown = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysDownward", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysDownward;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysDownward = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysLeft", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysLeft;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysLeft = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysRight", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysRight;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysRight = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysRotateLeft", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysRotateLeft;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysRotateLeft = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FreeCamera2.prototype, "keysRotateRight", {
        get: function() {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            return keyboard.keysRotateRight;
          }
          return [];
        },
        set: function(value) {
          var keyboard = this.inputs.attached["keyboard"];
          if (keyboard) {
            keyboard.keysRotateRight = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      FreeCamera2.prototype.attachControl = function(ignored, noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this.inputs.attachElement(noPreventDefault);
      };
      FreeCamera2.prototype.detachControl = function() {
        this.inputs.detachElement();
        this.cameraDirection = new Vector3(0, 0, 0);
        this.cameraRotation = new Vector2(0, 0);
      };
      Object.defineProperty(FreeCamera2.prototype, "collisionMask", {
        get: function() {
          return this._collisionMask;
        },
        set: function(mask) {
          this._collisionMask = !isNaN(mask) ? mask : -1;
        },
        enumerable: false,
        configurable: true
      });
      FreeCamera2.prototype._collideWithWorld = function(displacement) {
        var globalPosition;
        if (this.parent) {
          globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
          globalPosition = this.position;
        }
        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._oldPosition.addInPlace(this.ellipsoidOffset);
        var coordinator = this.getScene().collisionCoordinator;
        if (!this._collider) {
          this._collider = coordinator.createCollider();
        }
        this._collider._radius = this.ellipsoid;
        this._collider.collisionMask = this._collisionMask;
        var actualDisplacement = displacement;
        if (this.applyGravity) {
          actualDisplacement = displacement.add(this.getScene().gravity);
        }
        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
      };
      FreeCamera2.prototype._checkInputs = function() {
        if (!this._localDirection) {
          this._localDirection = Vector3.Zero();
          this._transformedDirection = Vector3.Zero();
        }
        this.inputs.checkInputs();
        _super.prototype._checkInputs.call(this);
      };
      FreeCamera2.prototype._decideIfNeedsToMove = function() {
        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      };
      FreeCamera2.prototype._updatePosition = function() {
        if (this.checkCollisions && this.getScene().collisionsEnabled) {
          this._collideWithWorld(this.cameraDirection);
        } else {
          _super.prototype._updatePosition.call(this);
        }
      };
      FreeCamera2.prototype.dispose = function() {
        this.inputs.clear();
        _super.prototype.dispose.call(this);
      };
      FreeCamera2.prototype.getClassName = function() {
        return "FreeCamera";
      };
      __decorate([
        serializeAsVector3()
      ], FreeCamera2.prototype, "ellipsoid", void 0);
      __decorate([
        serializeAsVector3()
      ], FreeCamera2.prototype, "ellipsoidOffset", void 0);
      __decorate([
        serialize()
      ], FreeCamera2.prototype, "checkCollisions", void 0);
      __decorate([
        serialize()
      ], FreeCamera2.prototype, "applyGravity", void 0);
      return FreeCamera2;
    }(TargetCamera);
  }
});

// node_modules/@babylonjs/core/Engines/renderTargetWrapper.js
var RenderTargetWrapper;
var init_renderTargetWrapper = __esm({
  "node_modules/@babylonjs/core/Engines/renderTargetWrapper.js"() {
    init_internalTexture();
    RenderTargetWrapper = function() {
      function RenderTargetWrapper2(isMulti, isCube, size, engine) {
        this._textures = null;
        this._attachments = null;
        this._generateStencilBuffer = false;
        this._generateDepthBuffer = false;
        this._depthStencilTextureWithStencil = false;
        this._isMulti = isMulti;
        this._isCube = isCube;
        this._size = size;
        this._engine = engine;
        this._depthStencilTexture = null;
      }
      Object.defineProperty(RenderTargetWrapper2.prototype, "depthStencilTexture", {
        get: function() {
          return this._depthStencilTexture;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "depthStencilTextureWithStencil", {
        get: function() {
          return this._depthStencilTextureWithStencil;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "isCube", {
        get: function() {
          return this._isCube;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "isMulti", {
        get: function() {
          return this._isMulti;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "is2DArray", {
        get: function() {
          return this.layers > 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "size", {
        get: function() {
          return this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "width", {
        get: function() {
          return this._size.width || this._size;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "height", {
        get: function() {
          return this._size.height || this._size;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "layers", {
        get: function() {
          return this._size.layers || 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "texture", {
        get: function() {
          var _a, _b;
          return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "textures", {
        get: function() {
          return this._textures;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetWrapper2.prototype, "samples", {
        get: function() {
          var _a, _b;
          return (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : 1;
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetWrapper2.prototype.setSamples = function(value, initializeBuffers, force) {
        if (initializeBuffers === void 0) {
          initializeBuffers = true;
        }
        if (force === void 0) {
          force = false;
        }
        if (this.samples === value && !force) {
          return value;
        }
        return this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);
      };
      RenderTargetWrapper2.prototype.setTextures = function(textures) {
        if (Array.isArray(textures)) {
          this._textures = textures;
        } else if (textures) {
          this._textures = [textures];
        } else {
          this._textures = null;
        }
      };
      RenderTargetWrapper2.prototype.setTexture = function(texture, index, disposePrevious) {
        if (index === void 0) {
          index = 0;
        }
        if (disposePrevious === void 0) {
          disposePrevious = true;
        }
        if (!this._textures) {
          this._textures = [];
        }
        if (this._textures[index] && disposePrevious) {
          this._textures[index].dispose();
        }
        this._textures[index] = texture;
      };
      RenderTargetWrapper2.prototype.createDepthStencilTexture = function(comparisonFunction, bilinearFiltering, generateStencil, samples, format) {
        var _a;
        if (comparisonFunction === void 0) {
          comparisonFunction = 0;
        }
        if (bilinearFiltering === void 0) {
          bilinearFiltering = true;
        }
        if (generateStencil === void 0) {
          generateStencil = false;
        }
        if (samples === void 0) {
          samples = 1;
        }
        if (format === void 0) {
          format = 14;
        }
        (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
        this._depthStencilTextureWithStencil = generateStencil;
        this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
          bilinearFiltering,
          comparisonFunction,
          generateStencil,
          isCube: this._isCube,
          samples,
          depthTextureFormat: format
        }, this);
        return this._depthStencilTexture;
      };
      RenderTargetWrapper2.prototype._shareDepth = function(renderTarget) {
        if (this._depthStencilTexture) {
          if (renderTarget._depthStencilTexture) {
            renderTarget._depthStencilTexture.dispose();
          }
          renderTarget._depthStencilTexture = this._depthStencilTexture;
          this._depthStencilTexture.incrementReferences();
        }
      };
      RenderTargetWrapper2.prototype._swapAndDie = function(target) {
        if (this.texture) {
          this.texture._swapAndDie(target);
        }
        this._textures = null;
        this.dispose(true);
      };
      RenderTargetWrapper2.prototype._cloneRenderTargetWrapper = function() {
        var _a, _b, _c, _d, _e, _f;
        var rtw = null;
        if (this._isMulti) {
          var textureArray = this.textures;
          if (textureArray && textureArray.length > 0) {
            var generateDepthTexture = false;
            var textureCount = textureArray.length;
            var lastTextureSource = textureArray[textureArray.length - 1]._source;
            if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {
              generateDepthTexture = true;
              textureCount--;
            }
            var samplingModes = [];
            var types = [];
            for (var i = 0; i < textureCount; ++i) {
              var texture = textureArray[i];
              samplingModes.push(texture.samplingMode);
              types.push(texture.type);
            }
            var optionsMRT = {
              samplingModes,
              generateMipMaps: textureArray[0].generateMipMaps,
              generateDepthBuffer: this._generateDepthBuffer,
              generateStencilBuffer: this._generateStencilBuffer,
              generateDepthTexture,
              types,
              textureCount
            };
            var size = {
              width: this.width,
              height: this.height
            };
            rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);
          }
        } else {
          var options = {};
          options.generateDepthBuffer = this._generateDepthBuffer;
          options.generateMipMaps = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) !== null && _b !== void 0 ? _b : false;
          options.generateStencilBuffer = this._generateStencilBuffer;
          options.samplingMode = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.samplingMode;
          options.type = (_d = this.texture) === null || _d === void 0 ? void 0 : _d.type;
          options.format = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.format;
          if (this.isCube) {
            rtw = this._engine.createRenderTargetCubeTexture(this.width, options);
          } else {
            var size = {
              width: this.width,
              height: this.height,
              layers: this.is2DArray ? (_f = this.texture) === null || _f === void 0 ? void 0 : _f.depth : void 0
            };
            rtw = this._engine.createRenderTargetTexture(size, options);
          }
          rtw.texture.isReady = true;
        }
        return rtw;
      };
      RenderTargetWrapper2.prototype._swapRenderTargetWrapper = function(target) {
        if (this._textures && target._textures) {
          for (var i = 0; i < this._textures.length; ++i) {
            this._textures[i]._swapAndDie(target._textures[i], false);
            target._textures[i].isReady = true;
          }
        }
        if (this._depthStencilTexture && target._depthStencilTexture) {
          this._depthStencilTexture._swapAndDie(target._depthStencilTexture);
          target._depthStencilTexture.isReady = true;
        }
        this._textures = null;
        this._depthStencilTexture = null;
      };
      RenderTargetWrapper2.prototype._rebuild = function() {
        var rtw = this._cloneRenderTargetWrapper();
        if (!rtw) {
          return;
        }
        if (this._depthStencilTexture) {
          var samplingMode = this._depthStencilTexture.samplingMode;
          var bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;
          rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
        }
        if (this.samples > 1) {
          rtw.setSamples(this.samples);
        }
        rtw._swapRenderTargetWrapper(this);
        rtw.dispose();
      };
      RenderTargetWrapper2.prototype.releaseTextures = function() {
        var _a, _b;
        if (this._textures) {
          for (var i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {
            this._textures[i].dispose();
          }
        }
        this._textures = null;
      };
      RenderTargetWrapper2.prototype.dispose = function(disposeOnlyFramebuffers) {
        var _a;
        if (disposeOnlyFramebuffers === void 0) {
          disposeOnlyFramebuffers = false;
        }
        if (!disposeOnlyFramebuffers) {
          (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          this._depthStencilTexture = null;
          this.releaseTextures();
        }
        this._engine._releaseRenderTargetWrapper(this);
      };
      return RenderTargetWrapper2;
    }();
  }
});

// node_modules/@babylonjs/core/Shaders/postprocess.vertex.js
var name, shader;
var init_postprocess_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/postprocess.vertex.js"() {
    init_shaderStore();
    name = "postprocessVertexShader";
    shader = "attribute vec2 position;\nuniform vec2 scale;\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";
    ShaderStore.ShadersStore[name] = shader;
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js
var WebGLRenderTargetWrapper;
var init_webGLRenderTargetWrapper = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js"() {
    init_tslib_es6();
    init_renderTargetWrapper();
    WebGLRenderTargetWrapper = function(_super) {
      __extends(WebGLRenderTargetWrapper2, _super);
      function WebGLRenderTargetWrapper2(isMulti, isCube, size, engine, context) {
        var _this = _super.call(this, isMulti, isCube, size, engine) || this;
        _this._framebuffer = null;
        _this._depthStencilBuffer = null;
        _this._MSAAFramebuffer = null;
        _this._colorTextureArray = null;
        _this._depthStencilTextureArray = null;
        _this._context = context;
        return _this;
      }
      WebGLRenderTargetWrapper2.prototype._cloneRenderTargetWrapper = function() {
        var rtw = null;
        if (this._colorTextureArray && this._depthStencilTextureArray) {
          rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);
          rtw.texture.isReady = true;
        } else {
          rtw = _super.prototype._cloneRenderTargetWrapper.call(this);
        }
        return rtw;
      };
      WebGLRenderTargetWrapper2.prototype._swapRenderTargetWrapper = function(target) {
        _super.prototype._swapRenderTargetWrapper.call(this, target);
        target._framebuffer = this._framebuffer;
        target._depthStencilBuffer = this._depthStencilBuffer;
        target._MSAAFramebuffer = this._MSAAFramebuffer;
        target._colorTextureArray = this._colorTextureArray;
        target._depthStencilTextureArray = this._depthStencilTextureArray;
        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
      };
      WebGLRenderTargetWrapper2.prototype._shareDepth = function(renderTarget) {
        _super.prototype._shareDepth.call(this, renderTarget);
        var gl = this._context;
        var depthbuffer = this._depthStencilBuffer;
        var framebuffer = renderTarget._framebuffer;
        if (renderTarget._depthStencilBuffer) {
          gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);
        }
        renderTarget._depthStencilBuffer = this._depthStencilBuffer;
        this._engine._bindUnboundFramebuffer(framebuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthbuffer);
        this._engine._bindUnboundFramebuffer(null);
      };
      WebGLRenderTargetWrapper2.prototype._bindTextureRenderTarget = function(texture, attachmentIndex, faceIndex, lodLevel) {
        if (attachmentIndex === void 0) {
          attachmentIndex = 0;
        }
        if (faceIndex === void 0) {
          faceIndex = -1;
        }
        if (lodLevel === void 0) {
          lodLevel = 0;
        }
        if (!texture._hardwareTexture) {
          return;
        }
        var gl = this._context;
        var framebuffer = this._framebuffer;
        var currentFB = this._engine._currentFramebuffer;
        this._engine._bindUnboundFramebuffer(framebuffer);
        var attachment = gl[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + attachmentIndex : "COLOR_ATTACHMENT" + attachmentIndex + "_WEBGL"];
        var target = faceIndex !== -1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);
        this._engine._bindUnboundFramebuffer(currentFB);
      };
      WebGLRenderTargetWrapper2.prototype.setTexture = function(texture, index, disposePrevious) {
        if (index === void 0) {
          index = 0;
        }
        if (disposePrevious === void 0) {
          disposePrevious = true;
        }
        _super.prototype.setTexture.call(this, texture, index, disposePrevious);
        this._bindTextureRenderTarget(texture, index);
      };
      WebGLRenderTargetWrapper2.prototype.dispose = function(disposeOnlyFramebuffers) {
        if (disposeOnlyFramebuffers === void 0) {
          disposeOnlyFramebuffers = false;
        }
        var gl = this._context;
        if (!disposeOnlyFramebuffers) {
          if (this._colorTextureArray) {
            this._context.deleteTexture(this._colorTextureArray);
            this._colorTextureArray = null;
          }
          if (this._depthStencilTextureArray) {
            this._context.deleteTexture(this._depthStencilTextureArray);
            this._depthStencilTextureArray = null;
          }
        }
        if (this._framebuffer) {
          gl.deleteFramebuffer(this._framebuffer);
          this._framebuffer = null;
        }
        if (this._depthStencilBuffer) {
          gl.deleteRenderbuffer(this._depthStencilBuffer);
          this._depthStencilBuffer = null;
        }
        if (this._MSAAFramebuffer) {
          gl.deleteFramebuffer(this._MSAAFramebuffer);
          this._MSAAFramebuffer = null;
        }
        _super.prototype.dispose.call(this, disposeOnlyFramebuffers);
      };
      return WebGLRenderTargetWrapper2;
    }(RenderTargetWrapper);
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js
var init_engine_renderTarget = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js"() {
    init_tslib_es6();
    init_internalTexture();
    init_logger();
    init_thinEngine();
    init_webGLRenderTargetWrapper();
    ThinEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
      var rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);
      this._renderTargetWrapperCache.push(rtWrapper);
      return rtWrapper;
    };
    ThinEngine.prototype.createRenderTargetTexture = function(size, options) {
      var rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
      var fullOptions = {};
      if (options !== void 0 && typeof options === "object") {
        fullOptions.generateDepthBuffer = !!options.generateDepthBuffer;
        fullOptions.generateStencilBuffer = !!options.generateStencilBuffer;
        fullOptions.noColorTarget = !!options.noColorTarget;
      } else {
        fullOptions.generateDepthBuffer = true;
        fullOptions.generateStencilBuffer = false;
        fullOptions.noColorTarget = false;
      }
      var texture = fullOptions.noColorTarget ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);
      var width = size.width || size;
      var height = size.height || size;
      var currentFrameBuffer = this._currentFramebuffer;
      var gl = this._gl;
      var framebuffer = gl.createFramebuffer();
      this._bindUnboundFramebuffer(framebuffer);
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, width, height);
      if (texture && !texture.is2DArray) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
      }
      this._bindUnboundFramebuffer(currentFrameBuffer);
      rtWrapper._framebuffer = framebuffer;
      rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
      rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
      rtWrapper.setTextures(texture);
      return rtWrapper;
    };
    ThinEngine.prototype.createDepthStencilTexture = function(size, options, rtWrapper) {
      if (options.isCube) {
        var width = size.width || size;
        return this._createDepthStencilCubeTexture(width, options, rtWrapper);
      } else {
        return this._createDepthStencilTexture(size, options, rtWrapper);
      }
    };
    ThinEngine.prototype._createDepthStencilTexture = function(size, options, rtWrapper) {
      var gl = this._gl;
      var layers = size.layers || 0;
      var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
      var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
      if (!this._caps.depthTextureExtension) {
        Logger.Error("Depth texture is not supported by your browser or hardware.");
        return internalTexture;
      }
      var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
      this._bindTextureDirectly(target, internalTexture, true);
      this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
      internalTexture.format = internalOptions.generateStencil ? 13 : 16;
      rtWrapper._depthStencilTexture = internalTexture;
      rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;
      var type = internalOptions.generateStencil ? gl.UNSIGNED_INT_24_8 : gl.UNSIGNED_INT;
      var internalFormat = internalOptions.generateStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
      var sizedFormat = internalFormat;
      if (this.webGLVersion > 1) {
        sizedFormat = internalOptions.generateStencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
      }
      if (internalTexture.is2DArray) {
        gl.texImage3D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, layers, 0, internalFormat, type, null);
      } else {
        gl.texImage2D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, 0, internalFormat, type, null);
      }
      this._bindTextureDirectly(target, null);
      this._internalTexturesCache.push(internalTexture);
      return internalTexture;
    };
    ThinEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
      if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {
        return 1;
      }
      if (rtWrapper.samples === samples) {
        return samples;
      }
      var gl = this._gl;
      samples = Math.min(samples, this.getCaps().maxMSAASamples);
      if (rtWrapper._depthStencilBuffer) {
        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
        rtWrapper._depthStencilBuffer = null;
      }
      if (rtWrapper._MSAAFramebuffer) {
        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
        rtWrapper._MSAAFramebuffer = null;
      }
      var hardwareTexture = rtWrapper.texture._hardwareTexture;
      if (hardwareTexture._MSAARenderBuffer) {
        gl.deleteRenderbuffer(hardwareTexture._MSAARenderBuffer);
        hardwareTexture._MSAARenderBuffer = null;
      }
      if (samples > 1 && gl.renderbufferStorageMultisample) {
        var framebuffer = gl.createFramebuffer();
        if (!framebuffer) {
          throw new Error("Unable to create multi sampled framebuffer");
        }
        rtWrapper._MSAAFramebuffer = framebuffer;
        this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
        var colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(rtWrapper.texture.type), gl.COLOR_ATTACHMENT0, false);
        if (!colorRenderbuffer) {
          throw new Error("Unable to create multi sampled framebuffer");
        }
        hardwareTexture._MSAARenderBuffer = colorRenderbuffer;
      } else {
        this._bindUnboundFramebuffer(rtWrapper._framebuffer);
      }
      rtWrapper.texture.samples = samples;
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);
      this._bindUnboundFramebuffer(null);
      return samples;
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/postProcess.js
var PostProcess;
var init_postProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/postProcess.js"() {
    init_tslib_es6();
    init_smartArray();
    init_observable();
    init_math_vector();
    init_postprocess_vertex();
    init_engine();
    init_engine_renderTarget();
    init_decorators();
    init_typeStore();
    init_drawWrapper();
    PostProcess = function() {
      function PostProcess2(name105, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {
        if (samplingMode === void 0) {
          samplingMode = 1;
        }
        if (defines === void 0) {
          defines = null;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        if (vertexUrl === void 0) {
          vertexUrl = "postprocess";
        }
        if (blockCompilation === void 0) {
          blockCompilation = false;
        }
        if (textureFormat === void 0) {
          textureFormat = 5;
        }
        this._parentContainer = null;
        this.width = -1;
        this.height = -1;
        this.nodeMaterialSource = null;
        this._outputTexture = null;
        this.autoClear = true;
        this.alphaMode = 0;
        this.animations = new Array();
        this.enablePixelPerfectMode = false;
        this.forceFullscreenViewport = true;
        this.scaleMode = 1;
        this.alwaysForcePOT = false;
        this._samples = 1;
        this.adaptScaleToCurrentViewport = false;
        this._reusable = false;
        this._renderId = 0;
        this.externalTextureSamplerBinding = false;
        this._textures = new SmartArray(2);
        this._textureCache = [];
        this._currentRenderTextureInd = 0;
        this._scaleRatio = new Vector2(1, 1);
        this._texelSize = Vector2.Zero();
        this.onActivateObservable = new Observable();
        this.onSizeChangedObservable = new Observable();
        this.onApplyObservable = new Observable();
        this.onBeforeRenderObservable = new Observable();
        this.onAfterRenderObservable = new Observable();
        this.name = name105;
        if (camera != null) {
          this._camera = camera;
          this._scene = camera.getScene();
          camera.attachPostProcess(this);
          this._engine = this._scene.getEngine();
          this._scene.postProcesses.push(this);
          this.uniqueId = this._scene.getUniqueId();
        } else if (engine) {
          this._engine = engine;
          this._engine.postProcesses.push(this);
        }
        this._options = options;
        this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
        this._reusable = reusable || false;
        this._textureType = textureType;
        this._textureFormat = textureFormat;
        this._samplers = samplers || [];
        this._samplers.push("textureSampler");
        this._fragmentUrl = fragmentUrl;
        this._vertexUrl = vertexUrl;
        this._parameters = parameters || [];
        this._parameters.push("scale");
        this._indexParameters = indexParameters;
        this._drawWrapper = new DrawWrapper(this._engine);
        if (!blockCompilation) {
          this.updateEffect(defines);
        }
      }
      Object.defineProperty(PostProcess2.prototype, "samples", {
        get: function() {
          return this._samples;
        },
        set: function(n) {
          var _this = this;
          this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
          this._textures.forEach(function(texture) {
            if (texture.samples !== _this._samples) {
              _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      PostProcess2.prototype.getEffectName = function() {
        return this._fragmentUrl;
      };
      Object.defineProperty(PostProcess2.prototype, "onActivate", {
        set: function(callback) {
          if (this._onActivateObserver) {
            this.onActivateObservable.remove(this._onActivateObserver);
          }
          if (callback) {
            this._onActivateObserver = this.onActivateObservable.add(callback);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "onSizeChanged", {
        set: function(callback) {
          if (this._onSizeChangedObserver) {
            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
          }
          this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "onApply", {
        set: function(callback) {
          if (this._onApplyObserver) {
            this.onApplyObservable.remove(this._onApplyObserver);
          }
          this._onApplyObserver = this.onApplyObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "onBeforeRender", {
        set: function(callback) {
          if (this._onBeforeRenderObserver) {
            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
          }
          this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "onAfterRender", {
        set: function(callback) {
          if (this._onAfterRenderObserver) {
            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
          }
          this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "inputTexture", {
        get: function() {
          return this._textures.data[this._currentRenderTextureInd];
        },
        set: function(value) {
          this._forcedOutputTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      PostProcess2.prototype.restoreDefaultInputTexture = function() {
        if (this._forcedOutputTexture) {
          this._forcedOutputTexture = null;
          this.markTextureDirty();
        }
      };
      PostProcess2.prototype.getCamera = function() {
        return this._camera;
      };
      Object.defineProperty(PostProcess2.prototype, "texelSize", {
        get: function() {
          if (this._shareOutputWithPostProcess) {
            return this._shareOutputWithPostProcess.texelSize;
          }
          if (this._forcedOutputTexture) {
            this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
          }
          return this._texelSize;
        },
        enumerable: false,
        configurable: true
      });
      PostProcess2.prototype.getClassName = function() {
        return "PostProcess";
      };
      PostProcess2.prototype.getEngine = function() {
        return this._engine;
      };
      PostProcess2.prototype.getEffect = function() {
        return this._drawWrapper.effect;
      };
      PostProcess2.prototype.shareOutputWith = function(postProcess) {
        this._disposeTextures();
        this._shareOutputWithPostProcess = postProcess;
        return this;
      };
      PostProcess2.prototype.useOwnOutput = function() {
        if (this._textures.length == 0) {
          this._textures = new SmartArray(2);
        }
        this._shareOutputWithPostProcess = null;
      };
      PostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
        if (defines === void 0) {
          defines = null;
        }
        if (uniforms === void 0) {
          uniforms = null;
        }
        if (samplers === void 0) {
          samplers = null;
        }
        this._postProcessDefines = defines;
        this._drawWrapper.effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, ["position"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : "", void 0, onCompiled, onError, indexParameters || this._indexParameters);
      };
      PostProcess2.prototype.isReusable = function() {
        return this._reusable;
      };
      PostProcess2.prototype.markTextureDirty = function() {
        this.width = -1;
      };
      PostProcess2.prototype._createRenderTargetTexture = function(textureSize, textureOptions, channel) {
        if (channel === void 0) {
          channel = 0;
        }
        for (var i = 0; i < this._textureCache.length; i++) {
          if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer) {
            return this._textureCache[i].texture;
          }
        }
        var tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
        return tex;
      };
      PostProcess2.prototype._flushTextureCache = function() {
        var currentRenderId = this._renderId;
        for (var i = this._textureCache.length - 1; i >= 0; i--) {
          if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
            var currentlyUsed = false;
            for (var j = 0; j < this._textures.length; j++) {
              if (this._textures.data[j] === this._textureCache[i].texture) {
                currentlyUsed = true;
                break;
              }
            }
            if (!currentlyUsed) {
              this._textureCache[i].texture.dispose();
              this._textureCache.splice(i, 1);
            }
          }
        }
      };
      PostProcess2.prototype._resize = function(width, height, camera, needMipMaps, forceDepthStencil) {
        if (this._textures.length > 0) {
          this._textures.reset();
        }
        this.width = width;
        this.height = height;
        var firstPP = null;
        for (var i = 0; i < camera._postProcesses.length; i++) {
          if (camera._postProcesses[i] !== null) {
            firstPP = camera._postProcesses[i];
            break;
          }
        }
        var textureSize = { width: this.width, height: this.height };
        var textureOptions = {
          generateMipMaps: needMipMaps,
          generateDepthBuffer: forceDepthStencil || firstPP === this,
          generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
          samplingMode: this.renderTargetSamplingMode,
          type: this._textureType,
          format: this._textureFormat
        };
        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
        if (this._reusable) {
          this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
        }
        this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
        this.onSizeChangedObservable.notifyObservers(this);
      };
      PostProcess2.prototype.activate = function(camera, sourceTexture, forceDepthStencil) {
        var _this = this;
        var _a, _b;
        if (sourceTexture === void 0) {
          sourceTexture = null;
        }
        camera = camera || this._camera;
        var scene = camera.getScene();
        var engine = scene.getEngine();
        var maxSize = engine.getCaps().maxTextureSize;
        var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
        var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
        var webVRCamera = camera.parent;
        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {
          requiredWidth /= 2;
        }
        var desiredWidth = this._options.width || requiredWidth;
        var desiredHeight = this._options.height || requiredHeight;
        var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
          if (this.adaptScaleToCurrentViewport) {
            var currentViewport = engine.currentViewport;
            if (currentViewport) {
              desiredWidth *= currentViewport.width;
              desiredHeight *= currentViewport.height;
            }
          }
          if (needMipMaps || this.alwaysForcePOT) {
            if (!this._options.width) {
              desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
            }
            if (!this._options.height) {
              desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
            }
          }
          if (this.width !== desiredWidth || this.height !== desiredHeight) {
            this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
          }
          this._textures.forEach(function(texture) {
            if (texture.samples !== _this.samples) {
              _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);
            }
          });
          this._flushTextureCache();
          this._renderId++;
        }
        var target;
        if (this._shareOutputWithPostProcess) {
          target = this._shareOutputWithPostProcess.inputTexture;
        } else if (this._forcedOutputTexture) {
          target = this._forcedOutputTexture;
          this.width = this._forcedOutputTexture.width;
          this.height = this._forcedOutputTexture.height;
        } else {
          target = this.inputTexture;
          var cache = void 0;
          for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].texture === target) {
              cache = this._textureCache[i];
              break;
            }
          }
          if (cache) {
            cache.lastUsedRenderId = this._renderId;
          }
        }
        if (this.enablePixelPerfectMode) {
          this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
          this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
        } else {
          this._scaleRatio.copyFromFloats(1, 1);
          this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
        }
        (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, "post process ".concat(this.name, " input"));
        this.onActivateObservable.notifyObservers(camera);
        if (this.autoClear && this.alphaMode === 0) {
          this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
        }
        if (this._reusable) {
          this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
        }
        return target;
      };
      Object.defineProperty(PostProcess2.prototype, "isSupported", {
        get: function() {
          return this._drawWrapper.effect.isSupported;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PostProcess2.prototype, "aspectRatio", {
        get: function() {
          if (this._shareOutputWithPostProcess) {
            return this._shareOutputWithPostProcess.aspectRatio;
          }
          if (this._forcedOutputTexture) {
            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
          }
          return this.width / this.height;
        },
        enumerable: false,
        configurable: true
      });
      PostProcess2.prototype.isReady = function() {
        var _a, _b;
        return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
      };
      PostProcess2.prototype.apply = function() {
        var _a;
        if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {
          return null;
        }
        this._engine.enableEffect(this._drawWrapper);
        this._engine.setState(false);
        this._engine.setDepthBuffer(false);
        this._engine.setDepthWrite(false);
        this._engine.setAlphaMode(this.alphaMode);
        if (this.alphaConstants) {
          this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
        }
        var source;
        if (this._shareOutputWithPostProcess) {
          source = this._shareOutputWithPostProcess.inputTexture;
        } else if (this._forcedOutputTexture) {
          source = this._forcedOutputTexture;
        } else {
          source = this.inputTexture;
        }
        if (!this.externalTextureSamplerBinding) {
          this._drawWrapper.effect._bindTexture("textureSampler", source === null || source === void 0 ? void 0 : source.texture);
        }
        this._drawWrapper.effect.setVector2("scale", this._scaleRatio);
        this.onApplyObservable.notifyObservers(this._drawWrapper.effect);
        return this._drawWrapper.effect;
      };
      PostProcess2.prototype._disposeTextures = function() {
        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
          this._disposeTextureCache();
          return;
        }
        this._disposeTextureCache();
        this._textures.dispose();
      };
      PostProcess2.prototype._disposeTextureCache = function() {
        for (var i = this._textureCache.length - 1; i >= 0; i--) {
          this._textureCache[i].texture.dispose();
        }
        this._textureCache.length = 0;
      };
      PostProcess2.prototype.setPrePassRenderer = function(prePassRenderer) {
        if (this._prePassEffectConfiguration) {
          this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
          this._prePassEffectConfiguration.enabled = true;
          return true;
        }
        return false;
      };
      PostProcess2.prototype.dispose = function(camera) {
        camera = camera || this._camera;
        this._disposeTextures();
        var index;
        if (this._scene) {
          index = this._scene.postProcesses.indexOf(this);
          if (index !== -1) {
            this._scene.postProcesses.splice(index, 1);
          }
        }
        if (this._parentContainer) {
          var index_1 = this._parentContainer.postProcesses.indexOf(this);
          if (index_1 > -1) {
            this._parentContainer.postProcesses.splice(index_1, 1);
          }
          this._parentContainer = null;
        }
        index = this._engine.postProcesses.indexOf(this);
        if (index !== -1) {
          this._engine.postProcesses.splice(index, 1);
        }
        if (!camera) {
          return;
        }
        camera.detachPostProcess(this);
        index = camera._postProcesses.indexOf(this);
        if (index === 0 && camera._postProcesses.length > 0) {
          var firstPostProcess = this._camera._getFirstPostProcess();
          if (firstPostProcess) {
            firstPostProcess.markTextureDirty();
          }
        }
        this.onActivateObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onApplyObservable.clear();
        this.onBeforeRenderObservable.clear();
        this.onSizeChangedObservable.clear();
      };
      PostProcess2.prototype.serialize = function() {
        var serializationObject = SerializationHelper.Serialize(this);
        var camera = this.getCamera() || this._scene && this._scene.activeCamera;
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.cameraId = camera ? camera.id : null;
        serializationObject.reusable = this._reusable;
        serializationObject.textureType = this._textureType;
        serializationObject.fragmentUrl = this._fragmentUrl;
        serializationObject.parameters = this._parameters;
        serializationObject.samplers = this._samplers;
        serializationObject.options = this._options;
        serializationObject.defines = this._postProcessDefines;
        serializationObject.textureFormat = this._textureFormat;
        serializationObject.vertexUrl = this._vertexUrl;
        serializationObject.indexParameters = this._indexParameters;
        return serializationObject;
      };
      PostProcess2.prototype.clone = function() {
        var serializationObject = this.serialize();
        serializationObject._engine = this._engine;
        serializationObject.cameraId = null;
        var result = PostProcess2.Parse(serializationObject, this._scene, "");
        if (!result) {
          return null;
        }
        result.onActivateObservable = this.onActivateObservable.clone();
        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
        result.onApplyObservable = this.onApplyObservable.clone();
        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
        result._prePassEffectConfiguration = this._prePassEffectConfiguration;
        return result;
      };
      PostProcess2.Parse = function(parsedPostProcess, scene, rootUrl) {
        var postProcessType = GetClass(parsedPostProcess.customType);
        if (!postProcessType || !postProcessType._Parse) {
          return null;
        }
        var camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
      };
      PostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(function() {
          return new PostProcess2(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
        }, parsedPostProcess, scene, rootUrl);
      };
      __decorate([
        serialize()
      ], PostProcess2.prototype, "uniqueId", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "name", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "width", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "height", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "renderTargetSamplingMode", void 0);
      __decorate([
        serializeAsColor4()
      ], PostProcess2.prototype, "clearColor", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "autoClear", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "alphaMode", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "alphaConstants", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "enablePixelPerfectMode", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "forceFullscreenViewport", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "scaleMode", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "alwaysForcePOT", void 0);
      __decorate([
        serialize("samples")
      ], PostProcess2.prototype, "_samples", void 0);
      __decorate([
        serialize()
      ], PostProcess2.prototype, "adaptScaleToCurrentViewport", void 0);
      return PostProcess2;
    }();
    RegisterClass("BABYLON.PostProcess", PostProcess);
  }
});

// node_modules/@babylonjs/core/Shaders/pass.fragment.js
var name2, shader2;
var init_pass_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/pass.fragment.js"() {
    init_shaderStore();
    name2 = "passPixelShader";
    shader2 = "varying vec2 vUV;\nuniform sampler2D textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\ngl_FragColor=texture2D(textureSampler,vUV);\n}";
    ShaderStore.ShadersStore[name2] = shader2;
  }
});

// node_modules/@babylonjs/core/Shaders/passCube.fragment.js
var name3, shader3;
var init_passCube_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/passCube.fragment.js"() {
    init_shaderStore();
    name3 = "passCubePixelShader";
    shader3 = "varying vec2 vUV;\nuniform samplerCube textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\nvec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\n#endif\n}";
    ShaderStore.ShadersStore[name3] = shader3;
  }
});

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess, PassCubePostProcess;
var init_passPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/passPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_engine();
    init_pass_fragment();
    init_passCube_fragment();
    init_typeStore();
    init_decorators();
    PassPostProcess = function(_super) {
      __extends(PassPostProcess2, _super);
      function PassPostProcess2(name105, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (camera === void 0) {
          camera = null;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        if (blockCompilation === void 0) {
          blockCompilation = false;
        }
        return _super.call(this, name105, "pass", null, null, options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation) || this;
      }
      PassPostProcess2.prototype.getClassName = function() {
        return "PassPostProcess";
      };
      PassPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(function() {
          return new PassPostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      };
      return PassPostProcess2;
    }(PostProcess);
    RegisterClass("BABYLON.PassPostProcess", PassPostProcess);
    PassCubePostProcess = function(_super) {
      __extends(PassCubePostProcess2, _super);
      function PassCubePostProcess2(name105, options, camera, samplingMode, engine, reusable, textureType, blockCompilation) {
        if (camera === void 0) {
          camera = null;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        if (blockCompilation === void 0) {
          blockCompilation = false;
        }
        var _this = _super.call(this, name105, "passCube", null, null, options, camera, samplingMode, engine, reusable, "#define POSITIVEX", textureType, void 0, null, blockCompilation) || this;
        _this._face = 0;
        return _this;
      }
      Object.defineProperty(PassCubePostProcess2.prototype, "face", {
        get: function() {
          return this._face;
        },
        set: function(value) {
          if (value < 0 || value > 5) {
            return;
          }
          this._face = value;
          switch (this._face) {
            case 0:
              this.updateEffect("#define POSITIVEX");
              break;
            case 1:
              this.updateEffect("#define NEGATIVEX");
              break;
            case 2:
              this.updateEffect("#define POSITIVEY");
              break;
            case 3:
              this.updateEffect("#define NEGATIVEY");
              break;
            case 4:
              this.updateEffect("#define POSITIVEZ");
              break;
            case 5:
              this.updateEffect("#define NEGATIVEZ");
              break;
          }
        },
        enumerable: false,
        configurable: true
      });
      PassCubePostProcess2.prototype.getClassName = function() {
        return "PassCubePostProcess";
      };
      PassCubePostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(function() {
          return new PassCubePostProcess2(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      };
      return PassCubePostProcess2;
    }(PostProcess);
    Engine._RescalePostProcessFactory = function(engine) {
      return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js
var init_engine_renderTargetCube = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js"() {
    init_tslib_es6();
    init_internalTexture();
    init_logger();
    init_thinEngine();
    ThinEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
      var rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
      var fullOptions = __assign({ generateMipMaps: true, generateDepthBuffer: true, generateStencilBuffer: false, type: 0, samplingMode: 3, format: 5 }, options);
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
      if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
      } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
      }
      var gl = this._gl;
      var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
      if (fullOptions.type === 1 && !this._caps.textureFloat) {
        fullOptions.type = 0;
        Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      for (var face = 0; face < 6; face++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
      }
      var framebuffer = gl.createFramebuffer();
      this._bindUnboundFramebuffer(framebuffer);
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
      if (fullOptions.generateMipMaps) {
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      this._bindUnboundFramebuffer(null);
      rtWrapper._framebuffer = framebuffer;
      rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
      rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
      texture.width = size;
      texture.height = size;
      texture.isReady = true;
      texture.isCube = true;
      texture.samples = 1;
      texture.generateMipMaps = fullOptions.generateMipMaps;
      texture.samplingMode = fullOptions.samplingMode;
      texture.type = fullOptions.type;
      texture.format = fullOptions.format;
      this._internalTexturesCache.push(texture);
      rtWrapper.setTextures(texture);
      return rtWrapper;
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js
var RenderTargetTexture;
var init_renderTargetTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js"() {
    init_tslib_es6();
    init_observable();
    init_tools();
    init_math_vector();
    init_texture();
    init_postProcessManager();
    init_renderingManager();
    init_engine_renderTarget();
    init_engine_renderTargetCube();
    init_engine();
    RenderTargetTexture = function(_super) {
      __extends(RenderTargetTexture2, _super);
      function RenderTargetTexture2(name105, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti, format, delayAllocation, samples, creationFlags, noColorTarget) {
        if (doNotChangeAspectRatio === void 0) {
          doNotChangeAspectRatio = true;
        }
        if (type === void 0) {
          type = 0;
        }
        if (isCube === void 0) {
          isCube = false;
        }
        if (samplingMode === void 0) {
          samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
        }
        if (generateDepthBuffer === void 0) {
          generateDepthBuffer = true;
        }
        if (generateStencilBuffer === void 0) {
          generateStencilBuffer = false;
        }
        if (isMulti === void 0) {
          isMulti = false;
        }
        if (format === void 0) {
          format = 5;
        }
        if (delayAllocation === void 0) {
          delayAllocation = false;
        }
        if (noColorTarget === void 0) {
          noColorTarget = false;
        }
        var _this = this;
        var _a;
        _this = _super.call(this, null, scene, !generateMipMaps, void 0, samplingMode, void 0, void 0, void 0, void 0, format) || this;
        _this.renderParticles = true;
        _this.renderSprites = false;
        _this.ignoreCameraViewport = false;
        _this.onBeforeBindObservable = new Observable();
        _this.onAfterUnbindObservable = new Observable();
        _this.onBeforeRenderObservable = new Observable();
        _this.onAfterRenderObservable = new Observable();
        _this.onClearObservable = new Observable();
        _this.onResizeObservable = new Observable();
        _this._cleared = false;
        _this.skipInitialClear = false;
        _this._currentRefreshId = -1;
        _this._refreshRate = 1;
        _this._samples = 1;
        _this._canRescale = true;
        _this._renderTarget = null;
        _this.boundingBoxPosition = Vector3.Zero();
        scene = _this.getScene();
        if (!scene) {
          return _this;
        }
        var engine = _this.getScene().getEngine();
        _this._coordinatesMode = Texture.PROJECTION_MODE;
        _this.renderList = new Array();
        _this.name = name105;
        _this.isRenderTarget = true;
        _this._initialSizeParameter = size;
        _this._renderPassIds = [];
        _this._isCubeData = isCube;
        _this._processSizeParameter(size);
        _this.renderPassId = _this._renderPassIds[0];
        _this._resizeObserver = engine.onResizeObservable.add(function() {
        });
        _this._generateMipMaps = generateMipMaps ? true : false;
        _this._doNotChangeAspectRatio = doNotChangeAspectRatio;
        _this._renderingManager = new RenderingManager(scene);
        _this._renderingManager._useSceneAutoClearSetup = true;
        if (isMulti) {
          return _this;
        }
        _this._renderTargetOptions = {
          generateMipMaps,
          type,
          format: (_a = _this._format) !== null && _a !== void 0 ? _a : void 0,
          samplingMode: _this.samplingMode,
          generateDepthBuffer,
          generateStencilBuffer,
          samples,
          creationFlags,
          noColorTarget
        };
        if (_this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {
          _this.wrapU = Texture.CLAMP_ADDRESSMODE;
          _this.wrapV = Texture.CLAMP_ADDRESSMODE;
        }
        if (!delayAllocation) {
          if (isCube) {
            _this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(_this.getRenderSize(), _this._renderTargetOptions);
            _this.coordinatesMode = Texture.INVCUBIC_MODE;
            _this._textureMatrix = Matrix.Identity();
          } else {
            _this._renderTarget = scene.getEngine().createRenderTargetTexture(_this._size, _this._renderTargetOptions);
          }
          _this._texture = _this._renderTarget.texture;
          if (samples !== void 0) {
            _this.samples = samples;
          }
        }
        return _this;
      }
      Object.defineProperty(RenderTargetTexture2.prototype, "renderList", {
        get: function() {
          return this._renderList;
        },
        set: function(value) {
          this._renderList = value;
          if (this._renderList) {
            this._hookArray(this._renderList);
          }
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype._hookArray = function(array) {
        var _this = this;
        var oldPush = array.push;
        array.push = function() {
          var _a;
          var items = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
          }
          var wasEmpty = array.length === 0;
          var result = oldPush.apply(array, items);
          if (wasEmpty) {
            (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach(function(mesh) {
              mesh._markSubMeshesAsLightDirty();
            });
          }
          return result;
        };
        var oldSplice = array.splice;
        array.splice = function(index, deleteCount) {
          var _a;
          var deleted = oldSplice.apply(array, [index, deleteCount]);
          if (array.length === 0) {
            (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach(function(mesh) {
              mesh._markSubMeshesAsLightDirty();
            });
          }
          return deleted;
        };
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "postProcesses", {
        get: function() {
          return this._postProcesses;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "_prePassEnabled", {
        get: function() {
          return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "onAfterUnbind", {
        set: function(callback) {
          if (this._onAfterUnbindObserver) {
            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
          }
          this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "onBeforeRender", {
        set: function(callback) {
          if (this._onBeforeRenderObserver) {
            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
          }
          this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "onAfterRender", {
        set: function(callback) {
          if (this._onAfterRenderObserver) {
            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
          }
          this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "onClear", {
        set: function(callback) {
          if (this._onClearObserver) {
            this.onClearObservable.remove(this._onClearObserver);
          }
          this._onClearObserver = this.onClearObservable.add(callback);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "renderPassIds", {
        get: function() {
          return this._renderPassIds;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "currentRefreshId", {
        get: function() {
          return this._currentRefreshId;
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype.setMaterialForRendering = function(mesh, material) {
        var meshes;
        if (!Array.isArray(mesh)) {
          meshes = [mesh];
        } else {
          meshes = mesh;
        }
        for (var j = 0; j < meshes.length; ++j) {
          for (var i = 0; i < this._renderPassIds.length; ++i) {
            meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== void 0 ? Array.isArray(material) ? material[i] : material : void 0);
          }
        }
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "renderTargetOptions", {
        get: function() {
          return this._renderTargetOptions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "renderTarget", {
        get: function() {
          return this._renderTarget;
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype._onRatioRescale = function() {
        if (this._sizeRatio) {
          this.resize(this._initialSizeParameter);
        }
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "boundingBoxSize", {
        get: function() {
          return this._boundingBoxSize;
        },
        set: function(value) {
          if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
            return;
          }
          this._boundingBoxSize = value;
          var scene = this.getScene();
          if (scene) {
            scene.markAllMaterialsAsDirty(1);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTargetTexture2.prototype, "depthStencilTexture", {
        get: function() {
          var _a, _b;
          return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype.createDepthStencilTexture = function(comparisonFunction, bilinearFiltering, generateStencil, samples, format) {
        var _a;
        if (comparisonFunction === void 0) {
          comparisonFunction = 0;
        }
        if (bilinearFiltering === void 0) {
          bilinearFiltering = true;
        }
        if (generateStencil === void 0) {
          generateStencil = false;
        }
        if (samples === void 0) {
          samples = 1;
        }
        if (format === void 0) {
          format = 14;
        }
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);
      };
      RenderTargetTexture2.prototype._releaseRenderPassId = function() {
        if (this._scene) {
          var engine = this._scene.getEngine();
          for (var i = 0; i < this._renderPassIds.length; ++i) {
            engine.releaseRenderPassId(this._renderPassIds[i]);
          }
        }
        this._renderPassIds = [];
      };
      RenderTargetTexture2.prototype._createRenderPassId = function() {
        this._releaseRenderPassId();
        var engine = this._scene.getEngine();
        var numPasses = this._isCubeData ? 6 : this.getRenderLayers() || 1;
        for (var i = 0; i < numPasses; ++i) {
          this._renderPassIds[i] = engine.createRenderPassId("RenderTargetTexture - ".concat(this.name, "#").concat(i));
        }
      };
      RenderTargetTexture2.prototype._processSizeParameter = function(size) {
        if (size.ratio) {
          this._sizeRatio = size.ratio;
          var engine = this._getEngine();
          this._size = {
            width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
            height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
          };
        } else {
          this._size = size;
        }
        this._createRenderPassId();
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "samples", {
        get: function() {
          var _a, _b;
          return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;
        },
        set: function(value) {
          if (this._renderTarget) {
            this._samples = this._renderTarget.setSamples(value);
          }
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype.resetRefreshCounter = function() {
        this._currentRefreshId = -1;
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "refreshRate", {
        get: function() {
          return this._refreshRate;
        },
        set: function(value) {
          this._refreshRate = value;
          this.resetRefreshCounter();
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype.addPostProcess = function(postProcess) {
        if (!this._postProcessManager) {
          var scene = this.getScene();
          if (!scene) {
            return;
          }
          this._postProcessManager = new PostProcessManager(scene);
          this._postProcesses = new Array();
        }
        this._postProcesses.push(postProcess);
        this._postProcesses[0].autoClear = false;
      };
      RenderTargetTexture2.prototype.clearPostProcesses = function(dispose) {
        if (dispose === void 0) {
          dispose = false;
        }
        if (!this._postProcesses) {
          return;
        }
        if (dispose) {
          for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
            var postProcess = _a[_i];
            postProcess.dispose();
          }
        }
        this._postProcesses = [];
      };
      RenderTargetTexture2.prototype.removePostProcess = function(postProcess) {
        if (!this._postProcesses) {
          return;
        }
        var index = this._postProcesses.indexOf(postProcess);
        if (index === -1) {
          return;
        }
        this._postProcesses.splice(index, 1);
        if (this._postProcesses.length > 0) {
          this._postProcesses[0].autoClear = false;
        }
      };
      RenderTargetTexture2.prototype._shouldRender = function() {
        if (this._currentRefreshId === -1) {
          this._currentRefreshId = 1;
          return true;
        }
        if (this.refreshRate === this._currentRefreshId) {
          this._currentRefreshId = 1;
          return true;
        }
        this._currentRefreshId++;
        return false;
      };
      RenderTargetTexture2.prototype.getRenderSize = function() {
        return this.getRenderWidth();
      };
      RenderTargetTexture2.prototype.getRenderWidth = function() {
        if (this._size.width) {
          return this._size.width;
        }
        return this._size;
      };
      RenderTargetTexture2.prototype.getRenderHeight = function() {
        if (this._size.width) {
          return this._size.height;
        }
        return this._size;
      };
      RenderTargetTexture2.prototype.getRenderLayers = function() {
        var layers = this._size.layers;
        if (layers) {
          return layers;
        }
        return 0;
      };
      RenderTargetTexture2.prototype.disableRescaling = function() {
        this._canRescale = false;
      };
      Object.defineProperty(RenderTargetTexture2.prototype, "canRescale", {
        get: function() {
          return this._canRescale;
        },
        enumerable: false,
        configurable: true
      });
      RenderTargetTexture2.prototype.scale = function(ratio) {
        var newSize = Math.max(1, this.getRenderSize() * ratio);
        this.resize(newSize);
      };
      RenderTargetTexture2.prototype.getReflectionTextureMatrix = function() {
        if (this.isCube) {
          return this._textureMatrix;
        }
        return _super.prototype.getReflectionTextureMatrix.call(this);
      };
      RenderTargetTexture2.prototype.resize = function(size) {
        var _a;
        var wasCube = this.isCube;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        this._renderTarget = null;
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        this._processSizeParameter(size);
        if (wasCube) {
          this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
        } else {
          this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
        }
        this._texture = this._renderTarget.texture;
        if (this._renderTargetOptions.samples !== void 0) {
          this.samples = this._renderTargetOptions.samples;
        }
        if (this.onResizeObservable.hasObservers()) {
          this.onResizeObservable.notifyObservers(this);
        }
      };
      RenderTargetTexture2.prototype.render = function(useCameraPostProcess, dumpForDebug) {
        if (useCameraPostProcess === void 0) {
          useCameraPostProcess = false;
        }
        if (dumpForDebug === void 0) {
          dumpForDebug = false;
        }
        this._render(useCameraPostProcess, dumpForDebug);
      };
      RenderTargetTexture2.prototype.isReadyForRendering = function() {
        return this._render(false, false, true);
      };
      RenderTargetTexture2.prototype._render = function(useCameraPostProcess, dumpForDebug, checkReadiness) {
        var _a;
        if (useCameraPostProcess === void 0) {
          useCameraPostProcess = false;
        }
        if (dumpForDebug === void 0) {
          dumpForDebug = false;
        }
        if (checkReadiness === void 0) {
          checkReadiness = false;
        }
        var scene = this.getScene();
        if (!scene) {
          return checkReadiness;
        }
        var engine = scene.getEngine();
        if (this.useCameraPostProcesses !== void 0) {
          useCameraPostProcess = this.useCameraPostProcesses;
        }
        if (this._waitingRenderList) {
          this.renderList = [];
          for (var index = 0; index < this._waitingRenderList.length; index++) {
            var id = this._waitingRenderList[index];
            var mesh = scene.getMeshById(id);
            if (mesh) {
              this.renderList.push(mesh);
            }
          }
          this._waitingRenderList = void 0;
        }
        if (this.renderListPredicate) {
          if (this.renderList) {
            this.renderList.length = 0;
          } else {
            this.renderList = [];
          }
          var scene_1 = this.getScene();
          if (!scene_1) {
            return checkReadiness;
          }
          var sceneMeshes = scene_1.meshes;
          for (var index = 0; index < sceneMeshes.length; index++) {
            var mesh = sceneMeshes[index];
            if (this.renderListPredicate(mesh)) {
              this.renderList.push(mesh);
            }
          }
        }
        var currentRenderPassId = engine.currentRenderPassId;
        this.onBeforeBindObservable.notifyObservers(this);
        var camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;
        if (camera) {
          if (camera !== scene.activeCamera) {
            scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
          }
          engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());
        }
        this._defaultRenderListPrepared = false;
        var returnValue = checkReadiness;
        if (!checkReadiness) {
          if (this.is2DArray) {
            for (var layer = 0; layer < this.getRenderLayers(); layer++) {
              this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);
              scene.incrementRenderId();
              scene.resetCachedMaterial();
            }
          } else if (this.isCube) {
            for (var face = 0; face < 6; face++) {
              this._renderToTarget(face, useCameraPostProcess, dumpForDebug, void 0, camera);
              scene.incrementRenderId();
              scene.resetCachedMaterial();
            }
          } else {
            this._renderToTarget(0, useCameraPostProcess, dumpForDebug, void 0, camera);
          }
        } else {
          if (!scene.getViewMatrix()) {
            scene.updateTransformMatrix();
          }
          var numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
          for (var layer = 0; layer < numLayers && returnValue; layer++) {
            var currentRenderList = null;
            var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
            var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
            engine.currentRenderPassId = this._renderPassIds[layer];
            this.onBeforeRenderObservable.notifyObservers(layer);
            if (this.getCustomRenderList) {
              currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);
            }
            if (!currentRenderList) {
              currentRenderList = defaultRenderList;
            }
            if (!this._doNotChangeAspectRatio) {
              scene.updateTransformMatrix(true);
            }
            for (var i = 0; i < currentRenderList.length && returnValue; ++i) {
              var mesh = currentRenderList[i];
              if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {
                continue;
              }
              if (this.customIsReadyFunction) {
                if (!this.customIsReadyFunction(mesh, this.refreshRate)) {
                  returnValue = false;
                  break;
                }
              } else if (!mesh.isReady(true)) {
                returnValue = false;
                break;
              }
            }
            this.onAfterRenderObservable.notifyObservers(layer);
          }
        }
        this.onAfterUnbindObservable.notifyObservers(this);
        engine.currentRenderPassId = currentRenderPassId;
        if (scene.activeCamera) {
          if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {
            scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));
          }
          engine.setViewport(scene.activeCamera.viewport);
        }
        scene.resetCachedMaterial();
        return returnValue;
      };
      RenderTargetTexture2.prototype._bestReflectionRenderTargetDimension = function(renderDimension, scale) {
        var minimum = 128;
        var x = renderDimension * scale;
        var curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x));
        return Math.min(Engine.FloorPOT(renderDimension), curved);
      };
      RenderTargetTexture2.prototype._prepareRenderingManager = function(currentRenderList, currentRenderListLength, camera, checkLayerMask) {
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        this._renderingManager.reset();
        var sceneRenderId = scene.getRenderId();
        for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
          var mesh = currentRenderList[meshIndex];
          if (mesh && !mesh.isBlocked) {
            if (this.customIsReadyFunction) {
              if (!this.customIsReadyFunction(mesh, this.refreshRate)) {
                this.resetRefreshCounter();
                continue;
              }
            } else if (!mesh.isReady(this.refreshRate === 0)) {
              this.resetRefreshCounter();
              continue;
            }
            if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {
              mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera) : mesh.getLOD(this.activeCamera || scene.activeCamera);
              mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
            }
            if (!mesh._internalAbstractMeshDataInfo._currentLOD) {
              continue;
            }
            var meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;
            meshToRender._preActivateForIntermediateRendering(sceneRenderId);
            var isMasked = void 0;
            if (checkLayerMask && camera) {
              isMasked = (mesh.layerMask & camera.layerMask) === 0;
            } else {
              isMasked = false;
            }
            if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
              if (meshToRender !== mesh) {
                meshToRender._activate(sceneRenderId, true);
              }
              if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
                if (!mesh.isAnInstance) {
                  meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
                } else {
                  if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                    meshToRender = mesh;
                  }
                }
                meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
                for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
                  var subMesh = meshToRender.subMeshes[subIndex];
                  this._renderingManager.dispatch(subMesh, meshToRender);
                }
              }
            }
          }
        }
        for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {
          var particleSystem = scene.particleSystems[particleIndex];
          var emitter = particleSystem.emitter;
          if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {
            continue;
          }
          if (currentRenderList.indexOf(emitter) >= 0) {
            this._renderingManager.dispatchParticles(particleSystem);
          }
        }
      };
      RenderTargetTexture2.prototype._bindFrameBuffer = function(faceIndex, layer) {
        if (faceIndex === void 0) {
          faceIndex = 0;
        }
        if (layer === void 0) {
          layer = 0;
        }
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        var engine = scene.getEngine();
        if (this._renderTarget) {
          engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
        }
      };
      RenderTargetTexture2.prototype._unbindFrameBuffer = function(engine, faceIndex) {
        var _this = this;
        if (!this._renderTarget) {
          return;
        }
        engine.unBindFramebuffer(this._renderTarget, this.isCube, function() {
          _this.onAfterRenderObservable.notifyObservers(faceIndex);
        });
      };
      RenderTargetTexture2.prototype._prepareFrame = function(scene, faceIndex, layer, useCameraPostProcess) {
        if (this._postProcessManager) {
          if (!this._prePassEnabled) {
            this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
          }
        } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
          this._bindFrameBuffer(faceIndex, layer);
        }
      };
      RenderTargetTexture2.prototype._renderToTarget = function(faceIndex, useCameraPostProcess, dumpForDebug, layer, camera) {
        var _a, _b, _c, _d, _e, _f;
        if (layer === void 0) {
          layer = 0;
        }
        if (camera === void 0) {
          camera = null;
        }
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        var engine = scene.getEngine();
        (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "render to face #".concat(faceIndex, " layer #").concat(layer), 1);
        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
        if (this.is2DArray) {
          engine.currentRenderPassId = this._renderPassIds[layer];
          this.onBeforeRenderObservable.notifyObservers(layer);
        } else {
          engine.currentRenderPassId = this._renderPassIds[faceIndex];
          this.onBeforeRenderObservable.notifyObservers(faceIndex);
        }
        var fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
        if (!fastPath) {
          var currentRenderList = null;
          var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
          var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
          if (this.getCustomRenderList) {
            currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);
          }
          if (!currentRenderList) {
            if (!this._defaultRenderListPrepared) {
              this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);
              this._defaultRenderListPrepared = true;
            }
            currentRenderList = defaultRenderList;
          } else {
            this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);
          }
          for (var _i = 0, _g = scene._beforeRenderTargetClearStage; _i < _g.length; _i++) {
            var step = _g[_i];
            step.action(this, faceIndex, layer);
          }
          if (this.onClearObservable.hasObservers()) {
            this.onClearObservable.notifyObservers(engine);
          } else {
            if (!this.skipInitialClear) {
              engine.clear(this.clearColor || scene.clearColor, true, true, true);
            }
          }
          if (!this._doNotChangeAspectRatio) {
            scene.updateTransformMatrix(true);
          }
          for (var _h = 0, _j = scene._beforeRenderTargetDrawStage; _h < _j.length; _h++) {
            var step = _j[_h];
            step.action(this, faceIndex, layer);
          }
          this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
          for (var _k = 0, _l = scene._afterRenderTargetDrawStage; _k < _l.length; _k++) {
            var step = _l[_k];
            step.action(this, faceIndex, layer);
          }
          var saveGenerateMipMaps = (_c = (_b = this._texture) === null || _b === void 0 ? void 0 : _b.generateMipMaps) !== null && _c !== void 0 ? _c : false;
          if (this._texture) {
            this._texture.generateMipMaps = false;
          }
          if (this._postProcessManager) {
            this._postProcessManager._finalizeFrame(false, (_d = this._renderTarget) !== null && _d !== void 0 ? _d : void 0, faceIndex, this._postProcesses, this.ignoreCameraViewport);
          } else if (useCameraPostProcess) {
            scene.postProcessManager._finalizeFrame(false, (_e = this._renderTarget) !== null && _e !== void 0 ? _e : void 0, faceIndex);
          }
          if (this._texture) {
            this._texture.generateMipMaps = saveGenerateMipMaps;
          }
          if (!this._doNotChangeAspectRatio) {
            scene.updateTransformMatrix(true);
          }
          if (dumpForDebug) {
            Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
          }
        } else {
          if (this.onClearObservable.hasObservers()) {
            this.onClearObservable.notifyObservers(engine);
          } else {
            if (!this.skipInitialClear) {
              engine.clear(this.clearColor || scene.clearColor, true, true, true);
            }
          }
        }
        this._unbindFrameBuffer(engine, faceIndex);
        if (this._texture && this.isCube && faceIndex === 5) {
          engine.generateMipMapsForCubemap(this._texture);
        }
        (_f = engine._debugPopGroup) === null || _f === void 0 ? void 0 : _f.call(engine, 1);
      };
      RenderTargetTexture2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
        if (opaqueSortCompareFn === void 0) {
          opaqueSortCompareFn = null;
        }
        if (alphaTestSortCompareFn === void 0) {
          alphaTestSortCompareFn = null;
        }
        if (transparentSortCompareFn === void 0) {
          transparentSortCompareFn = null;
        }
        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
      };
      RenderTargetTexture2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil) {
        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
        this._renderingManager._useSceneAutoClearSetup = false;
      };
      RenderTargetTexture2.prototype.clone = function() {
        var textureSize = this.getSize();
        var newTexture = new RenderTargetTexture2(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.coordinatesMode = this.coordinatesMode;
        if (this.renderList) {
          newTexture.renderList = this.renderList.slice(0);
        }
        return newTexture;
      };
      RenderTargetTexture2.prototype.serialize = function() {
        if (!this.name) {
          return null;
        }
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.renderTargetSize = this.getRenderSize();
        serializationObject.renderList = [];
        if (this.renderList) {
          for (var index = 0; index < this.renderList.length; index++) {
            serializationObject.renderList.push(this.renderList[index].id);
          }
        }
        return serializationObject;
      };
      RenderTargetTexture2.prototype.disposeFramebufferObjects = function() {
        var _a;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);
      };
      RenderTargetTexture2.prototype.releaseInternalTexture = function() {
        var _a;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();
        this._texture = null;
      };
      RenderTargetTexture2.prototype.dispose = function() {
        var _a;
        this.onResizeObservable.clear();
        this.onClearObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onAfterUnbindObservable.clear();
        this.onBeforeBindObservable.clear();
        this.onBeforeRenderObservable.clear();
        if (this._postProcessManager) {
          this._postProcessManager.dispose();
          this._postProcessManager = null;
        }
        if (this._prePassRenderTarget) {
          this._prePassRenderTarget.dispose();
        }
        this._releaseRenderPassId();
        this.clearPostProcesses(true);
        if (this._resizeObserver) {
          this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
          this._resizeObserver = null;
        }
        this.renderList = null;
        var scene = this.getScene();
        if (!scene) {
          return;
        }
        var index = scene.customRenderTargets.indexOf(this);
        if (index >= 0) {
          scene.customRenderTargets.splice(index, 1);
        }
        for (var _i = 0, _b = scene.cameras; _i < _b.length; _i++) {
          var camera = _b[_i];
          index = camera.customRenderTargets.indexOf(this);
          if (index >= 0) {
            camera.customRenderTargets.splice(index, 1);
          }
        }
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        this._renderTarget = null;
        this._texture = null;
        _super.prototype.dispose.call(this);
      };
      RenderTargetTexture2.prototype._rebuild = function() {
        if (this.refreshRate === RenderTargetTexture2.REFRESHRATE_RENDER_ONCE) {
          this.refreshRate = RenderTargetTexture2.REFRESHRATE_RENDER_ONCE;
        }
        if (this._postProcessManager) {
          this._postProcessManager._rebuild();
        }
      };
      RenderTargetTexture2.prototype.freeRenderingGroups = function() {
        if (this._renderingManager) {
          this._renderingManager.freeRenderingGroups();
        }
      };
      RenderTargetTexture2.prototype.getViewCount = function() {
        return 1;
      };
      RenderTargetTexture2.REFRESHRATE_RENDER_ONCE = 0;
      RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
      RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
      return RenderTargetTexture2;
    }(Texture);
    Texture._CreateRenderTargetTexture = function(name105, renderTargetSize, scene, generateMipMaps, creationFlags) {
      return new RenderTargetTexture(name105, renderTargetSize, scene, generateMipMaps);
    };
  }
});

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
var HemisphericLight;
var init_hemisphericLight = __esm({
  "node_modules/@babylonjs/core/Lights/hemisphericLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_light();
    Node.AddNodeConstructor("Light_Type_3", function(name105, scene) {
      return function() {
        return new HemisphericLight(name105, Vector3.Zero(), scene);
      };
    });
    HemisphericLight = function(_super) {
      __extends(HemisphericLight2, _super);
      function HemisphericLight2(name105, direction, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this.groundColor = new Color3(0, 0, 0);
        _this.direction = direction || Vector3.Up();
        return _this;
      }
      HemisphericLight2.prototype._buildUniformLayout = function() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightGround", 3);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      };
      HemisphericLight2.prototype.getClassName = function() {
        return "HemisphericLight";
      };
      HemisphericLight2.prototype.setDirectionToTarget = function(target) {
        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
        return this.direction;
      };
      HemisphericLight2.prototype.getShadowGenerator = function() {
        return null;
      };
      HemisphericLight2.prototype.transferToEffect = function(_effect, lightIndex) {
        var normalizeDirection = Vector3.Normalize(this.direction);
        this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
        this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
        return this;
      };
      HemisphericLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
        var normalizeDirection = Vector3.Normalize(this.direction);
        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        return this;
      };
      HemisphericLight2.prototype.computeWorldMatrix = function() {
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        return this._worldMatrix;
      };
      HemisphericLight2.prototype.getTypeID = function() {
        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
      };
      HemisphericLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
        defines["HEMILIGHT" + lightIndex] = true;
      };
      __decorate([
        serializeAsColor3()
      ], HemisphericLight2.prototype, "groundColor", void 0);
      __decorate([
        serializeAsVector3()
      ], HemisphericLight2.prototype, "direction", void 0);
      return HemisphericLight2;
    }(Light);
  }
});

// node_modules/@babylonjs/core/Materials/pushMaterial.js
var PushMaterial;
var init_pushMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/pushMaterial.js"() {
    init_tslib_es6();
    init_math_vector();
    init_material();
    PushMaterial = function(_super) {
      __extends(PushMaterial2, _super);
      function PushMaterial2(name105, scene, storeEffectOnSubMeshes) {
        if (storeEffectOnSubMeshes === void 0) {
          storeEffectOnSubMeshes = true;
        }
        var _this = _super.call(this, name105, scene) || this;
        _this._normalMatrix = new Matrix();
        _this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;
        return _this;
      }
      PushMaterial2.prototype.getEffect = function() {
        return this._storeEffectOnSubMeshes ? this._activeEffect : _super.prototype.getEffect.call(this);
      };
      PushMaterial2.prototype.isReady = function(mesh, useInstances) {
        if (!mesh) {
          return false;
        }
        if (!this._storeEffectOnSubMeshes) {
          return true;
        }
        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
          return true;
        }
        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
      };
      PushMaterial2.prototype._isReadyForSubMesh = function(subMesh) {
        var defines = subMesh.materialDefines;
        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
          if (defines._renderId === this.getScene().getRenderId()) {
            return true;
          }
        }
        return false;
      };
      PushMaterial2.prototype.bindOnlyWorldMatrix = function(world) {
        this._activeEffect.setMatrix("world", world);
      };
      PushMaterial2.prototype.bindOnlyNormalMatrix = function(normalMatrix) {
        this._activeEffect.setMatrix("normalMatrix", normalMatrix);
      };
      PushMaterial2.prototype.bind = function(world, mesh) {
        if (!mesh) {
          return;
        }
        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
      };
      PushMaterial2.prototype._afterBind = function(mesh, effect) {
        if (effect === void 0) {
          effect = null;
        }
        _super.prototype._afterBind.call(this, mesh, effect);
        this.getScene()._cachedEffect = effect;
      };
      PushMaterial2.prototype._mustRebind = function(scene, effect, visibility) {
        if (visibility === void 0) {
          visibility = 1;
        }
        return scene.isCachedMaterialInvalid(this, effect, visibility);
      };
      return PushMaterial2;
    }(Material);
  }
});

// node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags;
var init_materialFlags = __esm({
  "node_modules/@babylonjs/core/Materials/materialFlags.js"() {
    init_engine();
    MaterialFlags = function() {
      function MaterialFlags2() {
      }
      Object.defineProperty(MaterialFlags2, "DiffuseTextureEnabled", {
        get: function() {
          return this._DiffuseTextureEnabled;
        },
        set: function(value) {
          if (this._DiffuseTextureEnabled === value) {
            return;
          }
          this._DiffuseTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "DetailTextureEnabled", {
        get: function() {
          return this._DetailTextureEnabled;
        },
        set: function(value) {
          if (this._DetailTextureEnabled === value) {
            return;
          }
          this._DetailTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "AmbientTextureEnabled", {
        get: function() {
          return this._AmbientTextureEnabled;
        },
        set: function(value) {
          if (this._AmbientTextureEnabled === value) {
            return;
          }
          this._AmbientTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "OpacityTextureEnabled", {
        get: function() {
          return this._OpacityTextureEnabled;
        },
        set: function(value) {
          if (this._OpacityTextureEnabled === value) {
            return;
          }
          this._OpacityTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ReflectionTextureEnabled", {
        get: function() {
          return this._ReflectionTextureEnabled;
        },
        set: function(value) {
          if (this._ReflectionTextureEnabled === value) {
            return;
          }
          this._ReflectionTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "EmissiveTextureEnabled", {
        get: function() {
          return this._EmissiveTextureEnabled;
        },
        set: function(value) {
          if (this._EmissiveTextureEnabled === value) {
            return;
          }
          this._EmissiveTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "SpecularTextureEnabled", {
        get: function() {
          return this._SpecularTextureEnabled;
        },
        set: function(value) {
          if (this._SpecularTextureEnabled === value) {
            return;
          }
          this._SpecularTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "BumpTextureEnabled", {
        get: function() {
          return this._BumpTextureEnabled;
        },
        set: function(value) {
          if (this._BumpTextureEnabled === value) {
            return;
          }
          this._BumpTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "LightmapTextureEnabled", {
        get: function() {
          return this._LightmapTextureEnabled;
        },
        set: function(value) {
          if (this._LightmapTextureEnabled === value) {
            return;
          }
          this._LightmapTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "RefractionTextureEnabled", {
        get: function() {
          return this._RefractionTextureEnabled;
        },
        set: function(value) {
          if (this._RefractionTextureEnabled === value) {
            return;
          }
          this._RefractionTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ColorGradingTextureEnabled", {
        get: function() {
          return this._ColorGradingTextureEnabled;
        },
        set: function(value) {
          if (this._ColorGradingTextureEnabled === value) {
            return;
          }
          this._ColorGradingTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "FresnelEnabled", {
        get: function() {
          return this._FresnelEnabled;
        },
        set: function(value) {
          if (this._FresnelEnabled === value) {
            return;
          }
          this._FresnelEnabled = value;
          Engine.MarkAllMaterialsAsDirty(4);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ClearCoatTextureEnabled", {
        get: function() {
          return this._ClearCoatTextureEnabled;
        },
        set: function(value) {
          if (this._ClearCoatTextureEnabled === value) {
            return;
          }
          this._ClearCoatTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ClearCoatBumpTextureEnabled", {
        get: function() {
          return this._ClearCoatBumpTextureEnabled;
        },
        set: function(value) {
          if (this._ClearCoatBumpTextureEnabled === value) {
            return;
          }
          this._ClearCoatBumpTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ClearCoatTintTextureEnabled", {
        get: function() {
          return this._ClearCoatTintTextureEnabled;
        },
        set: function(value) {
          if (this._ClearCoatTintTextureEnabled === value) {
            return;
          }
          this._ClearCoatTintTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "SheenTextureEnabled", {
        get: function() {
          return this._SheenTextureEnabled;
        },
        set: function(value) {
          if (this._SheenTextureEnabled === value) {
            return;
          }
          this._SheenTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "AnisotropicTextureEnabled", {
        get: function() {
          return this._AnisotropicTextureEnabled;
        },
        set: function(value) {
          if (this._AnisotropicTextureEnabled === value) {
            return;
          }
          this._AnisotropicTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "ThicknessTextureEnabled", {
        get: function() {
          return this._ThicknessTextureEnabled;
        },
        set: function(value) {
          if (this._ThicknessTextureEnabled === value) {
            return;
          }
          this._ThicknessTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "RefractionIntensityTextureEnabled", {
        get: function() {
          return this._ThicknessTextureEnabled;
        },
        set: function(value) {
          if (this._RefractionIntensityTextureEnabled === value) {
            return;
          }
          this._RefractionIntensityTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "TranslucencyIntensityTextureEnabled", {
        get: function() {
          return this._ThicknessTextureEnabled;
        },
        set: function(value) {
          if (this._TranslucencyIntensityTextureEnabled === value) {
            return;
          }
          this._TranslucencyIntensityTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaterialFlags2, "IridescenceTextureEnabled", {
        get: function() {
          return this._IridescenceTextureEnabled;
        },
        set: function(value) {
          if (this._IridescenceTextureEnabled === value) {
            return;
          }
          this._IridescenceTextureEnabled = value;
          Engine.MarkAllMaterialsAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      MaterialFlags2._DiffuseTextureEnabled = true;
      MaterialFlags2._DetailTextureEnabled = true;
      MaterialFlags2._AmbientTextureEnabled = true;
      MaterialFlags2._OpacityTextureEnabled = true;
      MaterialFlags2._ReflectionTextureEnabled = true;
      MaterialFlags2._EmissiveTextureEnabled = true;
      MaterialFlags2._SpecularTextureEnabled = true;
      MaterialFlags2._BumpTextureEnabled = true;
      MaterialFlags2._LightmapTextureEnabled = true;
      MaterialFlags2._RefractionTextureEnabled = true;
      MaterialFlags2._ColorGradingTextureEnabled = true;
      MaterialFlags2._FresnelEnabled = true;
      MaterialFlags2._ClearCoatTextureEnabled = true;
      MaterialFlags2._ClearCoatBumpTextureEnabled = true;
      MaterialFlags2._ClearCoatTintTextureEnabled = true;
      MaterialFlags2._SheenTextureEnabled = true;
      MaterialFlags2._AnisotropicTextureEnabled = true;
      MaterialFlags2._ThicknessTextureEnabled = true;
      MaterialFlags2._RefractionIntensityTextureEnabled = true;
      MaterialFlags2._TranslucencyIntensityTextureEnabled = true;
      MaterialFlags2._IridescenceTextureEnabled = true;
      return MaterialFlags2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks;
var init_effectFallbacks = __esm({
  "node_modules/@babylonjs/core/Materials/effectFallbacks.js"() {
    EffectFallbacks = function() {
      function EffectFallbacks2() {
        this._defines = {};
        this._currentRank = 32;
        this._maxRank = -1;
        this._mesh = null;
      }
      EffectFallbacks2.prototype.unBindMesh = function() {
        this._mesh = null;
      };
      EffectFallbacks2.prototype.addFallback = function(rank, define) {
        if (!this._defines[rank]) {
          if (rank < this._currentRank) {
            this._currentRank = rank;
          }
          if (rank > this._maxRank) {
            this._maxRank = rank;
          }
          this._defines[rank] = new Array();
        }
        this._defines[rank].push(define);
      };
      EffectFallbacks2.prototype.addCPUSkinningFallback = function(rank, mesh) {
        this._mesh = mesh;
        if (rank < this._currentRank) {
          this._currentRank = rank;
        }
        if (rank > this._maxRank) {
          this._maxRank = rank;
        }
      };
      Object.defineProperty(EffectFallbacks2.prototype, "hasMoreFallbacks", {
        get: function() {
          return this._currentRank <= this._maxRank;
        },
        enumerable: false,
        configurable: true
      });
      EffectFallbacks2.prototype.reduce = function(currentDefines, effect) {
        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
          this._mesh.computeBonesUsingShaders = false;
          currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
          effect._bonesComputationForcedToCPU = true;
          var scene = this._mesh.getScene();
          for (var index = 0; index < scene.meshes.length; index++) {
            var otherMesh = scene.meshes[index];
            if (!otherMesh.material) {
              if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
                otherMesh.computeBonesUsingShaders = false;
              }
              continue;
            }
            if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
              continue;
            }
            if (otherMesh.material.getEffect() === effect) {
              otherMesh.computeBonesUsingShaders = false;
            } else if (otherMesh.subMeshes) {
              for (var _i = 0, _a = otherMesh.subMeshes; _i < _a.length; _i++) {
                var subMesh = _a[_i];
                var subMeshEffect = subMesh.effect;
                if (subMeshEffect === effect) {
                  otherMesh.computeBonesUsingShaders = false;
                  break;
                }
              }
            }
          }
        } else {
          var currentFallbacks = this._defines[this._currentRank];
          if (currentFallbacks) {
            for (var index = 0; index < currentFallbacks.length; index++) {
              currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
            }
          }
          this._currentRank++;
        }
        return currentDefines;
      };
      return EffectFallbacks2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginManager.js
function RegisterMaterialPlugin(pluginName, factory) {
  if (!inited) {
    Material.OnEventObservable.add(function(material) {
      for (var _i = 0, plugins_1 = plugins; _i < plugins_1.length; _i++) {
        var _a = plugins_1[_i], factory_1 = _a[1];
        factory_1(material);
      }
    }, MaterialPluginEvent.Created);
    inited = true;
  }
  var existing = plugins.filter(function(_a) {
    var name105 = _a[0], _factory = _a[1];
    return name105 === pluginName;
  });
  if (existing.length > 0) {
    existing[0][1] = factory;
  } else {
    plugins.push([pluginName, factory]);
  }
}
function UnregisterMaterialPlugin(pluginName) {
  for (var i = 0; i < plugins.length; ++i) {
    if (plugins[i][0] === pluginName) {
      plugins.splice(i, 1);
      return true;
    }
  }
  return false;
}
function UnregisterAllMaterialPlugins() {
  plugins.length = 0;
}
var MaterialPluginManager, plugins, inited;
var init_materialPluginManager = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginManager.js"() {
    init_material();
    init_materialPluginEvent();
    MaterialPluginManager = function() {
      function MaterialPluginManager2(material) {
        this._plugins = [];
        this._activePlugins = [];
        this._activePluginsForExtraEvents = [];
        this._material = material;
        this._scene = material.getScene();
        this._engine = this._scene.getEngine();
      }
      MaterialPluginManager2.prototype._addPlugin = function(plugin) {
        for (var i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === plugin.name) {
            throw 'Plugin "'.concat(plugin.name, '" already added to the material "').concat(this._material.name, '"!');
          }
        }
        if (this._material._uniformBufferLayoutBuilt) {
          throw 'The plugin "'.concat(plugin.name, `" can't be added to the material "`).concat(this._material.name, '" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.');
        }
        this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);
        this._plugins.push(plugin);
        this._plugins.sort(function(a, b) {
          return a.priority - b.priority;
        });
        this._codeInjectionPoints = {};
        var defineNamesFromPlugins = {};
        for (var _i = 0, _a = this._plugins; _i < _a.length; _i++) {
          var plugin_1 = _a[_i];
          plugin_1.collectDefines(defineNamesFromPlugins);
          this._collectPointNames("vertex", plugin_1.getCustomCode("vertex"));
          this._collectPointNames("fragment", plugin_1.getCustomCode("fragment"));
        }
        if (Object.keys(defineNamesFromPlugins).length > 0) {
          this._defineNamesFromPlugins = defineNamesFromPlugins;
        } else {
          delete this._defineNamesFromPlugins;
        }
      };
      MaterialPluginManager2.prototype._activatePlugin = function(plugin) {
        if (this._activePlugins.indexOf(plugin) === -1) {
          this._activePlugins.push(plugin);
          this._activePlugins.sort(function(a, b) {
            return a.priority - b.priority;
          });
          this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
          this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
          this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
          if (plugin.registerForExtraEvents) {
            this._activePluginsForExtraEvents.push(plugin);
            this._activePluginsForExtraEvents.sort(function(a, b) {
              return a.priority - b.priority;
            });
            this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
            this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
            this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
          }
        }
      };
      MaterialPluginManager2.prototype.getPlugin = function(name105) {
        for (var i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === name105) {
            return this._plugins[i];
          }
        }
        return null;
      };
      MaterialPluginManager2.prototype._handlePluginEventIsReadyForSubMesh = function(eventData) {
        var isReady = true;
        for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
          var plugin = _a[_i];
          isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
        }
        eventData.isReadyForSubMesh = isReady;
      };
      MaterialPluginManager2.prototype._handlePluginEventPrepareDefines = function(eventData) {
        for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
          var plugin = _a[_i];
          plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
        }
      };
      MaterialPluginManager2.prototype._handlePluginEventHardBindForSubMesh = function(eventData) {
        for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
          var plugin = _a[_i];
          plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      };
      MaterialPluginManager2.prototype._handlePluginEventBindForSubMesh = function(eventData) {
        for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
          var plugin = _a[_i];
          plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      };
      MaterialPluginManager2.prototype._handlePluginEventHasRenderTargetTextures = function(eventData) {
        var hasRenderTargetTextures = false;
        for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
          var plugin = _a[_i];
          hasRenderTargetTextures = plugin.hasRenderTargetTextures();
          if (hasRenderTargetTextures) {
            break;
          }
        }
        eventData.hasRenderTargetTextures = hasRenderTargetTextures;
      };
      MaterialPluginManager2.prototype._handlePluginEventFillRenderTargetTextures = function(eventData) {
        for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
          var plugin = _a[_i];
          plugin.fillRenderTargetTextures(eventData.renderTargets);
        }
      };
      MaterialPluginManager2.prototype._handlePluginEvent = function(id, info) {
        var _a, _b, _c;
        switch (id) {
          case MaterialPluginEvent.GetActiveTextures: {
            var eventData = info;
            for (var _i = 0, _d = this._activePlugins; _i < _d.length; _i++) {
              var plugin = _d[_i];
              plugin.getActiveTextures(eventData.activeTextures);
            }
            break;
          }
          case MaterialPluginEvent.GetAnimatables: {
            var eventData = info;
            for (var _e = 0, _f = this._activePlugins; _e < _f.length; _e++) {
              var plugin = _f[_e];
              plugin.getAnimatables(eventData.animatables);
            }
            break;
          }
          case MaterialPluginEvent.HasTexture: {
            var eventData = info;
            var hasTexture = false;
            for (var _g = 0, _h = this._activePlugins; _g < _h.length; _g++) {
              var plugin = _h[_g];
              hasTexture = plugin.hasTexture(eventData.texture);
              if (hasTexture) {
                break;
              }
            }
            eventData.hasTexture = hasTexture;
            break;
          }
          case MaterialPluginEvent.Disposed: {
            var eventData = info;
            for (var _j = 0, _k = this._plugins; _j < _k.length; _j++) {
              var plugin = _k[_j];
              plugin.dispose(eventData.forceDisposeTextures);
            }
            break;
          }
          case MaterialPluginEvent.GetDefineNames: {
            var eventData = info;
            eventData.defineNames = this._defineNamesFromPlugins;
            break;
          }
          case MaterialPluginEvent.PrepareEffect: {
            var eventData = info;
            for (var _l = 0, _m = this._activePlugins; _l < _m.length; _l++) {
              var plugin = _m[_l];
              eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
            }
            if (this._uniformList.length > 0) {
              (_a = eventData.uniforms).push.apply(_a, this._uniformList);
            }
            if (this._samplerList.length > 0) {
              (_b = eventData.samplers).push.apply(_b, this._samplerList);
            }
            if (this._uboList.length > 0) {
              (_c = eventData.uniformBuffersNames).push.apply(_c, this._uboList);
            }
            eventData.customCode = this._injectCustomCode(eventData.customCode);
            break;
          }
          case MaterialPluginEvent.PrepareUniformBuffer: {
            var eventData = info;
            this._uboDeclaration = "";
            this._vertexDeclaration = "";
            this._fragmentDeclaration = "";
            this._uniformList = [];
            this._samplerList = [];
            this._uboList = [];
            for (var _o = 0, _p = this._plugins; _o < _p.length; _o++) {
              var plugin = _p[_o];
              var uniforms = plugin.getUniforms();
              if (uniforms) {
                if (uniforms.ubo) {
                  for (var _q = 0, _r = uniforms.ubo; _q < _r.length; _q++) {
                    var uniform = _r[_q];
                    eventData.ubo.addUniform(uniform.name, uniform.size);
                    this._uboDeclaration += "".concat(uniform.type, " ").concat(uniform.name, ";\r\n");
                    this._uniformList.push(uniform.name);
                  }
                }
                if (uniforms.vertex) {
                  this._vertexDeclaration += uniforms.vertex + "\r\n";
                }
                if (uniforms.fragment) {
                  this._fragmentDeclaration += uniforms.fragment + "\r\n";
                }
              }
              plugin.getSamplers(this._samplerList);
              plugin.getUniformBuffersNames(this._uboList);
            }
            break;
          }
        }
      };
      MaterialPluginManager2.prototype._collectPointNames = function(shaderType, customCode) {
        if (!customCode) {
          return;
        }
        for (var pointName in customCode) {
          if (!this._codeInjectionPoints[shaderType]) {
            this._codeInjectionPoints[shaderType] = {};
          }
          this._codeInjectionPoints[shaderType][pointName] = true;
        }
      };
      MaterialPluginManager2.prototype._injectCustomCode = function(existingCallback) {
        var _this = this;
        return function(shaderType, code) {
          var _a;
          if (existingCallback) {
            code = existingCallback(shaderType, code);
          }
          if (_this._uboDeclaration) {
            code = code.replace("#define ADDITIONAL_UBO_DECLARATION", _this._uboDeclaration);
          }
          if (_this._vertexDeclaration) {
            code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", _this._vertexDeclaration);
          }
          if (_this._fragmentDeclaration) {
            code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", _this._fragmentDeclaration);
          }
          var points = (_a = _this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];
          if (!points) {
            return code;
          }
          for (var pointName in points) {
            var injectedCode = "";
            for (var _i = 0, _b = _this._activePlugins; _i < _b.length; _i++) {
              var plugin = _b[_i];
              var customCode = plugin.getCustomCode(shaderType);
              if (customCode === null || customCode === void 0 ? void 0 : customCode[pointName]) {
                injectedCode += customCode[pointName] + "\r\n";
              }
            }
            if (injectedCode.length > 0) {
              if (pointName.charAt(0) === "!") {
                var rx = new RegExp(pointName.substring(1), "g");
                var match = rx.exec(code);
                while (match !== null) {
                  code = code.replace(match[0], injectedCode);
                  match = rx.exec(code);
                }
              } else {
                var fullPointName = "#define " + pointName;
                code = code.replace(fullPointName, "\r\n" + injectedCode + "\r\n" + fullPointName);
              }
            }
          }
          return code;
        };
      };
      return MaterialPluginManager2;
    }();
    plugins = [];
    inited = false;
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase;
var init_materialPluginBase = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginBase.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialPluginManager();
    MaterialPluginBase = function() {
      function MaterialPluginBase2(material, name105, priority, defines, addToPluginList, enable) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        if (enable === void 0) {
          enable = false;
        }
        this.priority = 500;
        this.registerForExtraEvents = false;
        this._material = material;
        this.name = name105;
        this.priority = priority;
        if (!material.pluginManager) {
          material.pluginManager = new MaterialPluginManager(material);
        }
        this._pluginDefineNames = defines;
        this._pluginManager = material.pluginManager;
        if (addToPluginList) {
          this._pluginManager._addPlugin(this);
        }
        if (enable) {
          this._enable(true);
        }
        this.markAllDefinesAsDirty = material._dirtyCallbacks[63];
      }
      MaterialPluginBase2.prototype._enable = function(enable) {
        if (enable) {
          this._pluginManager._activatePlugin(this);
        }
      };
      MaterialPluginBase2.prototype.getClassName = function() {
        return "MaterialPluginBase";
      };
      MaterialPluginBase2.prototype.isReadyForSubMesh = function(defines, scene, engine, subMesh) {
        return true;
      };
      MaterialPluginBase2.prototype.hardBindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
      };
      MaterialPluginBase2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
      };
      MaterialPluginBase2.prototype.dispose = function(forceDisposeTextures) {
      };
      MaterialPluginBase2.prototype.getCustomCode = function(shaderType) {
        return null;
      };
      MaterialPluginBase2.prototype.collectDefines = function(defines) {
        if (!this._pluginDefineNames) {
          return;
        }
        for (var _i = 0, _a = Object.keys(this._pluginDefineNames); _i < _a.length; _i++) {
          var key = _a[_i];
          if (key[0] === "_") {
            continue;
          }
          var type = typeof this._pluginDefineNames[key];
          defines[key] = {
            type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
            default: this._pluginDefineNames[key]
          };
        }
      };
      MaterialPluginBase2.prototype.prepareDefines = function(defines, scene, mesh) {
      };
      MaterialPluginBase2.prototype.hasTexture = function(texture) {
        return false;
      };
      MaterialPluginBase2.prototype.hasRenderTargetTextures = function() {
        return false;
      };
      MaterialPluginBase2.prototype.fillRenderTargetTextures = function(renderTargets) {
      };
      MaterialPluginBase2.prototype.getActiveTextures = function(activeTextures) {
      };
      MaterialPluginBase2.prototype.getAnimatables = function(animatables) {
      };
      MaterialPluginBase2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        return currentRank;
      };
      MaterialPluginBase2.prototype.getSamplers = function(samplers) {
      };
      MaterialPluginBase2.prototype.getUniformBuffersNames = function(ubos) {
      };
      MaterialPluginBase2.prototype.getUniforms = function() {
        return {};
      };
      MaterialPluginBase2.prototype.copyTo = function(plugin) {
        SerializationHelper.Clone(function() {
          return plugin;
        }, this);
      };
      MaterialPluginBase2.prototype.serialize = function() {
        return SerializationHelper.Serialize(this);
      };
      MaterialPluginBase2.prototype.parse = function(source, scene, rootUrl) {
        var _this = this;
        SerializationHelper.Parse(function() {
          return _this;
        }, source, scene, rootUrl);
      };
      __decorate([
        serialize()
      ], MaterialPluginBase2.prototype, "name", void 0);
      __decorate([
        serialize()
      ], MaterialPluginBase2.prototype, "priority", void 0);
      __decorate([
        serialize()
      ], MaterialPluginBase2.prototype, "registerForExtraEvents", void 0);
      return MaterialPluginBase2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines, DetailMapConfiguration;
var init_material_detailMapConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js"() {
    init_tslib_es6();
    init_material();
    init_decorators();
    init_materialFlags();
    init_materialHelper();
    init_materialDefines();
    init_materialPluginBase();
    MaterialDetailMapDefines = function(_super) {
      __extends(MaterialDetailMapDefines2, _super);
      function MaterialDetailMapDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.DETAIL = false;
        _this.DETAILDIRECTUV = 0;
        _this.DETAIL_NORMALBLENDMETHOD = 0;
        return _this;
      }
      return MaterialDetailMapDefines2;
    }(MaterialDefines);
    DetailMapConfiguration = function(_super) {
      __extends(DetailMapConfiguration2, _super);
      function DetailMapConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList) || this;
        _this._texture = null;
        _this.diffuseBlendLevel = 1;
        _this.roughnessBlendLevel = 1;
        _this.bumpLevel = 1;
        _this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
        _this._isEnabled = false;
        _this.isEnabled = false;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        return _this;
      }
      DetailMapConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      DetailMapConfiguration2.prototype.isReadyForSubMesh = function(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty && scene.texturesEnabled) {
          if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
            if (!this._texture.isReady()) {
              return false;
            }
          }
        }
        return true;
      };
      DetailMapConfiguration2.prototype.prepareDefines = function(defines, scene) {
        if (this._isEnabled) {
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
          var engine = scene.getEngine();
          if (defines._areTexturesDirty) {
            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
              defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
            } else {
              defines.DETAIL = false;
            }
          }
        } else {
          defines.DETAIL = false;
        }
      };
      DetailMapConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        var isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "detail");
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.setTexture("detailSampler", this._texture);
          }
        }
      };
      DetailMapConfiguration2.prototype.hasTexture = function(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      };
      DetailMapConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      };
      DetailMapConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      };
      DetailMapConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        var _a;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
        }
      };
      DetailMapConfiguration2.prototype.getClassName = function() {
        return "DetailMapConfiguration";
      };
      DetailMapConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("detailSampler");
      };
      DetailMapConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vDetailInfos", size: 4, type: "vec4" },
            { name: "detailMatrix", size: 16, type: "mat4" }
          ]
        };
      };
      __decorate([
        serializeAsTexture("detailTexture"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], DetailMapConfiguration2.prototype, "texture", void 0);
      __decorate([
        serialize()
      ], DetailMapConfiguration2.prototype, "diffuseBlendLevel", void 0);
      __decorate([
        serialize()
      ], DetailMapConfiguration2.prototype, "roughnessBlendLevel", void 0);
      __decorate([
        serialize()
      ], DetailMapConfiguration2.prototype, "bumpLevel", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], DetailMapConfiguration2.prototype, "normalBlendMethod", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], DetailMapConfiguration2.prototype, "isEnabled", void 0);
      return DetailMapConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration;
var init_prePassConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/prePassConfiguration.js"() {
    PrePassConfiguration = function() {
      function PrePassConfiguration2() {
        this.previousWorldMatrices = {};
        this.previousBones = {};
      }
      PrePassConfiguration2.AddUniforms = function(uniforms) {
        uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
      };
      PrePassConfiguration2.AddSamplers = function(samplers) {
      };
      PrePassConfiguration2.prototype.bindForSubMesh = function(effect, scene, mesh, world, isFrozen) {
        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
          if (scene.prePassRenderer.getIndex(2) !== -1) {
            if (!this.previousWorldMatrices[mesh.uniqueId]) {
              this.previousWorldMatrices[mesh.uniqueId] = world.clone();
            }
            if (!this.previousViewProjection) {
              this.previousViewProjection = scene.getTransformMatrix().clone();
              this.currentViewProjection = scene.getTransformMatrix().clone();
            }
            var engine = scene.getEngine();
            if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
              this.currentViewProjection.copyFrom(scene.getTransformMatrix());
            } else if (this._lastUpdateFrameId !== engine.frameId) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
            }
            effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
            effect.setMatrix("previousViewProjection", this.previousViewProjection);
            this.previousWorldMatrices[mesh.uniqueId] = world.clone();
          }
        }
      };
      return PrePassConfiguration2;
    }();
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js
var name4, shader4;
var init_defaultFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js"() {
    init_shaderStore();
    name4 = "defaultFragmentDeclaration";
    shader4 = "uniform vec4 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;\nuniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n";
    ShaderStore.IncludesShadersStore[name4] = shader4;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js
var name5, shader5;
var init_sceneUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js"() {
    init_shaderStore();
    name5 = "sceneUboDeclaration";
    shader5 = "layout(std140,column_major) uniform;\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;\nmat4 projection;\nvec4 vEyePosition;\n};\n";
    ShaderStore.IncludesShadersStore[name5] = shader5;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js
var name6, shader6;
var init_meshUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js"() {
    init_shaderStore();
    name6 = "meshUboDeclaration";
    shader6 = "#ifdef WEBGL2\nuniform mat4 world;\nuniform float visibility;\n#else\nlayout(std140,column_major) uniform;\nuniform Mesh\n{\nmat4 world;\nfloat visibility;\n};\n#endif\n#define WORLD_UBO\n";
    ShaderStore.IncludesShadersStore[name6] = shader6;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js
var name7, shader7;
var init_defaultUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    name7 = "defaultUboDeclaration";
    shader7 = "layout(std140,column_major) uniform;\nuniform Material\n{\nvec4 diffuseLeftColor;\nvec4 diffuseRightColor;\nvec4 opacityParts;\nvec4 reflectionLeftColor;\nvec4 reflectionRightColor;\nvec4 refractionLeftColor;\nvec4 refractionRightColor;\nvec4 emissiveLeftColor;\nvec4 emissiveRightColor;\nvec2 vDiffuseInfos;\nvec2 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vReflectionInfos;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec2 vSpecularInfos;\nvec3 vBumpInfos;\nmat4 diffuseMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 reflectionMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 specularMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nfloat pointSize;\nfloat alphaCutOff;\nmat4 refractionMatrix;\nvec4 vRefractionInfos;\nvec3 vRefractionPosition;\nvec3 vRefractionSize;\nvec4 vSpecularColor;\nvec3 vEmissiveColor;\nvec4 vDiffuseColor;\nvec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";
    ShaderStore.IncludesShadersStore[name7] = shader7;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js
var name8, shader8;
var init_prePassDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js"() {
    init_shaderStore();
    name8 = "prePassDeclaration";
    shader8 = "#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name8] = shader8;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js
var name9, shader9;
var init_oitDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js"() {
    init_shaderStore();
    name9 = "oitDeclaration";
    shader9 = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;\nlayout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;\nuniform sampler2D oitDepthSampler;\nuniform sampler2D oitFrontColorSampler;\n#endif\n";
    ShaderStore.IncludesShadersStore[name9] = shader9;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js
var name10, shader10;
var init_mainUVVaryingDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js"() {
    init_shaderStore();
    name10 = "mainUVVaryingDeclaration";
    shader10 = "#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n";
    ShaderStore.IncludesShadersStore[name10] = shader10;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js
var name11, shader11;
var init_helperFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js"() {
    init_shaderStore();
    name11 = "helperFunctions";
    shader11 = "const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\nfloat toLinearSpace(float color)\n{\nreturn pow(color,LinearEncodePowerApprox);\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn pow(color,vec3(LinearEncodePowerApprox));\n}\nvec4 toLinearSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn pow(color,vec3(GammaEncodePowerApprox));\n}\nvec4 toGammaSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n}\nfloat toGammaSpace(float color)\n{\nreturn pow(color,GammaEncodePowerApprox);\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nvec3 square(vec3 value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\nreturn dither;\n}\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D =max(rgbdMaxRange/maxRGB,1.);\nD =clamp(floor(D)/255.0,0.,1.);\nvec3 rgb=color.rgb*D;\nrgb=toGammaSpace(rgb);\nreturn vec4(clamp(rgb,0.,1.),D); \n}\nvec3 fromRGBD(vec4 rgbd) {\nrgbd.rgb=toLinearSpace(rgbd.rgb);\nreturn rgbd.rgb/rgbd.a;\n}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\nvec3 intersectPositionWS=vertexPos+origVec*distance;\nreturn intersectPositionWS-cubePos;\n}\n";
    ShaderStore.IncludesShadersStore[name11] = shader11;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js
var name12, shader12;
var init_lightFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js"() {
    init_shaderStore();
    name12 = "lightFragmentDeclaration";
    shader12 = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name12] = shader12;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js
var name13, shader13;
var init_lightUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js"() {
    init_shaderStore();
    name13 = "lightUboDeclaration";
    shader13 = "#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name13] = shader13;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js
var name14, shader14;
var init_lightsFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js"() {
    init_shaderStore();
    name14 = "lightsFragmentFunctions";
    shader14 = "struct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w==0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn textureColor;\n}";
    ShaderStore.IncludesShadersStore[name14] = shader14;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js
var name15, shader15;
var init_shadowsFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js"() {
    init_shaderStore();
    name15 = "shadowsFragmentFunctions";
    shader15 = "#ifdef SHADOWS\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\nreturn mix(value,1.0,mask);\n}\n#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;\n}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \nreturn esm;\n}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn esm;\n}\n#if defined(WEBGL2) || defined(WEBGPU)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadow=texture2D(shadowSampler,uv).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat shadow=texture2D(shadowSampler,uvDepthLayer);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat shadow=texture2D(shadowSampler,uvDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.)\n);\nconst vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\nfloat AAOffset=shadowMapSizeInverse*10.;\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec4 offset=vec4(poissonSamplers[i],0.);\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\nfloat AAOffset=shadowMapSizeInverse*10.;\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec3 offset=poissonSamplers[i];\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\n}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name15] = shader15;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js
var name16, shader16;
var init_samplerFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js"() {
    init_shaderStore();
    name16 = "samplerFragmentDeclaration";
    shader16 = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n";
    ShaderStore.IncludesShadersStore[name16] = shader16;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js
var name17, shader17;
var init_fresnelFunction = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js"() {
    init_shaderStore();
    name17 = "fresnelFunction";
    shader17 = "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name17] = shader17;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js
var name18, shader18;
var init_reflectionFunction = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js"() {
    init_shaderStore();
    name18 = "reflectionFunction";
    shader18 = "vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0); \n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0); \n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name18] = shader18;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js
var name19, shader19;
var init_imageProcessingDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js"() {
    init_shaderStore();
    name19 = "imageProcessingDeclaration";
    shader19 = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#ifdef VIGNETTE\nuniform vec2 vInverseScreenSize;\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n";
    ShaderStore.IncludesShadersStore[name19] = shader19;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js
var name20, shader20;
var init_imageProcessingFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js"() {
    init_shaderStore();
    name20 = "imageProcessingFunctions";
    shader20 = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\ncolor=saturate(color);\nreturn color;\n}\n#endif\nvec4 applyImageProcessing(vec4 result) {\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\nreturn result;\n}";
    ShaderStore.IncludesShadersStore[name20] = shader20;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js
var name21, shader21;
var init_bumpFragmentMainFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js"() {
    init_shaderStore();
    name21 = "bumpFragmentMainFunctions";
    shader21 = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\n}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\ntangent*=tangentSpaceParams.x;\nbitangent*=tangentSpaceParams.y;\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name21] = shader21;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js
var name22, shader22;
var init_bumpFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js"() {
    init_shaderStore();
    init_samplerFragmentDeclaration();
    name22 = "bumpFragmentFunctions";
    shader22 = "#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\nif (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\nbreak;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name22] = shader22;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js
var name23, shader23;
var init_clipPlaneFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js"() {
    init_shaderStore();
    name23 = "clipPlaneFragmentDeclaration";
    shader23 = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";
    ShaderStore.IncludesShadersStore[name23] = shader23;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js
var name24, shader24;
var init_logDepthDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js"() {
    init_shaderStore();
    name24 = "logDepthDeclaration";
    shader24 = "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif\n";
    ShaderStore.IncludesShadersStore[name24] = shader24;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js
var name25, shader25;
var init_fogFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js"() {
    init_shaderStore();
    name25 = "fogFragmentDeclaration";
    shader25 = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying vec3 vFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nfloat fogDistance=length(vFogDistance);\nif (FOGMODE_LINEAR==vFogInfos.x)\n{\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name25] = shader25;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js
var name26, shader26;
var init_oitFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js"() {
    init_shaderStore();
    name26 = "oitFragment";
    shader26 = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));\nvec2 full=unpackHalf2x16(halfFloat);\nfragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\nvec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;\nvec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);\ndepth.rg=vec2(-MAX_DEPTH);\nfrontColor=lastFrontColor;\nbackColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;\nfloat nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;\nfloat furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;\n}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);\nreturn;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name26] = shader26;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js
var name27, shader27;
var init_clipPlaneFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js"() {
    init_shaderStore();
    name27 = "clipPlaneFragment";
    shader27 = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name27] = shader27;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js
var name28, shader28;
var init_bumpFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js"() {
    init_shaderStore();
    name28 = "bumpFragment";
    shader28 = "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\nmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);\nnormalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;\nbumpNormal+=vec3(0.0,0.0,1.0);\ndetailNormal*=vec3(-1.0,-1.0,1.0);\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n";
    ShaderStore.IncludesShadersStore[name28] = shader28;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js
var name29, shader29;
var init_depthPrePass = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js"() {
    init_shaderStore();
    name29 = "depthPrePass";
    shader29 = "#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\nreturn;\n#endif\n";
    ShaderStore.IncludesShadersStore[name29] = shader29;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js
var name30, shader30;
var init_lightFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js"() {
    init_shaderStore();
    name30 = "lightFragment";
    shader30 = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\ninfo.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {\nindex{X}=i;\nbreak;\n}\n}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{\nindex{X}+=1;\nfloat nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\nshadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name30] = shader30;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js
var name31, shader31;
var init_logDepthFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js"() {
    init_shaderStore();
    name31 = "logDepthFragment";
    shader31 = "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n";
    ShaderStore.IncludesShadersStore[name31] = shader31;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js
var name32, shader32;
var init_fogFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js"() {
    init_shaderStore();
    name32 = "fogFragment";
    shader32 = "#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n";
    ShaderStore.IncludesShadersStore[name32] = shader32;
  }
});

// node_modules/@babylonjs/core/Shaders/default.fragment.js
var name33, shader33;
var init_default_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/default.fragment.js"() {
    init_shaderStore();
    init_defaultFragmentDeclaration();
    init_defaultUboDeclaration();
    init_prePassDeclaration();
    init_oitDeclaration();
    init_mainUVVaryingDeclaration();
    init_helperFunctions();
    init_lightFragmentDeclaration();
    init_lightUboDeclaration();
    init_lightsFragmentFunctions();
    init_shadowsFragmentFunctions();
    init_samplerFragmentDeclaration();
    init_fresnelFunction();
    init_reflectionFunction();
    init_imageProcessingDeclaration();
    init_imageProcessingFunctions();
    init_bumpFragmentMainFunctions();
    init_bumpFragmentFunctions();
    init_clipPlaneFragmentDeclaration();
    init_logDepthDeclaration();
    init_fogFragmentDeclaration();
    init_oitFragment();
    init_clipPlaneFragment();
    init_bumpFragment();
    init_depthPrePass();
    init_lightFragment();
    init_logDepthFragment();
    init_fogFragment();
    name33 = "defaultPixelShader";
    shader33 = "#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<oitFragment>\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0) {\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\ngl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); \n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor.rgb,specularMapColor.a*writeGeometryInfo);\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo);\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\nfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\nfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\n} else {\nbackColor+=color;\n}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";
    ShaderStore.ShadersStore[name33] = shader33;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js
var name34, shader34;
var init_defaultVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js"() {
    init_shaderStore();
    name34 = "defaultVertexDeclaration";
    shader34 = "uniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\nuniform mat4 detailMatrix;\n#endif\n#define ADDITIONAL_VERTEX_DECLARATION\n";
    ShaderStore.IncludesShadersStore[name34] = shader34;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js
var name35, shader35;
var init_uvAttributeDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js"() {
    init_shaderStore();
    name35 = "uvAttributeDeclaration";
    shader35 = "#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n";
    ShaderStore.IncludesShadersStore[name35] = shader35;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js
var name36, shader36;
var init_bonesDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js"() {
    init_shaderStore();
    name36 = "bonesDeclaration";
    shader36 = "#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\nuniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{\nfloat offset=index *4.0;\nfloat dx=1.0/boneTextureWidth;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name36] = shader36;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js
var name37, shader37;
var init_bakedVertexAnimationDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js"() {
    init_shaderStore();
    name37 = "bakedVertexAnimationDeclaration";
    shader37 = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;\nuniform vec2 bakedVertexAnimationTextureSizeInverted;\nuniform vec4 bakedVertexAnimationSettings;\nuniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{\nfloat offset=index*4.0;\nfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\nfloat dx=bakedVertexAnimationTextureSizeInverted.x;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name37] = shader37;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js
var name38, shader38;
var init_instancesDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js"() {
    init_shaderStore();
    name38 = "instancesDeclaration";
    shader38 = "#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;\nattribute vec4 previousWorld1;\nattribute vec4 previousWorld2;\nattribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name38] = shader38;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js
var name39, shader39;
var init_prePassVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js"() {
    init_shaderStore();
    name39 = "prePassVertexDeclaration";
    shader39 = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name39] = shader39;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js
var name40, shader40;
var init_samplerVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js"() {
    init_shaderStore();
    name40 = "samplerVertexDeclaration";
    shader40 = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n";
    ShaderStore.IncludesShadersStore[name40] = shader40;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js
var name41, shader41;
var init_bumpVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js"() {
    init_shaderStore();
    name41 = "bumpVertexDeclaration";
    shader41 = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name41] = shader41;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js
var name42, shader42;
var init_clipPlaneVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js"() {
    init_shaderStore();
    name42 = "clipPlaneVertexDeclaration";
    shader42 = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif\n";
    ShaderStore.IncludesShadersStore[name42] = shader42;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js
var name43, shader43;
var init_fogVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js"() {
    init_shaderStore();
    name43 = "fogVertexDeclaration";
    shader43 = "#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n";
    ShaderStore.IncludesShadersStore[name43] = shader43;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js
var name44, shader44;
var init_lightVxFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js"() {
    init_shaderStore();
    name44 = "lightVxFragmentDeclaration";
    shader44 = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name44] = shader44;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js
var name45, shader45;
var init_lightVxUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js"() {
    init_shaderStore();
    name45 = "lightVxUboDeclaration";
    shader45 = "#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name45] = shader45;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name46, shader46;
var init_morphTargetsVertexGlobalDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js"() {
    init_shaderStore();
    name46 = "morphTargetsVertexGlobalDeclaration";
    shader46 = "#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nprecision mediump sampler2DArray; \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];\nuniform vec3 morphTargetTextureInfo;\nuniform sampler2DArray morphTargets;\nvec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);\nfloat x=vertexIndex-y*morphTargetTextureInfo.y;\nvec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);\nreturn texture(morphTargets,textureUV).xyz;\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name46] = shader46;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js
var name47, shader47;
var init_morphTargetsVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js"() {
    init_shaderStore();
    name47 = "morphTargetsVertexDeclaration";
    shader47 = "#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name47] = shader47;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js
var name48, shader48;
var init_morphTargetsVertexGlobal = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js"() {
    init_shaderStore();
    name48 = "morphTargetsVertexGlobal";
    shader48 = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name48] = shader48;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js
var name49, shader49;
var init_morphTargetsVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js"() {
    init_shaderStore();
    name49 = "morphTargetsVertex";
    shader49 = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE \nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\npositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name49] = shader49;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js
var name50, shader50;
var init_instancesVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js"() {
    init_shaderStore();
    name50 = "instancesVertex";
    shader50 = "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name50] = shader50;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js
var name51, shader51;
var init_bonesVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js"() {
    init_shaderStore();
    name51 = "bonesVertex";
    shader51 = "#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name51] = shader51;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js
var name52, shader52;
var init_bakedVertexAnimation = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js"() {
    init_shaderStore();
    name52 = "bakedVertexAnimation";
    shader52 = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;\nfloat VATEndFrame=BVASNAME.y;\nfloat VATOffsetFrame=BVASNAME.z;\nfloat VATSpeed=BVASNAME.w;\nfloat totalFrames=VATEndFrame-VATStartFrame+1.0;\nfloat time=bakedVertexAnimationTime*VATSpeed/totalFrames;\nfloat frameCorrection=time<1.0 ? 0.0 : 1.0;\nfloat numOfFrames=totalFrames-frameCorrection;\nfloat VATFrameNum=fract(time)*numOfFrames;\nVATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);\nVATFrameNum=floor(VATFrameNum);\nVATFrameNum+=VATStartFrame+frameCorrection;\nmat4 VATInfluence;\nVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name52] = shader52;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js
var name53, shader53;
var init_prePassVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js"() {
    init_shaderStore();
    name53 = "prePassVertex";
    shader53 = "#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name53] = shader53;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js
var name54, shader54;
var init_uvVariableDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js"() {
    init_shaderStore();
    name54 = "uvVariableDeclaration";
    shader54 = "#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n";
    ShaderStore.IncludesShadersStore[name54] = shader54;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js
var name55, shader55;
var init_samplerVertexImplementation = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js"() {
    init_shaderStore();
    name55 = "samplerVertexImplementation";
    shader55 = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));\n}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));\n}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));\n}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));\n}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name55] = shader55;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js
var name56, shader56;
var init_bumpVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js"() {
    init_shaderStore();
    name56 = "bumpVertex";
    shader56 = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name56] = shader56;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js
var name57, shader57;
var init_clipPlaneVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js"() {
    init_shaderStore();
    name57 = "clipPlaneVertex";
    shader57 = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";
    ShaderStore.IncludesShadersStore[name57] = shader57;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js
var name58, shader58;
var init_fogVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js"() {
    init_shaderStore();
    name58 = "fogVertex";
    shader58 = "#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n";
    ShaderStore.IncludesShadersStore[name58] = shader58;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js
var name59, shader59;
var init_shadowsVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js"() {
    init_shaderStore();
    name59 = "shadowsVertex";
    shader59 = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name59] = shader59;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js
var name60, shader60;
var init_pointCloudVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js"() {
    init_shaderStore();
    name60 = "pointCloudVertex";
    shader60 = "#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n";
    ShaderStore.IncludesShadersStore[name60] = shader60;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js
var name61, shader61;
var init_logDepthVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js"() {
    init_shaderStore();
    name61 = "logDepthVertex";
    shader61 = "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n";
    ShaderStore.IncludesShadersStore[name61] = shader61;
  }
});

// node_modules/@babylonjs/core/Shaders/default.vertex.js
var name62, shader62;
var init_default_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/default.vertex.js"() {
    init_shaderStore();
    init_defaultVertexDeclaration();
    init_defaultUboDeclaration();
    init_uvAttributeDeclaration();
    init_helperFunctions();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_instancesDeclaration();
    init_prePassVertexDeclaration();
    init_mainUVVaryingDeclaration();
    init_samplerVertexDeclaration();
    init_bumpVertexDeclaration();
    init_clipPlaneVertexDeclaration();
    init_fogVertexDeclaration();
    init_lightVxFragmentDeclaration();
    init_lightVxUboDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_logDepthDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_prePassVertex();
    init_uvVariableDeclaration();
    init_samplerVertexImplementation();
    init_bumpVertex();
    init_clipPlaneVertex();
    init_fogVertex();
    init_shadowsVertex();
    init_pointCloudVertex();
    init_logDepthVertex();
    name62 = "defaultVertexShader";
    shader62 = "#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\n#elif INSTANCESCOLOR\nvColor=instanceColor;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";
    ShaderStore.ShadersStore[name62] = shader62;
  }
});

// node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters, StandardMaterialDefines, StandardMaterial;
var init_standardMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/standardMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_scene();
    init_math_vector();
    init_math_color();
    init_buffer();
    init_prePassConfiguration();
    init_imageProcessingConfiguration();
    init_material();
    init_materialPluginEvent();
    init_materialDefines();
    init_pushMaterial();
    init_materialHelper();
    init_texture();
    init_typeStore();
    init_materialFlags();
    init_default_fragment();
    init_default_vertex();
    init_effectFallbacks();
    init_material_detailMapConfiguration();
    onCreatedEffectParameters = { effect: null, subMesh: null };
    StandardMaterialDefines = function(_super) {
      __extends(StandardMaterialDefines2, _super);
      function StandardMaterialDefines2(externalProperties) {
        var _this = _super.call(this, externalProperties) || this;
        _this.MAINUV1 = false;
        _this.MAINUV2 = false;
        _this.MAINUV3 = false;
        _this.MAINUV4 = false;
        _this.MAINUV5 = false;
        _this.MAINUV6 = false;
        _this.DIFFUSE = false;
        _this.DIFFUSEDIRECTUV = 0;
        _this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        _this.AMBIENT = false;
        _this.AMBIENTDIRECTUV = 0;
        _this.OPACITY = false;
        _this.OPACITYDIRECTUV = 0;
        _this.OPACITYRGB = false;
        _this.REFLECTION = false;
        _this.EMISSIVE = false;
        _this.EMISSIVEDIRECTUV = 0;
        _this.SPECULAR = false;
        _this.SPECULARDIRECTUV = 0;
        _this.BUMP = false;
        _this.BUMPDIRECTUV = 0;
        _this.PARALLAX = false;
        _this.PARALLAXOCCLUSION = false;
        _this.SPECULAROVERALPHA = false;
        _this.CLIPPLANE = false;
        _this.CLIPPLANE2 = false;
        _this.CLIPPLANE3 = false;
        _this.CLIPPLANE4 = false;
        _this.CLIPPLANE5 = false;
        _this.CLIPPLANE6 = false;
        _this.ALPHATEST = false;
        _this.DEPTHPREPASS = false;
        _this.ALPHAFROMDIFFUSE = false;
        _this.POINTSIZE = false;
        _this.FOG = false;
        _this.SPECULARTERM = false;
        _this.DIFFUSEFRESNEL = false;
        _this.OPACITYFRESNEL = false;
        _this.REFLECTIONFRESNEL = false;
        _this.REFRACTIONFRESNEL = false;
        _this.EMISSIVEFRESNEL = false;
        _this.FRESNEL = false;
        _this.NORMAL = false;
        _this.TANGENT = false;
        _this.UV1 = false;
        _this.UV2 = false;
        _this.UV3 = false;
        _this.UV4 = false;
        _this.UV5 = false;
        _this.UV6 = false;
        _this.VERTEXCOLOR = false;
        _this.VERTEXALPHA = false;
        _this.NUM_BONE_INFLUENCERS = 0;
        _this.BonesPerMesh = 0;
        _this.BONETEXTURE = false;
        _this.BONES_VELOCITY_ENABLED = false;
        _this.INSTANCES = false;
        _this.THIN_INSTANCES = false;
        _this.INSTANCESCOLOR = false;
        _this.GLOSSINESS = false;
        _this.ROUGHNESS = false;
        _this.EMISSIVEASILLUMINATION = false;
        _this.LINKEMISSIVEWITHDIFFUSE = false;
        _this.REFLECTIONFRESNELFROMSPECULAR = false;
        _this.LIGHTMAP = false;
        _this.LIGHTMAPDIRECTUV = 0;
        _this.OBJECTSPACE_NORMALMAP = false;
        _this.USELIGHTMAPASSHADOWMAP = false;
        _this.REFLECTIONMAP_3D = false;
        _this.REFLECTIONMAP_SPHERICAL = false;
        _this.REFLECTIONMAP_PLANAR = false;
        _this.REFLECTIONMAP_CUBIC = false;
        _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        _this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        _this.REFLECTIONMAP_PROJECTION = false;
        _this.REFLECTIONMAP_SKYBOX = false;
        _this.REFLECTIONMAP_EXPLICIT = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        _this.REFLECTIONMAP_OPPOSITEZ = false;
        _this.INVERTCUBICMAP = false;
        _this.LOGARITHMICDEPTH = false;
        _this.REFRACTION = false;
        _this.REFRACTIONMAP_3D = false;
        _this.REFLECTIONOVERALPHA = false;
        _this.TWOSIDEDLIGHTING = false;
        _this.SHADOWFLOAT = false;
        _this.MORPHTARGETS = false;
        _this.MORPHTARGETS_NORMAL = false;
        _this.MORPHTARGETS_TANGENT = false;
        _this.MORPHTARGETS_UV = false;
        _this.NUM_MORPH_INFLUENCERS = 0;
        _this.MORPHTARGETS_TEXTURE = false;
        _this.NONUNIFORMSCALING = false;
        _this.PREMULTIPLYALPHA = false;
        _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
        _this.ALPHABLEND = true;
        _this.PREPASS = false;
        _this.PREPASS_IRRADIANCE = false;
        _this.PREPASS_IRRADIANCE_INDEX = -1;
        _this.PREPASS_ALBEDO_SQRT = false;
        _this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        _this.PREPASS_DEPTH = false;
        _this.PREPASS_DEPTH_INDEX = -1;
        _this.PREPASS_NORMAL = false;
        _this.PREPASS_NORMAL_INDEX = -1;
        _this.PREPASS_POSITION = false;
        _this.PREPASS_POSITION_INDEX = -1;
        _this.PREPASS_VELOCITY = false;
        _this.PREPASS_VELOCITY_INDEX = -1;
        _this.PREPASS_REFLECTIVITY = false;
        _this.PREPASS_REFLECTIVITY_INDEX = -1;
        _this.SCENE_MRT_COUNT = 0;
        _this.RGBDLIGHTMAP = false;
        _this.RGBDREFLECTION = false;
        _this.RGBDREFRACTION = false;
        _this.IMAGEPROCESSING = false;
        _this.VIGNETTE = false;
        _this.VIGNETTEBLENDMODEMULTIPLY = false;
        _this.VIGNETTEBLENDMODEOPAQUE = false;
        _this.TONEMAPPING = false;
        _this.TONEMAPPING_ACES = false;
        _this.CONTRAST = false;
        _this.COLORCURVES = false;
        _this.COLORGRADING = false;
        _this.COLORGRADING3D = false;
        _this.SAMPLER3DGREENDEPTH = false;
        _this.SAMPLER3DBGRMAP = false;
        _this.IMAGEPROCESSINGPOSTPROCESS = false;
        _this.SKIPFINALCOLORCLAMP = false;
        _this.MULTIVIEW = false;
        _this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        _this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        _this.IS_REFLECTION_LINEAR = false;
        _this.IS_REFRACTION_LINEAR = false;
        _this.EXPOSURE = false;
        _this.rebuild();
        return _this;
      }
      StandardMaterialDefines2.prototype.setReflectionMode = function(modeToEnable) {
        var modes = [
          "REFLECTIONMAP_CUBIC",
          "REFLECTIONMAP_EXPLICIT",
          "REFLECTIONMAP_PLANAR",
          "REFLECTIONMAP_PROJECTION",
          "REFLECTIONMAP_PROJECTION",
          "REFLECTIONMAP_SKYBOX",
          "REFLECTIONMAP_SPHERICAL",
          "REFLECTIONMAP_EQUIRECTANGULAR",
          "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
          "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
        ];
        for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {
          var mode = modes_1[_i];
          this[mode] = mode === modeToEnable;
        }
      };
      return StandardMaterialDefines2;
    }(MaterialDefines);
    StandardMaterial = function(_super) {
      __extends(StandardMaterial2, _super);
      function StandardMaterial2(name105, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this._diffuseTexture = null;
        _this._ambientTexture = null;
        _this._opacityTexture = null;
        _this._reflectionTexture = null;
        _this._emissiveTexture = null;
        _this._specularTexture = null;
        _this._bumpTexture = null;
        _this._lightmapTexture = null;
        _this._refractionTexture = null;
        _this.ambientColor = new Color3(0, 0, 0);
        _this.diffuseColor = new Color3(1, 1, 1);
        _this.specularColor = new Color3(1, 1, 1);
        _this.emissiveColor = new Color3(0, 0, 0);
        _this.specularPower = 64;
        _this._useAlphaFromDiffuseTexture = false;
        _this._useEmissiveAsIllumination = false;
        _this._linkEmissiveWithDiffuse = false;
        _this._useSpecularOverAlpha = false;
        _this._useReflectionOverAlpha = false;
        _this._disableLighting = false;
        _this._useObjectSpaceNormalMap = false;
        _this._useParallax = false;
        _this._useParallaxOcclusion = false;
        _this.parallaxScaleBias = 0.05;
        _this._roughness = 0;
        _this.indexOfRefraction = 0.98;
        _this.invertRefractionY = true;
        _this.alphaCutOff = 0.4;
        _this._useLightmapAsShadowmap = false;
        _this._useReflectionFresnelFromSpecular = false;
        _this._useGlossinessFromSpecularMapAlpha = false;
        _this._maxSimultaneousLights = 4;
        _this._invertNormalMapX = false;
        _this._invertNormalMapY = false;
        _this._twoSidedLighting = false;
        _this._renderTargets = new SmartArray(16);
        _this._worldViewProjectionMatrix = Matrix.Zero();
        _this._globalAmbientColor = new Color3(0, 0, 0);
        _this._cacheHasRenderTargetTextures = false;
        _this.detailMap = new DetailMapConfiguration(_this);
        _this._attachImageProcessingConfiguration(null);
        _this.prePassConfiguration = new PrePassConfiguration();
        _this.getRenderTargetTextures = function() {
          _this._renderTargets.reset();
          if (StandardMaterial2.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
            _this._renderTargets.push(_this._reflectionTexture);
          }
          if (StandardMaterial2.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {
            _this._renderTargets.push(_this._refractionTexture);
          }
          _this._eventInfo.renderTargets = _this._renderTargets;
          _this._callbackPluginEventFillRenderTargetTextures(_this._eventInfo);
          return _this._renderTargets;
        };
        return _this;
      }
      Object.defineProperty(StandardMaterial2.prototype, "imageProcessingConfiguration", {
        get: function() {
          return this._imageProcessingConfiguration;
        },
        set: function(value) {
          this._attachImageProcessingConfiguration(value);
          this._markAllSubMeshesAsTexturesDirty();
        },
        enumerable: false,
        configurable: true
      });
      StandardMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
        var _this = this;
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
            _this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      };
      Object.defineProperty(StandardMaterial2.prototype, "isPrePassCapable", {
        get: function() {
          return !this.disableDepthWrite;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurvesEnabled", {
        get: function() {
          return this.imageProcessingConfiguration.colorCurvesEnabled;
        },
        set: function(value) {
          this.imageProcessingConfiguration.colorCurvesEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingEnabled", {
        get: function() {
          return this.imageProcessingConfiguration.colorGradingEnabled;
        },
        set: function(value) {
          this.imageProcessingConfiguration.colorGradingEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraToneMappingEnabled", {
        get: function() {
          return this._imageProcessingConfiguration.toneMappingEnabled;
        },
        set: function(value) {
          this._imageProcessingConfiguration.toneMappingEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraExposure", {
        get: function() {
          return this._imageProcessingConfiguration.exposure;
        },
        set: function(value) {
          this._imageProcessingConfiguration.exposure = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraContrast", {
        get: function() {
          return this._imageProcessingConfiguration.contrast;
        },
        set: function(value) {
          this._imageProcessingConfiguration.contrast = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingTexture", {
        get: function() {
          return this._imageProcessingConfiguration.colorGradingTexture;
        },
        set: function(value) {
          this._imageProcessingConfiguration.colorGradingTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurves", {
        get: function() {
          return this._imageProcessingConfiguration.colorCurves;
        },
        set: function(value) {
          this._imageProcessingConfiguration.colorCurves = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "canRenderToMRT", {
        get: function() {
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2.prototype, "hasRenderTargetTextures", {
        get: function() {
          if (StandardMaterial2.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            return true;
          }
          if (StandardMaterial2.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
            return true;
          }
          return this._cacheHasRenderTargetTextures;
        },
        enumerable: false,
        configurable: true
      });
      StandardMaterial2.prototype.getClassName = function() {
        return "StandardMaterial";
      };
      Object.defineProperty(StandardMaterial2.prototype, "useLogarithmicDepth", {
        get: function() {
          return this._useLogarithmicDepth;
        },
        set: function(value) {
          this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
          this._markAllSubMeshesAsMiscDirty();
        },
        enumerable: false,
        configurable: true
      });
      StandardMaterial2.prototype.needAlphaBlending = function() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
      };
      StandardMaterial2.prototype.needAlphaTesting = function() {
        if (this._forceAlphaTest) {
          return true;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
      };
      StandardMaterial2.prototype._shouldUseAlphaFromDiffuseTexture = function() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
      };
      StandardMaterial2.prototype._hasAlphaChannel = function() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
      };
      StandardMaterial2.prototype.getAlphaTestTexture = function() {
        return this._diffuseTexture;
      };
      StandardMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
        if (useInstances === void 0) {
          useInstances = false;
        }
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        if (subMesh.effect && this.isFrozen) {
          if (subMesh.effect._wasPreviouslyReady) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
          subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
        }
        var scene = this.getScene();
        var defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        var engine = scene.getEngine();
        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        MaterialHelper.PrepareDefinesForMultiview(scene, defines);
        var oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          defines._needUVs = false;
          for (var i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
              if (!this._diffuseTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
              }
            } else {
              defines.DIFFUSE = false;
            }
            if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              }
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
                defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
              }
            } else {
              defines.OPACITY = false;
            }
            if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
              if (!this._reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                defines._needNormals = true;
                defines.REFLECTION = true;
                defines.ROUGHNESS = this._roughness > 0;
                defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
                defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
                defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
                defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
                defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;
                switch (this._reflectionTexture.coordinatesMode) {
                  case Texture.EXPLICIT_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                    break;
                  case Texture.PLANAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                    break;
                  case Texture.PROJECTION_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                    break;
                  case Texture.SKYBOX_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                    break;
                  case Texture.SPHERICAL_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                    break;
                  case Texture.EQUIRECTANGULAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                    break;
                  case Texture.FIXED_EQUIRECTANGULAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                    break;
                  case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                    break;
                  case Texture.CUBIC_MODE:
                  case Texture.INVCUBIC_MODE:
                  default:
                    defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                    break;
                }
                defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
            }
            if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              }
            } else {
              defines.EMISSIVE = false;
            }
            if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
                defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
                defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
              }
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
              if (!this._specularTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
                defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
              }
            } else {
              defines.SPECULAR = false;
            }
            if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial2.BumpTextureEnabled) {
              if (!this._bumpTexture.isReady()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
                defines.PARALLAX = this._useParallax;
                defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
            }
            if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
              if (!this._refractionTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                defines._needUVs = true;
                defines.REFRACTION = true;
                defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
                defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
                defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
              }
            } else {
              defines.REFRACTION = false;
            }
            defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
          } else {
            defines.DIFFUSE = false;
            defines.AMBIENT = false;
            defines.OPACITY = false;
            defines.REFLECTION = false;
            defines.EMISSIVE = false;
            defines.LIGHTMAP = false;
            defines.BUMP = false;
            defines.REFRACTION = false;
          }
          defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
          defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
          defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
          defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
          this._imageProcessingConfiguration.prepareDefines(defines);
          defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
          defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
        }
        if (defines._areFresnelDirty) {
          if (StandardMaterial2.FresnelEnabled) {
            if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
              defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
              defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
              defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
              defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
              defines._needNormals = true;
              defines.FRESNEL = true;
            }
          } else {
            defines.FRESNEL = false;
          }
        }
        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);
        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefines(this._eventInfo);
        if (defines.isDirty) {
          var lightDisposed = defines._areLightsDisposed;
          defines.markAsProcessed();
          var fallbacks = new EffectFallbacks();
          if (defines.REFLECTION) {
            fallbacks.addFallback(0, "REFLECTION");
          }
          if (defines.SPECULAR) {
            fallbacks.addFallback(0, "SPECULAR");
          }
          if (defines.BUMP) {
            fallbacks.addFallback(0, "BUMP");
          }
          if (defines.PARALLAX) {
            fallbacks.addFallback(1, "PARALLAX");
          }
          if (defines.PARALLAXOCCLUSION) {
            fallbacks.addFallback(0, "PARALLAXOCCLUSION");
          }
          if (defines.SPECULAROVERALPHA) {
            fallbacks.addFallback(0, "SPECULAROVERALPHA");
          }
          if (defines.FOG) {
            fallbacks.addFallback(1, "FOG");
          }
          if (defines.POINTSIZE) {
            fallbacks.addFallback(0, "POINTSIZE");
          }
          if (defines.LOGARITHMICDEPTH) {
            fallbacks.addFallback(0, "LOGARITHMICDEPTH");
          }
          MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
          if (defines.SPECULARTERM) {
            fallbacks.addFallback(0, "SPECULARTERM");
          }
          if (defines.DIFFUSEFRESNEL) {
            fallbacks.addFallback(1, "DIFFUSEFRESNEL");
          }
          if (defines.OPACITYFRESNEL) {
            fallbacks.addFallback(2, "OPACITYFRESNEL");
          }
          if (defines.REFLECTIONFRESNEL) {
            fallbacks.addFallback(3, "REFLECTIONFRESNEL");
          }
          if (defines.EMISSIVEFRESNEL) {
            fallbacks.addFallback(4, "EMISSIVEFRESNEL");
          }
          if (defines.FRESNEL) {
            fallbacks.addFallback(4, "FRESNEL");
          }
          if (defines.MULTIVIEW) {
            fallbacks.addFallback(0, "MULTIVIEW");
          }
          var attribs = [VertexBuffer.PositionKind];
          if (defines.NORMAL) {
            attribs.push(VertexBuffer.NormalKind);
          }
          if (defines.TANGENT) {
            attribs.push(VertexBuffer.TangentKind);
          }
          for (var i = 1; i <= 6; ++i) {
            if (defines["UV" + i]) {
              attribs.push("uv".concat(i === 1 ? "" : i));
            }
          }
          if (defines.VERTEXCOLOR) {
            attribs.push(VertexBuffer.ColorKind);
          }
          if (defines.INSTANCESCOLOR) {
            attribs.push(VertexBuffer.ColorInstanceKind);
          }
          MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
          MaterialHelper.PrepareAttributesForInstances(attribs, defines);
          MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
          MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
          var shaderName = "default";
          var uniforms = [
            "world",
            "view",
            "viewProjection",
            "vEyePosition",
            "vLightsType",
            "vAmbientColor",
            "vDiffuseColor",
            "vSpecularColor",
            "vEmissiveColor",
            "visibility",
            "vFogInfos",
            "vFogColor",
            "pointSize",
            "vDiffuseInfos",
            "vAmbientInfos",
            "vOpacityInfos",
            "vReflectionInfos",
            "vEmissiveInfos",
            "vSpecularInfos",
            "vBumpInfos",
            "vLightmapInfos",
            "vRefractionInfos",
            "mBones",
            "vClipPlane",
            "vClipPlane2",
            "vClipPlane3",
            "vClipPlane4",
            "vClipPlane5",
            "vClipPlane6",
            "diffuseMatrix",
            "ambientMatrix",
            "opacityMatrix",
            "reflectionMatrix",
            "emissiveMatrix",
            "specularMatrix",
            "bumpMatrix",
            "normalMatrix",
            "lightmapMatrix",
            "refractionMatrix",
            "diffuseLeftColor",
            "diffuseRightColor",
            "opacityParts",
            "reflectionLeftColor",
            "reflectionRightColor",
            "emissiveLeftColor",
            "emissiveRightColor",
            "refractionLeftColor",
            "refractionRightColor",
            "vReflectionPosition",
            "vReflectionSize",
            "vRefractionPosition",
            "vRefractionSize",
            "logarithmicDepthConstant",
            "vTangentSpaceParams",
            "alphaCutOff",
            "boneTextureWidth",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices"
          ];
          var samplers = [
            "diffuseSampler",
            "ambientSampler",
            "opacitySampler",
            "reflectionCubeSampler",
            "reflection2DSampler",
            "emissiveSampler",
            "specularSampler",
            "bumpSampler",
            "lightmapSampler",
            "refractionCubeSampler",
            "refraction2DSampler",
            "boneSampler",
            "morphTargets",
            "oitDepthSampler",
            "oitFrontColorSampler"
          ];
          var uniformBuffers = ["Material", "Scene", "Mesh"];
          this._eventInfo.fallbacks = fallbacks;
          this._eventInfo.fallbackRank = 0;
          this._eventInfo.defines = defines;
          this._eventInfo.uniforms = uniforms;
          this._eventInfo.samplers = samplers;
          this._eventInfo.uniformBuffersNames = uniformBuffers;
          this._eventInfo.customCode = void 0;
          this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
          PrePassConfiguration.AddUniforms(uniforms);
          PrePassConfiguration.AddSamplers(samplers);
          if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
          }
          MaterialHelper.PrepareUniformsAndSamplersList({
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines,
            maxSimultaneousLights: this._maxSimultaneousLights
          });
          var csnrOptions = {};
          if (this.customShaderNameResolve) {
            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
          }
          var join = defines.toString();
          var previousEffect = subMesh.effect;
          var effect = scene.getEngine().createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
            processFinalCode: csnrOptions.processFinalCode,
            processCodeAfterIncludes: this._eventInfo.customCode,
            multiTarget: defines.PREPASS
          }, engine);
          if (effect) {
            if (this._onEffectCreatedObservable) {
              onCreatedEffectParameters.effect = effect;
              onCreatedEffectParameters.subMesh = subMesh;
              this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
            }
            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
              effect = previousEffect;
              defines.markAsUnprocessed();
              if (lightDisposed) {
                defines._areLightsDisposed = true;
                return false;
              }
            } else {
              scene.resetCachedMaterial();
              subMesh.setEffect(effect, defines, this._materialContext);
            }
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        subMesh.effect._wasPreviouslyReady = true;
        return true;
      };
      StandardMaterial2.prototype.buildUniformLayout = function() {
        var ubo = this._uniformBuffer;
        ubo.addUniform("diffuseLeftColor", 4);
        ubo.addUniform("diffuseRightColor", 4);
        ubo.addUniform("opacityParts", 4);
        ubo.addUniform("reflectionLeftColor", 4);
        ubo.addUniform("reflectionRightColor", 4);
        ubo.addUniform("refractionLeftColor", 4);
        ubo.addUniform("refractionRightColor", 4);
        ubo.addUniform("emissiveLeftColor", 4);
        ubo.addUniform("emissiveRightColor", 4);
        ubo.addUniform("vDiffuseInfos", 2);
        ubo.addUniform("vAmbientInfos", 2);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vReflectionInfos", 2);
        ubo.addUniform("vReflectionPosition", 3);
        ubo.addUniform("vReflectionSize", 3);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vSpecularInfos", 2);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("diffuseMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("reflectionMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("specularMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("alphaCutOff", 1);
        ubo.addUniform("refractionMatrix", 16);
        ubo.addUniform("vRefractionInfos", 4);
        ubo.addUniform("vRefractionPosition", 3);
        ubo.addUniform("vRefractionSize", 3);
        ubo.addUniform("vSpecularColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vDiffuseColor", 4);
        ubo.addUniform("vAmbientColor", 3);
        _super.prototype.buildUniformLayout.call(this);
      };
      StandardMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
        var _a;
        var scene = this.getScene();
        var defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        var effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
        MaterialHelper.BindBonesParameters(mesh, effect);
        var ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
            if (StandardMaterial2.FresnelEnabled && defines.FRESNEL) {
              if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
                ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
                ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
              }
              if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
                ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
              }
              if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
                ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
                ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
              }
              if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
                ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
                ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
              }
              if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
                ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
                ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
              }
            }
            if (scene.texturesEnabled) {
              if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
                ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
                MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
              }
              if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
                ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
                MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (this._hasAlphaChannel()) {
                ubo.updateFloat("alphaCutOff", this.alphaCutOff);
              }
              if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
                ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
                ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
                if (this._reflectionTexture.boundingBoxSize) {
                  var cubeTexture = this._reflectionTexture;
                  ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
                }
              }
              if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
                ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
                MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, "specular");
              }
              if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
                MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
              if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
                var depth = 1;
                if (!this._refractionTexture.isCube) {
                  ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
                  if (this._refractionTexture.depth) {
                    depth = this._refractionTexture.depth;
                  }
                }
                ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
                if (this._refractionTexture.boundingBoxSize) {
                  var cubeTexture = this._refractionTexture;
                  ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.SPECULARTERM) {
              ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
            }
            ubo.updateColor3("vEmissiveColor", StandardMaterial2.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
          }
          if (scene.texturesEnabled) {
            if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
              effect.setTexture("diffuseSampler", this._diffuseTexture);
            }
            if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
              effect.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
              effect.setTexture("opacitySampler", this._opacityTexture);
            }
            if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
              if (this._reflectionTexture.isCube) {
                effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
              } else {
                effect.setTexture("reflection2DSampler", this._reflectionTexture);
              }
            }
            if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
              effect.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
              effect.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
              effect.setTexture("specularSampler", this._specularTexture);
            }
            if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
              effect.setTexture("bumpSampler", this._bumpTexture);
            }
            if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
              if (this._refractionTexture.isCube) {
                effect.setTexture("refractionCubeSampler", this._refractionTexture);
              } else {
                effect.setTexture("refraction2DSampler", this._refractionTexture);
              }
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          MaterialHelper.BindClipPlane(effect, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows) {
            this.bindView(effect);
          }
          MaterialHelper.BindFogParameters(scene, mesh, effect);
          if (defines.NUM_MORPH_INFLUENCERS) {
            MaterialHelper.BindMorphTargetParameters(mesh, effect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, defines.INSTANCES);
          }
          if (this.useLogarithmicDepth) {
            MaterialHelper.BindLogDepth(defines, effect, scene);
          }
          if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
            this._imageProcessingConfiguration.bind(this._activeEffect);
          }
        }
        this._afterBind(mesh, this._activeEffect);
        ubo.update();
      };
      StandardMaterial2.prototype.getAnimatables = function() {
        var results = _super.prototype.getAnimatables.call(this);
        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
          results.push(this._diffuseTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
          results.push(this._specularTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          results.push(this._refractionTexture);
        }
        return results;
      };
      StandardMaterial2.prototype.getActiveTextures = function() {
        var activeTextures = _super.prototype.getActiveTextures.call(this);
        if (this._diffuseTexture) {
          activeTextures.push(this._diffuseTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._specularTexture) {
          activeTextures.push(this._specularTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
        return activeTextures;
      };
      StandardMaterial2.prototype.hasTexture = function(texture) {
        if (_super.prototype.hasTexture.call(this, texture)) {
          return true;
        }
        if (this._diffuseTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._specularTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        return false;
      };
      StandardMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (forceDisposeTextures) {
          (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
          (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
          (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();
          (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();
          (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();
          (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
      };
      StandardMaterial2.prototype.clone = function(name105) {
        var _this = this;
        var result = SerializationHelper.Clone(function() {
          return new StandardMaterial2(name105, _this.getScene());
        }, this);
        result.name = name105;
        result.id = name105;
        this.stencil.copyTo(result.stencil);
        return result;
      };
      StandardMaterial2.Parse = function(source, scene, rootUrl) {
        var material = SerializationHelper.Parse(function() {
          return new StandardMaterial2(source.name, scene);
        }, source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        return material;
      };
      Object.defineProperty(StandardMaterial2, "DiffuseTextureEnabled", {
        get: function() {
          return MaterialFlags.DiffuseTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.DiffuseTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "DetailTextureEnabled", {
        get: function() {
          return MaterialFlags.DetailTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.DetailTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "AmbientTextureEnabled", {
        get: function() {
          return MaterialFlags.AmbientTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.AmbientTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "OpacityTextureEnabled", {
        get: function() {
          return MaterialFlags.OpacityTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.OpacityTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "ReflectionTextureEnabled", {
        get: function() {
          return MaterialFlags.ReflectionTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.ReflectionTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "EmissiveTextureEnabled", {
        get: function() {
          return MaterialFlags.EmissiveTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.EmissiveTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "SpecularTextureEnabled", {
        get: function() {
          return MaterialFlags.SpecularTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.SpecularTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "BumpTextureEnabled", {
        get: function() {
          return MaterialFlags.BumpTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.BumpTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "LightmapTextureEnabled", {
        get: function() {
          return MaterialFlags.LightmapTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.LightmapTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "RefractionTextureEnabled", {
        get: function() {
          return MaterialFlags.RefractionTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.RefractionTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "ColorGradingTextureEnabled", {
        get: function() {
          return MaterialFlags.ColorGradingTextureEnabled;
        },
        set: function(value) {
          MaterialFlags.ColorGradingTextureEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StandardMaterial2, "FresnelEnabled", {
        get: function() {
          return MaterialFlags.FresnelEnabled;
        },
        set: function(value) {
          MaterialFlags.FresnelEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      __decorate([
        serializeAsTexture("diffuseTexture")
      ], StandardMaterial2.prototype, "_diffuseTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], StandardMaterial2.prototype, "diffuseTexture", void 0);
      __decorate([
        serializeAsTexture("ambientTexture")
      ], StandardMaterial2.prototype, "_ambientTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "ambientTexture", void 0);
      __decorate([
        serializeAsTexture("opacityTexture")
      ], StandardMaterial2.prototype, "_opacityTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], StandardMaterial2.prototype, "opacityTexture", void 0);
      __decorate([
        serializeAsTexture("reflectionTexture")
      ], StandardMaterial2.prototype, "_reflectionTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "reflectionTexture", void 0);
      __decorate([
        serializeAsTexture("emissiveTexture")
      ], StandardMaterial2.prototype, "_emissiveTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "emissiveTexture", void 0);
      __decorate([
        serializeAsTexture("specularTexture")
      ], StandardMaterial2.prototype, "_specularTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "specularTexture", void 0);
      __decorate([
        serializeAsTexture("bumpTexture")
      ], StandardMaterial2.prototype, "_bumpTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "bumpTexture", void 0);
      __decorate([
        serializeAsTexture("lightmapTexture")
      ], StandardMaterial2.prototype, "_lightmapTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "lightmapTexture", void 0);
      __decorate([
        serializeAsTexture("refractionTexture")
      ], StandardMaterial2.prototype, "_refractionTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "refractionTexture", void 0);
      __decorate([
        serializeAsColor3("ambient")
      ], StandardMaterial2.prototype, "ambientColor", void 0);
      __decorate([
        serializeAsColor3("diffuse")
      ], StandardMaterial2.prototype, "diffuseColor", void 0);
      __decorate([
        serializeAsColor3("specular")
      ], StandardMaterial2.prototype, "specularColor", void 0);
      __decorate([
        serializeAsColor3("emissive")
      ], StandardMaterial2.prototype, "emissiveColor", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "specularPower", void 0);
      __decorate([
        serialize("useAlphaFromDiffuseTexture")
      ], StandardMaterial2.prototype, "_useAlphaFromDiffuseTexture", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], StandardMaterial2.prototype, "useAlphaFromDiffuseTexture", void 0);
      __decorate([
        serialize("useEmissiveAsIllumination")
      ], StandardMaterial2.prototype, "_useEmissiveAsIllumination", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useEmissiveAsIllumination", void 0);
      __decorate([
        serialize("linkEmissiveWithDiffuse")
      ], StandardMaterial2.prototype, "_linkEmissiveWithDiffuse", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "linkEmissiveWithDiffuse", void 0);
      __decorate([
        serialize("useSpecularOverAlpha")
      ], StandardMaterial2.prototype, "_useSpecularOverAlpha", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useSpecularOverAlpha", void 0);
      __decorate([
        serialize("useReflectionOverAlpha")
      ], StandardMaterial2.prototype, "_useReflectionOverAlpha", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useReflectionOverAlpha", void 0);
      __decorate([
        serialize("disableLighting")
      ], StandardMaterial2.prototype, "_disableLighting", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsLightsDirty")
      ], StandardMaterial2.prototype, "disableLighting", void 0);
      __decorate([
        serialize("useObjectSpaceNormalMap")
      ], StandardMaterial2.prototype, "_useObjectSpaceNormalMap", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useObjectSpaceNormalMap", void 0);
      __decorate([
        serialize("useParallax")
      ], StandardMaterial2.prototype, "_useParallax", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useParallax", void 0);
      __decorate([
        serialize("useParallaxOcclusion")
      ], StandardMaterial2.prototype, "_useParallaxOcclusion", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useParallaxOcclusion", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "parallaxScaleBias", void 0);
      __decorate([
        serialize("roughness")
      ], StandardMaterial2.prototype, "_roughness", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "roughness", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "indexOfRefraction", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "invertRefractionY", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "alphaCutOff", void 0);
      __decorate([
        serialize("useLightmapAsShadowmap")
      ], StandardMaterial2.prototype, "_useLightmapAsShadowmap", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useLightmapAsShadowmap", void 0);
      __decorate([
        serializeAsFresnelParameters("diffuseFresnelParameters")
      ], StandardMaterial2.prototype, "_diffuseFresnelParameters", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelDirty")
      ], StandardMaterial2.prototype, "diffuseFresnelParameters", void 0);
      __decorate([
        serializeAsFresnelParameters("opacityFresnelParameters")
      ], StandardMaterial2.prototype, "_opacityFresnelParameters", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
      ], StandardMaterial2.prototype, "opacityFresnelParameters", void 0);
      __decorate([
        serializeAsFresnelParameters("reflectionFresnelParameters")
      ], StandardMaterial2.prototype, "_reflectionFresnelParameters", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelDirty")
      ], StandardMaterial2.prototype, "reflectionFresnelParameters", void 0);
      __decorate([
        serializeAsFresnelParameters("refractionFresnelParameters")
      ], StandardMaterial2.prototype, "_refractionFresnelParameters", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelDirty")
      ], StandardMaterial2.prototype, "refractionFresnelParameters", void 0);
      __decorate([
        serializeAsFresnelParameters("emissiveFresnelParameters")
      ], StandardMaterial2.prototype, "_emissiveFresnelParameters", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelDirty")
      ], StandardMaterial2.prototype, "emissiveFresnelParameters", void 0);
      __decorate([
        serialize("useReflectionFresnelFromSpecular")
      ], StandardMaterial2.prototype, "_useReflectionFresnelFromSpecular", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsFresnelDirty")
      ], StandardMaterial2.prototype, "useReflectionFresnelFromSpecular", void 0);
      __decorate([
        serialize("useGlossinessFromSpecularMapAlpha")
      ], StandardMaterial2.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
      __decorate([
        serialize("maxSimultaneousLights")
      ], StandardMaterial2.prototype, "_maxSimultaneousLights", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsLightsDirty")
      ], StandardMaterial2.prototype, "maxSimultaneousLights", void 0);
      __decorate([
        serialize("invertNormalMapX")
      ], StandardMaterial2.prototype, "_invertNormalMapX", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "invertNormalMapX", void 0);
      __decorate([
        serialize("invertNormalMapY")
      ], StandardMaterial2.prototype, "_invertNormalMapY", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "invertNormalMapY", void 0);
      __decorate([
        serialize("twoSidedLighting")
      ], StandardMaterial2.prototype, "_twoSidedLighting", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], StandardMaterial2.prototype, "twoSidedLighting", void 0);
      __decorate([
        serialize()
      ], StandardMaterial2.prototype, "useLogarithmicDepth", null);
      return StandardMaterial2;
    }(PushMaterial);
    RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
    Scene.DefaultMaterialFactory = function(scene) {
      return new StandardMaterial("default material", scene);
    };
  }
});

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters2, ShaderMaterial;
var init_shaderMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/shaderMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_buffer();
    init_texture();
    init_materialHelper();
    init_typeStore();
    init_math_color();
    init_effectFallbacks();
    init_webRequest();
    init_pushMaterial();
    init_engineStore();
    onCreatedEffectParameters2 = { effect: null, subMesh: null };
    ShaderMaterial = function(_super) {
      __extends(ShaderMaterial2, _super);
      function ShaderMaterial2(name105, scene, shaderPath, options, storeEffectOnSubMeshes) {
        if (options === void 0) {
          options = {};
        }
        if (storeEffectOnSubMeshes === void 0) {
          storeEffectOnSubMeshes = true;
        }
        var _this = _super.call(this, name105, scene, storeEffectOnSubMeshes) || this;
        _this._textures = {};
        _this._textureArrays = {};
        _this._externalTextures = {};
        _this._floats = {};
        _this._ints = {};
        _this._floatsArrays = {};
        _this._colors3 = {};
        _this._colors3Arrays = {};
        _this._colors4 = {};
        _this._colors4Arrays = {};
        _this._vectors2 = {};
        _this._vectors3 = {};
        _this._vectors4 = {};
        _this._matrices = {};
        _this._matrixArrays = {};
        _this._matrices3x3 = {};
        _this._matrices2x2 = {};
        _this._vectors2Arrays = {};
        _this._vectors3Arrays = {};
        _this._vectors4Arrays = {};
        _this._uniformBuffers = {};
        _this._textureSamplers = {};
        _this._storageBuffers = {};
        _this._cachedWorldViewMatrix = new Matrix();
        _this._cachedWorldViewProjectionMatrix = new Matrix();
        _this._multiview = false;
        _this._shaderPath = shaderPath;
        _this._options = __assign({ needAlphaBlending: false, needAlphaTesting: false, attributes: ["position", "normal", "uv"], uniforms: ["worldViewProjection"], uniformBuffers: [], samplers: [], externalTextures: [], samplerObjects: [], storageBuffers: [], defines: [], useClipPlane: false }, options);
        return _this;
      }
      Object.defineProperty(ShaderMaterial2.prototype, "shaderPath", {
        get: function() {
          return this._shaderPath;
        },
        set: function(shaderPath) {
          this._shaderPath = shaderPath;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ShaderMaterial2.prototype, "options", {
        get: function() {
          return this._options;
        },
        enumerable: false,
        configurable: true
      });
      ShaderMaterial2.prototype.getClassName = function() {
        return "ShaderMaterial";
      };
      ShaderMaterial2.prototype.needAlphaBlending = function() {
        return this.alpha < 1 || this._options.needAlphaBlending;
      };
      ShaderMaterial2.prototype.needAlphaTesting = function() {
        return this._options.needAlphaTesting;
      };
      ShaderMaterial2.prototype._checkUniform = function(uniformName) {
        if (this._options.uniforms.indexOf(uniformName) === -1) {
          this._options.uniforms.push(uniformName);
        }
      };
      ShaderMaterial2.prototype.setTexture = function(name105, texture) {
        if (this._options.samplers.indexOf(name105) === -1) {
          this._options.samplers.push(name105);
        }
        this._textures[name105] = texture;
        return this;
      };
      ShaderMaterial2.prototype.setTextureArray = function(name105, textures) {
        if (this._options.samplers.indexOf(name105) === -1) {
          this._options.samplers.push(name105);
        }
        this._checkUniform(name105);
        this._textureArrays[name105] = textures;
        return this;
      };
      ShaderMaterial2.prototype.setExternalTexture = function(name105, texture) {
        if (this._options.externalTextures.indexOf(name105) === -1) {
          this._options.externalTextures.push(name105);
        }
        this._externalTextures[name105] = texture;
        return this;
      };
      ShaderMaterial2.prototype.setFloat = function(name105, value) {
        this._checkUniform(name105);
        this._floats[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setInt = function(name105, value) {
        this._checkUniform(name105);
        this._ints[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setFloats = function(name105, value) {
        this._checkUniform(name105);
        this._floatsArrays[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setColor3 = function(name105, value) {
        this._checkUniform(name105);
        this._colors3[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setColor3Array = function(name105, value) {
        this._checkUniform(name105);
        this._colors3Arrays[name105] = value.reduce(function(arr, color) {
          color.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      };
      ShaderMaterial2.prototype.setColor4 = function(name105, value) {
        this._checkUniform(name105);
        this._colors4[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setColor4Array = function(name105, value) {
        this._checkUniform(name105);
        this._colors4Arrays[name105] = value.reduce(function(arr, color) {
          color.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      };
      ShaderMaterial2.prototype.setVector2 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors2[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setVector3 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors3[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setVector4 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors4[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setMatrix = function(name105, value) {
        this._checkUniform(name105);
        this._matrices[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setMatrices = function(name105, value) {
        this._checkUniform(name105);
        var float32Array = new Float32Array(value.length * 16);
        for (var index = 0; index < value.length; index++) {
          var matrix = value[index];
          matrix.copyToArray(float32Array, index * 16);
        }
        this._matrixArrays[name105] = float32Array;
        return this;
      };
      ShaderMaterial2.prototype.setMatrix3x3 = function(name105, value) {
        this._checkUniform(name105);
        this._matrices3x3[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setMatrix2x2 = function(name105, value) {
        this._checkUniform(name105);
        this._matrices2x2[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setArray2 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors2Arrays[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setArray3 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors3Arrays[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setArray4 = function(name105, value) {
        this._checkUniform(name105);
        this._vectors4Arrays[name105] = value;
        return this;
      };
      ShaderMaterial2.prototype.setUniformBuffer = function(name105, buffer) {
        if (this._options.uniformBuffers.indexOf(name105) === -1) {
          this._options.uniformBuffers.push(name105);
        }
        this._uniformBuffers[name105] = buffer;
        return this;
      };
      ShaderMaterial2.prototype.setTextureSampler = function(name105, sampler) {
        if (this._options.samplerObjects.indexOf(name105) === -1) {
          this._options.samplerObjects.push(name105);
        }
        this._textureSamplers[name105] = sampler;
        return this;
      };
      ShaderMaterial2.prototype.setStorageBuffer = function(name105, buffer) {
        if (this._options.storageBuffers.indexOf(name105) === -1) {
          this._options.storageBuffers.push(name105);
        }
        this._storageBuffers[name105] = buffer;
        return this;
      };
      ShaderMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
        return this.isReady(mesh, useInstances, subMesh);
      };
      ShaderMaterial2.prototype.isReady = function(mesh, useInstances, subMesh) {
        var _a, _b, _c, _d;
        var storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        if (this.isFrozen) {
          if (storeEffectOnSubMeshes) {
            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
              return true;
            }
          } else {
            var effect_1 = this._drawWrapper.effect;
            if (effect_1 && effect_1._wasPreviouslyReady && this._effectUsesInstances === useInstances) {
              return true;
            }
          }
        }
        var scene = this.getScene();
        var engine = scene.getEngine();
        var defines = [];
        var attribs = [];
        var fallbacks = new EffectFallbacks();
        var shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
          this._multiview = true;
          defines.push("#define MULTIVIEW");
          if (this._options.uniforms.indexOf("viewProjection") !== -1 && this._options.uniforms.indexOf("viewProjectionR") === -1) {
            this._options.uniforms.push("viewProjectionR");
          }
        }
        for (var index = 0; index < this._options.defines.length; index++) {
          var defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : "#define ".concat(this._options.defines[index]);
          defines.push(defineToAdd);
        }
        for (var index = 0; index < this._options.attributes.length; index++) {
          attribs.push(this._options.attributes[index]);
        }
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          attribs.push(VertexBuffer.ColorKind);
          defines.push("#define VERTEXCOLOR");
        }
        if (useInstances) {
          defines.push("#define INSTANCES");
          MaterialHelper.PushAttributesForInstances(attribs);
          if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
            if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
              attribs.push(VertexBuffer.ColorInstanceKind);
              defines.push("#define INSTANCESCOLOR");
            }
          }
        }
        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          var skeleton = mesh.skeleton;
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          fallbacks.addCPUSkinningFallback(0, mesh);
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
            if (this._options.uniforms.indexOf("boneTextureWidth") === -1) {
              this._options.uniforms.push("boneTextureWidth");
            }
            if (this._options.samplers.indexOf("boneSampler") === -1) {
              this._options.samplers.push("boneSampler");
            }
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            if (this._options.uniforms.indexOf("mBones") === -1) {
              this._options.uniforms.push("mBones");
            }
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        var numInfluencers = 0;
        var manager = mesh ? mesh.morphTargetManager : null;
        if (manager) {
          var uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
          var tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
          var normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
          numInfluencers = manager.numInfluencers;
          if (uv) {
            defines.push("#define MORPHTARGETS_UV");
          }
          if (tangent) {
            defines.push("#define MORPHTARGETS_TANGENT");
          }
          if (normal) {
            defines.push("#define MORPHTARGETS_NORMAL");
          }
          if (numInfluencers > 0) {
            defines.push("#define MORPHTARGETS");
          }
          if (manager.isUsingTextureForTargets) {
            defines.push("#define MORPHTARGETS_TEXTURE");
            if (this._options.uniforms.indexOf("morphTargetTextureIndices") === -1) {
              this._options.uniforms.push("morphTargetTextureIndices");
            }
            if (this._options.samplers.indexOf("morphTargets") === -1) {
              this._options.samplers.push("morphTargets");
            }
          }
          defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
          for (var index = 0; index < numInfluencers; index++) {
            attribs.push(VertexBuffer.PositionKind + index);
            if (normal) {
              attribs.push(VertexBuffer.NormalKind + index);
            }
            if (tangent) {
              attribs.push(VertexBuffer.TangentKind + index);
            }
            if (uv) {
              attribs.push(VertexBuffer.UVKind + "_" + index);
            }
          }
          if (numInfluencers > 0) {
            uniforms = uniforms.slice();
            uniforms.push("morphTargetInfluences");
            uniforms.push("morphTargetTextureInfo");
            uniforms.push("morphTargetTextureIndices");
          }
        } else {
          defines.push("#define NUM_MORPH_INFLUENCERS 0");
        }
        if (mesh) {
          var bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
            if (this._options.uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
              this._options.uniforms.push("bakedVertexAnimationSettings");
            }
            if (this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
              this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted");
            }
            if (this._options.uniforms.indexOf("bakedVertexAnimationTime") === -1) {
              this._options.uniforms.push("bakedVertexAnimationTime");
            }
            if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
              this._options.samplers.push("bakedVertexAnimationTexture");
            }
          }
          MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        }
        for (var name_1 in this._textures) {
          if (!this._textures[name_1].isReady()) {
            return false;
          }
        }
        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
          defines.push("#define ALPHATEST");
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE");
          if (uniforms.indexOf("vClipPlane") === -1) {
            uniforms.push("vClipPlane");
          }
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane2 || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE2");
          if (uniforms.indexOf("vClipPlane2") === -1) {
            uniforms.push("vClipPlane2");
          }
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane3 || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE3");
          if (uniforms.indexOf("vClipPlane3") === -1) {
            uniforms.push("vClipPlane3");
          }
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane4 || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE4");
          if (uniforms.indexOf("vClipPlane4") === -1) {
            uniforms.push("vClipPlane4");
          }
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane5 || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE5");
          if (uniforms.indexOf("vClipPlane5") === -1) {
            uniforms.push("vClipPlane5");
          }
        }
        if (this._options.useClipPlane === null && !!scene.clipPlane6 || this._options.useClipPlane) {
          defines.push("#define CLIPPLANE6");
          if (uniforms.indexOf("vClipPlane6") === -1) {
            uniforms.push("vClipPlane6");
          }
        }
        if (this.customShaderNameResolve) {
          uniforms = uniforms.slice();
          uniformBuffers = uniformBuffers.slice();
          samplers = samplers.slice();
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
        }
        var drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;
        var previousEffect = (_a = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _a !== void 0 ? _a : null;
        var previousDefines = (_b = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.defines) !== null && _b !== void 0 ? _b : null;
        var join = defines.join("\n");
        var effect = previousEffect;
        if (previousDefines !== join) {
          effect = engine.createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
            shaderLanguage: this._options.shaderLanguage
          }, engine);
          if (storeEffectOnSubMeshes) {
            subMesh.setEffect(effect, join, this._materialContext);
          } else if (drawWrapper) {
            drawWrapper.setEffect(effect, join);
          }
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters2.effect = effect;
            onCreatedEffectParameters2.subMesh = (_c = subMesh !== null && subMesh !== void 0 ? subMesh : mesh === null || mesh === void 0 ? void 0 : mesh.subMeshes[0]) !== null && _c !== void 0 ? _c : null;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
          }
        }
        this._effectUsesInstances = !!useInstances;
        if ((_d = !(effect === null || effect === void 0 ? void 0 : effect.isReady())) !== null && _d !== void 0 ? _d : true) {
          return false;
        }
        if (previousEffect !== effect) {
          scene.resetCachedMaterial();
        }
        effect._wasPreviouslyReady = true;
        return true;
      };
      ShaderMaterial2.prototype.bindOnlyWorldMatrix = function(world, effectOverride) {
        var scene = this.getScene();
        var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this.getEffect();
        if (!effect) {
          return;
        }
        if (this._options.uniforms.indexOf("world") !== -1) {
          effect.setMatrix("world", world);
        }
        if (this._options.uniforms.indexOf("worldView") !== -1) {
          world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
          effect.setMatrix("worldView", this._cachedWorldViewMatrix);
        }
        if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
          world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
          effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
        }
      };
      ShaderMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
        var _a;
        this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) === null || _a === void 0 ? void 0 : _a.effect, subMesh);
      };
      ShaderMaterial2.prototype.bind = function(world, mesh, effectOverride, subMesh) {
        var _a;
        var storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : storeEffectOnSubMeshes ? subMesh.effect : this.getEffect();
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        this.bindOnlyWorldMatrix(world, effectOverride);
        var uniformBuffers = this._options.uniformBuffers;
        var useSceneUBO = false;
        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {
          for (var i = 0; i < uniformBuffers.length; ++i) {
            var bufferName = uniformBuffers[i];
            switch (bufferName) {
              case "Mesh":
                if (mesh) {
                  mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
                  mesh.transferToEffect(world);
                }
                break;
              case "Scene":
                MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
                this.getScene().finalizeSceneUbo();
                useSceneUBO = true;
                break;
            }
          }
        }
        var mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;
        if (effect && mustRebind) {
          if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
            effect.setMatrix("view", this.getScene().getViewMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
            effect.setMatrix("projection", this.getScene().getProjectionMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
            effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
            if (this._multiview) {
              effect.setMatrix("viewProjectionR", this.getScene()._transformMatrixR);
            }
          }
          if (this.getScene().activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
            effect.setVector3("cameraPosition", this.getScene().activeCamera.globalPosition);
          }
          MaterialHelper.BindBonesParameters(mesh, effect);
          MaterialHelper.BindClipPlane(effect, this.getScene());
          var name_2;
          for (name_2 in this._textures) {
            effect.setTexture(name_2, this._textures[name_2]);
          }
          for (name_2 in this._textureArrays) {
            effect.setTextureArray(name_2, this._textureArrays[name_2]);
          }
          for (name_2 in this._externalTextures) {
            effect.setExternalTexture(name_2, this._externalTextures[name_2]);
          }
          for (name_2 in this._ints) {
            effect.setInt(name_2, this._ints[name_2]);
          }
          for (name_2 in this._floats) {
            effect.setFloat(name_2, this._floats[name_2]);
          }
          for (name_2 in this._floatsArrays) {
            effect.setArray(name_2, this._floatsArrays[name_2]);
          }
          for (name_2 in this._colors3) {
            effect.setColor3(name_2, this._colors3[name_2]);
          }
          for (name_2 in this._colors3Arrays) {
            effect.setArray3(name_2, this._colors3Arrays[name_2]);
          }
          for (name_2 in this._colors4) {
            var color = this._colors4[name_2];
            effect.setFloat4(name_2, color.r, color.g, color.b, color.a);
          }
          for (name_2 in this._colors4Arrays) {
            effect.setArray4(name_2, this._colors4Arrays[name_2]);
          }
          for (name_2 in this._vectors2) {
            effect.setVector2(name_2, this._vectors2[name_2]);
          }
          for (name_2 in this._vectors3) {
            effect.setVector3(name_2, this._vectors3[name_2]);
          }
          for (name_2 in this._vectors4) {
            effect.setVector4(name_2, this._vectors4[name_2]);
          }
          for (name_2 in this._matrices) {
            effect.setMatrix(name_2, this._matrices[name_2]);
          }
          for (name_2 in this._matrixArrays) {
            effect.setMatrices(name_2, this._matrixArrays[name_2]);
          }
          for (name_2 in this._matrices3x3) {
            effect.setMatrix3x3(name_2, this._matrices3x3[name_2]);
          }
          for (name_2 in this._matrices2x2) {
            effect.setMatrix2x2(name_2, this._matrices2x2[name_2]);
          }
          for (name_2 in this._vectors2Arrays) {
            effect.setArray2(name_2, this._vectors2Arrays[name_2]);
          }
          for (name_2 in this._vectors3Arrays) {
            effect.setArray3(name_2, this._vectors3Arrays[name_2]);
          }
          for (name_2 in this._vectors4Arrays) {
            effect.setArray4(name_2, this._vectors4Arrays[name_2]);
          }
          for (name_2 in this._uniformBuffers) {
            var buffer = this._uniformBuffers[name_2].getBuffer();
            if (buffer) {
              effect.bindUniformBuffer(buffer, name_2);
            }
          }
          for (name_2 in this._textureSamplers) {
            effect.setTextureSampler(name_2, this._textureSamplers[name_2]);
          }
          for (name_2 in this._storageBuffers) {
            effect.setStorageBuffer(name_2, this._storageBuffers[name_2]);
          }
        }
        if (effect && mesh && (mustRebind || !this.isFrozen)) {
          var manager = mesh.morphTargetManager;
          if (manager && manager.numInfluencers > 0) {
            MaterialHelper.BindMorphTargetParameters(mesh, effect);
          }
          var bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, this._effectUsesInstances);
          }
        }
        this._afterBind(mesh, effect);
      };
      ShaderMaterial2.prototype.getActiveTextures = function() {
        var activeTextures = _super.prototype.getActiveTextures.call(this);
        for (var name_3 in this._textures) {
          activeTextures.push(this._textures[name_3]);
        }
        for (var name_4 in this._textureArrays) {
          var array = this._textureArrays[name_4];
          for (var index = 0; index < array.length; index++) {
            activeTextures.push(array[index]);
          }
        }
        return activeTextures;
      };
      ShaderMaterial2.prototype.hasTexture = function(texture) {
        if (_super.prototype.hasTexture.call(this, texture)) {
          return true;
        }
        for (var name_5 in this._textures) {
          if (this._textures[name_5] === texture) {
            return true;
          }
        }
        for (var name_6 in this._textureArrays) {
          var array = this._textureArrays[name_6];
          for (var index = 0; index < array.length; index++) {
            if (array[index] === texture) {
              return true;
            }
          }
        }
        return false;
      };
      ShaderMaterial2.prototype.clone = function(name105) {
        var _this = this;
        var result = SerializationHelper.Clone(function() {
          return new ShaderMaterial2(name105, _this.getScene(), _this._shaderPath, _this._options, _this._storeEffectOnSubMeshes);
        }, this);
        result.name = name105;
        result.id = name105;
        if (typeof result._shaderPath === "object") {
          result._shaderPath = __assign({}, result._shaderPath);
        }
        this._options = __assign({}, this._options);
        Object.keys(this._options).forEach(function(propName) {
          var propValue = _this._options[propName];
          if (Array.isArray(propValue)) {
            _this._options[propName] = propValue.slice(0);
          }
        });
        this.stencil.copyTo(result.stencil);
        for (var key in this._textures) {
          result.setTexture(key, this._textures[key]);
        }
        for (var key in this._textureArrays) {
          result.setTextureArray(key, this._textureArrays[key]);
        }
        for (var key in this._externalTextures) {
          result.setExternalTexture(key, this._externalTextures[key]);
        }
        for (var key in this._ints) {
          result.setInt(key, this._ints[key]);
        }
        for (var key in this._floats) {
          result.setFloat(key, this._floats[key]);
        }
        for (var key in this._floatsArrays) {
          result.setFloats(key, this._floatsArrays[key]);
        }
        for (var key in this._colors3) {
          result.setColor3(key, this._colors3[key]);
        }
        for (var key in this._colors3Arrays) {
          result._colors3Arrays[key] = this._colors3Arrays[key];
        }
        for (var key in this._colors4) {
          result.setColor4(key, this._colors4[key]);
        }
        for (var key in this._colors4Arrays) {
          result._colors4Arrays[key] = this._colors4Arrays[key];
        }
        for (var key in this._vectors2) {
          result.setVector2(key, this._vectors2[key]);
        }
        for (var key in this._vectors3) {
          result.setVector3(key, this._vectors3[key]);
        }
        for (var key in this._vectors4) {
          result.setVector4(key, this._vectors4[key]);
        }
        for (var key in this._matrices) {
          result.setMatrix(key, this._matrices[key]);
        }
        for (var key in this._matrixArrays) {
          result._matrixArrays[key] = this._matrixArrays[key].slice();
        }
        for (var key in this._matrices3x3) {
          result.setMatrix3x3(key, this._matrices3x3[key]);
        }
        for (var key in this._matrices2x2) {
          result.setMatrix2x2(key, this._matrices2x2[key]);
        }
        for (var key in this._vectors2Arrays) {
          result.setArray2(key, this._vectors2Arrays[key]);
        }
        for (var key in this._vectors3Arrays) {
          result.setArray3(key, this._vectors3Arrays[key]);
        }
        for (var key in this._vectors4Arrays) {
          result.setArray4(key, this._vectors4Arrays[key]);
        }
        for (var key in this._uniformBuffers) {
          result.setUniformBuffer(key, this._uniformBuffers[key]);
        }
        for (var key in this._textureSamplers) {
          result.setTextureSampler(key, this._textureSamplers[key]);
        }
        for (var key in this._storageBuffers) {
          result.setStorageBuffer(key, this._storageBuffers[key]);
        }
        return result;
      };
      ShaderMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        if (forceDisposeTextures) {
          var name_7;
          for (name_7 in this._textures) {
            this._textures[name_7].dispose();
          }
          for (name_7 in this._textureArrays) {
            var array = this._textureArrays[name_7];
            for (var index = 0; index < array.length; index++) {
              array[index].dispose();
            }
          }
        }
        this._textures = {};
        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
      };
      ShaderMaterial2.prototype.serialize = function() {
        var serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.ShaderMaterial";
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.options = this._options;
        serializationObject.shaderPath = this._shaderPath;
        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
        var name105;
        serializationObject.stencil = this.stencil.serialize();
        serializationObject.textures = {};
        for (name105 in this._textures) {
          serializationObject.textures[name105] = this._textures[name105].serialize();
        }
        serializationObject.textureArrays = {};
        for (name105 in this._textureArrays) {
          serializationObject.textureArrays[name105] = [];
          var array = this._textureArrays[name105];
          for (var index = 0; index < array.length; index++) {
            serializationObject.textureArrays[name105].push(array[index].serialize());
          }
        }
        serializationObject.ints = {};
        for (name105 in this._ints) {
          serializationObject.ints[name105] = this._ints[name105];
        }
        serializationObject.floats = {};
        for (name105 in this._floats) {
          serializationObject.floats[name105] = this._floats[name105];
        }
        serializationObject.FloatArrays = {};
        for (name105 in this._floatsArrays) {
          serializationObject.FloatArrays[name105] = this._floatsArrays[name105];
        }
        serializationObject.colors3 = {};
        for (name105 in this._colors3) {
          serializationObject.colors3[name105] = this._colors3[name105].asArray();
        }
        serializationObject.colors3Arrays = {};
        for (name105 in this._colors3Arrays) {
          serializationObject.colors3Arrays[name105] = this._colors3Arrays[name105];
        }
        serializationObject.colors4 = {};
        for (name105 in this._colors4) {
          serializationObject.colors4[name105] = this._colors4[name105].asArray();
        }
        serializationObject.colors4Arrays = {};
        for (name105 in this._colors4Arrays) {
          serializationObject.colors4Arrays[name105] = this._colors4Arrays[name105];
        }
        serializationObject.vectors2 = {};
        for (name105 in this._vectors2) {
          serializationObject.vectors2[name105] = this._vectors2[name105].asArray();
        }
        serializationObject.vectors3 = {};
        for (name105 in this._vectors3) {
          serializationObject.vectors3[name105] = this._vectors3[name105].asArray();
        }
        serializationObject.vectors4 = {};
        for (name105 in this._vectors4) {
          serializationObject.vectors4[name105] = this._vectors4[name105].asArray();
        }
        serializationObject.matrices = {};
        for (name105 in this._matrices) {
          serializationObject.matrices[name105] = this._matrices[name105].asArray();
        }
        serializationObject.matrixArray = {};
        for (name105 in this._matrixArrays) {
          serializationObject.matrixArray[name105] = this._matrixArrays[name105];
        }
        serializationObject.matrices3x3 = {};
        for (name105 in this._matrices3x3) {
          serializationObject.matrices3x3[name105] = this._matrices3x3[name105];
        }
        serializationObject.matrices2x2 = {};
        for (name105 in this._matrices2x2) {
          serializationObject.matrices2x2[name105] = this._matrices2x2[name105];
        }
        serializationObject.vectors2Arrays = {};
        for (name105 in this._vectors2Arrays) {
          serializationObject.vectors2Arrays[name105] = this._vectors2Arrays[name105];
        }
        serializationObject.vectors3Arrays = {};
        for (name105 in this._vectors3Arrays) {
          serializationObject.vectors3Arrays[name105] = this._vectors3Arrays[name105];
        }
        serializationObject.vectors4Arrays = {};
        for (name105 in this._vectors4Arrays) {
          serializationObject.vectors4Arrays[name105] = this._vectors4Arrays[name105];
        }
        return serializationObject;
      };
      ShaderMaterial2.Parse = function(source, scene, rootUrl) {
        var material = SerializationHelper.Parse(function() {
          return new ShaderMaterial2(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes);
        }, source, scene, rootUrl);
        var name105;
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        for (name105 in source.textures) {
          material.setTexture(name105, Texture.Parse(source.textures[name105], scene, rootUrl));
        }
        for (name105 in source.textureArrays) {
          var array = source.textureArrays[name105];
          var textureArray = new Array();
          for (var index = 0; index < array.length; index++) {
            textureArray.push(Texture.Parse(array[index], scene, rootUrl));
          }
          material.setTextureArray(name105, textureArray);
        }
        for (name105 in source.ints) {
          material.setInt(name105, source.ints[name105]);
        }
        for (name105 in source.floats) {
          material.setFloat(name105, source.floats[name105]);
        }
        for (name105 in source.floatsArrays) {
          material.setFloats(name105, source.floatsArrays[name105]);
        }
        for (name105 in source.colors3) {
          material.setColor3(name105, Color3.FromArray(source.colors3[name105]));
        }
        for (name105 in source.colors3Arrays) {
          var colors = source.colors3Arrays[name105].reduce(function(arr, num, i) {
            if (i % 3 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map(function(color) {
            return Color3.FromArray(color);
          });
          material.setColor3Array(name105, colors);
        }
        for (name105 in source.colors4) {
          material.setColor4(name105, Color4.FromArray(source.colors4[name105]));
        }
        for (name105 in source.colors4Arrays) {
          var colors = source.colors4Arrays[name105].reduce(function(arr, num, i) {
            if (i % 4 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map(function(color) {
            return Color4.FromArray(color);
          });
          material.setColor4Array(name105, colors);
        }
        for (name105 in source.vectors2) {
          material.setVector2(name105, Vector2.FromArray(source.vectors2[name105]));
        }
        for (name105 in source.vectors3) {
          material.setVector3(name105, Vector3.FromArray(source.vectors3[name105]));
        }
        for (name105 in source.vectors4) {
          material.setVector4(name105, Vector4.FromArray(source.vectors4[name105]));
        }
        for (name105 in source.matrices) {
          material.setMatrix(name105, Matrix.FromArray(source.matrices[name105]));
        }
        for (name105 in source.matrixArray) {
          material._matrixArrays[name105] = new Float32Array(source.matrixArray[name105]);
        }
        for (name105 in source.matrices3x3) {
          material.setMatrix3x3(name105, source.matrices3x3[name105]);
        }
        for (name105 in source.matrices2x2) {
          material.setMatrix2x2(name105, source.matrices2x2[name105]);
        }
        for (name105 in source.vectors2Arrays) {
          material.setArray2(name105, source.vectors2Arrays[name105]);
        }
        for (name105 in source.vectors3Arrays) {
          material.setArray3(name105, source.vectors3Arrays[name105]);
        }
        for (name105 in source.vectors4Arrays) {
          material.setArray4(name105, source.vectors4Arrays[name105]);
        }
        return material;
      };
      ShaderMaterial2.ParseFromFileAsync = function(name105, url, scene, rootUrl) {
        var _this = this;
        if (rootUrl === void 0) {
          rootUrl = "";
        }
        return new Promise(function(resolve, reject) {
          var request = new WebRequest();
          request.addEventListener("readystatechange", function() {
            if (request.readyState == 4) {
              if (request.status == 200) {
                var serializationObject = JSON.parse(request.responseText);
                var output = _this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                if (name105) {
                  output.name = name105;
                }
                resolve(output);
              } else {
                reject("Unable to load the ShaderMaterial");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      };
      ShaderMaterial2.CreateFromSnippetAsync = function(snippetId, scene, rootUrl) {
        var _this = this;
        if (rootUrl === void 0) {
          rootUrl = "";
        }
        return new Promise(function(resolve, reject) {
          var request = new WebRequest();
          request.addEventListener("readystatechange", function() {
            if (request.readyState == 4) {
              if (request.status == 200) {
                var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                var serializationObject = JSON.parse(snippet.shaderMaterial);
                var output = _this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                output.snippetId = snippetId;
                resolve(output);
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", _this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      };
      ShaderMaterial2.SnippetUrl = "https://snippet.babylonjs.com";
      return ShaderMaterial2;
    }(PushMaterial);
    RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);
  }
});

// node_modules/@babylonjs/core/Engines/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/@babylonjs/core/Engines/constants.js"() {
    Constants = function() {
      function Constants2() {
      }
      Constants2.ALPHA_DISABLE = 0;
      Constants2.ALPHA_ADD = 1;
      Constants2.ALPHA_COMBINE = 2;
      Constants2.ALPHA_SUBTRACT = 3;
      Constants2.ALPHA_MULTIPLY = 4;
      Constants2.ALPHA_MAXIMIZED = 5;
      Constants2.ALPHA_ONEONE = 6;
      Constants2.ALPHA_PREMULTIPLIED = 7;
      Constants2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
      Constants2.ALPHA_INTERPOLATE = 9;
      Constants2.ALPHA_SCREENMODE = 10;
      Constants2.ALPHA_ONEONE_ONEONE = 11;
      Constants2.ALPHA_ALPHATOCOLOR = 12;
      Constants2.ALPHA_REVERSEONEMINUS = 13;
      Constants2.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;
      Constants2.ALPHA_ONEONE_ONEZERO = 15;
      Constants2.ALPHA_EXCLUSION = 16;
      Constants2.ALPHA_LAYER_ACCUMULATE = 17;
      Constants2.ALPHA_EQUATION_ADD = 0;
      Constants2.ALPHA_EQUATION_SUBSTRACT = 1;
      Constants2.ALPHA_EQUATION_REVERSE_SUBTRACT = 2;
      Constants2.ALPHA_EQUATION_MAX = 3;
      Constants2.ALPHA_EQUATION_MIN = 4;
      Constants2.ALPHA_EQUATION_DARKEN = 5;
      Constants2.DELAYLOADSTATE_NONE = 0;
      Constants2.DELAYLOADSTATE_LOADED = 1;
      Constants2.DELAYLOADSTATE_LOADING = 2;
      Constants2.DELAYLOADSTATE_NOTLOADED = 4;
      Constants2.NEVER = 512;
      Constants2.ALWAYS = 519;
      Constants2.LESS = 513;
      Constants2.EQUAL = 514;
      Constants2.LEQUAL = 515;
      Constants2.GREATER = 516;
      Constants2.GEQUAL = 518;
      Constants2.NOTEQUAL = 517;
      Constants2.KEEP = 7680;
      Constants2.ZERO = 0;
      Constants2.REPLACE = 7681;
      Constants2.INCR = 7682;
      Constants2.DECR = 7683;
      Constants2.INVERT = 5386;
      Constants2.INCR_WRAP = 34055;
      Constants2.DECR_WRAP = 34056;
      Constants2.TEXTURE_CLAMP_ADDRESSMODE = 0;
      Constants2.TEXTURE_WRAP_ADDRESSMODE = 1;
      Constants2.TEXTURE_MIRROR_ADDRESSMODE = 2;
      Constants2.TEXTURE_CREATIONFLAG_STORAGE = 1;
      Constants2.TEXTUREFORMAT_ALPHA = 0;
      Constants2.TEXTUREFORMAT_LUMINANCE = 1;
      Constants2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
      Constants2.TEXTUREFORMAT_RGB = 4;
      Constants2.TEXTUREFORMAT_RGBA = 5;
      Constants2.TEXTUREFORMAT_RED = 6;
      Constants2.TEXTUREFORMAT_R = 6;
      Constants2.TEXTUREFORMAT_RG = 7;
      Constants2.TEXTUREFORMAT_RED_INTEGER = 8;
      Constants2.TEXTUREFORMAT_R_INTEGER = 8;
      Constants2.TEXTUREFORMAT_RG_INTEGER = 9;
      Constants2.TEXTUREFORMAT_RGB_INTEGER = 10;
      Constants2.TEXTUREFORMAT_RGBA_INTEGER = 11;
      Constants2.TEXTUREFORMAT_BGRA = 12;
      Constants2.TEXTUREFORMAT_DEPTH24_STENCIL8 = 13;
      Constants2.TEXTUREFORMAT_DEPTH32_FLOAT = 14;
      Constants2.TEXTUREFORMAT_DEPTH16 = 15;
      Constants2.TEXTUREFORMAT_DEPTH24 = 16;
      Constants2.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17;
      Constants2.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
      Constants2.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496;
      Constants2.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
      Constants2.TEXTURETYPE_UNSIGNED_BYTE = 0;
      Constants2.TEXTURETYPE_UNSIGNED_INT = 0;
      Constants2.TEXTURETYPE_FLOAT = 1;
      Constants2.TEXTURETYPE_HALF_FLOAT = 2;
      Constants2.TEXTURETYPE_BYTE = 3;
      Constants2.TEXTURETYPE_SHORT = 4;
      Constants2.TEXTURETYPE_UNSIGNED_SHORT = 5;
      Constants2.TEXTURETYPE_INT = 6;
      Constants2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
      Constants2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
      Constants2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
      Constants2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
      Constants2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
      Constants2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
      Constants2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
      Constants2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
      Constants2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
      Constants2.TEXTURETYPE_UNDEFINED = 16;
      Constants2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
      Constants2.TEXTURE_NEAREST_NEAREST = 1;
      Constants2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
      Constants2.TEXTURE_LINEAR_LINEAR = 2;
      Constants2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
      Constants2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
      Constants2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
      Constants2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
      Constants2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
      Constants2.TEXTURE_NEAREST_LINEAR = 7;
      Constants2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
      Constants2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
      Constants2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
      Constants2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
      Constants2.TEXTURE_LINEAR_NEAREST = 12;
      Constants2.TEXTURE_EXPLICIT_MODE = 0;
      Constants2.TEXTURE_SPHERICAL_MODE = 1;
      Constants2.TEXTURE_PLANAR_MODE = 2;
      Constants2.TEXTURE_CUBIC_MODE = 3;
      Constants2.TEXTURE_PROJECTION_MODE = 4;
      Constants2.TEXTURE_SKYBOX_MODE = 5;
      Constants2.TEXTURE_INVCUBIC_MODE = 6;
      Constants2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
      Constants2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
      Constants2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
      Constants2.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;
      Constants2.TEXTURE_FILTERING_QUALITY_HIGH = 64;
      Constants2.TEXTURE_FILTERING_QUALITY_MEDIUM = 16;
      Constants2.TEXTURE_FILTERING_QUALITY_LOW = 8;
      Constants2.SCALEMODE_FLOOR = 1;
      Constants2.SCALEMODE_NEAREST = 2;
      Constants2.SCALEMODE_CEILING = 3;
      Constants2.MATERIAL_TextureDirtyFlag = 1;
      Constants2.MATERIAL_LightDirtyFlag = 2;
      Constants2.MATERIAL_FresnelDirtyFlag = 4;
      Constants2.MATERIAL_AttributesDirtyFlag = 8;
      Constants2.MATERIAL_MiscDirtyFlag = 16;
      Constants2.MATERIAL_PrePassDirtyFlag = 32;
      Constants2.MATERIAL_AllDirtyFlag = 63;
      Constants2.MATERIAL_TriangleFillMode = 0;
      Constants2.MATERIAL_WireFrameFillMode = 1;
      Constants2.MATERIAL_PointFillMode = 2;
      Constants2.MATERIAL_PointListDrawMode = 3;
      Constants2.MATERIAL_LineListDrawMode = 4;
      Constants2.MATERIAL_LineLoopDrawMode = 5;
      Constants2.MATERIAL_LineStripDrawMode = 6;
      Constants2.MATERIAL_TriangleStripDrawMode = 7;
      Constants2.MATERIAL_TriangleFanDrawMode = 8;
      Constants2.MATERIAL_ClockWiseSideOrientation = 0;
      Constants2.MATERIAL_CounterClockWiseSideOrientation = 1;
      Constants2.ACTION_NothingTrigger = 0;
      Constants2.ACTION_OnPickTrigger = 1;
      Constants2.ACTION_OnLeftPickTrigger = 2;
      Constants2.ACTION_OnRightPickTrigger = 3;
      Constants2.ACTION_OnCenterPickTrigger = 4;
      Constants2.ACTION_OnPickDownTrigger = 5;
      Constants2.ACTION_OnDoublePickTrigger = 6;
      Constants2.ACTION_OnPickUpTrigger = 7;
      Constants2.ACTION_OnPickOutTrigger = 16;
      Constants2.ACTION_OnLongPressTrigger = 8;
      Constants2.ACTION_OnPointerOverTrigger = 9;
      Constants2.ACTION_OnPointerOutTrigger = 10;
      Constants2.ACTION_OnEveryFrameTrigger = 11;
      Constants2.ACTION_OnIntersectionEnterTrigger = 12;
      Constants2.ACTION_OnIntersectionExitTrigger = 13;
      Constants2.ACTION_OnKeyDownTrigger = 14;
      Constants2.ACTION_OnKeyUpTrigger = 15;
      Constants2.PARTICLES_BILLBOARDMODE_Y = 2;
      Constants2.PARTICLES_BILLBOARDMODE_ALL = 7;
      Constants2.PARTICLES_BILLBOARDMODE_STRETCHED = 8;
      Constants2.MESHES_CULLINGSTRATEGY_STANDARD = 0;
      Constants2.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
      Constants2.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
      Constants2.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
      Constants2.SCENELOADER_NO_LOGGING = 0;
      Constants2.SCENELOADER_MINIMAL_LOGGING = 1;
      Constants2.SCENELOADER_SUMMARY_LOGGING = 2;
      Constants2.SCENELOADER_DETAILED_LOGGING = 3;
      Constants2.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;
      Constants2.PREPASS_POSITION_TEXTURE_TYPE = 1;
      Constants2.PREPASS_VELOCITY_TEXTURE_TYPE = 2;
      Constants2.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;
      Constants2.PREPASS_COLOR_TEXTURE_TYPE = 4;
      Constants2.PREPASS_DEPTH_TEXTURE_TYPE = 5;
      Constants2.PREPASS_NORMAL_TEXTURE_TYPE = 6;
      Constants2.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7;
      Constants2.BUFFER_CREATIONFLAG_READ = 1;
      Constants2.BUFFER_CREATIONFLAG_WRITE = 2;
      Constants2.BUFFER_CREATIONFLAG_READWRITE = 3;
      Constants2.BUFFER_CREATIONFLAG_UNIFORM = 4;
      Constants2.BUFFER_CREATIONFLAG_VERTEX = 8;
      Constants2.BUFFER_CREATIONFLAG_INDEX = 16;
      Constants2.BUFFER_CREATIONFLAG_STORAGE = 32;
      Constants2.RENDERPASS_MAIN = 0;
      Constants2.INPUT_ALT_KEY = 18;
      Constants2.INPUT_CTRL_KEY = 17;
      Constants2.INPUT_META_KEY1 = 91;
      Constants2.INPUT_META_KEY2 = 92;
      Constants2.INPUT_META_KEY3 = 93;
      Constants2.INPUT_SHIFT_KEY = 16;
      Constants2.SNAPSHOTRENDERING_STANDARD = 0;
      Constants2.SNAPSHOTRENDERING_FAST = 1;
      Constants2.PERSPECTIVE_CAMERA = 0;
      Constants2.ORTHOGRAPHIC_CAMERA = 1;
      Constants2.FOVMODE_VERTICAL_FIXED = 0;
      Constants2.FOVMODE_HORIZONTAL_FIXED = 1;
      Constants2.RIG_MODE_NONE = 0;
      Constants2.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
      Constants2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
      Constants2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
      Constants2.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
      Constants2.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
      Constants2.RIG_MODE_VR = 20;
      Constants2.RIG_MODE_WEBVR = 21;
      Constants2.RIG_MODE_CUSTOM = 22;
      Constants2.MAX_SUPPORTED_UV_SETS = 6;
      Constants2.GL_ALPHA_EQUATION_ADD = 32774;
      Constants2.GL_ALPHA_EQUATION_MIN = 32775;
      Constants2.GL_ALPHA_EQUATION_MAX = 32776;
      Constants2.GL_ALPHA_EQUATION_SUBTRACT = 32778;
      Constants2.GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 32779;
      Constants2.GL_ALPHA_FUNCTION_SRC = 768;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 769;
      Constants2.GL_ALPHA_FUNCTION_SRC_ALPHA = 770;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 771;
      Constants2.GL_ALPHA_FUNCTION_DST_ALPHA = 772;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 773;
      Constants2.GL_ALPHA_FUNCTION_DST_COLOR = 774;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 775;
      Constants2.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 776;
      Constants2.GL_ALPHA_FUNCTION_CONSTANT_COLOR = 32769;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 32770;
      Constants2.GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 32771;
      Constants2.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 32772;
      return Constants2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.vertexFormat.js
var PositionNormalVertex, PositionNormalTextureVertex;
var init_math_vertexFormat = __esm({
  "node_modules/@babylonjs/core/Maths/math.vertexFormat.js"() {
    init_math_vector();
    PositionNormalVertex = function() {
      function PositionNormalVertex2(position, normal) {
        if (position === void 0) {
          position = Vector3.Zero();
        }
        if (normal === void 0) {
          normal = Vector3.Up();
        }
        this.position = position;
        this.normal = normal;
      }
      PositionNormalVertex2.prototype.clone = function() {
        return new PositionNormalVertex2(this.position.clone(), this.normal.clone());
      };
      return PositionNormalVertex2;
    }();
    PositionNormalTextureVertex = function() {
      function PositionNormalTextureVertex2(position, normal, uv) {
        if (position === void 0) {
          position = Vector3.Zero();
        }
        if (normal === void 0) {
          normal = Vector3.Up();
        }
        if (uv === void 0) {
          uv = Vector2.Zero();
        }
        this.position = position;
        this.normal = normal;
        this.uv = uv;
      }
      PositionNormalTextureVertex2.prototype.clone = function() {
        return new PositionNormalTextureVertex2(this.position.clone(), this.normal.clone(), this.uv.clone());
      };
      return PositionNormalTextureVertex2;
    }();
  }
});

// node_modules/@babylonjs/core/Maths/math.js
var init_math = __esm({
  "node_modules/@babylonjs/core/Maths/math.js"() {
    init_math_axis();
    init_math_color();
    init_math_constants();
    init_math_frustum();
    init_math_path();
    init_math_plane();
    init_math_size();
    init_math_vector();
    init_math_vertexFormat();
    init_math_viewport();
  }
});

// node_modules/@babylonjs/core/Maths/sphericalPolynomial.js
var SH3ylmBasisConstants, SH3ylmBasisTrigonometricTerms, applySH3, SHCosKernelConvolution, SphericalHarmonics, SphericalPolynomial;
var init_sphericalPolynomial = __esm({
  "node_modules/@babylonjs/core/Maths/sphericalPolynomial.js"() {
    init_math_vector();
    init_math();
    SH3ylmBasisConstants = [
      Math.sqrt(1 / (4 * Math.PI)),
      -Math.sqrt(3 / (4 * Math.PI)),
      Math.sqrt(3 / (4 * Math.PI)),
      -Math.sqrt(3 / (4 * Math.PI)),
      Math.sqrt(15 / (4 * Math.PI)),
      -Math.sqrt(15 / (4 * Math.PI)),
      Math.sqrt(5 / (16 * Math.PI)),
      -Math.sqrt(15 / (4 * Math.PI)),
      Math.sqrt(15 / (16 * Math.PI))
    ];
    SH3ylmBasisTrigonometricTerms = [
      function() {
        return 1;
      },
      function(direction) {
        return direction.y;
      },
      function(direction) {
        return direction.z;
      },
      function(direction) {
        return direction.x;
      },
      function(direction) {
        return direction.x * direction.y;
      },
      function(direction) {
        return direction.y * direction.z;
      },
      function(direction) {
        return 3 * direction.z * direction.z - 1;
      },
      function(direction) {
        return direction.x * direction.z;
      },
      function(direction) {
        return direction.x * direction.x - direction.y * direction.y;
      }
    ];
    applySH3 = function(lm, direction) {
      return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);
    };
    SHCosKernelConvolution = [Math.PI, 2 * Math.PI / 3, 2 * Math.PI / 3, 2 * Math.PI / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];
    SphericalHarmonics = function() {
      function SphericalHarmonics2() {
        this.preScaled = false;
        this.l00 = Vector3.Zero();
        this.l1_1 = Vector3.Zero();
        this.l10 = Vector3.Zero();
        this.l11 = Vector3.Zero();
        this.l2_2 = Vector3.Zero();
        this.l2_1 = Vector3.Zero();
        this.l20 = Vector3.Zero();
        this.l21 = Vector3.Zero();
        this.l22 = Vector3.Zero();
      }
      SphericalHarmonics2.prototype.addLight = function(direction, color, deltaSolidAngle) {
        TmpVectors.Vector3[0].set(color.r, color.g, color.b);
        var colorVector = TmpVectors.Vector3[0];
        var c = TmpVectors.Vector3[1];
        colorVector.scaleToRef(deltaSolidAngle, c);
        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);
        this.l00.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);
        this.l1_1.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);
        this.l10.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);
        this.l11.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);
        this.l2_2.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);
        this.l2_1.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);
        this.l20.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);
        this.l21.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);
        this.l22.addInPlace(TmpVectors.Vector3[2]);
      };
      SphericalHarmonics2.prototype.scaleInPlace = function(scale) {
        this.l00.scaleInPlace(scale);
        this.l1_1.scaleInPlace(scale);
        this.l10.scaleInPlace(scale);
        this.l11.scaleInPlace(scale);
        this.l2_2.scaleInPlace(scale);
        this.l2_1.scaleInPlace(scale);
        this.l20.scaleInPlace(scale);
        this.l21.scaleInPlace(scale);
        this.l22.scaleInPlace(scale);
      };
      SphericalHarmonics2.prototype.convertIncidentRadianceToIrradiance = function() {
        this.l00.scaleInPlace(SHCosKernelConvolution[0]);
        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);
        this.l10.scaleInPlace(SHCosKernelConvolution[2]);
        this.l11.scaleInPlace(SHCosKernelConvolution[3]);
        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);
        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);
        this.l20.scaleInPlace(SHCosKernelConvolution[6]);
        this.l21.scaleInPlace(SHCosKernelConvolution[7]);
        this.l22.scaleInPlace(SHCosKernelConvolution[8]);
      };
      SphericalHarmonics2.prototype.convertIrradianceToLambertianRadiance = function() {
        this.scaleInPlace(1 / Math.PI);
      };
      SphericalHarmonics2.prototype.preScaleForRendering = function() {
        this.preScaled = true;
        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);
        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);
        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);
        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);
        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);
        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);
        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);
        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);
        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);
      };
      SphericalHarmonics2.prototype.updateFromArray = function(data) {
        Vector3.FromArrayToRef(data[0], 0, this.l00);
        Vector3.FromArrayToRef(data[1], 0, this.l1_1);
        Vector3.FromArrayToRef(data[2], 0, this.l10);
        Vector3.FromArrayToRef(data[3], 0, this.l11);
        Vector3.FromArrayToRef(data[4], 0, this.l2_2);
        Vector3.FromArrayToRef(data[5], 0, this.l2_1);
        Vector3.FromArrayToRef(data[6], 0, this.l20);
        Vector3.FromArrayToRef(data[7], 0, this.l21);
        Vector3.FromArrayToRef(data[8], 0, this.l22);
        return this;
      };
      SphericalHarmonics2.prototype.updateFromFloatsArray = function(data) {
        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);
        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);
        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);
        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);
        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);
        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);
        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);
        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);
        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);
        return this;
      };
      SphericalHarmonics2.FromArray = function(data) {
        var sh = new SphericalHarmonics2();
        return sh.updateFromArray(data);
      };
      SphericalHarmonics2.FromPolynomial = function(polynomial) {
        var result = new SphericalHarmonics2();
        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));
        result.l1_1 = polynomial.y.scale(0.977204);
        result.l10 = polynomial.z.scale(0.977204);
        result.l11 = polynomial.x.scale(0.977204);
        result.l2_2 = polynomial.xy.scale(1.16538);
        result.l2_1 = polynomial.yz.scale(1.16538);
        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));
        result.l21 = polynomial.zx.scale(1.16538);
        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));
        result.l1_1.scaleInPlace(-1);
        result.l11.scaleInPlace(-1);
        result.l2_1.scaleInPlace(-1);
        result.l21.scaleInPlace(-1);
        result.scaleInPlace(Math.PI);
        return result;
      };
      return SphericalHarmonics2;
    }();
    SphericalPolynomial = function() {
      function SphericalPolynomial2() {
        this.x = Vector3.Zero();
        this.y = Vector3.Zero();
        this.z = Vector3.Zero();
        this.xx = Vector3.Zero();
        this.yy = Vector3.Zero();
        this.zz = Vector3.Zero();
        this.xy = Vector3.Zero();
        this.yz = Vector3.Zero();
        this.zx = Vector3.Zero();
      }
      Object.defineProperty(SphericalPolynomial2.prototype, "preScaledHarmonics", {
        get: function() {
          if (!this._harmonics) {
            this._harmonics = SphericalHarmonics.FromPolynomial(this);
          }
          if (!this._harmonics.preScaled) {
            this._harmonics.preScaleForRendering();
          }
          return this._harmonics;
        },
        enumerable: false,
        configurable: true
      });
      SphericalPolynomial2.prototype.addAmbient = function(color) {
        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);
        var colorVector = TmpVectors.Vector3[0];
        this.xx.addInPlace(colorVector);
        this.yy.addInPlace(colorVector);
        this.zz.addInPlace(colorVector);
      };
      SphericalPolynomial2.prototype.scaleInPlace = function(scale) {
        this.x.scaleInPlace(scale);
        this.y.scaleInPlace(scale);
        this.z.scaleInPlace(scale);
        this.xx.scaleInPlace(scale);
        this.yy.scaleInPlace(scale);
        this.zz.scaleInPlace(scale);
        this.yz.scaleInPlace(scale);
        this.zx.scaleInPlace(scale);
        this.xy.scaleInPlace(scale);
      };
      SphericalPolynomial2.prototype.updateFromHarmonics = function(harmonics) {
        this._harmonics = harmonics;
        this.x.copyFrom(harmonics.l11);
        this.x.scaleInPlace(1.02333).scaleInPlace(-1);
        this.y.copyFrom(harmonics.l1_1);
        this.y.scaleInPlace(1.02333).scaleInPlace(-1);
        this.z.copyFrom(harmonics.l10);
        this.z.scaleInPlace(1.02333);
        this.xx.copyFrom(harmonics.l00);
        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);
        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);
        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);
        this.yy.copyFrom(harmonics.l00);
        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);
        this.zz.copyFrom(harmonics.l00);
        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);
        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);
        this.yz.copyFrom(harmonics.l2_1);
        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);
        this.zx.copyFrom(harmonics.l21);
        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);
        this.xy.copyFrom(harmonics.l2_2);
        this.xy.scaleInPlace(0.858086);
        this.scaleInPlace(1 / Math.PI);
        return this;
      };
      SphericalPolynomial2.FromHarmonics = function(harmonics) {
        var result = new SphericalPolynomial2();
        return result.updateFromHarmonics(harmonics);
      };
      SphericalPolynomial2.FromArray = function(data) {
        var sp = new SphericalPolynomial2();
        Vector3.FromArrayToRef(data[0], 0, sp.x);
        Vector3.FromArrayToRef(data[1], 0, sp.y);
        Vector3.FromArrayToRef(data[2], 0, sp.z);
        Vector3.FromArrayToRef(data[3], 0, sp.xx);
        Vector3.FromArrayToRef(data[4], 0, sp.yy);
        Vector3.FromArrayToRef(data[5], 0, sp.zz);
        Vector3.FromArrayToRef(data[6], 0, sp.yz);
        Vector3.FromArrayToRef(data[7], 0, sp.zx);
        Vector3.FromArrayToRef(data[8], 0, sp.xy);
        return sp;
      };
      return SphericalPolynomial2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode) {
  if (useBilinearMode === void 0) {
    useBilinearMode = true;
  }
  var scene = texture.getScene();
  var engine = scene.getEngine();
  var rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  var passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.getEffect().executeWhenCompiled(function() {
    passPostProcess.onApply = function(effect) {
      effect.setTexture("textureSampler", texture);
    };
    var internalTexture = rtt.renderTarget;
    if (internalTexture) {
      scene.postProcessManager.directRender([passPostProcess], internalTexture);
      engine.unBindFramebuffer(internalTexture);
      rtt.disposeFramebufferObjects();
      passPostProcess.dispose();
      rtt.getInternalTexture().isReady = true;
    }
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format) {
  var engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;
  type = type !== null && type !== void 0 ? type : internalTexture.type;
  format = format !== null && format !== void 0 ? format : internalTexture.format;
  if (type === -1) {
    type = 0;
  }
  return new Promise(function(resolve) {
    var postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    var encodedTexture = engine.createRenderTargetTexture({ width: internalTexture.width, height: internalTexture.height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.getEffect().executeWhenCompiled(function() {
      postProcess.onApply = function(effect) {
        effect._bindTexture("textureSampler", internalTexture);
        effect.setFloat2("scale", 1, 1);
      };
      scene.postProcessManager.directRender([postProcess], encodedTexture, true);
      engine.restoreDefaultFramebuffer();
      engine._releaseTexture(internalTexture);
      if (postProcess) {
        postProcess.dispose();
      }
      encodedTexture._swapAndDie(internalTexture);
      internalTexture.type = type;
      internalTexture.format = 5;
      internalTexture.isReady = true;
      resolve(internalTexture);
    });
  });
}
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  var x = int32View[0];
  var bits = x >> 16 & 32768;
  var m = x >> 12 & 2047;
  var e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  var s = (value & 32768) >> 15;
  var e = (value & 31744) >> 10;
  var f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var floatView, int32View, TextureTools;
var init_textureTools = __esm({
  "node_modules/@babylonjs/core/Misc/textureTools.js"() {
    init_texture();
    init_renderTargetTexture();
    init_passPostProcess();
    init_postProcess();
    TextureTools = {
      CreateResizedCopy,
      ApplyPostProcess,
      ToHalfFloat,
      FromHalfFloat
    };
  }
});

// node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js
var name63, shader63;
var init_rgbdDecode_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name63 = "rgbdDecodePixelShader";
    shader63 = "varying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\ngl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);\n}";
    ShaderStore.ShadersStore[name63] = shader63;
  }
});

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools;
var init_rgbdTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/rgbdTextureTools.js"() {
    init_postProcess();
    init_rgbdDecode_fragment();
    init_engine_renderTarget();
    init_textureTools();
    RGBDTextureTools = function() {
      function RGBDTextureTools2() {
      }
      RGBDTextureTools2.ExpandRGBDTexture = function(texture) {
        var internalTexture = texture._texture;
        if (!internalTexture || !texture.isRGBD) {
          return;
        }
        var engine = internalTexture.getEngine();
        var caps = engine.getCaps();
        var isReady = internalTexture.isReady;
        var expandTexture = false;
        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
          expandTexture = true;
          internalTexture.type = 2;
        } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
          expandTexture = true;
          internalTexture.type = 1;
        }
        if (expandTexture) {
          internalTexture.isReady = false;
          internalTexture._isRGBD = false;
          internalTexture.invertY = false;
        }
        var expandRGBDTexture = function() {
          if (expandTexture) {
            var rgbdPostProcess_1 = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false);
            rgbdPostProcess_1.externalTextureSamplerBinding = true;
            var expandedTexture_1 = engine.createRenderTargetTexture(internalTexture.width, {
              generateDepthBuffer: false,
              generateMipMaps: false,
              generateStencilBuffer: false,
              samplingMode: internalTexture.samplingMode,
              type: internalTexture.type,
              format: 5
            });
            rgbdPostProcess_1.getEffect().executeWhenCompiled(function() {
              rgbdPostProcess_1.onApply = function(effect) {
                effect._bindTexture("textureSampler", internalTexture);
                effect.setFloat2("scale", 1, 1);
              };
              texture.getScene().postProcessManager.directRender([rgbdPostProcess_1], expandedTexture_1, true);
              engine.restoreDefaultFramebuffer();
              engine._releaseTexture(internalTexture);
              if (rgbdPostProcess_1) {
                rgbdPostProcess_1.dispose();
              }
              expandedTexture_1._swapAndDie(internalTexture);
              internalTexture.isReady = true;
            });
          }
        };
        if (isReady) {
          expandRGBDTexture();
        } else {
          texture.onLoadObservable.addOnce(expandRGBDTexture);
        }
      };
      RGBDTextureTools2.EncodeTextureToRGBD = function(internalTexture, scene, outputTextureType) {
        if (outputTextureType === void 0) {
          outputTextureType = 0;
        }
        return ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
      };
      return RGBDTextureTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation, CubeMapToSphericalPolynomialTools;
var init_cubemapToSphericalPolynomial = __esm({
  "node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js"() {
    init_math_vector();
    init_math_scalar();
    init_sphericalPolynomial();
    init_math_constants();
    init_math_color();
    FileFaceOrientation = function() {
      function FileFaceOrientation2(name105, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
        this.name = name105;
        this.worldAxisForNormal = worldAxisForNormal;
        this.worldAxisForFileX = worldAxisForFileX;
        this.worldAxisForFileY = worldAxisForFileY;
      }
      return FileFaceOrientation2;
    }();
    CubeMapToSphericalPolynomialTools = function() {
      function CubeMapToSphericalPolynomialTools2() {
      }
      CubeMapToSphericalPolynomialTools2.ConvertCubeMapTextureToSphericalPolynomial = function(texture) {
        var _this = this;
        var _a;
        if (!texture.isCube) {
          return null;
        }
        (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();
        var size = texture.getSize().width;
        var rightPromise = texture.readPixels(0, void 0, void 0, false);
        var leftPromise = texture.readPixels(1, void 0, void 0, false);
        var upPromise;
        var downPromise;
        if (texture.isRenderTarget) {
          upPromise = texture.readPixels(3, void 0, void 0, false);
          downPromise = texture.readPixels(2, void 0, void 0, false);
        } else {
          upPromise = texture.readPixels(2, void 0, void 0, false);
          downPromise = texture.readPixels(3, void 0, void 0, false);
        }
        var frontPromise = texture.readPixels(4, void 0, void 0, false);
        var backPromise = texture.readPixels(5, void 0, void 0, false);
        var gammaSpace = texture.gammaSpace;
        var format = 5;
        var type = 0;
        if (texture.textureType == 1 || texture.textureType == 2) {
          type = 1;
        }
        return new Promise(function(resolve) {
          Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(function(_a2) {
            var left = _a2[0], right = _a2[1], up = _a2[2], down = _a2[3], front = _a2[4], back = _a2[5];
            var cubeInfo = {
              size,
              right,
              left,
              up,
              down,
              front,
              back,
              format,
              type,
              gammaSpace
            };
            resolve(_this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
          });
        });
      };
      CubeMapToSphericalPolynomialTools2._AreaElement = function(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
      };
      CubeMapToSphericalPolynomialTools2.ConvertCubeMapToSphericalPolynomial = function(cubeInfo) {
        var sphericalHarmonics = new SphericalHarmonics();
        var totalSolidAngle = 0;
        var du = 2 / cubeInfo.size;
        var dv = du;
        var halfTexel = 0.5 * du;
        var minUV = halfTexel - 1;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          var fileFace = this._FileFaces[faceIndex];
          var dataArray = cubeInfo[fileFace.name];
          var v = minUV;
          var stride = cubeInfo.format === 5 ? 4 : 3;
          for (var y = 0; y < cubeInfo.size; y++) {
            var u = minUV;
            for (var x = 0; x < cubeInfo.size; x++) {
              var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
              worldDirection.normalize();
              var deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
              var r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
              var g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
              var b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
              if (isNaN(r)) {
                r = 0;
              }
              if (isNaN(g)) {
                g = 0;
              }
              if (isNaN(b)) {
                b = 0;
              }
              if (cubeInfo.type === 0) {
                r /= 255;
                g /= 255;
                b /= 255;
              }
              if (cubeInfo.gammaSpace) {
                r = Math.pow(Scalar.Clamp(r), ToLinearSpace);
                g = Math.pow(Scalar.Clamp(g), ToLinearSpace);
                b = Math.pow(Scalar.Clamp(b), ToLinearSpace);
              }
              var max = 4096;
              r = Scalar.Clamp(r, 0, max);
              g = Scalar.Clamp(g, 0, max);
              b = Scalar.Clamp(b, 0, max);
              var color = new Color3(r, g, b);
              sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
              totalSolidAngle += deltaSolidAngle;
              u += du;
            }
            v += dv;
          }
        }
        var sphereSolidAngle = 4 * Math.PI;
        var facesProcessed = 6;
        var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
        var correctionFactor = expectedSolidAngle / totalSolidAngle;
        sphericalHarmonics.scaleInPlace(correctionFactor);
        sphericalHarmonics.convertIncidentRadianceToIrradiance();
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
      };
      CubeMapToSphericalPolynomialTools2._FileFaces = [
        new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
        new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
        new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
        new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
        new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
        new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
      ];
      return CubeMapToSphericalPolynomialTools2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
var init_baseTexture_polynomial = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js"() {
    init_cubemapToSphericalPolynomial();
    init_baseTexture();
    BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
      if (this._texture) {
        this._texture._sphericalPolynomial = null;
        this._texture._sphericalPolynomialPromise = null;
        this._texture._sphericalPolynomialComputed = false;
      }
    };
    Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
      get: function() {
        var _this = this;
        if (this._texture) {
          if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
            return this._texture._sphericalPolynomial;
          }
          if (this._texture.isReady) {
            if (!this._texture._sphericalPolynomialPromise) {
              this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
              if (this._texture._sphericalPolynomialPromise === null) {
                this._texture._sphericalPolynomialComputed = true;
              } else {
                this._texture._sphericalPolynomialPromise.then(function(sphericalPolynomial) {
                  _this._texture._sphericalPolynomial = sphericalPolynomial;
                  _this._texture._sphericalPolynomialComputed = true;
                });
              }
            }
            return null;
          }
        }
        return null;
      },
      set: function(value) {
        if (this._texture) {
          this._texture._sphericalPolynomial = value;
        }
      },
      enumerable: true,
      configurable: true
    });
  }
});

// node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js
var name64, shader64;
var init_rgbdEncode_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name64 = "rgbdEncodePixelShader";
    shader64 = "varying vec2 vUV;\nuniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\ngl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);\n}";
    ShaderStore.ShadersStore[name64] = shader64;
  }
});

// node_modules/@babylonjs/core/Misc/environmentTextureTools.js
function GetEnvInfo(data) {
  var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  var pos = 0;
  for (var i = 0; i < MagicBytes.length; i++) {
    if (dataView.getUint8(pos++) !== MagicBytes[i]) {
      Logger.Error("Not a babylon environment map");
      return null;
    }
  }
  var manifestString = "";
  var charCode = 0;
  while (charCode = dataView.getUint8(pos++)) {
    manifestString += String.fromCharCode(charCode);
  }
  var manifest = JSON.parse(manifestString);
  manifest = normalizeEnvInfo(manifest);
  if (manifest.specular) {
    manifest.specular.specularDataPosition = pos;
    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
  }
  return manifest;
}
function normalizeEnvInfo(info) {
  if (info.version > CurrentVersion) {
    throw new Error('Unsupported babylon environment map version "'.concat(info.version, '". Latest supported version is "').concat(CurrentVersion, '".'));
  }
  if (info.version === 2) {
    return info;
  }
  info = __assign(__assign({}, info), { version: 2, imageType: DefaultEnvironmentTextureImageType });
  return info;
}
function CreateEnvTextureAsync(texture, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  return __awaiter(this, void 0, void 0, function() {
    var internalTexture, imageType, engine, textureType, cubeWidth, hostingScene, specularTextures, mipmapsCount, i, faceWidth, face, faceData, faceDataFloat, i_1, tempTexture, rgbdEncodedData, imageEncodedData, info, position, i, face, byteLength, infoString, infoBuffer, infoView, i, strLen, totalSize, finalBuffer, finalBufferView, dataView, pos, i, i, face, dataBuffer;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          internalTexture = texture.getInternalTexture();
          if (!internalTexture) {
            return [2, Promise.reject("The cube texture is invalid.")];
          }
          imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;
          engine = internalTexture.getEngine();
          if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {
            return [2, Promise.reject("The cube texture should allow HDR (Full Float or Half Float).")];
          }
          textureType = 1;
          if (!engine.getCaps().textureFloatRender) {
            textureType = 2;
            if (!engine.getCaps().textureHalfFloatRender) {
              return [2, Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.")];
            }
          }
          cubeWidth = internalTexture.width;
          hostingScene = new Scene(engine);
          specularTextures = {};
          engine.flushFramebuffer();
          mipmapsCount = Scalar.ILog2(internalTexture.width);
          i = 0;
          _b.label = 1;
        case 1:
          if (!(i <= mipmapsCount))
            return [3, 9];
          faceWidth = Math.pow(2, mipmapsCount - i);
          face = 0;
          _b.label = 2;
        case 2:
          if (!(face < 6))
            return [3, 8];
          return [4, texture.readPixels(face, i, void 0, false)];
        case 3:
          faceData = _b.sent();
          if (faceData && faceData.byteLength === faceData.length) {
            faceDataFloat = new Float32Array(faceData.byteLength * 4);
            for (i_1 = 0; i_1 < faceData.byteLength; i_1++) {
              faceDataFloat[i_1] = faceData[i_1] / 255;
              faceDataFloat[i_1] = Math.pow(faceDataFloat[i_1], 2.2);
            }
            faceData = faceDataFloat;
          }
          tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);
          return [4, RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType)];
        case 4:
          _b.sent();
          return [4, engine._readTexturePixels(tempTexture, faceWidth, faceWidth)];
        case 5:
          rgbdEncodedData = _b.sent();
          return [4, Tools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, void 0, false, true, options.imageQuality)];
        case 6:
          imageEncodedData = _b.sent();
          specularTextures[i * 6 + face] = imageEncodedData;
          tempTexture.dispose();
          _b.label = 7;
        case 7:
          face++;
          return [3, 2];
        case 8:
          i++;
          return [3, 1];
        case 9:
          hostingScene.dispose();
          info = {
            version: CurrentVersion,
            width: cubeWidth,
            imageType,
            irradiance: _CreateEnvTextureIrradiance(texture),
            specular: {
              mipmaps: [],
              lodGenerationScale: texture.lodGenerationScale
            }
          };
          position = 0;
          for (i = 0; i <= mipmapsCount; i++) {
            for (face = 0; face < 6; face++) {
              byteLength = specularTextures[i * 6 + face].byteLength;
              info.specular.mipmaps.push({
                length: byteLength,
                position
              });
              position += byteLength;
            }
          }
          infoString = JSON.stringify(info);
          infoBuffer = new ArrayBuffer(infoString.length + 1);
          infoView = new Uint8Array(infoBuffer);
          for (i = 0, strLen = infoString.length; i < strLen; i++) {
            infoView[i] = infoString.charCodeAt(i);
          }
          infoView[infoString.length] = 0;
          totalSize = MagicBytes.length + position + infoBuffer.byteLength;
          finalBuffer = new ArrayBuffer(totalSize);
          finalBufferView = new Uint8Array(finalBuffer);
          dataView = new DataView(finalBuffer);
          pos = 0;
          for (i = 0; i < MagicBytes.length; i++) {
            dataView.setUint8(pos++, MagicBytes[i]);
          }
          finalBufferView.set(new Uint8Array(infoBuffer), pos);
          pos += infoBuffer.byteLength;
          for (i = 0; i <= mipmapsCount; i++) {
            for (face = 0; face < 6; face++) {
              dataBuffer = specularTextures[i * 6 + face];
              finalBufferView.set(new Uint8Array(dataBuffer), pos);
              pos += dataBuffer.byteLength;
            }
          }
          return [2, finalBuffer];
      }
    });
  });
}
function _CreateEnvTextureIrradiance(texture) {
  var polynmials = texture.sphericalPolynomial;
  if (polynmials == null) {
    return null;
  }
  return {
    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]
  };
}
function CreateImageDataArrayBufferViews(data, info) {
  info = normalizeEnvInfo(info);
  var specularInfo = info.specular;
  var mipmapsCount = Scalar.Log2(info.width);
  mipmapsCount = Math.round(mipmapsCount) + 1;
  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
    throw new Error('Unsupported specular mipmaps number "'.concat(specularInfo.mipmaps.length, '"'));
  }
  var imageData = new Array(mipmapsCount);
  for (var i = 0; i < mipmapsCount; i++) {
    imageData[i] = new Array(6);
    for (var face = 0; face < 6; face++) {
      var imageInfo = specularInfo.mipmaps[i * 6 + face];
      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);
    }
  }
  return imageData;
}
function UploadEnvLevelsAsync(texture, data, info) {
  info = normalizeEnvInfo(info);
  var specularInfo = info.specular;
  if (!specularInfo) {
    return Promise.resolve();
  }
  texture._lodGenerationScale = specularInfo.lodGenerationScale;
  var imageData = CreateImageDataArrayBufferViews(data, info);
  return UploadLevelsAsync(texture, imageData, info.imageType);
}
function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
  return new Promise(function(resolve, reject) {
    if (expandTexture) {
      var tempTexture_1 = engine.createTexture(null, true, true, null, 1, null, function(message) {
        reject(message);
      }, image);
      rgbdPostProcess.getEffect().executeWhenCompiled(function() {
        rgbdPostProcess.externalTextureSamplerBinding = true;
        rgbdPostProcess.onApply = function(effect) {
          effect._bindTexture("textureSampler", tempTexture_1);
          effect.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
        };
        if (!engine.scenes.length) {
          return;
        }
        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
        engine.restoreDefaultFramebuffer();
        tempTexture_1.dispose();
        URL.revokeObjectURL(url);
        resolve();
      });
    } else {
      engine._uploadImageToTexture(texture, image, face, i);
      if (generateNonLODTextures) {
        var lodTexture = lodTextures[i];
        if (lodTexture) {
          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
        }
      }
      resolve();
    }
  });
}
function UploadLevelsAsync(texture, imageData, imageType) {
  if (imageType === void 0) {
    imageType = DefaultEnvironmentTextureImageType;
  }
  if (!Tools.IsExponentOfTwo(texture.width)) {
    throw new Error("Texture size must be a power of two");
  }
  var mipmapsCount = Scalar.ILog2(texture.width) + 1;
  var engine = texture.getEngine();
  var expandTexture = false;
  var generateNonLODTextures = false;
  var rgbdPostProcess = null;
  var cubeRtt = null;
  var lodTextures = null;
  var caps = engine.getCaps();
  texture.format = 5;
  texture.type = 0;
  texture.generateMipMaps = true;
  texture._cachedAnisotropicFilteringLevel = null;
  engine.updateTextureSamplingMode(3, texture);
  if (!caps.textureLOD) {
    expandTexture = false;
    generateNonLODTextures = true;
    lodTextures = {};
  } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
    expandTexture = false;
  } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 2;
  } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 1;
  }
  if (expandTexture) {
    rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, texture.type, void 0, null, false);
    texture._isRGBD = false;
    texture.invertY = false;
    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
      generateDepthBuffer: false,
      generateMipMaps: true,
      generateStencilBuffer: false,
      samplingMode: 3,
      type: texture.type,
      format: 5
    });
  } else {
    texture._isRGBD = true;
    texture.invertY = true;
    if (generateNonLODTextures) {
      var mipSlices = 3;
      var scale = texture._lodGenerationScale;
      var offset = texture._lodGenerationOffset;
      for (var i = 0; i < mipSlices; i++) {
        var smoothness = i / (mipSlices - 1);
        var roughness = 1 - smoothness;
        var minLODIndex = offset;
        var maxLODIndex = (mipmapsCount - 1) * scale + offset;
        var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
        var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
        var glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);
        glTextureFromLod.isCube = true;
        glTextureFromLod.invertY = true;
        glTextureFromLod.generateMipMaps = false;
        engine.updateTextureSamplingMode(2, glTextureFromLod);
        var lodTexture = new BaseTexture(null);
        lodTexture.isCube = true;
        lodTexture._texture = glTextureFromLod;
        lodTextures[mipmapIndex] = lodTexture;
        switch (i) {
          case 0:
            texture._lodTextureLow = lodTexture;
            break;
          case 1:
            texture._lodTextureMid = lodTexture;
            break;
          case 2:
            texture._lodTextureHigh = lodTexture;
            break;
        }
      }
    }
  }
  var promises = [];
  var _loop_1 = function(i2) {
    var _loop_2 = function(face3) {
      var bytes = imageData[i2][face3];
      var blob = new Blob([bytes], { type: imageType });
      var url = URL.createObjectURL(blob);
      var promise = void 0;
      if (typeof Image === "undefined" || engine._features.forceBitmapOverHTMLImageElement) {
        promise = engine.createImageBitmap(blob, { premultiplyAlpha: "none" }).then(function(img) {
          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face3, i2, generateNonLODTextures, lodTextures, cubeRtt, texture);
        });
      } else {
        var image_1 = new Image();
        image_1.src = url;
        promise = new Promise(function(resolve, reject) {
          image_1.onload = function() {
            _OnImageReadyAsync(image_1, engine, expandTexture, rgbdPostProcess, url, face3, i2, generateNonLODTextures, lodTextures, cubeRtt, texture).then(function() {
              return resolve();
            }).catch(function(reason) {
              reject(reason);
            });
          };
          image_1.onerror = function(error) {
            reject(error);
          };
        });
      }
      promises.push(promise);
    };
    for (var face2 = 0; face2 < 6; face2++) {
      _loop_2(face2);
    }
  };
  for (var i = 0; i < imageData.length; i++) {
    _loop_1(i);
  }
  if (imageData.length < mipmapsCount) {
    var data = void 0;
    var size = Math.pow(2, mipmapsCount - 1 - imageData.length);
    var dataLength = size * size * 4;
    switch (texture.type) {
      case 0: {
        data = new Uint8Array(dataLength);
        break;
      }
      case 2: {
        data = new Uint16Array(dataLength);
        break;
      }
      case 1: {
        data = new Float32Array(dataLength);
        break;
      }
    }
    for (var i = imageData.length; i < mipmapsCount; i++) {
      for (var face = 0; face < 6; face++) {
        engine._uploadArrayBufferViewToTexture(texture, data, face, i);
      }
    }
  }
  return Promise.all(promises).then(function() {
    if (cubeRtt) {
      engine._releaseTexture(texture);
      cubeRtt._swapAndDie(texture);
    }
    if (rgbdPostProcess) {
      rgbdPostProcess.dispose();
    }
    if (generateNonLODTextures) {
      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
        texture._lodTextureHigh._texture.isReady = true;
      }
      if (texture._lodTextureMid && texture._lodTextureMid._texture) {
        texture._lodTextureMid._texture.isReady = true;
      }
      if (texture._lodTextureLow && texture._lodTextureLow._texture) {
        texture._lodTextureLow._texture.isReady = true;
      }
    }
  });
}
function UploadEnvSpherical(texture, info) {
  info = normalizeEnvInfo(info);
  var irradianceInfo = info.irradiance;
  if (!irradianceInfo) {
    return;
  }
  var sp = new SphericalPolynomial();
  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
  texture._sphericalPolynomial = sp;
}
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
  var proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
  var proxyPromise = UploadLevelsAsync(proxy, data).then(function() {
    return internalTexture;
  });
  internalTexture.onRebuildCallback = function(_internalTexture) {
    return {
      proxy: proxyPromise,
      isReady: true,
      isAsync: true
    };
  };
  internalTexture._source = InternalTextureSource.CubeRawRGBD;
  internalTexture._bufferViewArrayArray = data;
  internalTexture._lodGenerationScale = lodScale;
  internalTexture._lodGenerationOffset = lodOffset;
  internalTexture._sphericalPolynomial = sphericalPolynomial;
  return UploadLevelsAsync(internalTexture, data).then(function() {
    internalTexture.isReady = true;
    return internalTexture;
  });
}
var DefaultEnvironmentTextureImageType, CurrentVersion, MagicBytes, EnvironmentTextureTools;
var init_environmentTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/environmentTextureTools.js"() {
    init_tslib_es6();
    init_tools();
    init_math_vector();
    init_math_scalar();
    init_sphericalPolynomial();
    init_internalTexture();
    init_baseTexture();
    init_scene();
    init_postProcess();
    init_logger();
    init_rgbdTextureTools();
    init_engine_renderTargetCube();
    init_engine_readTexture();
    init_baseTexture_polynomial();
    init_rgbdEncode_fragment();
    init_rgbdDecode_fragment();
    DefaultEnvironmentTextureImageType = "image/png";
    CurrentVersion = 2;
    MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54];
    EnvironmentTextureTools = {
      GetEnvInfo,
      CreateEnvTextureAsync,
      CreateImageDataArrayBufferViews,
      UploadEnvLevelsAsync,
      UploadLevelsAsync,
      UploadEnvSpherical
    };
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode, SceneLoader;
var init_sceneLoader = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoader.js"() {
    init_tools();
    init_observable();
    init_scene();
    init_engine();
    init_engineStore();
    init_logger();
    init_sceneLoaderFlags();
    init_fileTools();
    init_stringTools();
    init_error();
    (function(SceneLoaderAnimationGroupLoadingMode2) {
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
    })(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
    SceneLoader = function() {
      function SceneLoader2() {
      }
      Object.defineProperty(SceneLoader2, "ForceFullSceneLoadingForIncremental", {
        get: function() {
          return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
        },
        set: function(value) {
          SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoader2, "ShowLoadingScreen", {
        get: function() {
          return SceneLoaderFlags.ShowLoadingScreen;
        },
        set: function(value) {
          SceneLoaderFlags.ShowLoadingScreen = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoader2, "loggingLevel", {
        get: function() {
          return SceneLoaderFlags.loggingLevel;
        },
        set: function(value) {
          SceneLoaderFlags.loggingLevel = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SceneLoader2, "CleanBoneMatrixWeights", {
        get: function() {
          return SceneLoaderFlags.CleanBoneMatrixWeights;
        },
        set: function(value) {
          SceneLoaderFlags.CleanBoneMatrixWeights = value;
        },
        enumerable: false,
        configurable: true
      });
      SceneLoader2.GetDefaultPlugin = function() {
        return SceneLoader2._RegisteredPlugins[".babylon"];
      };
      SceneLoader2._GetPluginForExtension = function(extension) {
        var registeredPlugin = SceneLoader2._RegisteredPlugins[extension];
        if (registeredPlugin) {
          return registeredPlugin;
        }
        Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type");
        return SceneLoader2.GetDefaultPlugin();
      };
      SceneLoader2._GetPluginForDirectLoad = function(data) {
        for (var extension in SceneLoader2._RegisteredPlugins) {
          var plugin = SceneLoader2._RegisteredPlugins[extension].plugin;
          if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
            return SceneLoader2._RegisteredPlugins[extension];
          }
        }
        return SceneLoader2.GetDefaultPlugin();
      };
      SceneLoader2._GetPluginForFilename = function(sceneFilename) {
        var queryStringPosition = sceneFilename.indexOf("?");
        if (queryStringPosition !== -1) {
          sceneFilename = sceneFilename.substring(0, queryStringPosition);
        }
        var dotPosition = sceneFilename.lastIndexOf(".");
        var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
        return SceneLoader2._GetPluginForExtension(extension);
      };
      SceneLoader2._GetDirectLoad = function(sceneFilename) {
        if (sceneFilename.substr(0, 5) === "data:") {
          return sceneFilename.substr(5);
        }
        return null;
      };
      SceneLoader2._FormatErrorMessage = function(fileInfo, message, exception) {
        var errorMessage = "Unable to load from " + fileInfo.url;
        if (message) {
          errorMessage += ": ".concat(message);
        } else if (exception) {
          errorMessage += ": ".concat(exception);
        }
        return errorMessage;
      };
      SceneLoader2._LoadData = function(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {
        var directLoad = SceneLoader2._GetDirectLoad(fileInfo.url);
        var registeredPlugin = pluginExtension ? SceneLoader2._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader2._GetPluginForDirectLoad(fileInfo.url) : SceneLoader2._GetPluginForFilename(fileInfo.url);
        var plugin;
        if (registeredPlugin.plugin.createPlugin !== void 0) {
          plugin = registeredPlugin.plugin.createPlugin();
        } else {
          plugin = registeredPlugin.plugin;
        }
        if (!plugin) {
          throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
        }
        SceneLoader2.OnPluginActivatedObservable.notifyObservers(plugin);
        if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
          if (plugin.directLoad) {
            var result = plugin.directLoad(scene, directLoad);
            if (result.then) {
              result.then(function(data) {
                onSuccess(plugin, data);
              }).catch(function(error) {
                onError("Error in directLoad of _loadData: " + error, error);
              });
            } else {
              onSuccess(plugin, result);
            }
          } else {
            onSuccess(plugin, directLoad);
          }
          return plugin;
        }
        var useArrayBuffer = registeredPlugin.isBinary;
        var dataCallback = function(data, responseURL) {
          if (scene.isDisposed) {
            onError("Scene has been disposed");
            return;
          }
          onSuccess(plugin, data, responseURL);
        };
        var request = null;
        var pluginDisposed = false;
        var onDisposeObservable = plugin.onDisposeObservable;
        if (onDisposeObservable) {
          onDisposeObservable.add(function() {
            pluginDisposed = true;
            if (request) {
              request.abort();
              request = null;
            }
            onDispose();
          });
        }
        var manifestChecked = function() {
          if (pluginDisposed) {
            return;
          }
          var errorCallback = function(request2, exception) {
            onError(request2 === null || request2 === void 0 ? void 0 : request2.statusText, exception);
          };
          var fileOrUrl = fileInfo.file || fileInfo.url;
          request = plugin.loadFile ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
        };
        var engine = scene.getEngine();
        var canUseOfflineSupport = engine.enableOfflineSupport;
        if (canUseOfflineSupport) {
          var exceptionFound = false;
          for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {
            var regex = _a[_i];
            if (regex.test(fileInfo.url)) {
              exceptionFound = true;
              break;
            }
          }
          canUseOfflineSupport = !exceptionFound;
        }
        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
          scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
        } else {
          manifestChecked();
        }
        return plugin;
      };
      SceneLoader2._GetFileInfo = function(rootUrl, sceneFilename) {
        var url;
        var name105;
        var file = null;
        if (!sceneFilename) {
          url = rootUrl;
          name105 = Tools.GetFilename(rootUrl);
          rootUrl = Tools.GetFolderPath(rootUrl);
        } else if (sceneFilename.name) {
          var sceneFile = sceneFilename;
          url = "file:".concat(sceneFile.name);
          name105 = sceneFile.name;
          file = sceneFile;
        } else if (typeof sceneFilename === "string" && StartsWith(sceneFilename, "data:")) {
          url = sceneFilename;
          name105 = "";
        } else {
          var filename = sceneFilename;
          if (filename.substr(0, 1) === "/") {
            Tools.Error("Wrong sceneFilename parameter");
            return null;
          }
          url = rootUrl + filename;
          name105 = filename;
        }
        return {
          url,
          rootUrl,
          name: name105,
          file
        };
      };
      SceneLoader2.GetPluginForExtension = function(extension) {
        return SceneLoader2._GetPluginForExtension(extension).plugin;
      };
      SceneLoader2.IsPluginForExtensionAvailable = function(extension) {
        return !!SceneLoader2._RegisteredPlugins[extension];
      };
      SceneLoader2.RegisterPlugin = function(plugin) {
        if (typeof plugin.extensions === "string") {
          var extension = plugin.extensions;
          SceneLoader2._RegisteredPlugins[extension.toLowerCase()] = {
            plugin,
            isBinary: false
          };
        } else {
          var extensions_1 = plugin.extensions;
          Object.keys(extensions_1).forEach(function(extension2) {
            SceneLoader2._RegisteredPlugins[extension2.toLowerCase()] = {
              plugin,
              isBinary: extensions_1[extension2].isBinary
            };
          });
        }
      };
      SceneLoader2.ImportMesh = function(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        if (!scene) {
          Logger.Error("No scene available to import mesh to");
          return null;
        }
        var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        var loadingToken = {};
        scene._addPendingData(loadingToken);
        var disposeHandler = function() {
          scene._removePendingData(loadingToken);
        };
        var errorHandler = function(message, exception) {
          var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        var progressHandler = onProgress ? function(event) {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback: " + e, e);
          }
        } : void 0;
        var successHandler = function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
          scene.importedMeshesFiles.push(fileInfo.url);
          if (onSuccess) {
            try {
              onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);
            } catch (e) {
              errorHandler("Error in onSuccess callback: " + e, e);
            }
          }
          scene._removePendingData(loadingToken);
        };
        return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data, responseURL) {
          if (plugin.rewriteRootURL) {
            fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
          }
          if (plugin.importMesh) {
            var syncedPlugin = plugin;
            var meshes = new Array();
            var particleSystems = new Array();
            var skeletons = new Array();
            if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
              return;
            }
            scene.loadingPluginName = plugin.name;
            successHandler(meshes, particleSystems, skeletons, [], [], [], []);
          } else {
            var asyncedPlugin = plugin;
            asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(result) {
              scene.loadingPluginName = plugin.name;
              successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);
            }).catch(function(error) {
              errorHandler(error.message, error);
            });
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension);
      };
      SceneLoader2.ImportMeshAsync = function(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        return new Promise(function(resolve, reject) {
          SceneLoader2.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
            resolve({
              meshes,
              particleSystems,
              skeletons,
              animationGroups,
              transformNodes,
              geometries,
              lights
            });
          }, onProgress, function(scene2, message, exception) {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      };
      SceneLoader2.Load = function(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (engine === void 0) {
          engine = EngineStore.LastCreatedEngine;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        if (!engine) {
          Tools.Error("No engine available");
          return null;
        }
        return SceneLoader2.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);
      };
      SceneLoader2.LoadAsync = function(rootUrl, sceneFilename, engine, onProgress, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (engine === void 0) {
          engine = EngineStore.LastCreatedEngine;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        return new Promise(function(resolve, reject) {
          SceneLoader2.Load(rootUrl, sceneFilename, engine, function(scene) {
            resolve(scene);
          }, onProgress, function(scene, message, exception) {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      };
      SceneLoader2.Append = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
        var _this = this;
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        if (!scene) {
          Logger.Error("No scene available to append to");
          return null;
        }
        var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        if (SceneLoader2.ShowLoadingScreen && !this._ShowingLoadingScreen) {
          this._ShowingLoadingScreen = true;
          scene.getEngine().displayLoadingUI();
          scene.executeWhenReady(function() {
            scene.getEngine().hideLoadingUI();
            _this._ShowingLoadingScreen = false;
          });
        }
        var loadingToken = {};
        scene._addPendingData(loadingToken);
        var disposeHandler = function() {
          scene._removePendingData(loadingToken);
        };
        var errorHandler = function(message, exception) {
          var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        var progressHandler = onProgress ? function(event) {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback", e);
          }
        } : void 0;
        var successHandler = function() {
          if (onSuccess) {
            try {
              onSuccess(scene);
            } catch (e) {
              errorHandler("Error in onSuccess callback", e);
            }
          }
          scene._removePendingData(loadingToken);
        };
        return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
          if (plugin.load) {
            var syncedPlugin = plugin;
            if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
              return;
            }
            scene.loadingPluginName = plugin.name;
            successHandler();
          } else {
            var asyncedPlugin = plugin;
            asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function() {
              scene.loadingPluginName = plugin.name;
              successHandler();
            }).catch(function(error) {
              errorHandler(error.message, error);
            });
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension);
      };
      SceneLoader2.AppendAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        return new Promise(function(resolve, reject) {
          SceneLoader2.Append(rootUrl, sceneFilename, scene, function(scene2) {
            resolve(scene2);
          }, onProgress, function(scene2, message, exception) {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      };
      SceneLoader2.LoadAssetContainer = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        if (!scene) {
          Logger.Error("No scene available to load asset container to");
          return null;
        }
        var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        var loadingToken = {};
        scene._addPendingData(loadingToken);
        var disposeHandler = function() {
          scene._removePendingData(loadingToken);
        };
        var errorHandler = function(message, exception) {
          var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        var progressHandler = onProgress ? function(event) {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback", e);
          }
        } : void 0;
        var successHandler = function(assets) {
          if (onSuccess) {
            try {
              onSuccess(assets);
            } catch (e) {
              errorHandler("Error in onSuccess callback", e);
            }
          }
          scene._removePendingData(loadingToken);
        };
        return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
          if (plugin.loadAssetContainer) {
            var syncedPlugin = plugin;
            var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
            if (!assetContainer) {
              return;
            }
            scene.loadingPluginName = plugin.name;
            successHandler(assetContainer);
          } else if (plugin.loadAssetContainerAsync) {
            var asyncedPlugin = plugin;
            asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(assetContainer2) {
              scene.loadingPluginName = plugin.name;
              successHandler(assetContainer2);
            }).catch(function(error) {
              errorHandler(error.message, error);
            });
          } else {
            errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension);
      };
      SceneLoader2.LoadAssetContainerAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        return new Promise(function(resolve, reject) {
          SceneLoader2.LoadAssetContainer(rootUrl, sceneFilename, scene, function(assetContainer) {
            resolve(assetContainer);
          }, onProgress, function(scene2, message, exception) {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      };
      SceneLoader2.ImportAnimations = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (overwriteAnimations === void 0) {
          overwriteAnimations = true;
        }
        if (animationGroupLoadingMode === void 0) {
          animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
        }
        if (targetConverter === void 0) {
          targetConverter = null;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        if (!scene) {
          Logger.Error("No scene available to load animations to");
          return;
        }
        if (overwriteAnimations) {
          for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {
            var animatable = _a[_i];
            animatable.reset();
          }
          scene.stopAllAnimations();
          scene.animationGroups.slice().forEach(function(animationGroup) {
            animationGroup.dispose();
          });
          var nodes = scene.getNodes();
          nodes.forEach(function(node) {
            if (node.animations) {
              node.animations = [];
            }
          });
        } else {
          switch (animationGroupLoadingMode) {
            case SceneLoaderAnimationGroupLoadingMode.Clean:
              scene.animationGroups.slice().forEach(function(animationGroup) {
                animationGroup.dispose();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.Stop:
              scene.animationGroups.forEach(function(animationGroup) {
                animationGroup.stop();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.Sync:
              scene.animationGroups.forEach(function(animationGroup) {
                animationGroup.reset();
                animationGroup.restart();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.NoSync:
              break;
            default:
              Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
              return;
          }
        }
        var startingIndexForNewAnimatables = scene.animatables.length;
        var onAssetContainerLoaded = function(container) {
          container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
          container.dispose();
          scene.onAnimationFileImportedObservable.notifyObservers(scene);
          if (onSuccess) {
            onSuccess(scene);
          }
        };
        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
      };
      SceneLoader2.ImportAnimationsAsync = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
        if (sceneFilename === void 0) {
          sceneFilename = "";
        }
        if (scene === void 0) {
          scene = EngineStore.LastCreatedScene;
        }
        if (overwriteAnimations === void 0) {
          overwriteAnimations = true;
        }
        if (animationGroupLoadingMode === void 0) {
          animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
        }
        if (targetConverter === void 0) {
          targetConverter = null;
        }
        if (onSuccess === void 0) {
          onSuccess = null;
        }
        if (onProgress === void 0) {
          onProgress = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (pluginExtension === void 0) {
          pluginExtension = null;
        }
        return new Promise(function(resolve, reject) {
          SceneLoader2.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function(_scene) {
            resolve(_scene);
          }, onProgress, function(_scene, message, exception) {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      };
      SceneLoader2.NO_LOGGING = 0;
      SceneLoader2.MINIMAL_LOGGING = 1;
      SceneLoader2.SUMMARY_LOGGING = 2;
      SceneLoader2.DETAILED_LOGGING = 3;
      SceneLoader2.OnPluginActivatedObservable = new Observable();
      SceneLoader2._RegisteredPlugins = {};
      SceneLoader2._ShowingLoadingScreen = false;
      return SceneLoader2;
    }();
  }
});

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight;
var init_shadowLight = __esm({
  "node_modules/@babylonjs/core/Lights/shadowLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_light();
    init_math_axis();
    ShadowLight = function(_super) {
      __extends(ShadowLight2, _super);
      function ShadowLight2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._needProjectionMatrixCompute = true;
        return _this;
      }
      ShadowLight2.prototype._setPosition = function(value) {
        this._position = value;
      };
      Object.defineProperty(ShadowLight2.prototype, "position", {
        get: function() {
          return this._position;
        },
        set: function(value) {
          this._setPosition(value);
        },
        enumerable: false,
        configurable: true
      });
      ShadowLight2.prototype._setDirection = function(value) {
        this._direction = value;
      };
      Object.defineProperty(ShadowLight2.prototype, "direction", {
        get: function() {
          return this._direction;
        },
        set: function(value) {
          this._setDirection(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ShadowLight2.prototype, "shadowMinZ", {
        get: function() {
          return this._shadowMinZ;
        },
        set: function(value) {
          this._shadowMinZ = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ShadowLight2.prototype, "shadowMaxZ", {
        get: function() {
          return this._shadowMaxZ;
        },
        set: function(value) {
          this._shadowMaxZ = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      ShadowLight2.prototype.computeTransformedInformation = function() {
        if (this.parent && this.parent.getWorldMatrix) {
          if (!this.transformedPosition) {
            this.transformedPosition = Vector3.Zero();
          }
          Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
          if (this.direction) {
            if (!this.transformedDirection) {
              this.transformedDirection = Vector3.Zero();
            }
            Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
          }
          return true;
        }
        return false;
      };
      ShadowLight2.prototype.getDepthScale = function() {
        return 50;
      };
      ShadowLight2.prototype.getShadowDirection = function(faceIndex) {
        return this.transformedDirection ? this.transformedDirection : this.direction;
      };
      ShadowLight2.prototype.getAbsolutePosition = function() {
        return this.transformedPosition ? this.transformedPosition : this.position;
      };
      ShadowLight2.prototype.setDirectionToTarget = function(target) {
        this.direction = Vector3.Normalize(target.subtract(this.position));
        return this.direction;
      };
      ShadowLight2.prototype.getRotation = function() {
        this.direction.normalize();
        var xaxis = Vector3.Cross(this.direction, Axis.Y);
        var yaxis = Vector3.Cross(xaxis, this.direction);
        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
      };
      ShadowLight2.prototype.needCube = function() {
        return false;
      };
      ShadowLight2.prototype.needProjectionMatrixCompute = function() {
        return this._needProjectionMatrixCompute;
      };
      ShadowLight2.prototype.forceProjectionMatrixCompute = function() {
        this._needProjectionMatrixCompute = true;
      };
      ShadowLight2.prototype._initCache = function() {
        _super.prototype._initCache.call(this);
        this._cache.position = Vector3.Zero();
      };
      ShadowLight2.prototype._isSynchronized = function() {
        if (!this._cache.position.equals(this.position)) {
          return false;
        }
        return true;
      };
      ShadowLight2.prototype.computeWorldMatrix = function(force) {
        if (!force && this.isSynchronized()) {
          this._currentRenderId = this.getScene().getRenderId();
          return this._worldMatrix;
        }
        this._updateCache();
        this._cache.position.copyFrom(this.position);
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
        if (this.parent && this.parent.getWorldMatrix) {
          this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
          this._markSyncedWithParent();
        }
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
      };
      ShadowLight2.prototype.getDepthMinZ = function(activeCamera) {
        return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
      };
      ShadowLight2.prototype.getDepthMaxZ = function(activeCamera) {
        return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
      };
      ShadowLight2.prototype.setShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
        if (this.customProjectionMatrixBuilder) {
          this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
        } else {
          this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
        return this;
      };
      __decorate([
        serializeAsVector3()
      ], ShadowLight2.prototype, "position", null);
      __decorate([
        serializeAsVector3()
      ], ShadowLight2.prototype, "direction", null);
      __decorate([
        serialize()
      ], ShadowLight2.prototype, "shadowMinZ", null);
      __decorate([
        serialize()
      ], ShadowLight2.prototype, "shadowMaxZ", null);
      return ShadowLight2;
    }(Light);
  }
});

// node_modules/@babylonjs/core/Lights/directionalLight.js
var DirectionalLight;
var init_directionalLight = __esm({
  "node_modules/@babylonjs/core/Lights/directionalLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    Node.AddNodeConstructor("Light_Type_1", function(name105, scene) {
      return function() {
        return new DirectionalLight(name105, Vector3.Zero(), scene);
      };
    });
    DirectionalLight = function(_super) {
      __extends(DirectionalLight2, _super);
      function DirectionalLight2(name105, direction, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this._shadowFrustumSize = 0;
        _this._shadowOrthoScale = 0.1;
        _this.autoUpdateExtends = true;
        _this.autoCalcShadowZBounds = false;
        _this._orthoLeft = Number.MAX_VALUE;
        _this._orthoRight = Number.MIN_VALUE;
        _this._orthoTop = Number.MIN_VALUE;
        _this._orthoBottom = Number.MAX_VALUE;
        _this.position = direction.scale(-1);
        _this.direction = direction;
        return _this;
      }
      Object.defineProperty(DirectionalLight2.prototype, "shadowFrustumSize", {
        get: function() {
          return this._shadowFrustumSize;
        },
        set: function(value) {
          this._shadowFrustumSize = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DirectionalLight2.prototype, "shadowOrthoScale", {
        get: function() {
          return this._shadowOrthoScale;
        },
        set: function(value) {
          this._shadowOrthoScale = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DirectionalLight2.prototype, "orthoLeft", {
        get: function() {
          return this._orthoLeft;
        },
        set: function(left) {
          this._orthoLeft = left;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DirectionalLight2.prototype, "orthoRight", {
        get: function() {
          return this._orthoRight;
        },
        set: function(right) {
          this._orthoRight = right;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DirectionalLight2.prototype, "orthoTop", {
        get: function() {
          return this._orthoTop;
        },
        set: function(top) {
          this._orthoTop = top;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DirectionalLight2.prototype, "orthoBottom", {
        get: function() {
          return this._orthoBottom;
        },
        set: function(bottom) {
          this._orthoBottom = bottom;
        },
        enumerable: false,
        configurable: true
      });
      DirectionalLight2.prototype.getClassName = function() {
        return "DirectionalLight";
      };
      DirectionalLight2.prototype.getTypeID = function() {
        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
      };
      DirectionalLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
        if (this.shadowFrustumSize > 0) {
          this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
        } else {
          this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
      };
      DirectionalLight2.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function(matrix) {
        var activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      };
      DirectionalLight2.prototype._setDefaultAutoExtendShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
        var activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
          var tempVector3 = Vector3.Zero();
          this._orthoLeft = Number.MAX_VALUE;
          this._orthoRight = Number.MIN_VALUE;
          this._orthoTop = Number.MIN_VALUE;
          this._orthoBottom = Number.MAX_VALUE;
          var shadowMinZ = Number.MAX_VALUE;
          var shadowMaxZ = Number.MIN_VALUE;
          for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            var mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            var boundingInfo = mesh.getBoundingInfo();
            var boundingBox = boundingInfo.boundingBox;
            for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {
              Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
              if (tempVector3.x < this._orthoLeft) {
                this._orthoLeft = tempVector3.x;
              }
              if (tempVector3.y < this._orthoBottom) {
                this._orthoBottom = tempVector3.y;
              }
              if (tempVector3.x > this._orthoRight) {
                this._orthoRight = tempVector3.x;
              }
              if (tempVector3.y > this._orthoTop) {
                this._orthoTop = tempVector3.y;
              }
              if (this.autoCalcShadowZBounds) {
                if (tempVector3.z < shadowMinZ) {
                  shadowMinZ = tempVector3.z;
                }
                if (tempVector3.z > shadowMaxZ) {
                  shadowMaxZ = tempVector3.z;
                }
              }
            }
          }
          if (this.autoCalcShadowZBounds) {
            this._shadowMinZ = shadowMinZ;
            this._shadowMaxZ = shadowMaxZ;
          }
        }
        var xOffset = this._orthoRight - this._orthoLeft;
        var yOffset = this._orthoTop - this._orthoBottom;
        var minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        var maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        var useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      };
      DirectionalLight2.prototype._buildUniformLayout = function() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      };
      DirectionalLight2.prototype.transferToEffect = function(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
          return this;
        }
        this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
        return this;
      };
      DirectionalLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
          return this;
        }
        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
        return this;
      };
      DirectionalLight2.prototype.getDepthMinZ = function(activeCamera) {
        var engine = this._scene.getEngine();
        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      };
      DirectionalLight2.prototype.getDepthMaxZ = function(activeCamera) {
        var engine = this._scene.getEngine();
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      };
      DirectionalLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
        defines["DIRLIGHT" + lightIndex] = true;
      };
      __decorate([
        serialize()
      ], DirectionalLight2.prototype, "shadowFrustumSize", null);
      __decorate([
        serialize()
      ], DirectionalLight2.prototype, "shadowOrthoScale", null);
      __decorate([
        serialize()
      ], DirectionalLight2.prototype, "autoUpdateExtends", void 0);
      __decorate([
        serialize()
      ], DirectionalLight2.prototype, "autoCalcShadowZBounds", void 0);
      __decorate([
        serialize("orthoLeft")
      ], DirectionalLight2.prototype, "_orthoLeft", void 0);
      __decorate([
        serialize("orthoRight")
      ], DirectionalLight2.prototype, "_orthoRight", void 0);
      __decorate([
        serialize("orthoTop")
      ], DirectionalLight2.prototype, "_orthoTop", void 0);
      __decorate([
        serialize("orthoBottom")
      ], DirectionalLight2.prototype, "_orthoBottom", void 0);
      return DirectionalLight2;
    }(ShadowLight);
  }
});

// node_modules/@babylonjs/core/Lights/spotLight.js
var SpotLight;
var init_spotLight = __esm({
  "node_modules/@babylonjs/core/Lights/spotLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_texture();
    Node.AddNodeConstructor("Light_Type_2", function(name105, scene) {
      return function() {
        return new SpotLight(name105, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);
      };
    });
    SpotLight = function(_super) {
      __extends(SpotLight2, _super);
      function SpotLight2(name105, position, direction, angle, exponent, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this._innerAngle = 0;
        _this._projectionTextureMatrix = Matrix.Zero();
        _this._projectionTextureLightNear = 1e-6;
        _this._projectionTextureLightFar = 1e3;
        _this._projectionTextureUpDirection = Vector3.Up();
        _this._projectionTextureViewLightDirty = true;
        _this._projectionTextureProjectionLightDirty = true;
        _this._projectionTextureDirty = true;
        _this._projectionTextureViewTargetVector = Vector3.Zero();
        _this._projectionTextureViewLightMatrix = Matrix.Zero();
        _this._projectionTextureProjectionLightMatrix = Matrix.Zero();
        _this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
        _this.position = position;
        _this.direction = direction;
        _this.angle = angle;
        _this.exponent = exponent;
        return _this;
      }
      Object.defineProperty(SpotLight2.prototype, "angle", {
        get: function() {
          return this._angle;
        },
        set: function(value) {
          this._angle = value;
          this._cosHalfAngle = Math.cos(value * 0.5);
          this._projectionTextureProjectionLightDirty = true;
          this.forceProjectionMatrixCompute();
          this._computeAngleValues();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "innerAngle", {
        get: function() {
          return this._innerAngle;
        },
        set: function(value) {
          this._innerAngle = value;
          this._computeAngleValues();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "shadowAngleScale", {
        get: function() {
          return this._shadowAngleScale;
        },
        set: function(value) {
          this._shadowAngleScale = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "projectionTextureMatrix", {
        get: function() {
          return this._projectionTextureMatrix;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "projectionTextureLightNear", {
        get: function() {
          return this._projectionTextureLightNear;
        },
        set: function(value) {
          this._projectionTextureLightNear = value;
          this._projectionTextureProjectionLightDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "projectionTextureLightFar", {
        get: function() {
          return this._projectionTextureLightFar;
        },
        set: function(value) {
          this._projectionTextureLightFar = value;
          this._projectionTextureProjectionLightDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "projectionTextureUpDirection", {
        get: function() {
          return this._projectionTextureUpDirection;
        },
        set: function(value) {
          this._projectionTextureUpDirection = value;
          this._projectionTextureProjectionLightDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SpotLight2.prototype, "projectionTexture", {
        get: function() {
          return this._projectionTexture;
        },
        set: function(value) {
          var _this = this;
          if (this._projectionTexture === value) {
            return;
          }
          this._projectionTexture = value;
          this._projectionTextureDirty = true;
          if (this._projectionTexture && !this._projectionTexture.isReady()) {
            if (SpotLight2._IsProceduralTexture(this._projectionTexture)) {
              this._projectionTexture.getEffect().executeWhenCompiled(function() {
                _this._markMeshesAsLightDirty();
              });
            } else if (SpotLight2._IsTexture(this._projectionTexture)) {
              this._projectionTexture.onLoadObservable.addOnce(function() {
                _this._markMeshesAsLightDirty();
              });
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      SpotLight2._IsProceduralTexture = function(texture) {
        return texture.onGeneratedObservable !== void 0;
      };
      SpotLight2._IsTexture = function(texture) {
        return texture.onLoadObservable !== void 0;
      };
      Object.defineProperty(SpotLight2.prototype, "projectionTextureProjectionLightMatrix", {
        get: function() {
          return this._projectionTextureProjectionLightMatrix;
        },
        set: function(projection) {
          this._projectionTextureProjectionLightMatrix = projection;
          this._projectionTextureProjectionLightDirty = false;
          this._projectionTextureDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      SpotLight2.prototype.getClassName = function() {
        return "SpotLight";
      };
      SpotLight2.prototype.getTypeID = function() {
        return Light.LIGHTTYPEID_SPOTLIGHT;
      };
      SpotLight2.prototype._setDirection = function(value) {
        _super.prototype._setDirection.call(this, value);
        this._projectionTextureViewLightDirty = true;
      };
      SpotLight2.prototype._setPosition = function(value) {
        _super.prototype._setPosition.call(this, value);
        this._projectionTextureViewLightDirty = true;
      };
      SpotLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
        var activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        this._shadowAngleScale = this._shadowAngleScale || 1;
        var angle = this._shadowAngleScale * this._angle;
        var minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        var maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        var useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(angle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      };
      SpotLight2.prototype._computeProjectionTextureViewLightMatrix = function() {
        this._projectionTextureViewLightDirty = false;
        this._projectionTextureDirty = true;
        this.position.addToRef(this.direction, this._projectionTextureViewTargetVector);
        Matrix.LookAtLHToRef(this.position, this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);
      };
      SpotLight2.prototype._computeProjectionTextureProjectionLightMatrix = function() {
        this._projectionTextureProjectionLightDirty = false;
        this._projectionTextureDirty = true;
        var lightFar = this.projectionTextureLightFar;
        var lightNear = this.projectionTextureLightNear;
        var P = lightFar / (lightFar - lightNear);
        var Q = -P * lightNear;
        var S = 1 / Math.tan(this._angle / 2);
        var A = 1;
        Matrix.FromValuesToRef(S / A, 0, 0, 0, 0, S, 0, 0, 0, 0, P, 1, 0, 0, Q, 0, this._projectionTextureProjectionLightMatrix);
      };
      SpotLight2.prototype._computeProjectionTextureMatrix = function() {
        this._projectionTextureDirty = false;
        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);
        if (this._projectionTexture instanceof Texture) {
          var u = this._projectionTexture.uScale / 2;
          var v = this._projectionTexture.vScale / 2;
          Matrix.FromValuesToRef(u, 0, 0, 0, 0, v, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1, this._projectionTextureScalingMatrix);
        }
        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);
      };
      SpotLight2.prototype._buildUniformLayout = function() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightDirection", 3);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      };
      SpotLight2.prototype._computeAngleValues = function() {
        this._lightAngleScale = 1 / Math.max(1e-3, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);
        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;
      };
      SpotLight2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
        if (this.projectionTexture && this.projectionTexture.isReady()) {
          if (this._projectionTextureViewLightDirty) {
            this._computeProjectionTextureViewLightMatrix();
          }
          if (this._projectionTextureProjectionLightDirty) {
            this._computeProjectionTextureProjectionLightMatrix();
          }
          if (this._projectionTextureDirty) {
            this._computeProjectionTextureMatrix();
          }
          effect.setMatrix("textureProjectionMatrix" + lightIndex, this._projectionTextureMatrix);
          effect.setTexture("projectionLightSampler" + lightIndex, this.projectionTexture);
        }
        return this;
      };
      SpotLight2.prototype.transferToEffect = function(effect, lightIndex) {
        var normalizeDirection;
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        this._uniformBuffer.updateFloat4("vLightDirection", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);
        return this;
      };
      SpotLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
        var normalizeDirection;
        if (this.computeTransformedInformation()) {
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        if (this.getScene().useRightHandedSystem) {
          effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);
        } else {
          effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        }
        return this;
      };
      SpotLight2.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        if (this._projectionTexture) {
          this._projectionTexture.dispose();
        }
      };
      SpotLight2.prototype.getDepthMinZ = function(activeCamera) {
        var engine = this._scene.getEngine();
        var minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;
      };
      SpotLight2.prototype.getDepthMaxZ = function(activeCamera) {
        var engine = this._scene.getEngine();
        var maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;
      };
      SpotLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
        defines["SPOTLIGHT" + lightIndex] = true;
        defines["PROJECTEDLIGHTTEXTURE" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;
      };
      __decorate([
        serialize()
      ], SpotLight2.prototype, "angle", null);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "innerAngle", null);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "shadowAngleScale", null);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "exponent", void 0);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "projectionTextureLightNear", null);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "projectionTextureLightFar", null);
      __decorate([
        serialize()
      ], SpotLight2.prototype, "projectionTextureUpDirection", null);
      __decorate([
        serializeAsTexture("projectedLightTexture")
      ], SpotLight2.prototype, "_projectionTexture", void 0);
      return SpotLight2;
    }(ShadowLight);
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js
var init_engine_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js"() {
    init_tslib_es6();
    init_thinEngine();
    init_internalTexture();
    init_logger();
    init_fileTools();
    init_guid();
    ThinEngine.prototype._createDepthStencilCubeTexture = function(size, options, rtWrapper) {
      var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
      internalTexture.isCube = true;
      if (this.webGLVersion === 1) {
        Logger.Error("Depth cube texture is not supported by WebGL 1.");
        return internalTexture;
      }
      var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
      var gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);
      this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
      rtWrapper._depthStencilTexture = internalTexture;
      rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;
      for (var face = 0; face < 6; face++) {
        if (internalOptions.generateStencil) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);
        } else {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
        }
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      this._internalTexturesCache.push(internalTexture);
      return internalTexture;
    };
    ThinEngine.prototype._partialLoadFile = function(url, index, loadedFiles, onfinish, onErrorCallBack) {
      if (onErrorCallBack === void 0) {
        onErrorCallBack = null;
      }
      var onload = function(data) {
        loadedFiles[index] = data;
        loadedFiles._internalCount++;
        if (loadedFiles._internalCount === 6) {
          onfinish(loadedFiles);
        }
      };
      var onerror = function(request, exception) {
        if (onErrorCallBack && request) {
          onErrorCallBack(request.status + " " + request.statusText, exception);
        }
      };
      this._loadFile(url, onload, void 0, void 0, true, onerror);
    };
    ThinEngine.prototype._cascadeLoadFiles = function(scene, onfinish, files, onError) {
      if (onError === void 0) {
        onError = null;
      }
      var loadedFiles = [];
      loadedFiles._internalCount = 0;
      for (var index = 0; index < 6; index++) {
        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
      }
    };
    ThinEngine.prototype._cascadeLoadImgs = function(scene, texture, onfinish, files, onError, mimeType) {
      if (onError === void 0) {
        onError = null;
      }
      var loadedImages = [];
      loadedImages._internalCount = 0;
      for (var index = 0; index < 6; index++) {
        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);
      }
    };
    ThinEngine.prototype._partialLoadImg = function(url, index, loadedImages, scene, texture, onfinish, onErrorCallBack, mimeType) {
      if (onErrorCallBack === void 0) {
        onErrorCallBack = null;
      }
      var tokenPendingData = RandomGUID();
      var onload = function(img) {
        loadedImages[index] = img;
        loadedImages._internalCount++;
        if (scene) {
          scene._removePendingData(tokenPendingData);
        }
        if (loadedImages._internalCount === 6 && onfinish) {
          onfinish(texture, loadedImages);
        }
      };
      var onerror = function(message, exception) {
        if (scene) {
          scene._removePendingData(tokenPendingData);
        }
        if (onErrorCallBack) {
          onErrorCallBack(message, exception);
        }
      };
      LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
      if (scene) {
        scene._addPendingData(tokenPendingData);
      }
    };
    ThinEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap, maxLevel) {
      var gl = this._gl;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      texture.samplingMode = loadMipmap ? 3 : 2;
      if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== void 0 && maxLevel > 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);
        texture._maxLodLevel = maxLevel;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    };
    ThinEngine.prototype.createCubeTextureBase = function(rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer) {
      var _this = this;
      if (onLoad === void 0) {
        onLoad = null;
      }
      if (onError === void 0) {
        onError = null;
      }
      if (forcedExtension === void 0) {
        forcedExtension = null;
      }
      if (createPolynomials === void 0) {
        createPolynomials = false;
      }
      if (lodScale === void 0) {
        lodScale = 0;
      }
      if (lodOffset === void 0) {
        lodOffset = 0;
      }
      if (fallback === void 0) {
        fallback = null;
      }
      if (beforeLoadCubeDataCallback === void 0) {
        beforeLoadCubeDataCallback = null;
      }
      if (imageHandler === void 0) {
        imageHandler = null;
      }
      if (useSRGBBuffer === void 0) {
        useSRGBBuffer = false;
      }
      var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
      texture.isCube = true;
      texture.url = rootUrl;
      texture.generateMipMaps = !noMipmap;
      texture._lodGenerationScale = lodScale;
      texture._lodGenerationOffset = lodOffset;
      texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);
      if (!this._doNotHandleContextLost) {
        texture._extension = forcedExtension;
        texture._files = files;
      }
      var originalRootUrl = rootUrl;
      if (this._transformTextureUrl && !fallback) {
        rootUrl = this._transformTextureUrl(rootUrl);
      }
      var lastDot = rootUrl.lastIndexOf(".");
      var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "";
      var loader = null;
      for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {
        var availableLoader = _a[_i];
        if (availableLoader.canLoad(extension)) {
          loader = availableLoader;
          break;
        }
      }
      var onInternalError = function(request, exception) {
        if (rootUrl === originalRootUrl) {
          if (onError && request) {
            onError(request.status + " " + request.statusText, exception);
          }
        } else {
          Logger.Warn("Failed to load ".concat(rootUrl, ", falling back to the ").concat(originalRootUrl));
          _this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);
        }
      };
      if (loader) {
        var onloaddata_1 = function(data) {
          if (beforeLoadCubeDataCallback) {
            beforeLoadCubeDataCallback(texture, data);
          }
          loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);
        };
        if (files && files.length === 6) {
          if (loader.supportCascades) {
            this._cascadeLoadFiles(scene, function(images) {
              return onloaddata_1(images.map(function(image) {
                return new Uint8Array(image);
              }));
            }, files, onError);
          } else {
            if (onError) {
              onError("Textures type does not support cascades.");
            } else {
              Logger.Warn("Texture loader does not support cascades.");
            }
          }
        } else {
          this._loadFile(rootUrl, function(data) {
            return onloaddata_1(new Uint8Array(data));
          }, void 0, void 0, true, onInternalError);
        }
      } else {
        if (!files) {
          throw new Error("Cannot load cubemap because files were not defined");
        }
        this._cascadeLoadImgs(scene, texture, function(texture2, imgs) {
          if (imageHandler) {
            imageHandler(texture2, imgs);
          }
        }, files, onError);
      }
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, loaderOptions, useSRGBBuffer) {
      var _this = this;
      if (onLoad === void 0) {
        onLoad = null;
      }
      if (onError === void 0) {
        onError = null;
      }
      if (forcedExtension === void 0) {
        forcedExtension = null;
      }
      if (createPolynomials === void 0) {
        createPolynomials = false;
      }
      if (lodScale === void 0) {
        lodScale = 0;
      }
      if (lodOffset === void 0) {
        lodOffset = 0;
      }
      if (fallback === void 0) {
        fallback = null;
      }
      if (useSRGBBuffer === void 0) {
        useSRGBBuffer = false;
      }
      var gl = this._gl;
      return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, function(texture) {
        return _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      }, function(texture, imgs) {
        var width = _this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize) : imgs[0].width;
        var height = width;
        var faces = [
          gl.TEXTURE_CUBE_MAP_POSITIVE_X,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        _this._unpackFlipY(false);
        var internalFormat = format ? _this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;
        var texelFormat = format ? _this._getInternalFormat(format) : gl.RGBA;
        if (texture._useSRGBBuffer && _this.webGLVersion === 1) {
          texelFormat = internalFormat;
        }
        for (var index = 0; index < faces.length; index++) {
          if (imgs[index].width !== width || imgs[index].height !== height) {
            _this._prepareWorkingCanvas();
            if (!_this._workingCanvas || !_this._workingContext) {
              Logger.Warn("Cannot create canvas to resize texture.");
              return;
            }
            _this._workingCanvas.width = width;
            _this._workingCanvas.height = height;
            _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);
            gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
          } else {
            gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);
          }
        }
        if (!noMipmap) {
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        _this._setCubeMapTextureParams(texture, !noMipmap);
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        if (format) {
          texture.format = format;
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
          onLoad();
        }
      }, !!useSRGBBuffer);
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var CubeTexture;
var init_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_math_vector();
    init_baseTexture();
    init_texture();
    init_typeStore();
    init_engine_cubeTexture();
    init_stringTools();
    init_observable();
    CubeTexture = function(_super) {
      __extends(CubeTexture2, _super);
      function CubeTexture2(rootUrl, sceneOrEngine, extensions, noMipmap, files, onLoad, onError, format, prefiltered, forcedExtension, createPolynomials, lodScale, lodOffset, loaderOptions, useSRGBBuffer) {
        if (extensions === void 0) {
          extensions = null;
        }
        if (noMipmap === void 0) {
          noMipmap = false;
        }
        if (files === void 0) {
          files = null;
        }
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (format === void 0) {
          format = 5;
        }
        if (prefiltered === void 0) {
          prefiltered = false;
        }
        if (forcedExtension === void 0) {
          forcedExtension = null;
        }
        if (createPolynomials === void 0) {
          createPolynomials = false;
        }
        if (lodScale === void 0) {
          lodScale = 0.8;
        }
        if (lodOffset === void 0) {
          lodOffset = 0;
        }
        var _this = this;
        var _a;
        _this = _super.call(this, sceneOrEngine) || this;
        _this._lodScale = 0.8;
        _this._lodOffset = 0;
        _this.onLoadObservable = new Observable();
        _this.boundingBoxPosition = Vector3.Zero();
        _this._rotationY = 0;
        _this._files = null;
        _this._forcedExtension = null;
        _this._extensions = null;
        _this.name = rootUrl;
        _this.url = rootUrl;
        _this._noMipmap = noMipmap;
        _this.hasAlpha = false;
        _this._format = format;
        _this.isCube = true;
        _this._textureMatrix = Matrix.Identity();
        _this._createPolynomials = createPolynomials;
        _this.coordinatesMode = Texture.CUBIC_MODE;
        _this._extensions = extensions;
        _this._files = files;
        _this._forcedExtension = forcedExtension;
        _this._loaderOptions = loaderOptions;
        _this._useSRGBBuffer = useSRGBBuffer;
        _this._lodScale = lodScale;
        _this._lodOffset = lodOffset;
        if (!rootUrl && !files) {
          return _this;
        }
        _this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading, files);
        return _this;
      }
      Object.defineProperty(CubeTexture2.prototype, "boundingBoxSize", {
        get: function() {
          return this._boundingBoxSize;
        },
        set: function(value) {
          if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
            return;
          }
          this._boundingBoxSize = value;
          var scene = this.getScene();
          if (scene) {
            scene.markAllMaterialsAsDirty(1);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CubeTexture2.prototype, "rotationY", {
        get: function() {
          return this._rotationY;
        },
        set: function(value) {
          this._rotationY = value;
          this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CubeTexture2.prototype, "noMipmap", {
        get: function() {
          return this._noMipmap;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CubeTexture2.prototype, "forcedExtension", {
        get: function() {
          return this._forcedExtension;
        },
        enumerable: false,
        configurable: true
      });
      CubeTexture2.CreateFromImages = function(files, scene, noMipmap) {
        var rootUrlKey = "";
        files.forEach(function(url) {
          return rootUrlKey += url;
        });
        return new CubeTexture2(rootUrlKey, scene, null, noMipmap, files);
      };
      CubeTexture2.CreateFromPrefilteredData = function(url, scene, forcedExtension, createPolynomials) {
        if (forcedExtension === void 0) {
          forcedExtension = null;
        }
        if (createPolynomials === void 0) {
          createPolynomials = true;
        }
        var oldValue = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        var result = new CubeTexture2(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
        scene.useDelayedTextureLoading = oldValue;
        return result;
      };
      CubeTexture2.prototype.getClassName = function() {
        return "CubeTexture";
      };
      CubeTexture2.prototype.updateURL = function(url, forcedExtension, onLoad, prefiltered, onError, extensions, delayLoad, files) {
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (prefiltered === void 0) {
          prefiltered = false;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (extensions === void 0) {
          extensions = null;
        }
        if (delayLoad === void 0) {
          delayLoad = false;
        }
        if (files === void 0) {
          files = null;
        }
        if (!this.name || StartsWith(this.name, "data:")) {
          this.name = url;
        }
        this.url = url;
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        var lastDot = url.lastIndexOf(".");
        var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        var isDDS = extension.indexOf(".dds") === 0;
        var isEnv = extension.indexOf(".env") === 0;
        if (isEnv) {
          this.gammaSpace = false;
          this._prefiltered = false;
          this.anisotropicFilteringLevel = 1;
        } else {
          this._prefiltered = prefiltered;
          if (prefiltered) {
            this.gammaSpace = false;
            this.anisotropicFilteringLevel = 1;
          }
        }
        if (files) {
          this._files = files;
        } else {
          if (!isEnv && !isDDS && !extensions) {
            extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
          }
          this._files = this._files || [];
          this._files.length = 0;
          if (extensions) {
            for (var index = 0; index < extensions.length; index++) {
              this._files.push(url + extensions[index]);
            }
            this._extensions = extensions;
          }
        }
        if (delayLoad) {
          this.delayLoadState = 4;
          this._delayedOnLoad = onLoad;
          this._delayedOnError = onError;
        } else {
          this._loadTexture(onLoad, onError);
        }
      };
      CubeTexture2.prototype.delayLoad = function(forcedExtension) {
        if (this.delayLoadState !== 4) {
          return;
        }
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        this.delayLoadState = 1;
        this._loadTexture(this._delayedOnLoad, this._delayedOnError);
      };
      CubeTexture2.prototype.getReflectionTextureMatrix = function() {
        return this._textureMatrix;
      };
      CubeTexture2.prototype.setReflectionTextureMatrix = function(value) {
        var _this = this;
        var _a;
        if (value.updateFlag === this._textureMatrix.updateFlag) {
          return;
        }
        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
          (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function(mat) {
            return mat.getActiveTextures().indexOf(_this) !== -1;
          });
        }
        this._textureMatrix = value;
      };
      CubeTexture2.prototype._loadTexture = function(onLoad, onError) {
        var _this = this;
        var _a;
        if (onLoad === void 0) {
          onLoad = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        var scene = this.getScene();
        var oldTexture = this._texture;
        this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer);
        var onLoadProcessing = function() {
          var _a2;
          _this.onLoadObservable.notifyObservers(_this);
          if (oldTexture) {
            oldTexture.dispose();
            (_a2 = _this.getScene()) === null || _a2 === void 0 ? void 0 : _a2.markAllMaterialsAsDirty(1);
          }
          if (onLoad) {
            onLoad();
          }
        };
        var errorHandler = function(message, exception) {
          _this._loadingError = true;
          _this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture.OnTextureLoadErrorObservable.notifyObservers(_this);
        };
        if (!this._texture) {
          if (this._prefiltered) {
            this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
          } else {
            this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);
          }
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function() {
            return _this.onLoadObservable.notifyObservers(_this);
          });
        } else {
          if (this._texture.isReady) {
            Tools.SetImmediate(function() {
              return onLoadProcessing();
            });
          } else {
            this._texture.onLoadedObservable.add(function() {
              return onLoadProcessing();
            });
          }
        }
      };
      CubeTexture2.Parse = function(parsedTexture, scene, rootUrl) {
        var texture = SerializationHelper.Parse(function() {
          var prefiltered = false;
          if (parsedTexture.prefiltered) {
            prefiltered = parsedTexture.prefiltered;
          }
          return new CubeTexture2(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
        }, parsedTexture, scene);
        if (parsedTexture.boundingBoxPosition) {
          texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
        }
        if (parsedTexture.boundingBoxSize) {
          texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
        }
        if (parsedTexture.animations) {
          for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
            var parsedAnimation = parsedTexture.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              texture.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
        }
        return texture;
      };
      CubeTexture2.prototype.clone = function() {
        var _this = this;
        var uniqueId = 0;
        var newCubeTexture = SerializationHelper.Clone(function() {
          var cubeTexture = new CubeTexture2(_this.url, _this.getScene() || _this._getEngine(), _this._extensions, _this._noMipmap, _this._files);
          uniqueId = cubeTexture.uniqueId;
          return cubeTexture;
        }, this);
        newCubeTexture.uniqueId = uniqueId;
        return newCubeTexture;
      };
      __decorate([
        serialize()
      ], CubeTexture2.prototype, "url", void 0);
      __decorate([
        serialize("rotationY")
      ], CubeTexture2.prototype, "rotationY", null);
      __decorate([
        serialize("files")
      ], CubeTexture2.prototype, "_files", void 0);
      __decorate([
        serialize("forcedExtension")
      ], CubeTexture2.prototype, "_forcedExtension", void 0);
      __decorate([
        serialize("extensions")
      ], CubeTexture2.prototype, "_extensions", void 0);
      __decorate([
        serializeAsMatrix("textureMatrix")
      ], CubeTexture2.prototype, "_textureMatrix", void 0);
      return CubeTexture2;
    }(BaseTexture);
    Texture._CubeTextureParser = CubeTexture.Parse;
    RegisterClass("BABYLON.CubeTexture", CubeTexture);
  }
});

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture, _instanceNumber, GetEnvironmentBRDFTexture, BRDFTextureTools;
var init_brdfTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/brdfTextureTools.js"() {
    init_texture();
    init_rgbdTextureTools();
    init_tools();
    _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
    _instanceNumber = 0;
    GetEnvironmentBRDFTexture = function(scene) {
      if (!scene.environmentBRDFTexture) {
        var useDelayedTextureLoading = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        var previousState = scene._blockEntityCollection;
        scene._blockEntityCollection = false;
        var texture_1 = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
        scene._blockEntityCollection = previousState;
        var texturesCache = scene.getEngine().getLoadedTexturesCache();
        var index = texturesCache.indexOf(texture_1.getInternalTexture());
        if (index !== -1) {
          texturesCache.splice(index, 1);
        }
        texture_1.isRGBD = true;
        texture_1.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture_1.wrapV = Texture.CLAMP_ADDRESSMODE;
        scene.environmentBRDFTexture = texture_1;
        scene.useDelayedTextureLoading = useDelayedTextureLoading;
        RGBDTextureTools.ExpandRGBDTexture(texture_1);
        var observer_1 = scene.getEngine().onContextRestoredObservable.add(function() {
          texture_1.isRGBD = true;
          var checkReady = function() {
            if (texture_1.isReady()) {
              RGBDTextureTools.ExpandRGBDTexture(texture_1);
            } else {
              Tools.SetImmediate(checkReady);
            }
          };
          checkReady();
        });
        scene.onDisposeObservable.add(function() {
          scene.getEngine().onContextRestoredObservable.remove(observer_1);
        });
      }
      return scene.environmentBRDFTexture;
    };
    BRDFTextureTools = {
      GetEnvironmentBRDFTexture
    };
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines, PBRClearCoatConfiguration;
var init_pbrClearCoatConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialClearCoatDefines = function(_super) {
      __extends(MaterialClearCoatDefines2, _super);
      function MaterialClearCoatDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.CLEARCOAT = false;
        _this.CLEARCOAT_DEFAULTIOR = false;
        _this.CLEARCOAT_TEXTURE = false;
        _this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
        _this.CLEARCOAT_TEXTUREDIRECTUV = 0;
        _this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
        _this.CLEARCOAT_BUMP = false;
        _this.CLEARCOAT_BUMPDIRECTUV = 0;
        _this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        _this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
        _this.CLEARCOAT_REMAP_F0 = false;
        _this.CLEARCOAT_TINT = false;
        _this.CLEARCOAT_TINT_TEXTURE = false;
        _this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
        _this.CLEARCOAT_TINT_GAMMATEXTURE = false;
        return _this;
      }
      return MaterialClearCoatDefines2;
    }(MaterialDefines);
    PBRClearCoatConfiguration = function(_super) {
      __extends(PBRClearCoatConfiguration2, _super);
      function PBRClearCoatConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList) || this;
        _this._isEnabled = false;
        _this.isEnabled = false;
        _this.intensity = 1;
        _this.roughness = 0;
        _this._indexOfRefraction = PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
        _this.indexOfRefraction = PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
        _this._texture = null;
        _this.texture = null;
        _this._useRoughnessFromMainTexture = true;
        _this.useRoughnessFromMainTexture = true;
        _this._textureRoughness = null;
        _this.textureRoughness = null;
        _this._remapF0OnInterfaceChange = true;
        _this.remapF0OnInterfaceChange = true;
        _this._bumpTexture = null;
        _this.bumpTexture = null;
        _this._isTintEnabled = false;
        _this.isTintEnabled = false;
        _this.tintColor = Color3.White();
        _this.tintColorAtDistance = 1;
        _this.tintThickness = 1;
        _this._tintTexture = null;
        _this.tintTexture = null;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        return _this;
      }
      PBRClearCoatConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      PBRClearCoatConfiguration2.prototype.isReadyForSubMesh = function(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        var disableBumpMap = this._material._disableBumpMap;
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              if (!this._tintTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      PBRClearCoatConfiguration2.prototype.prepareDefines = function(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.CLEARCOAT = true;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
          defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
              } else {
                defines.CLEARCOAT_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
              } else {
                defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
              }
              if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
              } else {
                defines.CLEARCOAT_BUMP = false;
              }
              defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration2._DefaultIndexOfRefraction;
              if (this._isTintEnabled) {
                defines.CLEARCOAT_TINT = true;
                if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
                  defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
                } else {
                  defines.CLEARCOAT_TINT_TEXTURE = false;
                }
              } else {
                defines.CLEARCOAT_TINT = false;
                defines.CLEARCOAT_TINT_TEXTURE = false;
              }
            }
          }
        } else {
          defines.CLEARCOAT = false;
          defines.CLEARCOAT_TEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          defines.CLEARCOAT_BUMP = false;
          defines.CLEARCOAT_TINT = false;
          defines.CLEARCOAT_TINT_TEXTURE = false;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
        }
      };
      PBRClearCoatConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        var defines = subMesh.materialDefines;
        var isFrozen = this._material.isFrozen;
        var disableBumpMap = this._material._disableBumpMap;
        var invertNormalMapX = this._material._invertNormalMapX;
        var invertNormalMapY = this._material._invertNormalMapY;
        var identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
          } else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
            }
            if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
            uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
            if (scene._mirroredCameraPosition) {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
            } else {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
            }
          }
          if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
            MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
          }
          uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
          var a = 1 - this._indexOfRefraction;
          var b = 1 + this._indexOfRefraction;
          var f0 = Math.pow(-a / b, 2);
          var eta = 1 / this._indexOfRefraction;
          uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
          if (this._isTintEnabled) {
            uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
            uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatSampler", this._texture);
          }
          if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
            uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
          }
          if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
          }
        }
      };
      PBRClearCoatConfiguration2.prototype.hasTexture = function(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._tintTexture === texture) {
          return true;
        }
        return false;
      };
      PBRClearCoatConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._tintTexture) {
          activeTextures.push(this._tintTexture);
        }
      };
      PBRClearCoatConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          animatables.push(this._bumpTexture);
        }
        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
          animatables.push(this._tintTexture);
        }
      };
      PBRClearCoatConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        var _a, _b, _c, _d;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._bumpTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._tintTexture) === null || _d === void 0 ? void 0 : _d.dispose();
        }
      };
      PBRClearCoatConfiguration2.prototype.getClassName = function() {
        return "PBRClearCoatConfiguration";
      };
      PBRClearCoatConfiguration2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        if (defines.CLEARCOAT_BUMP) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
        }
        if (defines.CLEARCOAT_TINT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
        }
        if (defines.CLEARCOAT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT");
        }
        return currentRank;
      };
      PBRClearCoatConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
      };
      PBRClearCoatConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vClearCoatParams", size: 2, type: "vec2" },
            { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
            { name: "vClearCoatInfos", size: 4, type: "vec4" },
            { name: "clearCoatMatrix", size: 16, type: "mat4" },
            { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
            { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
            { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatTintParams", size: 4, type: "vec4" },
            { name: "clearCoatColorAtDistance", size: 1, type: "float" },
            { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
            { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
          ]
        };
      };
      PBRClearCoatConfiguration2._DefaultIndexOfRefraction = 1.5;
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "isEnabled", void 0);
      __decorate([
        serialize()
      ], PBRClearCoatConfiguration2.prototype, "intensity", void 0);
      __decorate([
        serialize()
      ], PBRClearCoatConfiguration2.prototype, "roughness", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "indexOfRefraction", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "texture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "useRoughnessFromMainTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "textureRoughness", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "remapF0OnInterfaceChange", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "bumpTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "isTintEnabled", void 0);
      __decorate([
        serializeAsColor3()
      ], PBRClearCoatConfiguration2.prototype, "tintColor", void 0);
      __decorate([
        serialize()
      ], PBRClearCoatConfiguration2.prototype, "tintColorAtDistance", void 0);
      __decorate([
        serialize()
      ], PBRClearCoatConfiguration2.prototype, "tintThickness", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRClearCoatConfiguration2.prototype, "tintTexture", void 0);
      return PBRClearCoatConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines, PBRIridescenceConfiguration;
var init_pbrIridescenceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialIridescenceDefines = function(_super) {
      __extends(MaterialIridescenceDefines2, _super);
      function MaterialIridescenceDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.IRIDESCENCE = false;
        _this.IRIDESCENCE_TEXTURE = false;
        _this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
        _this.IRIDESCENCE_THICKNESS_TEXTURE = false;
        _this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
        _this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
        return _this;
      }
      return MaterialIridescenceDefines2;
    }(MaterialDefines);
    PBRIridescenceConfiguration = function(_super) {
      __extends(PBRIridescenceConfiguration2, _super);
      function PBRIridescenceConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList) || this;
        _this._isEnabled = false;
        _this.isEnabled = false;
        _this.intensity = 1;
        _this.minimumThickness = PBRIridescenceConfiguration2._DefaultMinimumThickness;
        _this.maximumThickness = PBRIridescenceConfiguration2._DefaultMaximumThickness;
        _this.indexOfRefraction = PBRIridescenceConfiguration2._DefaultIndexOfRefraction;
        _this._texture = null;
        _this.texture = null;
        _this._thicknessTexture = null;
        _this.thicknessTexture = null;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        return _this;
      }
      PBRIridescenceConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      PBRIridescenceConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      PBRIridescenceConfiguration2.prototype.prepareDefines = function(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.IRIDESCENCE = true;
          defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = this._texture !== null && this._texture._texture === ((_a = this._thicknessTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._thicknessTexture);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
              } else {
                defines.IRIDESCENCE_TEXTURE = false;
              }
              if (!defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
              } else {
                defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
              }
            }
          }
        } else {
          defines.IRIDESCENCE = false;
          defines.IRIDESCENCE_TEXTURE = false;
          defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
        }
      };
      PBRIridescenceConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        var defines = subMesh.materialDefines;
        var isFrozen = this._material.isFrozen;
        var identicalTextures = defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
          } else if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._thicknessTexture) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._thicknessTexture) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
            }
            if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
            }
          }
          uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceSampler", this._texture);
          }
          if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
          }
        }
      };
      PBRIridescenceConfiguration2.prototype.hasTexture = function(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._thicknessTexture === texture) {
          return true;
        }
        return false;
      };
      PBRIridescenceConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
      };
      PBRIridescenceConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
      };
      PBRIridescenceConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._thicknessTexture) === null || _b === void 0 ? void 0 : _b.dispose();
        }
      };
      PBRIridescenceConfiguration2.prototype.getClassName = function() {
        return "PBRIridescenceConfiguration";
      };
      PBRIridescenceConfiguration2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        if (defines.IRIDESCENCE) {
          fallbacks.addFallback(currentRank++, "IRIDESCENCE");
        }
        return currentRank;
      };
      PBRIridescenceConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
      };
      PBRIridescenceConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vIridescenceParams", size: 4, type: "vec4" },
            { name: "vIridescenceInfos", size: 4, type: "vec4" },
            { name: "iridescenceMatrix", size: 16, type: "mat4" },
            { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
          ]
        };
      };
      PBRIridescenceConfiguration2._DefaultMinimumThickness = 100;
      PBRIridescenceConfiguration2._DefaultMaximumThickness = 400;
      PBRIridescenceConfiguration2._DefaultIndexOfRefraction = 1.3;
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRIridescenceConfiguration2.prototype, "isEnabled", void 0);
      __decorate([
        serialize()
      ], PBRIridescenceConfiguration2.prototype, "intensity", void 0);
      __decorate([
        serialize()
      ], PBRIridescenceConfiguration2.prototype, "minimumThickness", void 0);
      __decorate([
        serialize()
      ], PBRIridescenceConfiguration2.prototype, "maximumThickness", void 0);
      __decorate([
        serialize()
      ], PBRIridescenceConfiguration2.prototype, "indexOfRefraction", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRIridescenceConfiguration2.prototype, "texture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRIridescenceConfiguration2.prototype, "thicknessTexture", void 0);
      return PBRIridescenceConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines, PBRAnisotropicConfiguration;
var init_pbrAnisotropicConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_buffer();
    init_math_vector();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialAnisotropicDefines = function(_super) {
      __extends(MaterialAnisotropicDefines2, _super);
      function MaterialAnisotropicDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ANISOTROPIC = false;
        _this.ANISOTROPIC_TEXTURE = false;
        _this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
        _this.MAINUV1 = false;
        return _this;
      }
      return MaterialAnisotropicDefines2;
    }(MaterialDefines);
    PBRAnisotropicConfiguration = function(_super) {
      __extends(PBRAnisotropicConfiguration2, _super);
      function PBRAnisotropicConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList) || this;
        _this._isEnabled = false;
        _this.isEnabled = false;
        _this.intensity = 1;
        _this.direction = new Vector2(1, 0);
        _this._texture = null;
        _this.texture = null;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        return _this;
      }
      PBRAnisotropicConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      PBRAnisotropicConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      PBRAnisotropicConfiguration2.prototype.prepareDefines = function(defines, scene, mesh) {
        if (this._isEnabled) {
          defines.ANISOTROPIC = this._isEnabled;
          if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
              } else {
                defines.ANISOTROPIC_TEXTURE = false;
              }
            }
          }
        } else {
          defines.ANISOTROPIC = false;
          defines.ANISOTROPIC_TEXTURE = false;
        }
      };
      PBRAnisotropicConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        var isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
          }
          uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.setTexture("anisotropySampler", this._texture);
          }
        }
      };
      PBRAnisotropicConfiguration2.prototype.hasTexture = function(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      };
      PBRAnisotropicConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      };
      PBRAnisotropicConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      };
      PBRAnisotropicConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._texture) {
            this._texture.dispose();
          }
        }
      };
      PBRAnisotropicConfiguration2.prototype.getClassName = function() {
        return "PBRAnisotropicConfiguration";
      };
      PBRAnisotropicConfiguration2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        if (defines.ANISOTROPIC) {
          fallbacks.addFallback(currentRank++, "ANISOTROPIC");
        }
        return currentRank;
      };
      PBRAnisotropicConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("anisotropySampler");
      };
      PBRAnisotropicConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vAnisotropy", size: 3, type: "vec3" },
            { name: "vAnisotropyInfos", size: 2, type: "vec2" },
            { name: "anisotropyMatrix", size: 16, type: "mat4" }
          ]
        };
      };
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRAnisotropicConfiguration2.prototype, "isEnabled", void 0);
      __decorate([
        serialize()
      ], PBRAnisotropicConfiguration2.prototype, "intensity", void 0);
      __decorate([
        serializeAsVector2()
      ], PBRAnisotropicConfiguration2.prototype, "direction", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRAnisotropicConfiguration2.prototype, "texture", void 0);
      return PBRAnisotropicConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines, PBRSheenConfiguration;
var init_pbrSheenConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialSheenDefines = function(_super) {
      __extends(MaterialSheenDefines2, _super);
      function MaterialSheenDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.SHEEN = false;
        _this.SHEEN_TEXTURE = false;
        _this.SHEEN_GAMMATEXTURE = false;
        _this.SHEEN_TEXTURE_ROUGHNESS = false;
        _this.SHEEN_TEXTUREDIRECTUV = 0;
        _this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        _this.SHEEN_LINKWITHALBEDO = false;
        _this.SHEEN_ROUGHNESS = false;
        _this.SHEEN_ALBEDOSCALING = false;
        _this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        _this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
        return _this;
      }
      return MaterialSheenDefines2;
    }(MaterialDefines);
    PBRSheenConfiguration = function(_super) {
      __extends(PBRSheenConfiguration2, _super);
      function PBRSheenConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList) || this;
        _this._isEnabled = false;
        _this.isEnabled = false;
        _this._linkSheenWithAlbedo = false;
        _this.linkSheenWithAlbedo = false;
        _this.intensity = 1;
        _this.color = Color3.White();
        _this._texture = null;
        _this.texture = null;
        _this._useRoughnessFromMainTexture = true;
        _this.useRoughnessFromMainTexture = true;
        _this._roughness = null;
        _this.roughness = null;
        _this._textureRoughness = null;
        _this.textureRoughness = null;
        _this._albedoScaling = false;
        _this.albedoScaling = false;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        return _this;
      }
      PBRSheenConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      PBRSheenConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.SheenTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      PBRSheenConfiguration2.prototype.prepareDefines = function(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.SHEEN = true;
          defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
          defines.SHEEN_ROUGHNESS = this._roughness !== null;
          defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.SheenTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
                defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
              } else {
                defines.SHEEN_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
              } else {
                defines.SHEEN_TEXTURE_ROUGHNESS = false;
              }
            }
          }
        } else {
          defines.SHEEN = false;
          defines.SHEEN_TEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS = false;
          defines.SHEEN_LINKWITHALBEDO = false;
          defines.SHEEN_ROUGHNESS = false;
          defines.SHEEN_ALBEDOSCALING = false;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
        }
      };
      PBRSheenConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        var defines = subMesh.materialDefines;
        var isFrozen = this._material.isFrozen;
        var identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
          } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
            }
            if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
            }
          }
          uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
          if (this._roughness !== null) {
            uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenSampler", this._texture);
          }
          if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
          }
        }
      };
      PBRSheenConfiguration2.prototype.hasTexture = function(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        return false;
      };
      PBRSheenConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
      };
      PBRSheenConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
      };
      PBRSheenConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
        }
      };
      PBRSheenConfiguration2.prototype.getClassName = function() {
        return "PBRSheenConfiguration";
      };
      PBRSheenConfiguration2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        if (defines.SHEEN) {
          fallbacks.addFallback(currentRank++, "SHEEN");
        }
        return currentRank;
      };
      PBRSheenConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("sheenSampler", "sheenRoughnessSampler");
      };
      PBRSheenConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vSheenColor", size: 4, type: "vec4" },
            { name: "vSheenRoughness", size: 1, type: "float" },
            { name: "vSheenInfos", size: 4, type: "vec4" },
            { name: "sheenMatrix", size: 16, type: "mat4" },
            { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
          ]
        };
      };
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "isEnabled", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "linkSheenWithAlbedo", void 0);
      __decorate([
        serialize()
      ], PBRSheenConfiguration2.prototype, "intensity", void 0);
      __decorate([
        serializeAsColor3()
      ], PBRSheenConfiguration2.prototype, "color", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "texture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "useRoughnessFromMainTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "roughness", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "textureRoughness", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSheenConfiguration2.prototype, "albedoScaling", void 0);
      return PBRSheenConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines, PBRSubSurfaceConfiguration;
var init_pbrSubSurfaceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_math_scalar();
    init_math_vector();
    init_materialPluginBase();
    init_materialDefines();
    MaterialSubSurfaceDefines = function(_super) {
      __extends(MaterialSubSurfaceDefines2, _super);
      function MaterialSubSurfaceDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.SUBSURFACE = false;
        _this.SS_REFRACTION = false;
        _this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
        _this.SS_TRANSLUCENCY = false;
        _this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
        _this.SS_SCATTERING = false;
        _this.SS_THICKNESSANDMASK_TEXTURE = false;
        _this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
        _this.SS_HAS_THICKNESS = false;
        _this.SS_REFRACTIONINTENSITY_TEXTURE = false;
        _this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
        _this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
        _this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
        _this.SS_REFRACTIONMAP_3D = false;
        _this.SS_REFRACTIONMAP_OPPOSITEZ = false;
        _this.SS_LODINREFRACTIONALPHA = false;
        _this.SS_GAMMAREFRACTION = false;
        _this.SS_RGBDREFRACTION = false;
        _this.SS_LINEARSPECULARREFRACTION = false;
        _this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
        _this.SS_ALBEDOFORREFRACTIONTINT = false;
        _this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
        _this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        _this.SS_USE_THICKNESS_AS_DEPTH = false;
        _this.SS_MASK_FROM_THICKNESS_TEXTURE = false;
        _this.SS_USE_GLTF_TEXTURES = false;
        return _this;
      }
      return MaterialSubSurfaceDefines2;
    }(MaterialDefines);
    PBRSubSurfaceConfiguration = function(_super) {
      __extends(PBRSubSurfaceConfiguration2, _super);
      function PBRSubSurfaceConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList) || this;
        _this._isRefractionEnabled = false;
        _this.isRefractionEnabled = false;
        _this._isTranslucencyEnabled = false;
        _this.isTranslucencyEnabled = false;
        _this._isScatteringEnabled = false;
        _this.isScatteringEnabled = false;
        _this._scatteringDiffusionProfileIndex = 0;
        _this.refractionIntensity = 1;
        _this.translucencyIntensity = 1;
        _this.useAlbedoToTintRefraction = false;
        _this.useAlbedoToTintTranslucency = false;
        _this._thicknessTexture = null;
        _this.thicknessTexture = null;
        _this._refractionTexture = null;
        _this.refractionTexture = null;
        _this._indexOfRefraction = 1.5;
        _this.indexOfRefraction = 1.5;
        _this._volumeIndexOfRefraction = -1;
        _this._invertRefractionY = false;
        _this.invertRefractionY = false;
        _this._linkRefractionWithTransparency = false;
        _this.linkRefractionWithTransparency = false;
        _this.minimumThickness = 0;
        _this.maximumThickness = 1;
        _this.useThicknessAsDepth = false;
        _this.tintColor = Color3.White();
        _this.tintColorAtDistance = 1;
        _this.diffusionDistance = Color3.White();
        _this._useMaskFromThicknessTexture = false;
        _this.useMaskFromThicknessTexture = false;
        _this._refractionIntensityTexture = null;
        _this.refractionIntensityTexture = null;
        _this._translucencyIntensityTexture = null;
        _this.translucencyIntensityTexture = null;
        _this._useGltfStyleTextures = false;
        _this.useGltfStyleTextures = false;
        _this._scene = material.getScene();
        _this.registerForExtraEvents = true;
        _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        _this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
        return _this;
      }
      Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "scatteringDiffusionProfile", {
        get: function() {
          if (!this._scene.subSurfaceConfiguration) {
            return null;
          }
          return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
        },
        set: function(c) {
          if (!this._scene.enableSubSurfaceForPrePass()) {
            return;
          }
          if (c) {
            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "volumeIndexOfRefraction", {
        get: function() {
          if (this._volumeIndexOfRefraction >= 1) {
            return this._volumeIndexOfRefraction;
          }
          return this._indexOfRefraction;
        },
        set: function(value) {
          if (value >= 1) {
            this._volumeIndexOfRefraction = value;
          } else {
            this._volumeIndexOfRefraction = -1;
          }
        },
        enumerable: false,
        configurable: true
      });
      PBRSubSurfaceConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      };
      PBRSubSurfaceConfiguration2.prototype._markScenePrePassDirty = function() {
        this._internalMarkAllSubMeshesAsTexturesDirty();
        this._internalMarkScenePrePassDirty();
      };
      PBRSubSurfaceConfiguration2.prototype.isReadyForSubMesh = function(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            var refractionTexture = this._getRefractionTexture(scene);
            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
              if (!refractionTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      PBRSubSurfaceConfiguration2.prototype.prepareDefines = function(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          defines.SUBSURFACE = false;
          defines.SS_TRANSLUCENCY = false;
          defines.SS_SCATTERING = false;
          defines.SS_REFRACTION = false;
          return;
        }
        if (defines._areTexturesDirty) {
          defines.SUBSURFACE = true;
          defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_SCATTERING = this._isScatteringEnabled;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          var refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;
          var translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;
          var useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
              }
              if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
              }
              if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
              }
            }
          }
          defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
          defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
          defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
          if (this._isRefractionEnabled) {
            if (scene.texturesEnabled) {
              var refractionTexture = this._getRefractionTexture(scene);
              if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
                defines.SS_REFRACTION = true;
                defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
                defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
                defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
                defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
                defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;
                defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
                defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
                defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
                defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
                defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
              }
            }
          }
          if (this._isTranslucencyEnabled) {
            defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
          }
        }
      };
      PBRSubSurfaceConfiguration2.prototype.hardBindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
        var thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
        uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
      };
      PBRSubSurfaceConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        var defines = subMesh.materialDefines;
        var isFrozen = this._material.isFrozen;
        var realTimeFiltering = this._material.realTimeFiltering;
        var lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
        var refractionTexture = this._getRefractionTexture(scene);
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
            MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
            MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
            MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getReflectionTextureMatrix());
            var depth = 1;
            if (!refractionTexture.isCube) {
              if (refractionTexture.depth) {
                depth = refractionTexture.depth;
              }
            }
            var width = refractionTexture.getSize().width;
            var refractionIor = this.volumeIndexOfRefraction;
            uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
            uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
            if (realTimeFiltering) {
              uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Scalar.Log2(width));
            }
            if (refractionTexture.boundingBoxSize) {
              var cubeTexture = refractionTexture;
              uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._isScatteringEnabled) {
            uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
          }
          uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
          uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
          uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
        }
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            if (lodBasedMicrosurface) {
              uniformBuffer.setTexture("refractionSampler", refractionTexture);
            } else {
              uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
            }
          }
        }
      };
      PBRSubSurfaceConfiguration2.prototype._getRefractionTexture = function(scene) {
        if (this._refractionTexture) {
          return this._refractionTexture;
        }
        if (this._isRefractionEnabled) {
          return scene.environmentTexture;
        }
        return null;
      };
      Object.defineProperty(PBRSubSurfaceConfiguration2.prototype, "disableAlphaBlending", {
        get: function() {
          return this._isRefractionEnabled && this._linkRefractionWithTransparency;
        },
        enumerable: false,
        configurable: true
      });
      PBRSubSurfaceConfiguration2.prototype.fillRenderTargetTextures = function(renderTargets) {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          renderTargets.push(this._refractionTexture);
        }
      };
      PBRSubSurfaceConfiguration2.prototype.hasTexture = function(texture) {
        if (this._thicknessTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        return false;
      };
      PBRSubSurfaceConfiguration2.prototype.hasRenderTargetTextures = function() {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return false;
      };
      PBRSubSurfaceConfiguration2.prototype.getActiveTextures = function(activeTextures) {
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
      };
      PBRSubSurfaceConfiguration2.prototype.getAnimatables = function(animatables) {
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          animatables.push(this._refractionTexture);
        }
      };
      PBRSubSurfaceConfiguration2.prototype.dispose = function(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._thicknessTexture) {
            this._thicknessTexture.dispose();
          }
          if (this._refractionTexture) {
            this._refractionTexture.dispose();
          }
        }
      };
      PBRSubSurfaceConfiguration2.prototype.getClassName = function() {
        return "PBRSubSurfaceConfiguration";
      };
      PBRSubSurfaceConfiguration2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
        if (defines.SS_SCATTERING) {
          fallbacks.addFallback(currentRank++, "SS_SCATTERING");
        }
        if (defines.SS_TRANSLUCENCY) {
          fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
        }
        return currentRank;
      };
      PBRSubSurfaceConfiguration2.prototype.getSamplers = function(samplers) {
        samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh");
      };
      PBRSubSurfaceConfiguration2.prototype.getUniforms = function() {
        return {
          ubo: [
            { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
            { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
            { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
            { name: "vRefractionInfos", size: 4, type: "vec4" },
            { name: "refractionMatrix", size: 16, type: "mat4" },
            { name: "vThicknessInfos", size: 2, type: "vec2" },
            { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
            { name: "thicknessMatrix", size: 16, type: "mat4" },
            { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
            { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
            { name: "vThicknessParam", size: 2, type: "vec2" },
            { name: "vDiffusionDistance", size: 3, type: "vec3" },
            { name: "vTintColor", size: 4, type: "vec4" },
            { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
            { name: "vRefractionPosition", size: 3, type: "vec3" },
            { name: "vRefractionSize", size: 3, type: "vec3" },
            { name: "scatteringDiffusionProfile", size: 1, type: "float" }
          ]
        };
      };
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "isRefractionEnabled", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "isTranslucencyEnabled", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markScenePrePassDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "isScatteringEnabled", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "_scatteringDiffusionProfileIndex", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "refractionIntensity", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "translucencyIntensity", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "useAlbedoToTintRefraction", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "useAlbedoToTintTranslucency", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "thicknessTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "refractionTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "indexOfRefraction", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "_volumeIndexOfRefraction", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "volumeIndexOfRefraction", null);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "invertRefractionY", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "linkRefractionWithTransparency", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "minimumThickness", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "maximumThickness", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "useThicknessAsDepth", void 0);
      __decorate([
        serializeAsColor3()
      ], PBRSubSurfaceConfiguration2.prototype, "tintColor", void 0);
      __decorate([
        serialize()
      ], PBRSubSurfaceConfiguration2.prototype, "tintColorAtDistance", void 0);
      __decorate([
        serializeAsColor3()
      ], PBRSubSurfaceConfiguration2.prototype, "diffusionDistance", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "useMaskFromThicknessTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "refractionIntensityTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "translucencyIntensityTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRSubSurfaceConfiguration2.prototype, "useGltfStyleTextures", void 0);
      return PBRSubSurfaceConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines, PBRBRDFConfiguration;
var init_pbrBRDFConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialDefines();
    init_materialPluginBase();
    MaterialBRDFDefines = function(_super) {
      __extends(MaterialBRDFDefines2, _super);
      function MaterialBRDFDefines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.BRDF_V_HEIGHT_CORRELATED = false;
        _this.MS_BRDF_ENERGY_CONSERVATION = false;
        _this.SPHERICAL_HARMONICS = false;
        _this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
        return _this;
      }
      return MaterialBRDFDefines2;
    }(MaterialDefines);
    PBRBRDFConfiguration = function(_super) {
      __extends(PBRBRDFConfiguration2, _super);
      function PBRBRDFConfiguration2(material, addToPluginList) {
        if (addToPluginList === void 0) {
          addToPluginList = true;
        }
        var _this = _super.call(this, material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList) || this;
        _this._useEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION;
        _this.useEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION;
        _this._useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        _this.useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        _this._useSphericalHarmonics = PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS;
        _this.useSphericalHarmonics = PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS;
        _this._useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        _this.useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        _this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
        _this._enable(true);
        return _this;
      }
      PBRBRDFConfiguration2.prototype._markAllSubMeshesAsMiscDirty = function() {
        this._internalMarkAllSubMeshesAsMiscDirty();
      };
      PBRBRDFConfiguration2.prototype.prepareDefines = function(defines) {
        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
      };
      PBRBRDFConfiguration2.prototype.getClassName = function() {
        return "PBRBRDFConfiguration";
      };
      PBRBRDFConfiguration2.DEFAULT_USE_ENERGY_CONSERVATION = true;
      PBRBRDFConfiguration2.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
      PBRBRDFConfiguration2.DEFAULT_USE_SPHERICAL_HARMONICS = true;
      PBRBRDFConfiguration2.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRBRDFConfiguration2.prototype, "useEnergyConservation", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRBRDFConfiguration2.prototype, "useSmithVisibilityHeightCorrelated", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRBRDFConfiguration2.prototype, "useSphericalHarmonics", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRBRDFConfiguration2.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
      return PBRBRDFConfiguration2;
    }(MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js
var name65, shader65;
var init_pbrFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js"() {
    init_shaderStore();
    name65 = "pbrFragmentDeclaration";
    shader65 = "uniform vec4 vEyePosition;\nuniform vec3 vReflectionColor;\nuniform vec4 vAlbedoColor;\nuniform vec4 vLightingIntensity;\nuniform vec4 vReflectivityColor;\nuniform vec4 vMetallicReflectanceFactors;\nuniform vec3 vEmissiveColor;\nuniform float visibility;\nuniform vec3 vAmbientColor;\n#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\n#endif\nuniform mat4 reflectionMatrix;\nuniform vec3 vReflectionMicrosurfaceInfos;\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize; \n#endif\n#endif\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\nuniform vec3 vRefractionPosition;\nuniform vec3 vRefractionSize; \n#endif\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;\nuniform vec4 vClearCoatRefractionParams;\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;\nuniform vec2 vClearCoatTangentSpaceParams;\nuniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;\nuniform float clearCoatColorAtDistance;\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;\nuniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#endif\n#ifdef IRIDESCENCE\nuniform vec4 vIridescenceParams;\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;\nuniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\nuniform vec4 vSheenColor;\n#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\n#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionMicrosurfaceInfos;\nuniform vec4 vRefractionInfos;\nuniform mat4 refractionMatrix;\n#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;\nuniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;\nuniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;\nuniform mat4 translucencyIntensityMatrix;\n#endif\nuniform vec2 vThicknessParam;\nuniform vec3 vDiffusionDistance;\nuniform vec4 vTintColor;\nuniform vec3 vSubSurfaceIntensity;\n#endif\n#ifdef PREPASS\n#ifdef SS_SCATTERING\nuniform float scatteringDiffusionProfile;\n#endif\n#endif\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;\nuniform vec3 vSphericalL1_1;\nuniform vec3 vSphericalL10;\nuniform vec3 vSphericalL11;\nuniform vec3 vSphericalL2_2;\nuniform vec3 vSphericalL2_1;\nuniform vec3 vSphericalL20;\nuniform vec3 vSphericalL21;\nuniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;\nuniform vec3 vSphericalY;\nuniform vec3 vSphericalZ;\nuniform vec3 vSphericalXX_ZZ;\nuniform vec3 vSphericalYY_ZZ;\nuniform vec3 vSphericalZZ;\nuniform vec3 vSphericalXY;\nuniform vec3 vSphericalYZ;\nuniform vec3 vSphericalZX;\n#endif\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n";
    ShaderStore.IncludesShadersStore[name65] = shader65;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js
var name66, shader66;
var init_pbrUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    name66 = "pbrUboDeclaration";
    shader66 = "layout(std140,column_major) uniform;\nuniform Material {\nvec2 vAlbedoInfos;\nvec4 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec3 vReflectivityInfos;\nvec2 vMicroSurfaceSamplerInfos;\nvec2 vReflectionInfos;\nvec2 vReflectionFilteringInfo;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec3 vBumpInfos;\nmat4 albedoMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 reflectivityMatrix;\nmat4 microSurfaceSamplerMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nmat4 reflectionMatrix;\nvec3 vReflectionColor;\nvec4 vAlbedoColor;\nvec4 vLightingIntensity;\nvec3 vReflectionMicrosurfaceInfos;\nfloat pointSize;\nvec4 vReflectivityColor;\nvec3 vEmissiveColor;\nvec3 vAmbientColor;\nvec2 vDebugMode;\nvec4 vMetallicReflectanceFactors;\nvec2 vMetallicReflectanceInfos;\nmat4 metallicReflectanceMatrix;\nvec2 vReflectanceInfos;\nmat4 reflectanceMatrix;\nvec3 vSphericalL00;\nvec3 vSphericalL1_1;\nvec3 vSphericalL10;\nvec3 vSphericalL11;\nvec3 vSphericalL2_2;\nvec3 vSphericalL2_1;\nvec3 vSphericalL20;\nvec3 vSphericalL21;\nvec3 vSphericalL22;\nvec3 vSphericalX;\nvec3 vSphericalY;\nvec3 vSphericalZ;\nvec3 vSphericalXX_ZZ;\nvec3 vSphericalYY_ZZ;\nvec3 vSphericalZZ;\nvec3 vSphericalXY;\nvec3 vSphericalYZ;\nvec3 vSphericalZX;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";
    ShaderStore.IncludesShadersStore[name66] = shader66;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js
var name67, shader67;
var init_pbrFragmentExtraDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js"() {
    init_shaderStore();
    init_mainUVVaryingDeclaration();
    name67 = "pbrFragmentExtraDeclaration";
    shader67 = "varying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n";
    ShaderStore.IncludesShadersStore[name67] = shader67;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js
var name68, shader68;
var init_samplerFragmentAlternateDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js"() {
    init_shaderStore();
    name68 = "samplerFragmentAlternateDeclaration";
    shader68 = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name68] = shader68;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js
var name69, shader69;
var init_pbrFragmentSamplersDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js"() {
    init_shaderStore();
    init_samplerFragmentDeclaration();
    init_samplerFragmentAlternateDeclaration();
    name69 = "pbrFragmentSamplersDeclaration";
    shader69 = "#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D clearCoatRoughnessSampler;\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\nuniform sampler2D sheenRoughnessSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;\nuniform samplerCube reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;\nuniform sampler2D reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;\nuniform samplerCube refractionSamplerHigh;\n#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;\nuniform sampler2D refractionSamplerHigh;\n#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#endif\n";
    ShaderStore.IncludesShadersStore[name69] = shader69;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js
var name70, shader70;
var init_subSurfaceScatteringFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js"() {
    init_shaderStore();
    name70 = "subSurfaceScatteringFunctions";
    shader70 = "bool testLightingForSSS(float diffusionProfile)\n{\nreturn diffusionProfile<1.;\n}";
    ShaderStore.IncludesShadersStore[name70] = shader70;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js
var name71, shader71;
var init_importanceSampling = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js"() {
    init_shaderStore();
    name71 = "importanceSampling";
    shader71 = "vec3 hemisphereCosSample(vec2 u) {\nfloat phi=2.*PI*u.x;\nfloat cosTheta2=1.-u.y;\nfloat cosTheta=sqrt(cosTheta2);\nfloat sinTheta=sqrt(1.-cosTheta2);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {\nfloat phi=2.*PI*u.x;\nfloat cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));\nfloat cosTheta=sqrt(cosTheta2);\nfloat sinTheta=sqrt(1.-cosTheta2);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \nfloat phi=2.*PI*u.x;\nfloat sinTheta=pow(u.y,a/(2.*a+1.));\nfloat cosTheta=sqrt(1.-sinTheta*sinTheta);\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n}";
    ShaderStore.IncludesShadersStore[name71] = shader71;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js
var name72, shader72;
var init_pbrHelperFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js"() {
    init_shaderStore();
    name72 = "pbrHelperFunctions";
    shader72 = "#define RECIPROCAL_PI2 0.15915494\n#define RECIPROCAL_PI 0.31830988618\n#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\n{\nreturn square(roughness)+MINIMUMVARIANCE;\n}\nfloat fresnelGrazingReflectance(float reflectance0) {\nfloat reflectance90=saturate(reflectance0*25.0);\nreturn reflectance90;\n}\nvec2 getAARoughnessFactors(vec3 normalVector) {\n#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);\nvec3 nDfdy=dFdy(normalVector.xyz);\nfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\nfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\nfloat geometricAlphaGFactor=sqrt(slopeSquare);\ngeometricAlphaGFactor*=0.75;\nreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2(0.);\n#endif\n}\n#ifdef ANISOTROPIC\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\nfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\nfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\nreturn vec2(alphaT,alphaB);\n}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\nvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\nvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\nvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\nvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\nreturn anisotropicNormal;\n}\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {\nreturn exp(-alpha*distance);\n}\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\nreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\n}\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\nreturn -log(color)/distance;\n}\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\nvec3 clearCoatAbsorption=mix(vec3(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);\nreturn clearCoatAbsorption;\n}\n#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\nreturn microSurface;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name72] = shader72;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js
var name73, shader73;
var init_harmonicsFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js"() {
    init_shaderStore();
    name73 = "harmonicsFunctions";
    shader73 = "#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {\nreturn vSphericalL00\n+ vSphericalL1_1*(normal.y)\n+ vSphericalL10*(normal.z)\n+ vSphericalL11*(normal.x)\n+ vSphericalL2_2*(normal.y*normal.x)\n+ vSphericalL2_1*(normal.y*normal.z)\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ vSphericalL21*(normal.z*normal.x)\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\n}\n#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {\nfloat Nx=normal.x;\nfloat Ny=normal.y;\nfloat Nz=normal.z;\nvec3 C1=vSphericalZZ.rgb;\nvec3 Cx=vSphericalX.rgb;\nvec3 Cy=vSphericalY.rgb;\nvec3 Cz=vSphericalZ.rgb;\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\nvec3 Cxy=vSphericalXY.rgb;\nvec3 Cyz=vSphericalYZ.rgb;\nvec3 Czx=vSphericalZX.rgb;\nvec3 a1=Cyy_zz*Ny+Cy;\nvec3 a2=Cyz*Nz+a1;\nvec3 b1=Czx*Nz+Cx;\nvec3 b2=Cxy*Ny+b1;\nvec3 b3=Cxx_zz*Nx+b2;\nvec3 t1=Cz *Nz+C1;\nvec3 t2=a2 *Ny+t1;\nvec3 t3=b3 *Nx+t2;\nreturn t3;\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name73] = shader73;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js
var name74, shader74;
var init_pbrDirectLightingSetupFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js"() {
    init_shaderStore();
    name74 = "pbrDirectLightingSetupFunctions";
    shader74 = "struct preLightingInfo\n{\nvec3 lightOffset;\nfloat lightDistanceSquared;\nfloat lightDistance;\nfloat attenuation;\nvec3 L;\nvec3 H;\nfloat NdotV;\nfloat NdotLUnclamped;\nfloat NdotL;\nfloat VdotH;\nfloat roughness;\n#ifdef IRIDESCENCE\nfloat iridescenceIntensity;\n#endif\n};\npreLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\nresult.lightOffset=lightData.xyz-vPositionW;\nresult.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);\nresult.lightDistance=sqrt(result.lightDistanceSquared);\nresult.L=normalize(result.lightOffset);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\nresult.NdotLUnclamped=dot(N,result.L);\nresult.NdotL=saturateEps(result.NdotLUnclamped);\nreturn result;\n}\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\nresult.lightDistance=length(-lightData.xyz);\nresult.L=normalize(-lightData.xyz);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\nresult.NdotLUnclamped=dot(N,result.L);\nresult.NdotL=saturateEps(result.NdotLUnclamped);\nreturn result;\n}\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\npreLightingInfo result;\nresult.NdotL=dot(N,lightData.xyz)*0.5+0.5;\nresult.NdotL=saturateEps(result.NdotL);\nresult.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);\nresult.H=normalize(V+result.L);\nresult.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;\n}";
    ShaderStore.IncludesShadersStore[name74] = shader74;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js
var name75, shader75;
var init_pbrDirectLightingFalloffFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js"() {
    init_shaderStore();
    name75 = "pbrDirectLightingFalloffFunctions";
    shader75 = "float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\n{\nreturn max(0.,1.0-length(lightOffset)/range);\n}\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n{\nreturn 1.0/maxEps(lightDistanceSquared);\n}\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\n{\nfloat lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);\nfloat factor=lightDistanceSquared*inverseSquaredRange;\nfloat attenuation=saturate(1.0-factor*factor);\nattenuation*=attenuation;\nlightDistanceFalloff*=attenuation;\nreturn lightDistanceFalloff;\n}\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\n{\nfloat falloff=0.0;\nfloat cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));\nif (cosAngle>=cosHalfAngle)\n{\nfalloff=max(0.,pow(cosAngle,exponent));\n}\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\n{\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\nfloat falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\n{\nfloat cd=dot(-lightDirection,directionToLightCenterW);\nfloat falloff=saturate(cd*lightAngleScale+lightAngleOffset);\nfalloff*=falloff;\nreturn falloff;\n}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}";
    ShaderStore.IncludesShadersStore[name75] = shader75;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js
var name76, shader76;
var init_pbrBRDFFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js"() {
    init_shaderStore();
    name76 = "pbrBRDFFunctions";
    shader76 = "#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\nreturn 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);\n}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {\nvec2 UV=vec2(NdotV,perceptualRoughness);\nvec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;\n}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;\n}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;\n}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\n{\nfloat c=1.0-NdotV;\nfloat c3=c*c*c;\nreturn 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));\n}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\n}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {\nvec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;\nreturn sheenEnvironmentReflectance;\n}\n#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\n}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\n}\n#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);\nvec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);\nreturn square(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);\nvec3 getIORTfromAirToSurfaceR0(vec3 f0) {\nvec3 sqrtF0=sqrt(f0);\nreturn (1.+sqrtF0)/(1.-sqrtF0);\n}\nvec3 getR0fromIORs(vec3 iorT,float iorI) {\nreturn square((iorT-vec3(iorI))/(iorT+vec3(iorI)));\n}\nfloat getR0fromIORs(float iorT,float iorI) {\nreturn square((iorT-iorI)/(iorT+iorI));\n}\nvec3 evalSensitivity(float opd,vec3 shift) {\nfloat phase=2.0*PI*opd*1.0e-9;\nconst vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);\nconst vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);\nconst vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);\nvec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);\nxyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));\nxyz/=1.0685e-7;\nvec3 srgb=XYZ_TO_REC709*xyz;\nreturn srgb;\n}\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {\nvec3 I=vec3(1.0);\nfloat iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));\nfloat sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));\nfloat cosTheta2Sq=1.0-sinTheta2Sq;\nif (cosTheta2Sq<0.0) {\nreturn I;\n}\nfloat cosTheta2=sqrt(cosTheta2Sq);\nfloat R0=getR0fromIORs(iridescenceIOR,outsideIOR);\nfloat R12=fresnelSchlickGGX(cosTheta1,R0,1.);\nfloat R21=R12;\nfloat T121=1.0-R12;\nfloat phi12=0.0;\nif (iridescenceIOR<outsideIOR) phi12=PI;\nfloat phi21=PI-phi12;\nvec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);\nvec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));\nvec3 phi23=vec3(0.0);\nif (baseIOR[0]<iridescenceIOR) phi23[0]=PI;\nif (baseIOR[1]<iridescenceIOR) phi23[1]=PI;\nif (baseIOR[2]<iridescenceIOR) phi23[2]=PI;\nfloat opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;\nvec3 phi=vec3(phi21)+phi23;\nvec3 R123=clamp(R12*R23,1e-5,0.9999);\nvec3 r123=sqrt(R123);\nvec3 Rs=square(T121)*R23/(vec3(1.0)-R123);\nvec3 C0=R12+Rs;\nI=C0;\nvec3 Cm=Rs-T121;\nfor (int m=1; m<=2; ++m)\n{\nCm*=r123;\nvec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);\nI+=Cm*Sm;\n}\nreturn max(I,vec3(0.0));\n}\n#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{\nfloat a2=square(alphaG);\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\nreturn a2/(PI*d*d);\n}\n#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{\nfloat invR=1./alphaG;\nfloat cos2h=NdotH*NdotH;\nfloat sin2h=1.-cos2h;\nreturn (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);\n}\n#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {\nfloat a2=alphaTB.x*alphaTB.y;\nvec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);\nfloat v2=dot(v,v);\nfloat w2=a2/v2;\nreturn a2*w2*w2*RECIPROCAL_PI;\n}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);\nfloat GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);\nreturn 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;\nfloat GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);\nfloat GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);\nreturn 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;\nreturn 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{\nfloat visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);\nreturn visibility;\n}\n#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {\nfloat lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));\nfloat lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));\nfloat v=0.5/(lambdaV+lambdaL);\nreturn v;\n}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {\nreturn 0.25/(VdotH*VdotH); \n}\n#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{\nreturn 1./(4.*(NdotL+NdotV-NdotL*NdotV));\n}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\n{\nfloat oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);\nfloat a=mix(21.5473,25.3245,oneMinusAlphaSq);\nfloat b=mix(3.82987,3.32435,oneMinusAlphaSq);\nfloat c=mix(0.19823,0.16801,oneMinusAlphaSq);\nfloat d=mix(-1.97760,-1.27393,oneMinusAlphaSq);\nfloat e=mix(-4.32054,-4.85967,oneMinusAlphaSq);\nreturn a/(1.0+b*pow(x,c))+d*x+e;\n}\nfloat lambdaSheen(float cosTheta,float alphaG)\n{\nreturn abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));\n}\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\n{\nfloat G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));\nreturn G/(4.0*NdotV*NdotL);\n}\n#endif\n*/\n#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {\nfloat diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));\nfloat diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\nfloat fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\nreturn fresnel/PI;\n}\n#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {\nvec3 S=1./maxEps(diffusionDistance);\nvec3 temp=exp((-0.333333333*thickness)*S);\nreturn tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\n}\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {\nfloat t=1.0+w;\nfloat invt2=1.0/square(t);\nreturn saturate((NdotL+w)*invt2);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name76] = shader76;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js
var name77, shader77;
var init_hdrFilteringFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js"() {
    init_shaderStore();
    name77 = "hdrFilteringFunctions";
    shader77 = "#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU)\nfloat radicalInverse_VdC(uint bits) \n{\nbits=(bits<<16u) | (bits>>16u);\nbits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);\nbits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);\nbits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);\nbits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);\nreturn float(bits)*2.3283064365386963e-10; \n}\nvec2 hammersley(uint i,uint N)\n{\nreturn vec2(float(i)/float(N),radicalInverse_VdC(i));\n}\n#else\nfloat vanDerCorpus(int n,int base)\n{\nfloat invBase=1.0/float(base);\nfloat denom =1.0;\nfloat result =0.0;\nfor(int i=0; i<32; ++i)\n{\nif(n>0)\n{\ndenom =mod(float(n),2.0);\nresult+=denom*invBase;\ninvBase=invBase/2.0;\nn =int(float(n)/2.0);\n}\n}\nreturn result;\n}\nvec2 hammersley(int i,int N)\n{\nreturn vec2(float(i)/float(N),vanDerCorpus(i,2));\n}\n#endif\nfloat log4(float x) {\nreturn log2(x)/2.;\n}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;\nconst float K=4.;\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{\nvec3 n=normalize(inputN);\nvec3 result=vec3(0.0);\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\ntangent=normalize(cross(tangent,n));\nvec3 bitangent=cross(n,tangent);\nmat3 tbn=mat3(tangent,bitangent,n);\nfloat maxLevel=filteringInfo.y;\nfloat dim0=filteringInfo.x;\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\n#if defined(WEBGL2) || defined(WEBGPU)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{\nvec2 Xi=hammersley(i,NUM_SAMPLES);\nvec3 Ls=hemisphereCosSample(Xi);\nLs=normalize(Ls);\nvec3 Ns=vec3(0.,0.,1.);\nfloat NoL=dot(Ns,Ls);\nif (NoL>0.) {\nfloat pdf_inversed=PI/NoL;\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\nfloat mipLevel=clamp(l,0.0,maxLevel);\nvec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;\n}\n}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;\nreturn result;\n}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{\nvec3 n=normalize(inputN);\nif (alphaG==0.) {\nvec3 c=textureCube(inputTexture,n).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;\n} else {\nvec3 result=vec3(0.);\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\ntangent=normalize(cross(tangent,n));\nvec3 bitangent=cross(n,tangent);\nmat3 tbn=mat3(tangent,bitangent,n);\nfloat maxLevel=filteringInfo.y;\nfloat dim0=filteringInfo.x;\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\nfloat weight=0.;\n#if defined(WEBGL2) || defined(WEBGPU)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{\nvec2 Xi=hammersley(i,NUM_SAMPLES);\nvec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);\nfloat NoV=1.;\nfloat NoH=H.z;\nfloat NoH2=H.z*H.z;\nfloat NoL=2.*NoH2-1.;\nvec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);\nL=normalize(L);\nif (NoL>0.) {\nfloat pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\nfloat mipLevel=clamp(float(l),0.0,maxLevel);\nweight+=NoL;\nvec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;\n}\n}\nresult=result/weight;\nreturn result;\n}\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name77] = shader77;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js
var name78, shader78;
var init_pbrDirectLightingFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js"() {
    init_shaderStore();
    name78 = "pbrDirectLightingFunctions";
    shader78 = "#define CLEARCOATREFLECTANCE90 1.0\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef CLEARCOAT\nvec4 clearCoat;\n#endif\n#ifdef SHEEN\nvec3 sheen;\n#endif\n};\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\nfloat lightRoughness=lightRadius/lightDistance;\nfloat totalRoughness=saturate(lightRoughness+roughness);\nreturn totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {\nreturn mix(groundColor,lightColor,info.NdotL);\n}\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {\nfloat diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);\nreturn diffuseTerm*info.attenuation*info.NdotL*lightColor;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn toLinearSpace(textureColor);\n}\n#ifdef SS_TRANSLUCENCY\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {\nfloat NdotL=absEps(info.NdotLUnclamped);\nfloat wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);\nfloat trAdapt=step(0.,info.NdotLUnclamped);\nvec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);\nfloat diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);\nreturn diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;\n}\n#endif\n#ifdef SPECULARTERM\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvec3 specTerm=fresnel*distribution*smithVisibility;\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n#ifdef ANISOTROPIC\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat TdotH=dot(T,info.H);\nfloat BdotH=dot(B,info.H);\nfloat TdotV=dot(T,V);\nfloat BdotV=dot(B,V);\nfloat TdotL=dot(T,info.L);\nfloat BdotL=dot(B,info.L);\nfloat alphaG=convertRoughnessToAverageSlope(info.roughness);\nvec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);\nalphaTB=max(alphaTB,square(geometricRoughnessFactor));\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);\nfloat smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);\nvec3 specTerm=fresnel*distribution*smithVisibility;\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n#ifdef CLEARCOAT\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {\nfloat NccdotL=saturateEps(dot(Ncc,info.L));\nfloat NccdotH=saturateEps(dot(Ncc,info.H));\nfloat clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\nfloat fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\nfresnel*=clearCoatIntensity;\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);\nfloat kelemenVisibility=visibility_Kelemen(info.VdotH);\nfloat clearCoatTerm=fresnel*distribution*kelemenVisibility;\nreturn vec4(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);\n}\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\nvec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);\nfloat NdotLRefract=saturateEps(dot(Ncc,LRefract));\nvec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);\nreturn absorption;\n}\n#endif\n#ifdef SHEEN\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\nfloat NdotH=saturateEps(dot(N,info.H));\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nfloat fresnel=1.;\nfloat distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);\n/*#ifdef SHEEN_SOFTER\nfloat visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\n#else */\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);\n/* #endif */\nfloat sheenTerm=fresnel*distribution*visibility;\nreturn sheenTerm*info.attenuation*info.NdotL*lightColor;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name78] = shader78;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js
var name79, shader79;
var init_pbrIBLFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js"() {
    init_shaderStore();
    name79 = "pbrIBLFunctions";
    shader79 = "#if defined(REFLECTION) || defined(SS_REFRACTION)\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {\nfloat microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;\nfloat lod=log2(microsurfaceAverageSlopeTexels);\nreturn lod;\n}\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {\nfloat lod=log2(cubeMapDimensionPixels)*roughness;\nreturn lod;\n}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {\nfloat temp=NdotVUnclamped+ambientOcclusion;\nreturn saturate(square(temp)-1.0+ambientOcclusion);\n}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {\nvec3 reflection=reflect(view,normal);\nfloat temp=saturate(1.0+1.1*dot(reflection,geometricNormal));\nreturn square(temp);\n}\n#endif\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\n#define UNPACK_LOD(x) (1.0-x)*255.0\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {\nfloat microsurfaceAverageSlope=alphaG;\nmicrosurfaceAverageSlope*=sqrt(abs(NdotV));\nreturn getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name79] = shader79;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js
var name80, shader80;
var init_pbrBlockAlbedoOpacity = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js"() {
    init_shaderStore();
    name80 = "pbrBlockAlbedoOpacity";
    shader80 = "struct albedoOpacityOutParams\n{\nvec3 surfaceAlbedo;\nfloat alpha;\n};\n#define pbr_inline\nvoid albedoOpacityBlock(\nin vec4 vAlbedoColor,\n#ifdef ALBEDO\nin vec4 albedoTexture,\nin vec2 albedoInfos,\n#endif\n#ifdef OPACITY\nin vec4 opacityMap,\nin vec2 vOpacityInfos,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\nout albedoOpacityOutParams outParams\n)\n{\nvec3 surfaceAlbedo=vAlbedoColor.rgb;\nfloat alpha=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nsurfaceAlbedo*=vColor.rgb;\n#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);\nsurfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST\nif (alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;\noutParams.alpha=alpha;\n}\n";
    ShaderStore.IncludesShadersStore[name80] = shader80;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js
var name81, shader81;
var init_pbrBlockReflectivity = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js"() {
    init_shaderStore();
    name81 = "pbrBlockReflectivity";
    shader81 = "struct reflectivityOutParams\n{\nfloat microSurface;\nfloat roughness;\nvec3 surfaceReflectivityColor;\n#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\n#endif\n#if DEBUGMODE>0\nvec4 surfaceMetallicColorMap;\nvec4 surfaceReflectivityColorMap;\nvec2 metallicRoughness;\nvec3 metallicF0;\n#endif\n};\n#define pbr_inline\nvoid reflectivityBlock(\nin vec4 vReflectivityColor,\n#ifdef METALLICWORKFLOW\nin vec3 surfaceAlbedo,\nin vec4 metallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nin vec3 reflectivityInfos,\nin vec4 surfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nin vec3 ambientOcclusionColorIn,\n#endif\n#ifdef MICROSURFACEMAP\nin vec4 microSurfaceTexel,\n#endif\n#ifdef DETAIL\nin vec4 detailColor,\nin vec4 vDetailInfos,\n#endif\nout reflectivityOutParams outParams\n)\n{\nfloat microSurface=vReflectivityColor.a;\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);\noutParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);\nfloat loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);\nfloat hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);\nmetallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;\nvec3 baseColor=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);\nsurfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);\nsurfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;\nmicroSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);\nfloat roughness=1.-microSurface;\noutParams.microSurface=microSurface;\noutParams.roughness=roughness;\noutParams.surfaceReflectivityColor=surfaceReflectivityColor;\n}\n";
    ShaderStore.IncludesShadersStore[name81] = shader81;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js
var name82, shader82;
var init_pbrBlockAmbientOcclusion = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js"() {
    init_shaderStore();
    name82 = "pbrBlockAmbientOcclusion";
    shader82 = "struct ambientOcclusionOutParams\n{\nvec3 ambientOcclusionColor;\n#if DEBUGMODE>0\nvec3 ambientOcclusionColorMap;\n#endif\n};\n#define pbr_inline\nvoid ambientOcclusionBlock(\n#ifdef AMBIENT\nin vec3 ambientOcclusionColorMap_,\nin vec4 vAmbientInfos,\n#endif\nout ambientOcclusionOutParams outParams\n)\n{\nvec3 ambientOcclusionColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;\n}\n";
    ShaderStore.IncludesShadersStore[name82] = shader82;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js
var name83, shader83;
var init_pbrBlockAlphaFresnel = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js"() {
    init_shaderStore();
    name83 = "pbrBlockAlphaFresnel";
    shader83 = "#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{\nfloat alpha;\n};\n#define pbr_inline\nvoid alphaFresnelBlock(\nin vec3 normalW,\nin vec3 viewDirectionW,\nin float alpha,\nin float microSurface,\nout alphaFresnelOutParams outParams\n)\n{\nfloat opacityPerceptual=alpha;\n#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\n#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\n#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);\nvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\noutParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\noutParams.alpha=1.0;\n#endif\n#endif\n}\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name83] = shader83;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js
var name84, shader84;
var init_pbrBlockAnisotropic = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js"() {
    init_shaderStore();
    name84 = "pbrBlockAnisotropic";
    shader84 = "#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{\nfloat anisotropy;\nvec3 anisotropicTangent;\nvec3 anisotropicBitangent;\nvec3 anisotropicNormal;\n#if DEBUGMODE>0\nvec3 anisotropyMapData;\n#endif\n};\n#define pbr_inline\nvoid anisotropicBlock(\nin vec3 vAnisotropy,\n#ifdef ANISOTROPIC_TEXTURE\nin vec3 anisotropyMapData,\n#endif\nin mat3 TBN,\nin vec3 normalW,\nin vec3 viewDirectionW,\nout anisotropicOutParams outParams\n)\n{\nfloat anisotropy=vAnisotropy.b;\nvec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\nanisotropyDirection.rg*=anisotropyMapData.rg*2.0-1.0;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));\nvec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);\nvec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));\noutParams.anisotropy=anisotropy;\noutParams.anisotropicTangent=anisotropicTangent;\noutParams.anisotropicBitangent=anisotropicBitangent;\noutParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy);\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name84] = shader84;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js
var name85, shader85;
var init_pbrBlockReflection = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js"() {
    init_shaderStore();
    name85 = "pbrBlockReflection";
    shader85 = "#ifdef REFLECTION\nstruct reflectionOutParams\n{\nvec4 environmentRadiance;\nvec3 environmentIrradiance;\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\n#else\nvec2 reflectionCoords;\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid createReflectionCoords(\nin vec3 vPositionW,\nin vec3 normalW,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\n#else\nout vec2 reflectionCoords\n#endif\n)\n{\n#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n}\n#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nconst vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nconst vec2 reflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout vec4 environmentRadiance\n)\n{\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\nfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\n#else\nfloat requestedReflectionLOD=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\nvec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);\nif (lodReflectionNormalizedDoubled<1.0){\nenvironmentRadiance=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);\n} else {\nenvironmentRadiance=mix(\nenvironmentMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);\n}\n#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\n#endif\nenvironmentRadiance.rgb*=vReflectionInfos.x;\nenvironmentRadiance.rgb*=vReflectionColor.rgb;\n}\n#define pbr_inline\n#define inline\nvoid reflectionBlock(\nin vec3 vPositionW,\nin vec3 normalW,\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nin vec3 vEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin mat4 reflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout reflectionOutParams outParams\n)\n{\nvec4 environmentRadiance=vec4(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\n#else\nvec2 reflectionCoords=vec2(0.);\n#endif\ncreateReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\nreflectionCoords\n);\nsampleReflectionTexture(\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\nreflectionCoords,\n#else\nreflectionSampler,\nreflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentRadiance\n);\nvec3 environmentIrradiance=vec3(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);\nenvironmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;\noutParams.environmentRadiance=environmentRadiance;\noutParams.environmentIrradiance=environmentIrradiance;\noutParams.reflectionCoords=reflectionCoords;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name85] = shader85;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js
var name86, shader86;
var init_pbrBlockSheen = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js"() {
    init_shaderStore();
    name86 = "pbrBlockSheen";
    shader86 = "#ifdef SHEEN\nstruct sheenOutParams\n{\nfloat sheenIntensity;\nvec3 sheenColor;\nfloat sheenRoughness;\n#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\n#endif\n#if DEBUGMODE>0\nvec4 sheenMapData;\nvec3 sheenEnvironmentReflectance;\n#endif\n};\n#define pbr_inline\n#define inline\nvoid sheenBlock(\nin vec4 vSheenColor,\n#ifdef SHEEN_ROUGHNESS\nin float vSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 sheenMapRoughnessData,\n#endif\n#endif\nin float roughness,\n#ifdef SHEEN_TEXTURE\nin vec4 sheenMapData,\nin float sheenMapLevel,\n#endif\nin float reflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nin vec3 baseColor,\nin vec3 surfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nin float NdotV,\nin vec3 environmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nin vec2 AARoughnessFactors,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nin vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nin vec2 reflectionCoords,\n#endif\nin float NdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nin float seo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nin float eho,\n#endif\n#endif\nout sheenOutParams outParams\n)\n{\nfloat sheenIntensity=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);\nvec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);\nfloat sheenRoughness=sheenIntensity;\noutParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\n#else\nsheenColor.rgb*=sheenMapData.rgb;\n#endif\nsheenColor.rgb*=sheenMapLevel;\n#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\nsheenRoughness*=sheenMapData.a;\n#else\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#endif\n#else\nfloat sheenRoughness=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\nsheenColor*=sheenIntensity;\n#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\nvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\n#else*/\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvec3 environmentSheenBrdf=environmentBrdf;\n#endif\n/*#endif*/\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);\nsampleReflectionTexture(\nsheenAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\n#endif\nreflectionSampler,\nreflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentSheenRadiance\n);\nvec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\noutParams.sheenIntensity=sheenIntensity;\noutParams.sheenColor=sheenColor;\noutParams.sheenRoughness=sheenRoughness;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name86] = shader86;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js
var name87, shader87;
var init_pbrBlockClearcoat = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js"() {
    init_shaderStore();
    name87 = "pbrBlockClearcoat";
    shader87 = "struct clearcoatOutParams\n{\nvec3 specularEnvironmentR0;\nfloat conservationFactor;\nvec3 clearCoatNormalW;\nvec2 clearCoatAARoughnessFactors;\nfloat clearCoatIntensity;\nfloat clearCoatRoughness;\n#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;\nfloat clearCoatNdotVRefract;\nvec3 clearCoatColor;\nfloat clearCoatThickness;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\n#endif\n#if DEBUGMODE>0\nmat3 TBNClearCoat;\nvec2 clearCoatMapData;\nvec4 clearCoatTintMapData;\nvec4 environmentClearCoatRadiance;\nfloat clearCoatNdotV;\nvec3 clearCoatEnvironmentReflectance;\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nvoid clearcoatBlock(\nin vec3 vPositionW,\nin vec3 geometricNormalW,\nin vec3 viewDirectionW,\nin vec2 vClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nin vec4 clearCoatMapRoughnessData,\n#endif\nin vec3 specularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nin vec4 vClearCoatTintParams,\nin float clearCoatColorAtDistance,\nin vec4 vClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nin vec4 clearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nin vec2 vClearCoatBumpInfos,\nin vec4 clearCoatBumpMapData,\nin vec2 vClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nin mat3 vTBN,\n#else\nin vec2 vClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nin mat4 normalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nin vec3 faceNormal,\n#endif\n#ifdef REFLECTION\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\nin vec4 vLightingIntensity,\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\n#else\nin sampler2D reflectionSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nin float ambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\nin float frontFacingMultiplier,\n#endif\nout clearcoatOutParams outParams\n)\n{\nfloat clearCoatIntensity=vClearCoatParams.x;\nfloat clearCoatRoughness=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\nclearCoatRoughness*=clearCoatMapData.y;\n#else\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;\noutParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;\nfloat clearCoatThickness=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\n#else\nclearCoatColor*=clearCoatTintMapData.rgb;\n#endif\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);\noutParams.clearCoatThickness=clearCoatThickness;\n#endif\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);\nvec3 clearCoatNormalW=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\n#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\n#else\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;\nmat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);\nclearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;\noutParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);\nfloat clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);\nfloat clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatVRefract=-refract(vPositionW,clearCoatNormalW,vClearCoatRefractionParams.y);\noutParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);\nvec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\n#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nsampleReflectionTexture(\nclearCoatAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\n#endif\nreflectionSampler,\nclearCoatReflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentClearCoatRadiance\n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef RADIANCEOCCLUSION\nfloat clearCoatSeo=environmentRadianceOcclusion(ambientMonochrome,clearCoatNdotVUnclamped);\nclearCoatEnvironmentReflectance*=clearCoatSeo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);\nclearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\nfresnelIBLClearCoat*=clearCoatIntensity;\noutParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name87] = shader87;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js
var name88, shader88;
var init_pbrBlockIridescence = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js"() {
    init_shaderStore();
    name88 = "pbrBlockIridescence";
    shader88 = "struct iridescenceOutParams\n{\nfloat iridescenceIntensity;\nfloat iridescenceIOR;\nfloat iridescenceThickness;\nvec3 specularEnvironmentR0;\n};\n#ifdef IRIDESCENCE\n#define pbr_inline\n#define inline\nvoid iridescenceBlock(\nin vec4 vIridescenceParams,\nin float viewAngle,\nin vec3 specularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\nin vec2 iridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nin vec2 iridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nin float NdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nin vec2 clearCoatMapData,\n#endif\n#endif\nout iridescenceOutParams outParams\n)\n{\nfloat iridescenceIntensity=vIridescenceParams.x;\nfloat iridescenceIOR=vIridescenceParams.y;\nfloat iridescenceThicknessMin=vIridescenceParams.z;\nfloat iridescenceThicknessMax=vIridescenceParams.w;\nfloat iridescenceThicknessWeight=1.;\n#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\n#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE\niridescenceThicknessWeight=iridescenceMapData.g;\n#endif\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\n#endif\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);\nfloat topIor=1.; \n#ifdef CLEARCOAT\nfloat clearCoatIntensity=vClearCoatParams.x;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#endif\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);\nviewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\n#endif\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);\noutParams.iridescenceIntensity=iridescenceIntensity;\noutParams.iridescenceThickness=iridescenceThickness;\noutParams.iridescenceIOR=iridescenceIOR;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name88] = shader88;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js
var name89, shader89;
var init_pbrBlockSubSurface = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js"() {
    init_shaderStore();
    name89 = "pbrBlockSubSurface";
    shader89 = "struct subSurfaceOutParams\n{\nvec3 specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvec3 finalRefraction;\nvec3 surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\n#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;\nfloat translucencyIntensity;\n#ifdef REFLECTION\nvec3 refractionIrradiance;\n#endif\n#endif\n#if DEBUGMODE>0\nvec4 thicknessMap;\nvec4 environmentRefraction;\nvec3 refractionTransmittance;\n#endif\n};\n#ifdef SUBSURFACE\n#define pbr_inline\n#define inline\nvoid subSurfaceBlock(\nin vec3 vSubSurfaceIntensity,\nin vec2 vThicknessParam,\nin vec4 vTintColor,\nin vec3 normalW,\nin vec3 specularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nin vec4 thicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nin vec4 refractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nin vec4 translucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nin mat4 reflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nin vec3 irradianceVector_,\n#endif\n#if defined(REALTIME_FILTERING)\nin samplerCube reflectionSampler,\nin vec2 vReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\nin samplerCube irradianceSampler,\n#else\nin sampler2D irradianceSampler,\n#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nin vec3 surfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nin vec3 vPositionW,\nin vec3 viewDirectionW,\nin mat4 view,\nin vec4 vRefractionInfos,\nin mat4 refractionMatrix,\nin vec4 vRefractionMicrosurfaceInfos,\nin vec4 vLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nin float alpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nin float NdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nin float roughness,\n#endif\nin float alphaG,\n#ifdef SS_REFRACTIONMAP_3D\nin samplerCube refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin samplerCube refractionSamplerLow,\nin samplerCube refractionSamplerHigh,\n#endif\n#else\nin sampler2D refractionSampler,\n#ifndef LODBASEDMICROSFURACE\nin sampler2D refractionSamplerLow,\nin sampler2D refractionSamplerHigh,\n#endif\n#endif\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nin vec3 refractionPosition,\nin vec3 refractionSize,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nin vec3 vDiffusionDistance,\n#endif\nout subSurfaceOutParams outParams\n)\n{\noutParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);\noutParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#if defined(SS_USE_GLTF_TEXTURES)\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#else\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)\n#if defined(SS_USE_GLTF_TEXTURES)\nrefractionIntensity*=thicknessMap.r;\n#else\nrefractionIntensity*=thicknessMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#endif\n#else\nfloat thickness=vThicknessParam.y;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\n#else\nrefractionIntensity*=refractionIntensityMap.g;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensity*=translucencyIntensityMap.b;\n#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);\nvec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);\ntransmittance*=translucencyIntensity;\noutParams.transmittance=transmittance;\noutParams.translucencyIntensity=translucencyIntensity;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);\n#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nvec3 refractionCoords=refractionVector;\nrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\n#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\n#endif\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef SS_HAS_THICKNESS\nfloat ior=vRefractionInfos.y;\n#else\nfloat ior=vRefractionMicrosurfaceInfos.w;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionAlphaG=alphaG;\nrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionRoughness=alphaG;\nrefractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\nfloat refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\n#else\nfloat refractionAlphaG=alphaG;\nrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\nfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\n#else\nfloat requestedRefractionLOD=refractionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));\nfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\nvec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);\nif (lodRefractionNormalizedDoubled<1.0){\nenvironmentRefraction=mix(\nsampleRefraction(refractionSamplerHigh,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);\n} else {\nenvironmentRefraction=mix(\nenvironmentRefractionMid,\nsampleRefraction(refractionSamplerLow,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);\n}\n#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\n#endif\nenvironmentRefraction.rgb*=vRefractionInfos.x;\n#endif\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\nrefractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);\nvec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);\nenvironmentRefraction.rgb*=volumeAlbedo;\n#else\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\nrefractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\noutParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvec3 irradianceVector=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\n#else\nvec2 irradianceCoords=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\n#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\n#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\n#endif\nrefractionIrradiance.rgb*=transmittance;\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.refractionIrradiance=refractionIrradiance.rgb;\n#endif\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name89] = shader89;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js
var name90, shader90;
var init_pbrBlockNormalGeometric = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js"() {
    init_shaderStore();
    name90 = "pbrBlockNormalGeometric";
    shader90 = "vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#endif\nvec3 geometricNormalW=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\n#endif\n";
    ShaderStore.IncludesShadersStore[name90] = shader90;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js
var name91, shader91;
var init_pbrBlockNormalFinal = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js"() {
    init_shaderStore();
    name91 = "pbrBlockNormalFinal";
    shader91 = "#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n";
    ShaderStore.IncludesShadersStore[name91] = shader91;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js
var name92, shader92;
var init_pbrBlockLightmapInit = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js"() {
    init_shaderStore();
    name92 = "pbrBlockLightmapInit";
    shader92 = "#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n";
    ShaderStore.IncludesShadersStore[name92] = shader92;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js
var name93, shader93;
var init_pbrBlockGeometryInfo = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js"() {
    init_shaderStore();
    name93 = "pbrBlockGeometryInfo";
    shader93 = "float NdotVUnclamped=dot(normalW,viewDirectionW);\nfloat NdotV=absEps(NdotVUnclamped);\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nvec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\n#else\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name93] = shader93;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js
var name94, shader94;
var init_pbrBlockReflectance0 = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js"() {
    init_shaderStore();
    name94 = "pbrBlockReflectance0";
    shader94 = "float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);\nvec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\n#else \nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\n#endif\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\nspecularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n";
    ShaderStore.IncludesShadersStore[name94] = shader94;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js
var name95, shader95;
var init_pbrBlockReflectance = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js"() {
    init_shaderStore();
    name95 = "pbrBlockReflectance";
    shader95 = "#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name95] = shader95;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js
var name96, shader96;
var init_pbrBlockDirectLighting = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js"() {
    init_shaderStore();
    name96 = "pbrBlockDirectLighting";
    shader96 = "vec3 diffuseBase=vec3(0.,0.,0.);\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatBase=vec3(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvec3 sheenBase=vec3(0.,0.,0.);\n#endif\npreLightingInfo preInfo;\nlightingInfo info;\nfloat shadow=1.; \n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvec3 absorption=vec3(0.);\n#endif\n";
    ShaderStore.IncludesShadersStore[name96] = shader96;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js
var name97, shader97;
var init_pbrBlockFinalLitComponents = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js"() {
    init_shaderStore();
    name97 = "pbrBlockFinalLitComponents";
    shader97 = "#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n#ifdef REFLECTION\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);\nfinalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;\nfinalIrradiance*=vLightingIntensity.z;\nfinalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase;\nfinalSpecular=max(finalSpecular,0.0);\nvec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef REFLECTION\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;\nfinalRadiance*=subSurfaceOut.specularEnvironmentReflectance;\nvec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef SHEEN\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;\nfinalSheen=max(finalSheen,0.0);\nvec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef CLEARCOAT\nvec3 finalClearCoat=clearCoatBase;\nfinalClearCoat=max(finalClearCoat,0.0);\nvec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef ALPHABLEND\nfloat luminanceOverAlpha=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n";
    ShaderStore.IncludesShadersStore[name97] = shader97;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js
var name98, shader98;
var init_pbrBlockFinalUnlitComponents = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js"() {
    init_shaderStore();
    name98 = "pbrBlockFinalUnlitComponents";
    shader98 = "vec3 finalDiffuse=diffuseBase;\nfinalDiffuse*=surfaceAlbedo.rgb;\nfinalDiffuse=max(finalDiffuse,0.0);\nfinalDiffuse*=vLightingIntensity.x;\nvec3 finalAmbient=vAmbientColor;\nfinalAmbient*=surfaceAlbedo.rgb;\nvec3 finalEmissive=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\n#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\n#else\nfinalEmissive*=emissiveColorTex.rgb;\n#endif\nfinalEmissive*= vEmissiveInfos.y;\n#endif\nfinalEmissive*=vLightingIntensity.y;\n#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\n#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;\nfinalDiffuse*=ambientOcclusionForDirectDiffuse;\n";
    ShaderStore.IncludesShadersStore[name98] = shader98;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js
var name99, shader99;
var init_pbrBlockFinalColorComposition = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js"() {
    init_shaderStore();
    name99 = "pbrBlockFinalColorComposition";
    shader99 = "vec4 finalColor=vec4(\nfinalAmbient +\nfinalDiffuse +\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalEmissive,\nalpha);\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor.rgb;\n#else\nfinalColor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,0.0);\n";
    ShaderStore.IncludesShadersStore[name99] = shader99;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js
var name100, shader100;
var init_pbrBlockImageProcessing = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js"() {
    init_shaderStore();
    name100 = "pbrBlockImageProcessing";
    shader100 = "#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\n#if !defined(SKIPFINALCOLORCLAMP)\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\n#endif\n#else\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\nfinalColor.rgb*=finalColor.a;\n#endif\n";
    ShaderStore.IncludesShadersStore[name100] = shader100;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js
var name101, shader101;
var init_pbrDebug = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js"() {
    init_shaderStore();
    name101 = "pbrDebug";
    shader101 = "#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\n#if DEBUGMODE==1\ngl_FragColor.rgb=vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ngl_FragColor.rgb=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\n#elif DEBUGMODE==7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\n#elif DEBUGMODE==21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE==22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\n#elif DEBUGMODE==23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ngl_FragColor.rgb=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\n#elif DEBUGMODE==63\ngl_FragColor.rgb=vec3(roughness);\n#elif DEBUGMODE==64\ngl_FragColor.rgb=vec3(alphaG);\n#elif DEBUGMODE==65\ngl_FragColor.rgb=vec3(NdotV);\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)\ngl_FragColor.rgb=vec3(eho);\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\n#elif DEBUGMODE==87\ngl_FragColor.rgb=vec3(alpha);\n#endif\ngl_FragColor.rgb*=vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\n#endif\ngl_FragColor.a=1.0;\n#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor); \ngl_FragData[1]=vec4(0.,0.,0.,0.); \n#endif\nreturn;\n}\n#endif\n";
    ShaderStore.IncludesShadersStore[name101] = shader101;
  }
});

// node_modules/@babylonjs/core/Shaders/pbr.fragment.js
var name102, shader102;
var init_pbr_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/pbr.fragment.js"() {
    init_shaderStore();
    init_prePassDeclaration();
    init_oitDeclaration();
    init_pbrFragmentDeclaration();
    init_pbrUboDeclaration();
    init_pbrFragmentExtraDeclaration();
    init_lightFragmentDeclaration();
    init_lightUboDeclaration();
    init_pbrFragmentSamplersDeclaration();
    init_imageProcessingDeclaration();
    init_clipPlaneFragmentDeclaration();
    init_logDepthDeclaration();
    init_fogFragmentDeclaration();
    init_helperFunctions();
    init_subSurfaceScatteringFunctions();
    init_importanceSampling();
    init_pbrHelperFunctions();
    init_imageProcessingFunctions();
    init_shadowsFragmentFunctions();
    init_harmonicsFunctions();
    init_pbrDirectLightingSetupFunctions();
    init_pbrDirectLightingFalloffFunctions();
    init_pbrBRDFFunctions();
    init_hdrFilteringFunctions();
    init_pbrDirectLightingFunctions();
    init_pbrIBLFunctions();
    init_bumpFragmentMainFunctions();
    init_bumpFragmentFunctions();
    init_reflectionFunction();
    init_pbrBlockAlbedoOpacity();
    init_pbrBlockReflectivity();
    init_pbrBlockAmbientOcclusion();
    init_pbrBlockAlphaFresnel();
    init_pbrBlockAnisotropic();
    init_pbrBlockReflection();
    init_pbrBlockSheen();
    init_pbrBlockClearcoat();
    init_pbrBlockIridescence();
    init_pbrBlockSubSurface();
    init_oitFragment();
    init_clipPlaneFragment();
    init_pbrBlockNormalGeometric();
    init_bumpFragment();
    init_pbrBlockNormalFinal();
    init_depthPrePass();
    init_pbrBlockLightmapInit();
    init_pbrBlockGeometryInfo();
    init_pbrBlockReflectance0();
    init_pbrBlockReflectance();
    init_pbrBlockDirectLighting();
    init_lightFragment();
    init_pbrBlockFinalLitComponents();
    init_pbrBlockFinalUnlitComponents();
    init_pbrBlockFinalColorComposition();
    init_logDepthFragment();
    init_fogFragment();
    init_pbrBlockImageProcessing();
    init_pbrDebug();
    name102 = "pbrPixelShader";
    shader102 = "#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<oitFragment>\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nalbedoOpacityOutParams albedoOpacityOut;\n#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#endif\nalbedoOpacityBlock(\nvAlbedoColor,\n#ifdef ALBEDO\nalbedoTexture,\nvAlbedoInfos,\n#endif\n#ifdef OPACITY\nopacityMap,\nvOpacityInfos,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nalbedoOpacityOut\n);\nvec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;\nfloat alpha=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nambientOcclusionOutParams aoOut;\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\n#endif\nambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nvAmbientInfos,\n#endif\naoOut\n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 baseColor=surfaceAlbedo;\nreflectivityOutParams reflectivityOut;\n#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\nvec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\n#endif\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\n#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityBlock(\nvReflectivityColor,\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo,\nmetallicReflectanceFactors,\n#endif\n#ifdef REFLECTIVITY\nvReflectivityInfos,\nsurfaceMetallicOrReflectivityColorMap,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor,\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurfaceTexel,\n#endif\n#ifdef DETAIL\ndetailColor,\nvDetailInfos,\n#endif\nreflectivityOut\n);\nfloat microSurface=reflectivityOut.microSurface;\nfloat roughness=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;\nalphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface,\nalphaFresnelOut\n);\nalpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\n#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\n#endif\nanisotropicBlock(\nvAnisotropy,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW,\nanisotropicOut\n);\n#endif\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionBlock(\nvPositionW,\nnormalW,\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\nreflectionSampler,\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nvEnvironmentIrradiance,\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionMatrix,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nreflectionOut\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nsheenOutParams sheenOut;\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\n#endif\nsheenBlock(\nvSheenColor,\n#ifdef SHEEN_ROUGHNESS\nvSheenRoughness,\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nsheenMapRoughnessData,\n#endif\n#endif\nroughness,\n#ifdef SHEEN_TEXTURE\nsheenMapData,\nvSheenInfos.y,\n#endif\nreflectance,\n#ifdef SHEEN_LINKWITHALBEDO\nbaseColor,\nsurfaceAlbedo,\n#endif\n#ifdef ENVIRONMENTBRDF\nNdotV,\nenvironmentBrdf,\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nAARoughnessFactors,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\nreflectionOut.reflectionCoords,\nNdotVUnclamped,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nseo,\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\neho,\n#endif\n#endif\nsheenOut\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\niridescenceOutParams iridescenceOut;\n#ifdef IRIDESCENCE_TEXTURE\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\n#endif\niridescenceBlock(\nvIridescenceParams,\nNdotV,\nspecularEnvironmentR0,\n#ifdef IRIDESCENCE_TEXTURE\niridescenceMapData,\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\niridescenceThicknessMapData,\n#endif\n#ifdef CLEARCOAT\nNdotVUnclamped,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#endif\niridescenceOut\n);\nfloat iridescenceIntensity=iridescenceOut.iridescenceIntensity;\nspecularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nclearcoatOutParams clearcoatOut;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatBlock(\nvPositionW,\ngeometricNormalW,\nviewDirectionW,\nvClearCoatParams,\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatMapRoughnessData,\n#endif\nspecularEnvironmentR0,\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData,\n#endif\n#ifdef CLEARCOAT_TINT\nvClearCoatTintParams,\nclearCoatColorAtDistance,\nvClearCoatRefractionParams,\n#ifdef CLEARCOAT_TINT_TEXTURE\nclearCoatTintMapData,\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\nvClearCoatBumpInfos,\nclearCoatBumpMapData,\nvClearCoatBumpUV,\n#if defined(TANGENT) && defined(NORMAL)\nvTBN,\n#else\nvClearCoatTangentSpaceParams,\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nnormalMatrix,\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nfaceNormal,\n#endif\n#ifdef REFLECTION\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\nvLightingIntensity,\nreflectionSampler,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\nambientMonochrome,\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n(gl_FrontFacing ? 1. : -1.),\n#endif\nclearcoatOut\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nsubSurfaceOutParams subSurfaceOut;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\n#endif\nsubSurfaceBlock(\nvSubSurfaceIntensity,\nvThicknessParam,\nvTintColor,\nnormalW,\nspecularEnvironmentReflectance,\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap,\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nrefractionIntensityMap,\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\ntranslucencyIntensityMap,\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\nreflectionMatrix,\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nreflectionOut.irradianceVector,\n#endif\n#if defined(REALTIME_FILTERING)\nreflectionSampler,\nvReflectionFilteringInfo,\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\nirradianceSampler,\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\nsurfaceAlbedo,\n#endif\n#ifdef SS_REFRACTION\nvPositionW,\nviewDirectionW,\nview,\nvRefractionInfos,\nrefractionMatrix,\nvRefractionMicrosurfaceInfos,\nvLightingIntensity,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha,\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nNdotVUnclamped,\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\nroughness,\n#endif\nalphaG,\nrefractionSampler,\n#ifndef LODBASEDMICROSFURACE\nrefractionSamplerLow,\nrefractionSamplerHigh,\n#endif\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\n#ifdef REALTIME_FILTERING\nvRefractionFilteringInfo,\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nvRefractionPosition,\nvRefractionSize,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvDiffusionDistance,\n#endif\nsubSurfaceOut\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \n#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \nirradiance/=sqAlbedo;\n#else\ngl_FragData[0]=finalColor; \nfloat scatteringDiffusionProfile=255.;\n#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \n#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); \n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(REFLECTIVITY)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(baseReflectivity.rgb,baseReflectivity.a*writeGeometryInfo);\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo);\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\n#endif\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\nfrontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;\nfrontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);\n} else {\nbackColor+=finalColor;\n}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";
    ShaderStore.ShadersStore[name102] = shader102;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js
var name103, shader103;
var init_pbrVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js"() {
    init_shaderStore();
    name103 = "pbrVertexDeclaration";
    shader103 = "uniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#ifdef REFLECTIVITY \nuniform vec3 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n#ifdef METALLIC_REFLECTANCE\nuniform vec2 vMetallicReflectanceInfos;\nuniform mat4 metallicReflectanceMatrix;\n#endif\n#ifdef REFLECTANCE\nuniform vec2 vReflectanceInfos;\nuniform mat4 reflectanceMatrix;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\nuniform mat4 microSurfaceSamplerMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;\nuniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;\nuniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#ifdef IRIDESCENCE\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;\nuniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionInfos;\nuniform mat4 refractionMatrix;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;\nuniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;\nuniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;\nuniform mat4 translucencyIntensityMatrix;\n#endif\n#endif\n#ifdef NORMAL\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;\nuniform vec3 vSphericalL1_1;\nuniform vec3 vSphericalL10;\nuniform vec3 vSphericalL11;\nuniform vec3 vSphericalL2_2;\nuniform vec3 vSphericalL2_1;\nuniform vec3 vSphericalL20;\nuniform vec3 vSphericalL21;\nuniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;\nuniform vec3 vSphericalY;\nuniform vec3 vSphericalZ;\nuniform vec3 vSphericalXX_ZZ;\nuniform vec3 vSphericalYY_ZZ;\nuniform vec3 vSphericalZZ;\nuniform vec3 vSphericalXY;\nuniform vec3 vSphericalYZ;\nuniform vec3 vSphericalZX;\n#endif\n#endif\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\nuniform mat4 detailMatrix;\n#endif\n#define ADDITIONAL_VERTEX_DECLARATION\n";
    ShaderStore.IncludesShadersStore[name103] = shader103;
  }
});

// node_modules/@babylonjs/core/Shaders/pbr.vertex.js
var name104, shader104;
var init_pbr_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/pbr.vertex.js"() {
    init_shaderStore();
    init_pbrVertexDeclaration();
    init_pbrUboDeclaration();
    init_uvAttributeDeclaration();
    init_mainUVVaryingDeclaration();
    init_helperFunctions();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_instancesDeclaration();
    init_prePassVertexDeclaration();
    init_samplerVertexDeclaration();
    init_harmonicsFunctions();
    init_bumpVertexDeclaration();
    init_clipPlaneVertexDeclaration();
    init_fogVertexDeclaration();
    init_lightVxFragmentDeclaration();
    init_lightVxUboDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_logDepthDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_prePassVertex();
    init_uvVariableDeclaration();
    init_samplerVertexImplementation();
    init_bumpVertex();
    init_clipPlaneVertex();
    init_fogVertex();
    init_shadowsVertex();
    init_logDepthVertex();
    name104 = "pbrVertexShader";
    shader104 = "precision highp float;\n#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#endif\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\n#elif INSTANCESCOLOR\nvColor=instanceColor;\n#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}";
    ShaderStore.ShadersStore[name104] = shader104;
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters3, PBRMaterialDefines, PBRBaseMaterial;
var init_pbrBaseMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_logger();
    init_smartArray();
    init_brdfTextureTools();
    init_scene();
    init_math_vector();
    init_buffer();
    init_pbrBRDFConfiguration();
    init_prePassConfiguration();
    init_math_color();
    init_math_scalar();
    init_imageProcessingConfiguration();
    init_material();
    init_materialPluginEvent();
    init_materialDefines();
    init_pushMaterial();
    init_materialHelper();
    init_texture();
    init_materialFlags();
    init_baseTexture_polynomial();
    init_pbr_fragment();
    init_pbr_vertex();
    init_effectFallbacks();
    init_pbrClearCoatConfiguration();
    init_pbrIridescenceConfiguration();
    init_pbrAnisotropicConfiguration();
    init_pbrSheenConfiguration();
    init_pbrSubSurfaceConfiguration();
    init_material_detailMapConfiguration();
    onCreatedEffectParameters3 = { effect: null, subMesh: null };
    PBRMaterialDefines = function(_super) {
      __extends(PBRMaterialDefines2, _super);
      function PBRMaterialDefines2(externalProperties) {
        var _this = _super.call(this, externalProperties) || this;
        _this.PBR = true;
        _this.NUM_SAMPLES = "0";
        _this.REALTIME_FILTERING = false;
        _this.MAINUV1 = false;
        _this.MAINUV2 = false;
        _this.MAINUV3 = false;
        _this.MAINUV4 = false;
        _this.MAINUV5 = false;
        _this.MAINUV6 = false;
        _this.UV1 = false;
        _this.UV2 = false;
        _this.UV3 = false;
        _this.UV4 = false;
        _this.UV5 = false;
        _this.UV6 = false;
        _this.ALBEDO = false;
        _this.GAMMAALBEDO = false;
        _this.ALBEDODIRECTUV = 0;
        _this.VERTEXCOLOR = false;
        _this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        _this.AMBIENT = false;
        _this.AMBIENTDIRECTUV = 0;
        _this.AMBIENTINGRAYSCALE = false;
        _this.OPACITY = false;
        _this.VERTEXALPHA = false;
        _this.OPACITYDIRECTUV = 0;
        _this.OPACITYRGB = false;
        _this.ALPHATEST = false;
        _this.DEPTHPREPASS = false;
        _this.ALPHABLEND = false;
        _this.ALPHAFROMALBEDO = false;
        _this.ALPHATESTVALUE = "0.5";
        _this.SPECULAROVERALPHA = false;
        _this.RADIANCEOVERALPHA = false;
        _this.ALPHAFRESNEL = false;
        _this.LINEARALPHAFRESNEL = false;
        _this.PREMULTIPLYALPHA = false;
        _this.EMISSIVE = false;
        _this.EMISSIVEDIRECTUV = 0;
        _this.GAMMAEMISSIVE = false;
        _this.REFLECTIVITY = false;
        _this.REFLECTIVITY_GAMMA = false;
        _this.REFLECTIVITYDIRECTUV = 0;
        _this.SPECULARTERM = false;
        _this.MICROSURFACEFROMREFLECTIVITYMAP = false;
        _this.MICROSURFACEAUTOMATIC = false;
        _this.LODBASEDMICROSFURACE = false;
        _this.MICROSURFACEMAP = false;
        _this.MICROSURFACEMAPDIRECTUV = 0;
        _this.METALLICWORKFLOW = false;
        _this.ROUGHNESSSTOREINMETALMAPALPHA = false;
        _this.ROUGHNESSSTOREINMETALMAPGREEN = false;
        _this.METALLNESSSTOREINMETALMAPBLUE = false;
        _this.AOSTOREINMETALMAPRED = false;
        _this.METALLIC_REFLECTANCE = false;
        _this.METALLIC_REFLECTANCE_GAMMA = false;
        _this.METALLIC_REFLECTANCEDIRECTUV = 0;
        _this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
        _this.REFLECTANCE = false;
        _this.REFLECTANCE_GAMMA = false;
        _this.REFLECTANCEDIRECTUV = 0;
        _this.ENVIRONMENTBRDF = false;
        _this.ENVIRONMENTBRDF_RGBD = false;
        _this.NORMAL = false;
        _this.TANGENT = false;
        _this.BUMP = false;
        _this.BUMPDIRECTUV = 0;
        _this.OBJECTSPACE_NORMALMAP = false;
        _this.PARALLAX = false;
        _this.PARALLAXOCCLUSION = false;
        _this.NORMALXYSCALE = true;
        _this.LIGHTMAP = false;
        _this.LIGHTMAPDIRECTUV = 0;
        _this.USELIGHTMAPASSHADOWMAP = false;
        _this.GAMMALIGHTMAP = false;
        _this.RGBDLIGHTMAP = false;
        _this.REFLECTION = false;
        _this.REFLECTIONMAP_3D = false;
        _this.REFLECTIONMAP_SPHERICAL = false;
        _this.REFLECTIONMAP_PLANAR = false;
        _this.REFLECTIONMAP_CUBIC = false;
        _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        _this.REFLECTIONMAP_PROJECTION = false;
        _this.REFLECTIONMAP_SKYBOX = false;
        _this.REFLECTIONMAP_EXPLICIT = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        _this.INVERTCUBICMAP = false;
        _this.USESPHERICALFROMREFLECTIONMAP = false;
        _this.USEIRRADIANCEMAP = false;
        _this.USESPHERICALINVERTEX = false;
        _this.REFLECTIONMAP_OPPOSITEZ = false;
        _this.LODINREFLECTIONALPHA = false;
        _this.GAMMAREFLECTION = false;
        _this.RGBDREFLECTION = false;
        _this.LINEARSPECULARREFLECTION = false;
        _this.RADIANCEOCCLUSION = false;
        _this.HORIZONOCCLUSION = false;
        _this.INSTANCES = false;
        _this.THIN_INSTANCES = false;
        _this.INSTANCESCOLOR = false;
        _this.PREPASS = false;
        _this.PREPASS_IRRADIANCE = false;
        _this.PREPASS_IRRADIANCE_INDEX = -1;
        _this.PREPASS_ALBEDO_SQRT = false;
        _this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        _this.PREPASS_DEPTH = false;
        _this.PREPASS_DEPTH_INDEX = -1;
        _this.PREPASS_NORMAL = false;
        _this.PREPASS_NORMAL_INDEX = -1;
        _this.PREPASS_POSITION = false;
        _this.PREPASS_POSITION_INDEX = -1;
        _this.PREPASS_VELOCITY = false;
        _this.PREPASS_VELOCITY_INDEX = -1;
        _this.PREPASS_REFLECTIVITY = false;
        _this.PREPASS_REFLECTIVITY_INDEX = -1;
        _this.SCENE_MRT_COUNT = 0;
        _this.NUM_BONE_INFLUENCERS = 0;
        _this.BonesPerMesh = 0;
        _this.BONETEXTURE = false;
        _this.BONES_VELOCITY_ENABLED = false;
        _this.NONUNIFORMSCALING = false;
        _this.MORPHTARGETS = false;
        _this.MORPHTARGETS_NORMAL = false;
        _this.MORPHTARGETS_TANGENT = false;
        _this.MORPHTARGETS_UV = false;
        _this.NUM_MORPH_INFLUENCERS = 0;
        _this.MORPHTARGETS_TEXTURE = false;
        _this.IMAGEPROCESSING = false;
        _this.VIGNETTE = false;
        _this.VIGNETTEBLENDMODEMULTIPLY = false;
        _this.VIGNETTEBLENDMODEOPAQUE = false;
        _this.TONEMAPPING = false;
        _this.TONEMAPPING_ACES = false;
        _this.CONTRAST = false;
        _this.COLORCURVES = false;
        _this.COLORGRADING = false;
        _this.COLORGRADING3D = false;
        _this.SAMPLER3DGREENDEPTH = false;
        _this.SAMPLER3DBGRMAP = false;
        _this.IMAGEPROCESSINGPOSTPROCESS = false;
        _this.SKIPFINALCOLORCLAMP = false;
        _this.EXPOSURE = false;
        _this.MULTIVIEW = false;
        _this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        _this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        _this.USEPHYSICALLIGHTFALLOFF = false;
        _this.USEGLTFLIGHTFALLOFF = false;
        _this.TWOSIDEDLIGHTING = false;
        _this.SHADOWFLOAT = false;
        _this.CLIPPLANE = false;
        _this.CLIPPLANE2 = false;
        _this.CLIPPLANE3 = false;
        _this.CLIPPLANE4 = false;
        _this.CLIPPLANE5 = false;
        _this.CLIPPLANE6 = false;
        _this.POINTSIZE = false;
        _this.FOG = false;
        _this.LOGARITHMICDEPTH = false;
        _this.FORCENORMALFORWARD = false;
        _this.SPECULARAA = false;
        _this.UNLIT = false;
        _this.DEBUGMODE = 0;
        _this.rebuild();
        return _this;
      }
      PBRMaterialDefines2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.ALPHATESTVALUE = "0.5";
        this.PBR = true;
        this.NORMALXYSCALE = true;
      };
      return PBRMaterialDefines2;
    }(MaterialDefines);
    PBRBaseMaterial = function(_super) {
      __extends(PBRBaseMaterial2, _super);
      function PBRBaseMaterial2(name105, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this._directIntensity = 1;
        _this._emissiveIntensity = 1;
        _this._environmentIntensity = 1;
        _this._specularIntensity = 1;
        _this._lightingInfos = new Vector4(_this._directIntensity, _this._emissiveIntensity, _this._environmentIntensity, _this._specularIntensity);
        _this._disableBumpMap = false;
        _this._albedoTexture = null;
        _this._ambientTexture = null;
        _this._ambientTextureStrength = 1;
        _this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        _this._opacityTexture = null;
        _this._reflectionTexture = null;
        _this._emissiveTexture = null;
        _this._reflectivityTexture = null;
        _this._metallicTexture = null;
        _this._metallic = null;
        _this._roughness = null;
        _this._metallicF0Factor = 1;
        _this._metallicReflectanceColor = Color3.White();
        _this._useOnlyMetallicFromMetallicReflectanceTexture = false;
        _this._metallicReflectanceTexture = null;
        _this._reflectanceTexture = null;
        _this._microSurfaceTexture = null;
        _this._bumpTexture = null;
        _this._lightmapTexture = null;
        _this._ambientColor = new Color3(0, 0, 0);
        _this._albedoColor = new Color3(1, 1, 1);
        _this._reflectivityColor = new Color3(1, 1, 1);
        _this._reflectionColor = new Color3(1, 1, 1);
        _this._emissiveColor = new Color3(0, 0, 0);
        _this._microSurface = 0.9;
        _this._useLightmapAsShadowmap = false;
        _this._useHorizonOcclusion = true;
        _this._useRadianceOcclusion = true;
        _this._useAlphaFromAlbedoTexture = false;
        _this._useSpecularOverAlpha = true;
        _this._useMicroSurfaceFromReflectivityMapAlpha = false;
        _this._useRoughnessFromMetallicTextureAlpha = true;
        _this._useRoughnessFromMetallicTextureGreen = false;
        _this._useMetallnessFromMetallicTextureBlue = false;
        _this._useAmbientOcclusionFromMetallicTextureRed = false;
        _this._useAmbientInGrayScale = false;
        _this._useAutoMicroSurfaceFromReflectivityMap = false;
        _this._lightFalloff = PBRBaseMaterial2.LIGHTFALLOFF_PHYSICAL;
        _this._useRadianceOverAlpha = true;
        _this._useObjectSpaceNormalMap = false;
        _this._useParallax = false;
        _this._useParallaxOcclusion = false;
        _this._parallaxScaleBias = 0.05;
        _this._disableLighting = false;
        _this._maxSimultaneousLights = 4;
        _this._invertNormalMapX = false;
        _this._invertNormalMapY = false;
        _this._twoSidedLighting = false;
        _this._alphaCutOff = 0.4;
        _this._forceAlphaTest = false;
        _this._useAlphaFresnel = false;
        _this._useLinearAlphaFresnel = false;
        _this._environmentBRDFTexture = null;
        _this._forceIrradianceInFragment = false;
        _this._realTimeFiltering = false;
        _this._realTimeFilteringQuality = 8;
        _this._forceNormalForward = false;
        _this._enableSpecularAntiAliasing = false;
        _this._imageProcessingObserver = null;
        _this._renderTargets = new SmartArray(16);
        _this._globalAmbientColor = new Color3(0, 0, 0);
        _this._useLogarithmicDepth = false;
        _this._unlit = false;
        _this._debugMode = 0;
        _this.debugMode = 0;
        _this._debugLimit = -1;
        _this._debugFactor = 1;
        _this._cacheHasRenderTargetTextures = false;
        _this.brdf = new PBRBRDFConfiguration(_this);
        _this.clearCoat = new PBRClearCoatConfiguration(_this);
        _this.iridescence = new PBRIridescenceConfiguration(_this);
        _this.anisotropy = new PBRAnisotropicConfiguration(_this);
        _this.sheen = new PBRSheenConfiguration(_this);
        _this.subSurface = new PBRSubSurfaceConfiguration(_this);
        _this.detailMap = new DetailMapConfiguration(_this);
        _this._attachImageProcessingConfiguration(null);
        _this.getRenderTargetTextures = function() {
          _this._renderTargets.reset();
          if (MaterialFlags.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
            _this._renderTargets.push(_this._reflectionTexture);
          }
          _this._eventInfo.renderTargets = _this._renderTargets;
          _this._callbackPluginEventFillRenderTargetTextures(_this._eventInfo);
          return _this._renderTargets;
        };
        _this._environmentBRDFTexture = GetEnvironmentBRDFTexture(_this.getScene());
        _this.prePassConfiguration = new PrePassConfiguration();
        return _this;
      }
      Object.defineProperty(PBRBaseMaterial2.prototype, "realTimeFiltering", {
        get: function() {
          return this._realTimeFiltering;
        },
        set: function(b) {
          this._realTimeFiltering = b;
          this.markAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRBaseMaterial2.prototype, "realTimeFilteringQuality", {
        get: function() {
          return this._realTimeFilteringQuality;
        },
        set: function(n) {
          this._realTimeFilteringQuality = n;
          this.markAsDirty(1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRBaseMaterial2.prototype, "canRenderToMRT", {
        get: function() {
          return true;
        },
        enumerable: false,
        configurable: true
      });
      PBRBaseMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
        var _this = this;
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
            _this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      };
      Object.defineProperty(PBRBaseMaterial2.prototype, "hasRenderTargetTextures", {
        get: function() {
          if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            return true;
          }
          return this._cacheHasRenderTargetTextures;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRBaseMaterial2.prototype, "isPrePassCapable", {
        get: function() {
          return !this.disableDepthWrite;
        },
        enumerable: false,
        configurable: true
      });
      PBRBaseMaterial2.prototype.getClassName = function() {
        return "PBRBaseMaterial";
      };
      Object.defineProperty(PBRBaseMaterial2.prototype, "useLogarithmicDepth", {
        get: function() {
          return this._useLogarithmicDepth;
        },
        set: function(value) {
          this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRBaseMaterial2.prototype, "_disableAlphaBlending", {
        get: function() {
          var _a;
          return this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_OPAQUE || this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_ALPHATEST || ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending);
        },
        enumerable: false,
        configurable: true
      });
      PBRBaseMaterial2.prototype.needAlphaBlending = function() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
      };
      PBRBaseMaterial2.prototype.needAlphaTesting = function() {
        var _a;
        if (this._forceAlphaTest) {
          return true;
        }
        if ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending) {
          return false;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial2.PBRMATERIAL_ALPHATEST);
      };
      PBRBaseMaterial2.prototype._shouldUseAlphaFromAlbedoTexture = function() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial2.PBRMATERIAL_OPAQUE;
      };
      PBRBaseMaterial2.prototype._hasAlphaChannel = function() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
      };
      PBRBaseMaterial2.prototype.getAlphaTestTexture = function() {
        return this._albedoTexture;
      };
      PBRBaseMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        if (subMesh.effect && this.isFrozen) {
          if (subMesh.effect._wasPreviouslyReady) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
          subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
        }
        var defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        var scene = this.getScene();
        var engine = scene.getEngine();
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              if (!this._albedoTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            var reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              }
              if (reflectionTexture.irradianceTexture && !reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                if (!this._metallicTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else if (this._reflectivityTexture) {
                if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._metallicReflectanceTexture) {
                if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._reflectanceTexture) {
                if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._microSurfaceTexture) {
                if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentBRDFTexture.isReady()) {
                return false;
              }
            }
          }
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
        }
        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
        }
        var previousEffect = subMesh.effect;
        var lightDisposed = defines._areLightsDisposed;
        var effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        if (effect) {
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters3.effect = effect;
            onCreatedEffectParameters3.subMesh = subMesh;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
          }
          if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
            effect = previousEffect;
            defines.markAsUnprocessed();
            if (lightDisposed) {
              defines._areLightsDisposed = true;
              return false;
            }
          } else {
            scene.resetCachedMaterial();
            subMesh.setEffect(effect, defines, this._materialContext);
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        subMesh.effect._wasPreviouslyReady = true;
        return true;
      };
      PBRBaseMaterial2.prototype.isMetallicWorkflow = function() {
        if (this._metallic != null || this._roughness != null || this._metallicTexture) {
          return true;
        }
        return false;
      };
      PBRBaseMaterial2.prototype._prepareEffect = function(mesh, defines, onCompiled, onError, useInstances, useClipPlane, useThinInstances) {
        if (onCompiled === void 0) {
          onCompiled = null;
        }
        if (onError === void 0) {
          onError = null;
        }
        if (useInstances === void 0) {
          useInstances = null;
        }
        if (useClipPlane === void 0) {
          useClipPlane = null;
        }
        this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
        if (!defines.isDirty) {
          return null;
        }
        defines.markAsProcessed();
        var scene = this.getScene();
        var engine = scene.getEngine();
        var fallbacks = new EffectFallbacks();
        var fallbackRank = 0;
        if (defines.USESPHERICALINVERTEX) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
        }
        if (defines.FOG) {
          fallbacks.addFallback(fallbackRank, "FOG");
        }
        if (defines.SPECULARAA) {
          fallbacks.addFallback(fallbackRank, "SPECULARAA");
        }
        if (defines.POINTSIZE) {
          fallbacks.addFallback(fallbackRank, "POINTSIZE");
        }
        if (defines.LOGARITHMICDEPTH) {
          fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
        }
        if (defines.PARALLAX) {
          fallbacks.addFallback(fallbackRank, "PARALLAX");
        }
        if (defines.PARALLAXOCCLUSION) {
          fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
        }
        if (defines.ENVIRONMENTBRDF) {
          fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
        }
        if (defines.TANGENT) {
          fallbacks.addFallback(fallbackRank++, "TANGENT");
        }
        if (defines.BUMP) {
          fallbacks.addFallback(fallbackRank++, "BUMP");
        }
        fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
        if (defines.SPECULARTERM) {
          fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
        }
        if (defines.USESPHERICALFROMREFLECTIONMAP) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
        }
        if (defines.USEIRRADIANCEMAP) {
          fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
        }
        if (defines.LIGHTMAP) {
          fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
        }
        if (defines.NORMAL) {
          fallbacks.addFallback(fallbackRank++, "NORMAL");
        }
        if (defines.AMBIENT) {
          fallbacks.addFallback(fallbackRank++, "AMBIENT");
        }
        if (defines.EMISSIVE) {
          fallbacks.addFallback(fallbackRank++, "EMISSIVE");
        }
        if (defines.VERTEXCOLOR) {
          fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
        }
        if (defines.MORPHTARGETS) {
          fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
        }
        if (defines.MULTIVIEW) {
          fallbacks.addFallback(0, "MULTIVIEW");
        }
        var attribs = [VertexBuffer.PositionKind];
        if (defines.NORMAL) {
          attribs.push(VertexBuffer.NormalKind);
        }
        if (defines.TANGENT) {
          attribs.push(VertexBuffer.TangentKind);
        }
        for (var i = 1; i <= 6; ++i) {
          if (defines["UV" + i]) {
            attribs.push("uv".concat(i === 1 ? "" : i));
          }
        }
        if (defines.VERTEXCOLOR) {
          attribs.push(VertexBuffer.ColorKind);
        }
        if (defines.INSTANCESCOLOR) {
          attribs.push(VertexBuffer.ColorInstanceKind);
        }
        MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
        MaterialHelper.PrepareAttributesForInstances(attribs, defines);
        MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
        MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        var shaderName = "pbr";
        var uniforms = [
          "world",
          "view",
          "viewProjection",
          "vEyePosition",
          "vLightsType",
          "vAmbientColor",
          "vAlbedoColor",
          "vReflectivityColor",
          "vMetallicReflectanceFactors",
          "vEmissiveColor",
          "visibility",
          "vReflectionColor",
          "vFogInfos",
          "vFogColor",
          "pointSize",
          "vAlbedoInfos",
          "vAmbientInfos",
          "vOpacityInfos",
          "vReflectionInfos",
          "vReflectionPosition",
          "vReflectionSize",
          "vEmissiveInfos",
          "vReflectivityInfos",
          "vReflectionFilteringInfo",
          "vMetallicReflectanceInfos",
          "vReflectanceInfos",
          "vMicroSurfaceSamplerInfos",
          "vBumpInfos",
          "vLightmapInfos",
          "mBones",
          "vClipPlane",
          "vClipPlane2",
          "vClipPlane3",
          "vClipPlane4",
          "vClipPlane5",
          "vClipPlane6",
          "albedoMatrix",
          "ambientMatrix",
          "opacityMatrix",
          "reflectionMatrix",
          "emissiveMatrix",
          "reflectivityMatrix",
          "normalMatrix",
          "microSurfaceSamplerMatrix",
          "bumpMatrix",
          "lightmapMatrix",
          "metallicReflectanceMatrix",
          "reflectanceMatrix",
          "vLightingIntensity",
          "logarithmicDepthConstant",
          "vSphericalX",
          "vSphericalY",
          "vSphericalZ",
          "vSphericalXX_ZZ",
          "vSphericalYY_ZZ",
          "vSphericalZZ",
          "vSphericalXY",
          "vSphericalYZ",
          "vSphericalZX",
          "vSphericalL00",
          "vSphericalL1_1",
          "vSphericalL10",
          "vSphericalL11",
          "vSphericalL2_2",
          "vSphericalL2_1",
          "vSphericalL20",
          "vSphericalL21",
          "vSphericalL22",
          "vReflectionMicrosurfaceInfos",
          "vTangentSpaceParams",
          "boneTextureWidth",
          "vDebugMode",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ];
        var samplers = [
          "albedoSampler",
          "reflectivitySampler",
          "ambientSampler",
          "emissiveSampler",
          "bumpSampler",
          "lightmapSampler",
          "opacitySampler",
          "reflectionSampler",
          "reflectionSamplerLow",
          "reflectionSamplerHigh",
          "irradianceSampler",
          "microSurfaceSampler",
          "environmentBrdfSampler",
          "boneSampler",
          "metallicReflectanceSampler",
          "reflectanceSampler",
          "morphTargets",
          "oitDepthSampler",
          "oitFrontColorSampler"
        ];
        var uniformBuffers = ["Material", "Scene", "Mesh"];
        this._eventInfo.fallbacks = fallbacks;
        this._eventInfo.fallbackRank = fallbackRank;
        this._eventInfo.defines = defines;
        this._eventInfo.uniforms = uniforms;
        this._eventInfo.samplers = samplers;
        this._eventInfo.uniformBuffersNames = uniformBuffers;
        this._eventInfo.customCode = void 0;
        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
        PrePassConfiguration.AddUniforms(uniforms);
        PrePassConfiguration.AddSamplers(samplers);
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
        }
        MaterialHelper.PrepareUniformsAndSamplersList({
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines,
          maxSimultaneousLights: this._maxSimultaneousLights
        });
        var csnrOptions = {};
        if (this.customShaderNameResolve) {
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
        }
        var join = defines.toString();
        return engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled,
          onError,
          indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
          processFinalCode: csnrOptions.processFinalCode,
          processCodeAfterIncludes: this._eventInfo.customCode,
          multiTarget: defines.PREPASS
        }, engine);
      };
      PBRBaseMaterial2.prototype._prepareDefines = function(mesh, defines, useInstances, useClipPlane, useThinInstances) {
        var _a;
        if (useInstances === void 0) {
          useInstances = null;
        }
        if (useClipPlane === void 0) {
          useClipPlane = null;
        }
        if (useThinInstances === void 0) {
          useThinInstances = false;
        }
        var scene = this.getScene();
        var engine = scene.getEngine();
        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        defines._needNormals = true;
        MaterialHelper.PrepareDefinesForMultiview(scene, defines);
        var oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
        defines.METALLICWORKFLOW = this.isMetallicWorkflow();
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          if (scene.texturesEnabled) {
            if (scene.getEngine().getCaps().textureLOD) {
              defines.LODBASEDMICROSFURACE = true;
            }
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
              defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
            } else {
              defines.ALBEDO = false;
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
              defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
            } else {
              defines.OPACITY = false;
            }
            var reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.REFLECTION = true;
              defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
              defines.RGBDREFLECTION = reflectionTexture.isRGBD;
              defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
              defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
              defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
              if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
                defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
                if (engine._features.needTypeSuffixInShaderConstants) {
                  defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
                }
                defines.REALTIME_FILTERING = true;
              } else {
                defines.REALTIME_FILTERING = false;
              }
              if (reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE) {
                defines.INVERTCUBICMAP = true;
              }
              defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              switch (reflectionTexture.coordinatesMode) {
                case Texture.EXPLICIT_MODE:
                  defines.REFLECTIONMAP_EXPLICIT = true;
                  break;
                case Texture.PLANAR_MODE:
                  defines.REFLECTIONMAP_PLANAR = true;
                  break;
                case Texture.PROJECTION_MODE:
                  defines.REFLECTIONMAP_PROJECTION = true;
                  break;
                case Texture.SKYBOX_MODE:
                  defines.REFLECTIONMAP_SKYBOX = true;
                  break;
                case Texture.SPHERICAL_MODE:
                  defines.REFLECTIONMAP_SPHERICAL = true;
                  break;
                case Texture.EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                  defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.CUBIC_MODE:
                case Texture.INVCUBIC_MODE:
                default:
                  defines.REFLECTIONMAP_CUBIC = true;
                  defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
                  break;
              }
              if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
                if (reflectionTexture.irradianceTexture) {
                  defines.USEIRRADIANCEMAP = true;
                  defines.USESPHERICALFROMREFLECTIONMAP = false;
                } else if (reflectionTexture.isCube) {
                  defines.USESPHERICALFROMREFLECTIONMAP = true;
                  defines.USEIRRADIANCEMAP = false;
                  if (this._forceIrradianceInFragment || this.realTimeFiltering || scene.getEngine().getCaps().maxVaryingVectors <= 8) {
                    defines.USESPHERICALINVERTEX = false;
                  } else {
                    defines.USESPHERICALINVERTEX = true;
                  }
                }
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONMAP_3D = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              defines.INVERTCUBICMAP = false;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
              defines.USEIRRADIANCEMAP = false;
              defines.USESPHERICALINVERTEX = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
              defines.LODINREFLECTIONALPHA = false;
              defines.GAMMAREFLECTION = false;
              defines.RGBDREFLECTION = false;
              defines.LINEARSPECULARREFLECTION = false;
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
              defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
              defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
              defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
            } else {
              defines.EMISSIVE = false;
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
                defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
                defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
                defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
                defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
                defines.REFLECTIVITY_GAMMA = false;
              } else if (this._reflectivityTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
                defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
                defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
                defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
              } else {
                defines.REFLECTIVITY = false;
              }
              if (this._metallicReflectanceTexture || this._reflectanceTexture) {
                var identicalTextures = this._metallicReflectanceTexture !== null && this._metallicReflectanceTexture._texture === ((_a = this._reflectanceTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);
                defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;
                if (this._metallicReflectanceTexture) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
                  defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
                } else {
                  defines.METALLIC_REFLECTANCE = false;
                }
                if (this._reflectanceTexture && !identicalTextures && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
                  defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
                } else {
                  defines.REFLECTANCE = false;
                }
              } else {
                defines.METALLIC_REFLECTANCE = false;
                defines.REFLECTANCE = false;
              }
              if (this._microSurfaceTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
              } else {
                defines.MICROSURFACEMAP = false;
              }
            } else {
              defines.REFLECTIVITY = false;
              defines.MICROSURFACEMAP = false;
            }
            if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
              if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                defines.PARALLAX = true;
                defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
              } else {
                defines.PARALLAX = false;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.ENVIRONMENTBRDF = true;
              defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
            } else {
              defines.ENVIRONMENTBRDF = false;
              defines.ENVIRONMENTBRDF_RGBD = false;
            }
            if (this._shouldUseAlphaFromAlbedoTexture()) {
              defines.ALPHAFROMALBEDO = true;
            } else {
              defines.ALPHAFROMALBEDO = false;
            }
          }
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          if (this._lightFalloff === PBRBaseMaterial2.LIGHTFALLOFF_STANDARD) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = false;
          } else if (this._lightFalloff === PBRBaseMaterial2.LIGHTFALLOFF_GLTF) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = true;
          } else {
            defines.USEPHYSICALLIGHTFALLOFF = true;
            defines.USEGLTFLIGHTFALLOFF = false;
          }
          defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
          if (!this.backFaceCulling && this._twoSidedLighting) {
            defines.TWOSIDEDLIGHTING = true;
          } else {
            defines.TWOSIDEDLIGHTING = false;
          }
          defines.SPECULARAA = scene.getEngine().getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
        }
        if (defines._areTexturesDirty || defines._areMiscDirty) {
          defines.ALPHATESTVALUE = "".concat(this._alphaCutOff).concat(this._alphaCutOff % 1 === 0 ? "." : "");
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
          defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
          defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        defines.FORCENORMALFORWARD = this._forceNormalForward;
        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
        if (defines._areMiscDirty) {
          MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
          defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
          defines.DEBUGMODE = this._debugMode;
        }
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefines(this._eventInfo);
        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false, useClipPlane, useThinInstances);
        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial2.PBRMATERIAL_OPAQUE);
      };
      PBRBaseMaterial2.prototype.forceCompilation = function(mesh, onCompiled, options) {
        var _this = this;
        var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
        var defines = new PBRMaterialDefines(this._eventInfo.defineNames);
        var effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters3.effect = effect;
          onCreatedEffectParameters3.subMesh = null;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
        }
        if (effect.isReady()) {
          if (onCompiled) {
            onCompiled(this);
          }
        } else {
          effect.onCompileObservable.add(function() {
            if (onCompiled) {
              onCompiled(_this);
            }
          });
        }
      };
      PBRBaseMaterial2.prototype.buildUniformLayout = function() {
        var ubo = this._uniformBuffer;
        ubo.addUniform("vAlbedoInfos", 2);
        ubo.addUniform("vAmbientInfos", 4);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vReflectivityInfos", 3);
        ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
        ubo.addUniform("vReflectionInfos", 2);
        ubo.addUniform("vReflectionFilteringInfo", 2);
        ubo.addUniform("vReflectionPosition", 3);
        ubo.addUniform("vReflectionSize", 3);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("albedoMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("reflectivityMatrix", 16);
        ubo.addUniform("microSurfaceSamplerMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("reflectionMatrix", 16);
        ubo.addUniform("vReflectionColor", 3);
        ubo.addUniform("vAlbedoColor", 4);
        ubo.addUniform("vLightingIntensity", 4);
        ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("vReflectivityColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vAmbientColor", 3);
        ubo.addUniform("vDebugMode", 2);
        ubo.addUniform("vMetallicReflectanceFactors", 4);
        ubo.addUniform("vMetallicReflectanceInfos", 2);
        ubo.addUniform("metallicReflectanceMatrix", 16);
        ubo.addUniform("vReflectanceInfos", 2);
        ubo.addUniform("reflectanceMatrix", 16);
        ubo.addUniform("vSphericalL00", 3);
        ubo.addUniform("vSphericalL1_1", 3);
        ubo.addUniform("vSphericalL10", 3);
        ubo.addUniform("vSphericalL11", 3);
        ubo.addUniform("vSphericalL2_2", 3);
        ubo.addUniform("vSphericalL2_1", 3);
        ubo.addUniform("vSphericalL20", 3);
        ubo.addUniform("vSphericalL21", 3);
        ubo.addUniform("vSphericalL22", 3);
        ubo.addUniform("vSphericalX", 3);
        ubo.addUniform("vSphericalY", 3);
        ubo.addUniform("vSphericalZ", 3);
        ubo.addUniform("vSphericalXX_ZZ", 3);
        ubo.addUniform("vSphericalYY_ZZ", 3);
        ubo.addUniform("vSphericalZZ", 3);
        ubo.addUniform("vSphericalXY", 3);
        ubo.addUniform("vSphericalYZ", 3);
        ubo.addUniform("vSphericalZX", 3);
        _super.prototype.buildUniformLayout.call(this);
      };
      PBRBaseMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
        var _a, _b, _c, _d;
        var scene = this.getScene();
        var defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        var effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        var engine = scene.getEngine();
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
        MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
        var reflectionTexture = null;
        var ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          reflectionTexture = this._getReflectionTexture();
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
            if (scene.texturesEnabled) {
              if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
                MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, "albedo");
              }
              if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
                ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
                MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
                ubo.updateFloat2("vReflectionInfos", reflectionTexture.level, 0);
                if (reflectionTexture.boundingBoxSize) {
                  var cubeTexture = reflectionTexture;
                  ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
                }
                if (this.realTimeFiltering) {
                  var width = reflectionTexture.getSize().width;
                  ubo.updateFloat2("vReflectionFilteringInfo", width, Scalar.Log2(width));
                }
                if (!defines.USEIRRADIANCEMAP) {
                  var polynomials = reflectionTexture.sphericalPolynomial;
                  if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                    if (defines.SPHERICAL_HARMONICS) {
                      var preScaledHarmonics = polynomials.preScaledHarmonics;
                      ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
                      ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                      ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
                      ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
                      ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                      ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                      ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
                      ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
                      ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
                    } else {
                      ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                      ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                      ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                      ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                      ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                      ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                      ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                    }
                  }
                }
                ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
              }
              if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (MaterialFlags.SpecularTextureEnabled) {
                if (this._metallicTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
                  MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
                } else if (this._reflectivityTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
                  MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
                }
                if (this._metallicReflectanceTexture) {
                  ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
                }
                if (this._reflectanceTexture && defines.REFLECTANCE) {
                  ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
                }
                if (this._microSurfaceTexture) {
                  ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
                }
              }
              if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
                MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.METALLICWORKFLOW) {
              TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
              TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
              ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
              var ior = (_b = (_a = this.subSurface) === null || _a === void 0 ? void 0 : _a._indexOfRefraction) !== null && _b !== void 0 ? _b : 1.5;
              var outsideIOR = 1;
              var f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
              this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
              var metallicF90 = this._metallicF0Factor;
              ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
            } else {
              ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
            }
            ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor3("vReflectionColor", this._reflectionColor);
            if (!defines.SS_REFRACTION && ((_c = this.subSurface) === null || _c === void 0 ? void 0 : _c._linkRefractionWithTransparency)) {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
            } else {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
            }
            this._lightingInfos.x = this._directIntensity;
            this._lightingInfos.y = this._emissiveIntensity;
            this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
            this._lightingInfos.w = this._specularIntensity;
            ubo.updateVector4("vLightingIntensity", this._lightingInfos);
            scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
            ubo.updateFloat2("vDebugMode", this._debugLimit, this._debugFactor);
          }
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              ubo.setTexture("albedoSampler", this._albedoTexture);
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              ubo.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              ubo.setTexture("opacitySampler", this._opacityTexture);
            }
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (defines.LODBASEDMICROSFURACE) {
                ubo.setTexture("reflectionSampler", reflectionTexture);
              } else {
                ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
                ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
                ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
              }
              if (defines.USEIRRADIANCEMAP) {
                ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
              }
            }
            if (defines.ENVIRONMENTBRDF) {
              ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              ubo.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              ubo.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                ubo.setTexture("reflectivitySampler", this._metallicTexture);
              } else if (this._reflectivityTexture) {
                ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
              }
              if (this._metallicReflectanceTexture) {
                ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
              }
              if (this._reflectanceTexture && defines.REFLECTANCE) {
                ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
              }
              if (this._microSurfaceTexture) {
                ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
              }
            }
            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              ubo.setTexture("bumpSampler", this._bumpTexture);
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          MaterialHelper.BindClipPlane(this._activeEffect, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || mesh.receiveShadows) {
            this.bindView(effect);
          }
          MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
          if (defines.NUM_MORPH_INFLUENCERS) {
            MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            (_d = mesh.bakedVertexAnimationManager) === null || _d === void 0 ? void 0 : _d.bind(effect, defines.INSTANCES);
          }
          this._imageProcessingConfiguration.bind(this._activeEffect);
          MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);
        }
        this._afterBind(mesh, this._activeEffect);
        ubo.update();
      };
      PBRBaseMaterial2.prototype.getAnimatables = function() {
        var results = _super.prototype.getAnimatables.call(this);
        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
          results.push(this._albedoTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
          results.push(this._metallicTexture);
        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
          results.push(this._reflectivityTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        return results;
      };
      PBRBaseMaterial2.prototype._getReflectionTexture = function() {
        if (this._reflectionTexture) {
          return this._reflectionTexture;
        }
        return this.getScene().environmentTexture;
      };
      PBRBaseMaterial2.prototype.getActiveTextures = function() {
        var activeTextures = _super.prototype.getActiveTextures.call(this);
        if (this._albedoTexture) {
          activeTextures.push(this._albedoTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._reflectivityTexture) {
          activeTextures.push(this._reflectivityTexture);
        }
        if (this._metallicTexture) {
          activeTextures.push(this._metallicTexture);
        }
        if (this._metallicReflectanceTexture) {
          activeTextures.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture) {
          activeTextures.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture) {
          activeTextures.push(this._microSurfaceTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        return activeTextures;
      };
      PBRBaseMaterial2.prototype.hasTexture = function(texture) {
        if (_super.prototype.hasTexture.call(this, texture)) {
          return true;
        }
        if (this._albedoTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._reflectivityTexture === texture) {
          return true;
        }
        if (this._metallicTexture === texture) {
          return true;
        }
        if (this._metallicReflectanceTexture === texture) {
          return true;
        }
        if (this._reflectanceTexture === texture) {
          return true;
        }
        if (this._microSurfaceTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        return false;
      };
      PBRBaseMaterial2.prototype.setPrePassRenderer = function() {
        var _a;
        if ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.isScatteringEnabled) {
          var subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
          if (subSurfaceConfiguration) {
            subSurfaceConfiguration.enabled = true;
          }
          return true;
        }
        return false;
      };
      PBRBaseMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (forceDisposeTextures) {
          if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
            this._environmentBRDFTexture.dispose();
          }
          (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
          (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
          (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();
          (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();
          (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();
          (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();
          (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();
          (_l = this._reflectanceTexture) === null || _l === void 0 ? void 0 : _l.dispose();
          (_m = this._microSurfaceTexture) === null || _m === void 0 ? void 0 : _m.dispose();
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
      };
      PBRBaseMaterial2.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
      PBRBaseMaterial2.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
      PBRBaseMaterial2.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
      PBRBaseMaterial2.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
      PBRBaseMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
      PBRBaseMaterial2.LIGHTFALLOFF_PHYSICAL = 0;
      PBRBaseMaterial2.LIGHTFALLOFF_GLTF = 1;
      PBRBaseMaterial2.LIGHTFALLOFF_STANDARD = 2;
      __decorate([
        serializeAsImageProcessingConfiguration()
      ], PBRBaseMaterial2.prototype, "_imageProcessingConfiguration", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRBaseMaterial2.prototype, "debugMode", void 0);
      __decorate([
        serialize()
      ], PBRBaseMaterial2.prototype, "useLogarithmicDepth", null);
      return PBRBaseMaterial2;
    }(PushMaterial);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial;
var init_pbrMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_brdfTextureTools();
    init_math_color();
    init_pbrBaseMaterial();
    init_typeStore();
    PBRMaterial = function(_super) {
      __extends(PBRMaterial2, _super);
      function PBRMaterial2(name105, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this.directIntensity = 1;
        _this.emissiveIntensity = 1;
        _this.environmentIntensity = 1;
        _this.specularIntensity = 1;
        _this.disableBumpMap = false;
        _this.ambientTextureStrength = 1;
        _this.ambientTextureImpactOnAnalyticalLights = PBRMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        _this.metallicF0Factor = 1;
        _this.metallicReflectanceColor = Color3.White();
        _this.useOnlyMetallicFromMetallicReflectanceTexture = false;
        _this.ambientColor = new Color3(0, 0, 0);
        _this.albedoColor = new Color3(1, 1, 1);
        _this.reflectivityColor = new Color3(1, 1, 1);
        _this.reflectionColor = new Color3(1, 1, 1);
        _this.emissiveColor = new Color3(0, 0, 0);
        _this.microSurface = 1;
        _this.useLightmapAsShadowmap = false;
        _this.useAlphaFromAlbedoTexture = false;
        _this.forceAlphaTest = false;
        _this.alphaCutOff = 0.4;
        _this.useSpecularOverAlpha = true;
        _this.useMicroSurfaceFromReflectivityMapAlpha = false;
        _this.useRoughnessFromMetallicTextureAlpha = true;
        _this.useRoughnessFromMetallicTextureGreen = false;
        _this.useMetallnessFromMetallicTextureBlue = false;
        _this.useAmbientOcclusionFromMetallicTextureRed = false;
        _this.useAmbientInGrayScale = false;
        _this.useAutoMicroSurfaceFromReflectivityMap = false;
        _this.useRadianceOverAlpha = true;
        _this.useObjectSpaceNormalMap = false;
        _this.useParallax = false;
        _this.useParallaxOcclusion = false;
        _this.parallaxScaleBias = 0.05;
        _this.disableLighting = false;
        _this.forceIrradianceInFragment = false;
        _this.maxSimultaneousLights = 4;
        _this.invertNormalMapX = false;
        _this.invertNormalMapY = false;
        _this.twoSidedLighting = false;
        _this.useAlphaFresnel = false;
        _this.useLinearAlphaFresnel = false;
        _this.environmentBRDFTexture = null;
        _this.forceNormalForward = false;
        _this.enableSpecularAntiAliasing = false;
        _this.useHorizonOcclusion = true;
        _this.useRadianceOcclusion = true;
        _this.unlit = false;
        _this._environmentBRDFTexture = GetEnvironmentBRDFTexture(_this.getScene());
        return _this;
      }
      Object.defineProperty(PBRMaterial2.prototype, "refractionTexture", {
        get: function() {
          return this.subSurface.refractionTexture;
        },
        set: function(value) {
          this.subSurface.refractionTexture = value;
          if (value) {
            this.subSurface.isRefractionEnabled = true;
          } else if (!this.subSurface.linkRefractionWithTransparency) {
            this.subSurface.isRefractionEnabled = false;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "indexOfRefraction", {
        get: function() {
          return this.subSurface.indexOfRefraction;
        },
        set: function(value) {
          this.subSurface.indexOfRefraction = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "invertRefractionY", {
        get: function() {
          return this.subSurface.invertRefractionY;
        },
        set: function(value) {
          this.subSurface.invertRefractionY = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "linkRefractionWithTransparency", {
        get: function() {
          return this.subSurface.linkRefractionWithTransparency;
        },
        set: function(value) {
          this.subSurface.linkRefractionWithTransparency = value;
          if (value) {
            this.subSurface.isRefractionEnabled = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "usePhysicalLightFalloff", {
        get: function() {
          return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
        },
        set: function(value) {
          if (value !== this.usePhysicalLightFalloff) {
            this._markAllSubMeshesAsTexturesDirty();
            if (value) {
              this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
            } else {
              this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "useGLTFLightFalloff", {
        get: function() {
          return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
        },
        set: function(value) {
          if (value !== this.useGLTFLightFalloff) {
            this._markAllSubMeshesAsTexturesDirty();
            if (value) {
              this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
            } else {
              this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "imageProcessingConfiguration", {
        get: function() {
          return this._imageProcessingConfiguration;
        },
        set: function(value) {
          this._attachImageProcessingConfiguration(value);
          this._markAllSubMeshesAsTexturesDirty();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraColorCurvesEnabled", {
        get: function() {
          return this.imageProcessingConfiguration.colorCurvesEnabled;
        },
        set: function(value) {
          this.imageProcessingConfiguration.colorCurvesEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraColorGradingEnabled", {
        get: function() {
          return this.imageProcessingConfiguration.colorGradingEnabled;
        },
        set: function(value) {
          this.imageProcessingConfiguration.colorGradingEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraToneMappingEnabled", {
        get: function() {
          return this._imageProcessingConfiguration.toneMappingEnabled;
        },
        set: function(value) {
          this._imageProcessingConfiguration.toneMappingEnabled = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraExposure", {
        get: function() {
          return this._imageProcessingConfiguration.exposure;
        },
        set: function(value) {
          this._imageProcessingConfiguration.exposure = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraContrast", {
        get: function() {
          return this._imageProcessingConfiguration.contrast;
        },
        set: function(value) {
          this._imageProcessingConfiguration.contrast = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraColorGradingTexture", {
        get: function() {
          return this._imageProcessingConfiguration.colorGradingTexture;
        },
        set: function(value) {
          this._imageProcessingConfiguration.colorGradingTexture = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PBRMaterial2.prototype, "cameraColorCurves", {
        get: function() {
          return this._imageProcessingConfiguration.colorCurves;
        },
        set: function(value) {
          this._imageProcessingConfiguration.colorCurves = value;
        },
        enumerable: false,
        configurable: true
      });
      PBRMaterial2.prototype.getClassName = function() {
        return "PBRMaterial";
      };
      PBRMaterial2.prototype.clone = function(name105) {
        var _this = this;
        var clone = SerializationHelper.Clone(function() {
          return new PBRMaterial2(name105, _this.getScene());
        }, this);
        clone.id = name105;
        clone.name = name105;
        this.stencil.copyTo(clone.stencil);
        this.clearCoat.copyTo(clone.clearCoat);
        this.anisotropy.copyTo(clone.anisotropy);
        this.brdf.copyTo(clone.brdf);
        this.sheen.copyTo(clone.sheen);
        this.subSurface.copyTo(clone.subSurface);
        return clone;
      };
      PBRMaterial2.prototype.serialize = function() {
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.customType = "BABYLON.PBRMaterial";
        serializationObject.clearCoat = this.clearCoat.serialize();
        serializationObject.anisotropy = this.anisotropy.serialize();
        serializationObject.brdf = this.brdf.serialize();
        serializationObject.sheen = this.sheen.serialize();
        serializationObject.subSurface = this.subSurface.serialize();
        return serializationObject;
      };
      PBRMaterial2.Parse = function(source, scene, rootUrl) {
        var material = SerializationHelper.Parse(function() {
          return new PBRMaterial2(source.name, scene);
        }, source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        if (source.clearCoat) {
          material.clearCoat.parse(source.clearCoat, scene, rootUrl);
        }
        if (source.anisotropy) {
          material.anisotropy.parse(source.anisotropy, scene, rootUrl);
        }
        if (source.brdf) {
          material.brdf.parse(source.brdf, scene, rootUrl);
        }
        if (source.sheen) {
          material.sheen.parse(source.sheen, scene, rootUrl);
        }
        if (source.subSurface) {
          material.subSurface.parse(source.subSurface, scene, rootUrl);
        }
        return material;
      };
      PBRMaterial2.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
      PBRMaterial2.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
      PBRMaterial2.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
      PBRMaterial2.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
      PBRMaterial2.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "directIntensity", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "emissiveIntensity", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "environmentIntensity", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "specularIntensity", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "disableBumpMap", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "albedoTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "ambientTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "ambientTextureStrength", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], PBRMaterial2.prototype, "opacityTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "reflectionTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "emissiveTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "reflectivityTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "metallicTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "metallic", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "roughness", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "metallicF0Factor", void 0);
      __decorate([
        serializeAsColor3(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "metallicReflectanceColor", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "metallicReflectanceTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "reflectanceTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "microSurfaceTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "bumpTexture", void 0);
      __decorate([
        serializeAsTexture(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
      ], PBRMaterial2.prototype, "lightmapTexture", void 0);
      __decorate([
        serializeAsColor3("ambient"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "ambientColor", void 0);
      __decorate([
        serializeAsColor3("albedo"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "albedoColor", void 0);
      __decorate([
        serializeAsColor3("reflectivity"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "reflectivityColor", void 0);
      __decorate([
        serializeAsColor3("reflection"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "reflectionColor", void 0);
      __decorate([
        serializeAsColor3("emissive"),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "emissiveColor", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "microSurface", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useLightmapAsShadowmap", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], PBRMaterial2.prototype, "useAlphaFromAlbedoTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], PBRMaterial2.prototype, "forceAlphaTest", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
      ], PBRMaterial2.prototype, "alphaCutOff", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useSpecularOverAlpha", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useAmbientInGrayScale", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
      __decorate([
        serialize()
      ], PBRMaterial2.prototype, "usePhysicalLightFalloff", null);
      __decorate([
        serialize()
      ], PBRMaterial2.prototype, "useGLTFLightFalloff", null);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useRadianceOverAlpha", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useObjectSpaceNormalMap", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useParallax", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useParallaxOcclusion", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "parallaxScaleBias", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsLightsDirty")
      ], PBRMaterial2.prototype, "disableLighting", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "forceIrradianceInFragment", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsLightsDirty")
      ], PBRMaterial2.prototype, "maxSimultaneousLights", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "invertNormalMapX", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "invertNormalMapY", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "twoSidedLighting", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useAlphaFresnel", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useLinearAlphaFresnel", void 0);
      __decorate([
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "environmentBRDFTexture", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "forceNormalForward", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "enableSpecularAntiAliasing", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useHorizonOcclusion", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsTexturesDirty")
      ], PBRMaterial2.prototype, "useRadianceOcclusion", void 0);
      __decorate([
        serialize(),
        expandToProperty("_markAllSubMeshesAsMiscDirty")
      ], PBRMaterial2.prototype, "unlit", void 0);
      return PBRMaterial2;
    }(PBRBaseMaterial);
    RegisterClass("BABYLON.PBRMaterial", PBRMaterial);
  }
});

// node_modules/@babylonjs/core/Misc/workerPool.js
var WorkerPool, AutoReleaseWorkerPool;
var init_workerPool = __esm({
  "node_modules/@babylonjs/core/Misc/workerPool.js"() {
    init_tslib_es6();
    WorkerPool = function() {
      function WorkerPool2(workers) {
        this._pendingActions = new Array();
        this._workerInfos = workers.map(function(worker2) {
          return {
            workerPromise: Promise.resolve(worker2),
            idle: true
          };
        });
      }
      WorkerPool2.prototype.dispose = function() {
        for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {
          var workerInfo = _a[_i];
          workerInfo.workerPromise.then(function(worker2) {
            worker2.terminate();
          });
        }
        this._workerInfos.length = 0;
        this._pendingActions.length = 0;
      };
      WorkerPool2.prototype.push = function(action) {
        if (!this._executeOnIdleWorker(action)) {
          this._pendingActions.push(action);
        }
      };
      WorkerPool2.prototype._executeOnIdleWorker = function(action) {
        for (var _i = 0, _a = this._workerInfos; _i < _a.length; _i++) {
          var workerInfo = _a[_i];
          if (workerInfo.idle) {
            this._execute(workerInfo, action);
            return true;
          }
        }
        return false;
      };
      WorkerPool2.prototype._execute = function(workerInfo, action) {
        var _this = this;
        workerInfo.idle = false;
        workerInfo.workerPromise.then(function(worker2) {
          action(worker2, function() {
            var nextAction = _this._pendingActions.shift();
            if (nextAction) {
              _this._execute(workerInfo, nextAction);
            } else {
              workerInfo.idle = true;
            }
          });
        });
      };
      return WorkerPool2;
    }();
    AutoReleaseWorkerPool = function(_super) {
      __extends(AutoReleaseWorkerPool2, _super);
      function AutoReleaseWorkerPool2(maxWorkers, createWorkerAsync, options) {
        if (options === void 0) {
          options = AutoReleaseWorkerPool2.DefaultOptions;
        }
        var _this = _super.call(this, []) || this;
        _this._maxWorkers = maxWorkers;
        _this._createWorkerAsync = createWorkerAsync;
        _this._options = options;
        return _this;
      }
      AutoReleaseWorkerPool2.prototype.push = function(action) {
        if (!this._executeOnIdleWorker(action)) {
          if (this._workerInfos.length < this._maxWorkers) {
            var workerInfo = {
              workerPromise: this._createWorkerAsync(),
              idle: false
            };
            this._workerInfos.push(workerInfo);
            this._execute(workerInfo, action);
          } else {
            this._pendingActions.push(action);
          }
        }
      };
      AutoReleaseWorkerPool2.prototype._execute = function(workerInfo, action) {
        var _this = this;
        if (workerInfo.timeoutId) {
          clearTimeout(workerInfo.timeoutId);
          delete workerInfo.timeoutId;
        }
        _super.prototype._execute.call(this, workerInfo, function(worker2, onComplete) {
          action(worker2, function() {
            onComplete();
            if (workerInfo.idle) {
              workerInfo.timeoutId = setTimeout(function() {
                workerInfo.workerPromise.then(function(worker3) {
                  worker3.terminate();
                });
                var indexOf = _this._workerInfos.indexOf(workerInfo);
                if (indexOf !== -1) {
                  _this._workerInfos.splice(indexOf, 1);
                }
              }, _this._options.idleTimeElapsedBeforeRelease);
            }
          });
        });
      };
      AutoReleaseWorkerPool2.DefaultOptions = {
        idleTimeElapsedBeforeRelease: 1e3
      };
      return AutoReleaseWorkerPool2;
    }(WorkerPool);
  }
});

// node_modules/@babylonjs/core/Lights/pointLight.js
var PointLight;
var init_pointLight = __esm({
  "node_modules/@babylonjs/core/Lights/pointLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    Node.AddNodeConstructor("Light_Type_0", function(name105, scene) {
      return function() {
        return new PointLight(name105, Vector3.Zero(), scene);
      };
    });
    PointLight = function(_super) {
      __extends(PointLight2, _super);
      function PointLight2(name105, position, scene) {
        var _this = _super.call(this, name105, scene) || this;
        _this._shadowAngle = Math.PI / 2;
        _this.position = position;
        return _this;
      }
      Object.defineProperty(PointLight2.prototype, "shadowAngle", {
        get: function() {
          return this._shadowAngle;
        },
        set: function(value) {
          this._shadowAngle = value;
          this.forceProjectionMatrixCompute();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PointLight2.prototype, "direction", {
        get: function() {
          return this._direction;
        },
        set: function(value) {
          var previousNeedCube = this.needCube();
          this._direction = value;
          if (this.needCube() !== previousNeedCube && this._shadowGenerator) {
            this._shadowGenerator.recreateShadowMap();
          }
        },
        enumerable: false,
        configurable: true
      });
      PointLight2.prototype.getClassName = function() {
        return "PointLight";
      };
      PointLight2.prototype.getTypeID = function() {
        return Light.LIGHTTYPEID_POINTLIGHT;
      };
      PointLight2.prototype.needCube = function() {
        return !this.direction;
      };
      PointLight2.prototype.getShadowDirection = function(faceIndex) {
        if (this.direction) {
          return _super.prototype.getShadowDirection.call(this, faceIndex);
        } else {
          switch (faceIndex) {
            case 0:
              return new Vector3(1, 0, 0);
            case 1:
              return new Vector3(-1, 0, 0);
            case 2:
              return new Vector3(0, -1, 0);
            case 3:
              return new Vector3(0, 1, 0);
            case 4:
              return new Vector3(0, 0, 1);
            case 5:
              return new Vector3(0, 0, -1);
          }
        }
        return Vector3.Zero();
      };
      PointLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
        var activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        var minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        var maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        var useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      };
      PointLight2.prototype._buildUniformLayout = function() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      };
      PointLight2.prototype.transferToEffect = function(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, lightIndex);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, 0, lightIndex);
        }
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
        return this;
      };
      PointLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);
        } else {
          effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);
        }
        return this;
      };
      PointLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
        defines["POINTLIGHT" + lightIndex] = true;
      };
      __decorate([
        serialize()
      ], PointLight2.prototype, "shadowAngle", null);
      return PointLight2;
    }(ShadowLight);
  }
});

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget;
var init_morphTarget = __esm({
  "node_modules/@babylonjs/core/Morph/morphTarget.js"() {
    init_tslib_es6();
    init_observable();
    init_engineStore();
    init_buffer();
    init_decorators();
    init_typeStore();
    MorphTarget = function() {
      function MorphTarget2(name105, influence, scene) {
        if (influence === void 0) {
          influence = 0;
        }
        if (scene === void 0) {
          scene = null;
        }
        this.name = name105;
        this.animations = new Array();
        this._positions = null;
        this._normals = null;
        this._tangents = null;
        this._uvs = null;
        this._uniqueId = 0;
        this.onInfluenceChanged = new Observable();
        this._onDataLayoutChanged = new Observable();
        this._animationPropertiesOverride = null;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.influence = influence;
        if (this._scene) {
          this._uniqueId = this._scene.getUniqueId();
        }
      }
      Object.defineProperty(MorphTarget2.prototype, "influence", {
        get: function() {
          return this._influence;
        },
        set: function(influence) {
          if (this._influence === influence) {
            return;
          }
          var previous = this._influence;
          this._influence = influence;
          if (this.onInfluenceChanged.hasObservers()) {
            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "animationPropertiesOverride", {
        get: function() {
          if (!this._animationPropertiesOverride && this._scene) {
            return this._scene.animationPropertiesOverride;
          }
          return this._animationPropertiesOverride;
        },
        set: function(value) {
          this._animationPropertiesOverride = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "uniqueId", {
        get: function() {
          return this._uniqueId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "hasPositions", {
        get: function() {
          return !!this._positions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "hasNormals", {
        get: function() {
          return !!this._normals;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "hasTangents", {
        get: function() {
          return !!this._tangents;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTarget2.prototype, "hasUVs", {
        get: function() {
          return !!this._uvs;
        },
        enumerable: false,
        configurable: true
      });
      MorphTarget2.prototype.setPositions = function(data) {
        var hadPositions = this.hasPositions;
        this._positions = data;
        if (hadPositions !== this.hasPositions) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      };
      MorphTarget2.prototype.getPositions = function() {
        return this._positions;
      };
      MorphTarget2.prototype.setNormals = function(data) {
        var hadNormals = this.hasNormals;
        this._normals = data;
        if (hadNormals !== this.hasNormals) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      };
      MorphTarget2.prototype.getNormals = function() {
        return this._normals;
      };
      MorphTarget2.prototype.setTangents = function(data) {
        var hadTangents = this.hasTangents;
        this._tangents = data;
        if (hadTangents !== this.hasTangents) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      };
      MorphTarget2.prototype.getTangents = function() {
        return this._tangents;
      };
      MorphTarget2.prototype.setUVs = function(data) {
        var hadUVs = this.hasUVs;
        this._uvs = data;
        if (hadUVs !== this.hasUVs) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      };
      MorphTarget2.prototype.getUVs = function() {
        return this._uvs;
      };
      MorphTarget2.prototype.clone = function() {
        var _this = this;
        var newOne = SerializationHelper.Clone(function() {
          return new MorphTarget2(_this.name, _this.influence, _this._scene);
        }, this);
        newOne._positions = this._positions;
        newOne._normals = this._normals;
        newOne._tangents = this._tangents;
        newOne._uvs = this._uvs;
        return newOne;
      };
      MorphTarget2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.influence = this.influence;
        serializationObject.positions = Array.prototype.slice.call(this.getPositions());
        if (this.id != null) {
          serializationObject.id = this.id;
        }
        if (this.hasNormals) {
          serializationObject.normals = Array.prototype.slice.call(this.getNormals());
        }
        if (this.hasTangents) {
          serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
        }
        if (this.hasUVs) {
          serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      };
      MorphTarget2.prototype.getClassName = function() {
        return "MorphTarget";
      };
      MorphTarget2.Parse = function(serializationObject, scene) {
        var result = new MorphTarget2(serializationObject.name, serializationObject.influence);
        result.setPositions(serializationObject.positions);
        if (serializationObject.id != null) {
          result.id = serializationObject.id;
        }
        if (serializationObject.normals) {
          result.setNormals(serializationObject.normals);
        }
        if (serializationObject.tangents) {
          result.setTangents(serializationObject.tangents);
        }
        if (serializationObject.uvs) {
          result.setUVs(serializationObject.uvs);
        }
        if (serializationObject.animations) {
          for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
            var parsedAnimation = serializationObject.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              result.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          if (serializationObject.autoAnimate && scene) {
            scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1);
          }
        }
        return result;
      };
      MorphTarget2.FromMesh = function(mesh, name105, influence) {
        if (!name105) {
          name105 = mesh.name;
        }
        var result = new MorphTarget2(name105, influence, mesh.getScene());
        result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
        }
        return result;
      };
      __decorate([
        serialize()
      ], MorphTarget2.prototype, "id", void 0);
      return MorphTarget2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray;
var init_rawTexture2DArray = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js"() {
    init_tslib_es6();
    init_texture();
    init_engine_rawTexture();
    RawTexture2DArray = function(_super) {
      __extends(RawTexture2DArray2, _super);
      function RawTexture2DArray2(data, width, height, depth, format, scene, generateMipMaps, invertY, samplingMode, textureType) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
        }
        if (textureType === void 0) {
          textureType = 0;
        }
        var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;
        _this.format = format;
        _this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);
        _this._depth = depth;
        _this.is2DArray = true;
        return _this;
      }
      Object.defineProperty(RawTexture2DArray2.prototype, "depth", {
        get: function() {
          return this._depth;
        },
        enumerable: false,
        configurable: true
      });
      RawTexture2DArray2.prototype.update = function(data) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
      };
      RawTexture2DArray2.CreateRGBATexture = function(data, width, height, depth, scene, generateMipMaps, invertY, samplingMode, type) {
        if (generateMipMaps === void 0) {
          generateMipMaps = true;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (type === void 0) {
          type = 0;
        }
        return new RawTexture2DArray2(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
      };
      return RawTexture2DArray2;
    }(Texture);
  }
});

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager;
var init_morphTargetManager = __esm({
  "node_modules/@babylonjs/core/Morph/morphTargetManager.js"() {
    init_smartArray();
    init_logger();
    init_engineStore();
    init_morphTarget();
    init_rawTexture2DArray();
    MorphTargetManager = function() {
      function MorphTargetManager2(scene) {
        if (scene === void 0) {
          scene = null;
        }
        this._targets = new Array();
        this._targetInfluenceChangedObservers = new Array();
        this._targetDataLayoutChangedObservers = new Array();
        this._activeTargets = new SmartArray(16);
        this._supportsNormals = false;
        this._supportsTangents = false;
        this._supportsUVs = false;
        this._vertexCount = 0;
        this._textureVertexStride = 0;
        this._textureWidth = 0;
        this._textureHeight = 1;
        this._uniqueId = 0;
        this._tempInfluences = new Array();
        this._canUseTextureForTargets = false;
        this._blockCounter = 0;
        this._parentContainer = null;
        this.optimizeInfluencers = true;
        this.enableNormalMorphing = true;
        this.enableTangentMorphing = true;
        this.enableUVMorphing = true;
        this._useTextureToStoreTargets = true;
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        this._scene = scene;
        if (this._scene) {
          this._scene.morphTargetManagers.push(this);
          this._uniqueId = this._scene.getUniqueId();
          var engineCaps = this._scene.getEngine().getCaps();
          this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
        }
      }
      Object.defineProperty(MorphTargetManager2.prototype, "areUpdatesFrozen", {
        get: function() {
          return this._blockCounter > 0;
        },
        set: function(block) {
          if (block) {
            this._blockCounter++;
          } else {
            this._blockCounter--;
            if (this._blockCounter <= 0) {
              this._blockCounter = 0;
              this._syncActiveTargets(true);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "uniqueId", {
        get: function() {
          return this._uniqueId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "vertexCount", {
        get: function() {
          return this._vertexCount;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "supportsNormals", {
        get: function() {
          return this._supportsNormals && this.enableNormalMorphing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "supportsTangents", {
        get: function() {
          return this._supportsTangents && this.enableTangentMorphing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "supportsUVs", {
        get: function() {
          return this._supportsUVs && this.enableUVMorphing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "numTargets", {
        get: function() {
          return this._targets.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "numInfluencers", {
        get: function() {
          return this._activeTargets.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "influences", {
        get: function() {
          return this._influences;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "useTextureToStoreTargets", {
        get: function() {
          return this._useTextureToStoreTargets;
        },
        set: function(value) {
          this._useTextureToStoreTargets = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MorphTargetManager2.prototype, "isUsingTextureForTargets", {
        get: function() {
          return MorphTargetManager2.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets;
        },
        enumerable: false,
        configurable: true
      });
      MorphTargetManager2.prototype.getActiveTarget = function(index) {
        return this._activeTargets.data[index];
      };
      MorphTargetManager2.prototype.getTarget = function(index) {
        return this._targets[index];
      };
      MorphTargetManager2.prototype.addTarget = function(target) {
        var _this = this;
        this._targets.push(target);
        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(function(needUpdate) {
          _this._syncActiveTargets(needUpdate);
        }));
        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(function() {
          _this._syncActiveTargets(true);
        }));
        this._syncActiveTargets(true);
      };
      MorphTargetManager2.prototype.removeTarget = function(target) {
        var index = this._targets.indexOf(target);
        if (index >= 0) {
          this._targets.splice(index, 1);
          target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
          target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
          this._syncActiveTargets(true);
        }
      };
      MorphTargetManager2.prototype._bind = function(effect) {
        effect.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight);
        effect.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices);
        effect.setTexture("morphTargets", this._targetStoreTexture);
      };
      MorphTargetManager2.prototype.clone = function() {
        var copy = new MorphTargetManager2(this._scene);
        for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
          var target = _a[_i];
          copy.addTarget(target.clone());
        }
        copy.enableNormalMorphing = this.enableNormalMorphing;
        copy.enableTangentMorphing = this.enableTangentMorphing;
        copy.enableUVMorphing = this.enableUVMorphing;
        return copy;
      };
      MorphTargetManager2.prototype.serialize = function() {
        var serializationObject = {};
        serializationObject.id = this.uniqueId;
        serializationObject.targets = [];
        for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
          var target = _a[_i];
          serializationObject.targets.push(target.serialize());
        }
        return serializationObject;
      };
      MorphTargetManager2.prototype._syncActiveTargets = function(needUpdate) {
        if (this.areUpdatesFrozen) {
          return;
        }
        var influenceCount = 0;
        this._activeTargets.reset();
        this._supportsNormals = true;
        this._supportsTangents = true;
        this._supportsUVs = true;
        this._vertexCount = 0;
        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {
          this._morphTargetTextureIndices = new Float32Array(this._targets.length);
        }
        var targetIndex = -1;
        for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {
          var target = _a[_i];
          targetIndex++;
          if (target.influence === 0 && this.optimizeInfluencers) {
            continue;
          }
          this._activeTargets.push(target);
          this._morphTargetTextureIndices[influenceCount] = targetIndex;
          this._tempInfluences[influenceCount++] = target.influence;
          this._supportsNormals = this._supportsNormals && target.hasNormals;
          this._supportsTangents = this._supportsTangents && target.hasTangents;
          this._supportsUVs = this._supportsUVs && target.hasUVs;
          var positions = target.getPositions();
          if (positions) {
            var vertexCount = positions.length / 3;
            if (this._vertexCount === 0) {
              this._vertexCount = vertexCount;
            } else if (this._vertexCount !== vertexCount) {
              Logger.Error("Incompatible target. Targets must all have the same vertices count.");
              return;
            }
          }
        }
        if (!this._influences || this._influences.length !== influenceCount) {
          this._influences = new Float32Array(influenceCount);
        }
        for (var index = 0; index < influenceCount; index++) {
          this._influences[index] = this._tempInfluences[index];
        }
        if (needUpdate) {
          this.synchronize();
        }
      };
      MorphTargetManager2.prototype.synchronize = function() {
        if (!this._scene || this.areUpdatesFrozen) {
          return;
        }
        if (this.isUsingTextureForTargets && this._vertexCount) {
          this._textureVertexStride = 1;
          if (this._supportsNormals) {
            this._textureVertexStride++;
          }
          if (this._supportsTangents) {
            this._textureVertexStride++;
          }
          if (this._supportsUVs) {
            this._textureVertexStride++;
          }
          this._textureWidth = this._vertexCount * this._textureVertexStride;
          this._textureHeight = 1;
          var maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;
          if (this._textureWidth > maxTextureSize) {
            this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);
            this._textureWidth = maxTextureSize;
          }
          var mustUpdateTexture = true;
          if (this._targetStoreTexture) {
            var textureSize = this._targetStoreTexture.getSize();
            if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {
              mustUpdateTexture = false;
            }
          }
          if (mustUpdateTexture) {
            if (this._targetStoreTexture) {
              this._targetStoreTexture.dispose();
            }
            var targetCount = this._targets.length;
            var data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);
            var offset = 0;
            for (var index = 0; index < targetCount; index++) {
              var target = this._targets[index];
              var positions = target.getPositions();
              var normals = target.getNormals();
              var uvs = target.getUVs();
              var tangents = target.getTangents();
              if (!positions) {
                if (index === 0) {
                  Logger.Error("Invalid morph target. Target must have positions.");
                }
                return;
              }
              offset = index * this._textureWidth * this._textureHeight * 4;
              for (var vertex = 0; vertex < this._vertexCount; vertex++) {
                data[offset] = positions[vertex * 3];
                data[offset + 1] = positions[vertex * 3 + 1];
                data[offset + 2] = positions[vertex * 3 + 2];
                offset += 4;
                if (normals) {
                  data[offset] = normals[vertex * 3];
                  data[offset + 1] = normals[vertex * 3 + 1];
                  data[offset + 2] = normals[vertex * 3 + 2];
                  offset += 4;
                }
                if (uvs) {
                  data[offset] = uvs[vertex * 2];
                  data[offset + 1] = uvs[vertex * 2 + 1];
                  offset += 4;
                }
                if (tangents) {
                  data[offset] = tangents[vertex * 3];
                  data[offset + 1] = tangents[vertex * 3 + 1];
                  data[offset + 2] = tangents[vertex * 3 + 2];
                  offset += 4;
                }
              }
            }
            this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);
          }
        }
        for (var _i = 0, _a = this._scene.meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          if (mesh.morphTargetManager === this) {
            mesh._syncGeometryWithMorphTargetManager();
          }
        }
      };
      MorphTargetManager2.prototype.dispose = function() {
        if (this._targetStoreTexture) {
          this._targetStoreTexture.dispose();
        }
        this._targetStoreTexture = null;
        if (this._scene) {
          this._scene.removeMorphTargetManager(this);
          if (this._parentContainer) {
            var index = this._parentContainer.morphTargetManagers.indexOf(this);
            if (index > -1) {
              this._parentContainer.morphTargetManagers.splice(index, 1);
            }
            this._parentContainer = null;
          }
        }
      };
      MorphTargetManager2.Parse = function(serializationObject, scene) {
        var result = new MorphTargetManager2(scene);
        result._uniqueId = serializationObject.id;
        for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {
          var targetData = _a[_i];
          result.addTarget(MorphTarget.Parse(targetData, scene));
        }
        return result;
      };
      MorphTargetManager2.EnableTextureStorage = true;
      return MorphTargetManager2;
    }();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js
var RawCubeTexture;
var init_rawCubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_environmentTextureTools();
    init_internalTexture();
    init_cubeTexture();
    init_engine_rawTexture();
    RawCubeTexture = function(_super) {
      __extends(RawCubeTexture2, _super);
      function RawCubeTexture2(scene, data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
        if (format === void 0) {
          format = 5;
        }
        if (type === void 0) {
          type = 0;
        }
        if (generateMipMaps === void 0) {
          generateMipMaps = false;
        }
        if (invertY === void 0) {
          invertY = false;
        }
        if (samplingMode === void 0) {
          samplingMode = 3;
        }
        if (compression === void 0) {
          compression = null;
        }
        var _this = _super.call(this, "", scene) || this;
        _this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);
        return _this;
      }
      RawCubeTexture2.prototype.update = function(data, format, type, invertY, compression) {
        if (compression === void 0) {
          compression = null;
        }
        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);
      };
      RawCubeTexture2.prototype.updateRGBDAsync = function(data, sphericalPolynomial, lodScale, lodOffset) {
        if (sphericalPolynomial === void 0) {
          sphericalPolynomial = null;
        }
        if (lodScale === void 0) {
          lodScale = 0.8;
        }
        if (lodOffset === void 0) {
          lodOffset = 0;
        }
        return _UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(function() {
        });
      };
      RawCubeTexture2.prototype.clone = function() {
        var _this = this;
        return SerializationHelper.Clone(function() {
          var scene = _this.getScene();
          var internalTexture = _this._texture;
          var texture = new RawCubeTexture2(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
          if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {
            texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);
          }
          return texture;
        }, this);
      };
      return RawCubeTexture2;
    }(CubeTexture);
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js
function createDecoderAsync(wasmBinary) {
  return new Promise(function(resolve) {
    DracoDecoderModule({ wasmBinary }).then(function(module) {
      resolve({ module });
    });
  });
}
function decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {
  var buffer = new decoderModule.DecoderBuffer();
  buffer.Init(dataView, dataView.byteLength);
  var decoder = new decoderModule.Decoder();
  var geometry;
  var status;
  try {
    var type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH:
        geometry = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, geometry);
        break;
      case decoderModule.POINT_CLOUD:
        geometry = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, geometry);
        break;
      default:
        throw new Error("Invalid geometry type ".concat(type));
    }
    if (!status.ok() || !geometry.ptr) {
      throw new Error(status.error_msg());
    }
    if (type === decoderModule.TRIANGULAR_MESH) {
      var numFaces = geometry.num_faces();
      var numIndices = numFaces * 3;
      var byteLength = numIndices * 4;
      var ptr = decoderModule._malloc(byteLength);
      try {
        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);
        var indices = new Uint32Array(numIndices);
        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
        onIndicesData(indices);
      } finally {
        decoderModule._free(ptr);
      }
    }
    var processAttribute = function(kind2, attribute2, divider2) {
      if (divider2 === void 0) {
        divider2 = 1;
      }
      var numComponents = attribute2.num_components();
      var numPoints = geometry.num_points();
      var numValues = numPoints * numComponents;
      var byteLength2 = numValues * Float32Array.BYTES_PER_ELEMENT;
      var ptr2 = decoderModule._malloc(byteLength2);
      try {
        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute2, decoderModule.DT_FLOAT32, byteLength2, ptr2);
        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr2, numValues);
        if (kind2 === "color" && numComponents === 3) {
          var babylonData = new Float32Array(numPoints * 4);
          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {
            babylonData[i + 0] = values[j + 0];
            babylonData[i + 1] = values[j + 1];
            babylonData[i + 2] = values[j + 2];
            babylonData[i + 3] = 1;
          }
          onAttributeData(kind2, babylonData);
        } else {
          var babylonData = new Float32Array(numValues);
          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr2, numValues));
          if (divider2 !== 1) {
            for (var i = 0; i < babylonData.length; i++) {
              babylonData[i] = babylonData[i] / divider2;
            }
          }
          onAttributeData(kind2, babylonData);
        }
      } finally {
        decoderModule._free(ptr2);
      }
    };
    if (attributes) {
      for (var kind in attributes) {
        var id = attributes[kind];
        var attribute = decoder.GetAttributeByUniqueId(geometry, id);
        var divider = dividers && dividers[kind] || 1;
        processAttribute(kind, attribute, divider);
      }
    } else {
      var nativeAttributeTypes = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD"
      };
      for (var kind in nativeAttributeTypes) {
        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);
        if (id !== -1) {
          var attribute = decoder.GetAttribute(geometry, id);
          processAttribute(kind, attribute);
        }
      }
    }
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    decoderModule.destroy(decoder);
    decoderModule.destroy(buffer);
  }
}
function worker() {
  var decoderPromise;
  onmessage = function(event) {
    var data = event.data;
    switch (data.id) {
      case "init": {
        var decoder = data.decoder;
        if (decoder.url) {
          importScripts(decoder.url);
          decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });
        }
        postMessage("done");
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then(function(decoder2) {
          decodeMesh(decoder2, data.dataView, data.attributes, function(indices) {
            postMessage({ id: "indices", value: indices }, [indices.buffer]);
          }, function(kind, data2) {
            postMessage({ id: kind, value: data2 }, [data2.buffer]);
          });
          postMessage("done");
        });
        break;
      }
    }
  };
}
var DracoCompression;
var init_dracoCompression = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js"() {
    init_tools();
    init_workerPool();
    init_mesh_vertexData();
    DracoCompression = function() {
      function DracoCompression2(numWorkers) {
        if (numWorkers === void 0) {
          numWorkers = DracoCompression2.DefaultNumWorkers;
        }
        var decoder = DracoCompression2.Configuration.decoder;
        var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" ? {
          url: Tools.GetAbsoluteUrl(decoder.wasmUrl),
          wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl))
        } : {
          url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),
          wasmBinaryPromise: Promise.resolve(void 0)
        };
        if (numWorkers && typeof Worker === "function") {
          this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function(decoderWasmBinary) {
            var workerContent = "".concat(decodeMesh, "(").concat(worker, ")()");
            var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
            return new AutoReleaseWorkerPool(numWorkers, function() {
              return new Promise(function(resolve, reject) {
                var worker2 = new Worker(workerBlobUrl);
                var onError = function(error) {
                  worker2.removeEventListener("error", onError);
                  worker2.removeEventListener("message", onMessage);
                  reject(error);
                };
                var onMessage = function(message) {
                  if (message.data === "done") {
                    worker2.removeEventListener("error", onError);
                    worker2.removeEventListener("message", onMessage);
                    resolve(worker2);
                  }
                };
                worker2.addEventListener("error", onError);
                worker2.addEventListener("message", onMessage);
                worker2.postMessage({
                  id: "init",
                  decoder: {
                    url: decoderInfo.url,
                    wasmBinary: decoderWasmBinary
                  }
                });
              });
            });
          });
        } else {
          this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function(decoderWasmBinary) {
            if (!decoderInfo.url) {
              throw new Error("Draco decoder module is not available");
            }
            return Tools.LoadScriptAsync(decoderInfo.url).then(function() {
              return createDecoderAsync(decoderWasmBinary);
            });
          });
        }
      }
      Object.defineProperty(DracoCompression2, "DecoderAvailable", {
        get: function() {
          var decoder = DracoCompression2.Configuration.decoder;
          return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" || decoder.fallbackUrl);
        },
        enumerable: false,
        configurable: true
      });
      DracoCompression2.GetDefaultNumWorkers = function() {
        if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
          return 1;
        }
        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
      };
      Object.defineProperty(DracoCompression2, "Default", {
        get: function() {
          if (!DracoCompression2._Default) {
            DracoCompression2._Default = new DracoCompression2();
          }
          return DracoCompression2._Default;
        },
        enumerable: false,
        configurable: true
      });
      DracoCompression2.prototype.dispose = function() {
        if (this._workerPoolPromise) {
          this._workerPoolPromise.then(function(workerPool) {
            workerPool.dispose();
          });
        }
        delete this._workerPoolPromise;
        delete this._decoderModulePromise;
      };
      DracoCompression2.prototype.whenReadyAsync = function() {
        if (this._workerPoolPromise) {
          return this._workerPoolPromise.then(function() {
          });
        }
        if (this._decoderModulePromise) {
          return this._decoderModulePromise.then(function() {
          });
        }
        return Promise.resolve();
      };
      DracoCompression2.prototype.decodeMeshAsync = function(data, attributes, dividers) {
        var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        if (this._workerPoolPromise) {
          return this._workerPoolPromise.then(function(workerPool) {
            return new Promise(function(resolve, reject) {
              workerPool.push(function(worker2, onComplete) {
                var vertexData = new VertexData();
                var onError = function(error) {
                  worker2.removeEventListener("error", onError);
                  worker2.removeEventListener("message", onMessage);
                  reject(error);
                  onComplete();
                };
                var onMessage = function(message) {
                  if (message.data === "done") {
                    worker2.removeEventListener("error", onError);
                    worker2.removeEventListener("message", onMessage);
                    resolve(vertexData);
                    onComplete();
                  } else if (message.data.id === "indices") {
                    vertexData.indices = message.data.value;
                  } else {
                    var divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;
                    if (divider !== 1) {
                      for (var i = 0; i < message.data.value.length; i++) {
                        message.data.value[i] = message.data.value[i] / divider;
                      }
                    }
                    vertexData.set(message.data.value, message.data.id);
                  }
                };
                worker2.addEventListener("error", onError);
                worker2.addEventListener("message", onMessage);
                var dataViewCopy = new Uint8Array(dataView.byteLength);
                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
                worker2.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
              });
            });
          });
        }
        if (this._decoderModulePromise) {
          return this._decoderModulePromise.then(function(decoder) {
            var vertexData = new VertexData();
            decodeMesh(decoder.module, dataView, attributes, function(indices) {
              vertexData.indices = indices;
            }, function(kind, data2) {
              vertexData.set(data2, kind);
            }, dividers);
            return vertexData;
          });
        }
        throw new Error("Draco decoder module is not available");
      };
      DracoCompression2.Configuration = {
        decoder: {
          wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js",
          wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm",
          fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
        }
      };
      DracoCompression2.DefaultNumWorkers = DracoCompression2.GetDefaultNumWorkers();
      DracoCompression2._Default = null;
      return DracoCompression2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var MeshoptCompression;
var init_meshoptCompression = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js"() {
    init_tools();
    MeshoptCompression = function() {
      function MeshoptCompression2() {
        var decoder = MeshoptCompression2.Configuration.decoder;
        this._decoderModulePromise = Tools.LoadScriptAsync(Tools.GetAbsoluteUrl(decoder.url)).then(function() {
          return MeshoptDecoder.ready;
        });
      }
      Object.defineProperty(MeshoptCompression2, "Default", {
        get: function() {
          if (!MeshoptCompression2._Default) {
            MeshoptCompression2._Default = new MeshoptCompression2();
          }
          return MeshoptCompression2._Default;
        },
        enumerable: false,
        configurable: true
      });
      MeshoptCompression2.prototype.dispose = function() {
        delete this._decoderModulePromise;
      };
      MeshoptCompression2.prototype.decodeGltfBufferAsync = function(source, count, stride, mode, filter) {
        return this._decoderModulePromise.then(function() {
          var result = new Uint8Array(count * stride);
          MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);
          return result;
        });
      };
      MeshoptCompression2.Configuration = {
        decoder: {
          url: "https://preview.babylonjs.com/meshopt_decoder.js"
        }
      };
      MeshoptCompression2._Default = null;
      return MeshoptCompression2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred;
var init_deferred = __esm({
  "node_modules/@babylonjs/core/Misc/deferred.js"() {
    Deferred = function() {
      function Deferred2() {
        var _this = this;
        this.promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      Object.defineProperty(Deferred2.prototype, "resolve", {
        get: function() {
          return this._resolve;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Deferred2.prototype, "reject", {
        get: function() {
          return this._reject;
        },
        enumerable: false,
        configurable: true
      });
      return Deferred2;
    }();
  }
});

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader;
var init_dataReader = __esm({
  "node_modules/@babylonjs/core/Misc/dataReader.js"() {
    init_stringTools();
    DataReader = function() {
      function DataReader2(buffer) {
        this.byteOffset = 0;
        this.buffer = buffer;
      }
      DataReader2.prototype.loadAsync = function(byteLength) {
        var _this = this;
        return this.buffer.readAsync(this.byteOffset, byteLength).then(function(data) {
          _this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
          _this._dataByteOffset = 0;
        });
      };
      DataReader2.prototype.readUint32 = function() {
        var value = this._dataView.getUint32(this._dataByteOffset, true);
        this._dataByteOffset += 4;
        this.byteOffset += 4;
        return value;
      };
      DataReader2.prototype.readUint8Array = function(byteLength) {
        var value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
        return value;
      };
      DataReader2.prototype.readString = function(byteLength) {
        return Decode(this.readUint8Array(byteLength));
      };
      DataReader2.prototype.skipBytes = function(byteLength) {
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
      };
      return DataReader2;
    }();
  }
});

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
var init_thinInstanceMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js"() {
    init_mesh();
    init_buffer();
    init_math_vector();
    Mesh.prototype.thinInstanceAdd = function(matrix, refresh) {
      if (refresh === void 0) {
        refresh = true;
      }
      this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
      var index = this._thinInstanceDataStorage.instancesCount;
      if (Array.isArray(matrix)) {
        for (var i = 0; i < matrix.length; ++i) {
          this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
        }
      } else {
        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
      }
      return index;
    };
    Mesh.prototype.thinInstanceAddSelf = function(refresh) {
      if (refresh === void 0) {
        refresh = true;
      }
      return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
    };
    Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      this.removeVerticesData(kind);
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
      this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    };
    Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh) {
      if (refresh === void 0) {
        refresh = true;
      }
      if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      var matrixData = this._thinInstanceDataStorage.matrixData;
      matrix.copyToArray(matrixData, index * 16);
      if (this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices[index] = matrix;
      }
      if (refresh) {
        this.thinInstanceBufferUpdated("matrix");
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      return true;
    };
    Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh) {
      if (refresh === void 0) {
        refresh = true;
      }
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      this._thinInstanceUpdateBufferSize(kind, 0);
      this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
      if (refresh) {
        this.thinInstanceBufferUpdated(kind);
      }
      return true;
    };
    Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
      get: function() {
        return this._thinInstanceDataStorage.instancesCount;
      },
      set: function(value) {
        var _a, _b;
        var matrixData = (_a = this._thinInstanceDataStorage.matrixData) !== null && _a !== void 0 ? _a : (_b = this.source) === null || _b === void 0 ? void 0 : _b._thinInstanceDataStorage.matrixData;
        var numMaxInstances = matrixData ? matrixData.length / 16 : 0;
        if (value <= numMaxInstances) {
          this._thinInstanceDataStorage.instancesCount = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer) {
      if (staticBuffer === void 0) {
        staticBuffer = false;
      }
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
      for (var i = 0; i < 4; i++) {
        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
      }
      return matrixBuffer;
    };
    Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride, staticBuffer) {
      var _a, _b, _c;
      if (stride === void 0) {
        stride = 0;
      }
      if (staticBuffer === void 0) {
        staticBuffer = false;
      }
      stride = stride || 16;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
        this._thinInstanceDataStorage.matrixData = buffer;
        this._thinInstanceDataStorage.worldMatrices = null;
        if (buffer !== null) {
          this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
          if (!this.doNotSyncBoundingInfo) {
            this.thinInstanceRefreshBoundingInfo(false);
          }
        } else {
          this._thinInstanceDataStorage.instancesCount = 0;
          if (!this.doNotSyncBoundingInfo) {
            this.refreshBoundingInfo();
          }
        }
      } else if (kind === "previousMatrix") {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
        this._thinInstanceDataStorage.previousMatrixData = buffer;
        if (buffer !== null) {
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (buffer === null) {
          if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {
            this.removeVerticesData(kind);
            delete this._userThinInstanceBuffersStorage.data[kind];
            delete this._userThinInstanceBuffersStorage.strides[kind];
            delete this._userThinInstanceBuffersStorage.sizes[kind];
            delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
          }
        } else {
          this._thinInstanceInitializeUserStorage();
          this._userThinInstanceBuffersStorage.data[kind] = buffer;
          this._userThinInstanceBuffersStorage.strides[kind] = stride;
          this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
      var _a, _b, _c;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else if (kind === "previousMatrix") {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
        }
      }
    };
    Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
      var _a;
      if (kind === "matrix") {
        if (this._thinInstanceDataStorage.matrixBuffer) {
          this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
        }
      }
    };
    Mesh.prototype.thinInstanceGetWorldMatrices = function() {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return [];
      }
      var matrixData = this._thinInstanceDataStorage.matrixData;
      if (!this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices = new Array();
        for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
          this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
        }
      }
      return this._thinInstanceDataStorage.worldMatrices;
    };
    Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo, applySkeleton, applyMorph) {
      if (forceRefreshParentInfo === void 0) {
        forceRefreshParentInfo = false;
      }
      if (applySkeleton === void 0) {
        applySkeleton = false;
      }
      if (applyMorph === void 0) {
        applyMorph = false;
      }
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return;
      }
      var vectors = this._thinInstanceDataStorage.boundingVectors;
      if (forceRefreshParentInfo) {
        vectors.length = 0;
        this.refreshBoundingInfo(applySkeleton, applyMorph);
      }
      var boundingInfo = this.getBoundingInfo();
      var matrixData = this._thinInstanceDataStorage.matrixData;
      if (vectors.length === 0) {
        for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
          vectors.push(boundingInfo.boundingBox.vectors[v].clone());
        }
      }
      TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
      TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
      for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
        for (var v = 0; v < vectors.length; ++v) {
          Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
          TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
          TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
        }
      }
      boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
      this._updateBoundingInfo();
    };
    Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances) {
      var _a, _b, _c;
      if (numInstances === void 0) {
        numInstances = 1;
      }
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      var kindIsMatrix = kind === "matrix";
      if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
        return;
      }
      var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
      var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
      var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
      var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
      var newSize = currentSize;
      while (newSize < bufferSize) {
        newSize *= 2;
      }
      if (!data || currentSize != newSize) {
        if (!data) {
          data = new Float32Array(newSize);
        } else {
          var newData = new Float32Array(newSize);
          newData.set(data, 0);
          data = newData;
        }
        if (kindIsMatrix) {
          (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
          this._thinInstanceDataStorage.matrixData = data;
          this._thinInstanceDataStorage.matrixBufferSize = newSize;
          if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
            (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
          }
        } else {
          (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();
          this._userThinInstanceBuffersStorage.data[kind] = data;
          this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype._thinInstanceInitializeUserStorage = function() {
      if (!this._userThinInstanceBuffersStorage) {
        this._userThinInstanceBuffersStorage = {
          data: {},
          sizes: {},
          vertexBuffers: {},
          strides: {}
        };
      }
    };
    Mesh.prototype._disposeThinInstanceSpecificData = function() {
      var _a;
      if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {
        this._thinInstanceDataStorage.matrixBuffer.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
      }
    };
  }
});

export {
  AnimationKeyInterpolation,
  init_animationKey,
  AnimationRange,
  init_animationRange,
  Node,
  init_node,
  Size,
  init_math_size,
  _IAnimationState,
  Animation,
  init_animation,
  Space,
  Axis,
  Coordinate,
  init_math_axis,
  Bone,
  init_bone,
  Orientation,
  BezierCurve,
  Angle,
  Arc2,
  Path2,
  Path3D,
  Curve3,
  init_math_path,
  AnimationEvent,
  init_animationEvent,
  TargetedAnimation,
  AnimationGroup,
  init_animationGroup,
  inlineScheduler,
  createYieldingScheduler,
  runCoroutine,
  runCoroutineSync,
  runCoroutineAsync,
  makeSyncFunction,
  makeAsyncFunction,
  init_coroutine,
  VertexData,
  init_mesh_vertexData,
  IntersectionInfo,
  init_intersectionInfo,
  BoundingBox,
  init_boundingBox,
  BoundingSphere,
  init_boundingSphere,
  BoundingInfo,
  init_boundingInfo,
  extractMinAndMaxIndexed,
  extractMinAndMax,
  init_math_functions,
  SubMesh,
  init_subMesh,
  SceneLoaderFlags,
  init_sceneLoaderFlags,
  CompatibilityOptions,
  init_compatibilityOptions,
  Geometry,
  init_geometry,
  TransformNode,
  init_transformNode,
  _MeshCollisionData,
  init_meshCollisionData,
  AbstractMesh,
  init_abstractMesh,
  Viewport,
  init_math_viewport,
  Camera,
  init_camera,
  Light,
  init_light,
  ThinMaterialHelper,
  init_thinMaterialHelper,
  MaterialHelper,
  init_materialHelper,
  Material,
  init_material,
  MultiMaterial,
  init_multiMaterial,
  MeshLODLevel,
  init_meshLODLevel,
  _CreationDataStorage,
  _InstancesBatch,
  Mesh,
  init_mesh,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  init_assetContainer,
  Sound,
  init_sound,
  WeightedSound,
  init_weightedsound,
  ThinTexture,
  init_thinTexture,
  BaseTexture,
  init_baseTexture,
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync,
  CopyTools,
  init_copyTools,
  Texture,
  init_texture,
  init_engine_rawTexture,
  RawTexture,
  init_rawTexture,
  Skeleton,
  init_skeleton,
  BaseCameraMouseWheelInput,
  init_BaseCameraMouseWheelInput,
  CameraInputTypes,
  CameraInputsManager,
  init_cameraInputsManager,
  FreeCameraKeyboardMoveInput,
  init_freeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  init_freeCameraMouseInput,
  FreeCameraMouseWheelInput,
  init_freeCameraMouseWheelInput,
  FreeCameraTouchInput,
  init_freeCameraTouchInput,
  FreeCameraInputsManager,
  init_freeCameraInputsManager,
  TargetCamera,
  init_targetCamera,
  FreeCamera,
  init_freeCamera,
  init_postprocess_vertex,
  RenderTargetWrapper,
  init_renderTargetWrapper,
  init_engine_renderTarget,
  PostProcess,
  init_postProcess,
  PassPostProcess,
  PassCubePostProcess,
  init_passPostProcess,
  init_engine_renderTargetCube,
  RenderTargetTexture,
  init_renderTargetTexture,
  HemisphericLight,
  init_hemisphericLight,
  PushMaterial,
  init_pushMaterial,
  MaterialFlags,
  init_materialFlags,
  init_sceneUboDeclaration,
  init_meshUboDeclaration,
  init_helperFunctions,
  init_lightFragmentDeclaration,
  init_lightUboDeclaration,
  init_lightsFragmentFunctions,
  init_shadowsFragmentFunctions,
  init_fresnelFunction,
  init_reflectionFunction,
  init_imageProcessingDeclaration,
  init_imageProcessingFunctions,
  init_bumpFragmentMainFunctions,
  init_bumpFragmentFunctions,
  init_clipPlaneFragmentDeclaration,
  init_logDepthDeclaration,
  init_fogFragmentDeclaration,
  init_clipPlaneFragment,
  init_bumpFragment,
  init_depthPrePass,
  init_lightFragment,
  init_logDepthFragment,
  init_fogFragment,
  init_bonesDeclaration,
  init_bakedVertexAnimationDeclaration,
  init_instancesDeclaration,
  init_clipPlaneVertexDeclaration,
  init_fogVertexDeclaration,
  init_lightVxFragmentDeclaration,
  init_lightVxUboDeclaration,
  init_morphTargetsVertexGlobalDeclaration,
  init_morphTargetsVertexDeclaration,
  init_morphTargetsVertexGlobal,
  init_morphTargetsVertex,
  init_instancesVertex,
  init_bonesVertex,
  init_bakedVertexAnimation,
  init_bumpVertex,
  init_clipPlaneVertex,
  init_fogVertex,
  init_shadowsVertex,
  init_logDepthVertex,
  EffectFallbacks,
  init_effectFallbacks,
  MaterialPluginManager,
  RegisterMaterialPlugin,
  UnregisterMaterialPlugin,
  UnregisterAllMaterialPlugins,
  init_materialPluginManager,
  MaterialPluginBase,
  init_materialPluginBase,
  MaterialDetailMapDefines,
  DetailMapConfiguration,
  init_material_detailMapConfiguration,
  StandardMaterialDefines,
  StandardMaterial,
  init_standardMaterial,
  ShaderMaterial,
  init_shaderMaterial,
  Constants,
  init_constants,
  init_engine_cubeTexture,
  PositionNormalVertex,
  PositionNormalTextureVertex,
  init_math_vertexFormat,
  init_math,
  SphericalHarmonics,
  SphericalPolynomial,
  init_sphericalPolynomial,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  TextureTools,
  init_textureTools,
  RGBDTextureTools,
  init_rgbdTextureTools,
  CubeMapToSphericalPolynomialTools,
  init_cubemapToSphericalPolynomial,
  init_baseTexture_polynomial,
  GetEnvInfo,
  normalizeEnvInfo,
  CreateEnvTextureAsync,
  CreateImageDataArrayBufferViews,
  UploadEnvLevelsAsync,
  UploadLevelsAsync,
  UploadEnvSpherical,
  _UpdateRGBDAsync,
  EnvironmentTextureTools,
  init_environmentTextureTools,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoader,
  init_sceneLoader,
  ShadowLight,
  init_shadowLight,
  DirectionalLight,
  init_directionalLight,
  SpotLight,
  init_spotLight,
  CubeTexture,
  init_cubeTexture,
  GetEnvironmentBRDFTexture,
  BRDFTextureTools,
  init_brdfTextureTools,
  PBRBRDFConfiguration,
  init_pbrBRDFConfiguration,
  init_subSurfaceScatteringFunctions,
  init_importanceSampling,
  init_pbrBRDFFunctions,
  init_hdrFilteringFunctions,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  init_pbrClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  init_pbrIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  init_pbrAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  init_pbrSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  init_pbrSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  init_pbrBaseMaterial,
  PBRMaterial,
  init_pbrMaterial,
  WorkerPool,
  AutoReleaseWorkerPool,
  init_workerPool,
  PointLight,
  init_pointLight,
  MorphTarget,
  init_morphTarget,
  RawTexture2DArray,
  init_rawTexture2DArray,
  MorphTargetManager,
  init_morphTargetManager,
  RawCubeTexture,
  init_rawCubeTexture,
  DracoCompression,
  init_dracoCompression,
  MeshoptCompression,
  init_meshoptCompression,
  init_thinInstanceMesh,
  Deferred,
  init_deferred,
  DataReader,
  init_dataReader
};
//# sourceMappingURL=chunk-ILTR56VQ.js.map
